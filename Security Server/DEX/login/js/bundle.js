(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
/*
 * Copyright (c) 2014, 2015 by Delphix. All rights reserved.
 */

/* global _ , $ */

'use strict';

var dxUtil = require('dxcore/js/util.js'),
    dxUserUtil = require('dxcore/js/userUtil.js'),
    dxFilter = require('dxcore/data/layer2/js/filter.js');

/*
 * Defines a special initialization routine on data which is used to set up delphix Schema specific filers.
 * In particular, all filters which can not be handled by the standard uberFilter are implemented here.
 */
module.exports._initDelphixFilters = function _initDelphixFilters(context) {
    /*
     * Filter functions for types that cannot be (fully) autogenerated
     */
    function actionFilter(collection, model, resultHandler) {
        var qParams = collection.getQueryParameters() || {};
        if (_.isEmpty(qParams)) {
            return resultHandler(context._filters.INCLUDE);
        }
        if (!!qParams.rootActionOnly && !!model.get('parentAction')) {
            return resultHandler(context._filters.EXCLUDE);
        }

        var filteredByStateAndUser = context._filters._checkSameProps(['state', 'user'], qParams, model);
        if (filteredByStateAndUser === context._filters.EXCLUDE) {
            return resultHandler(context._filters.EXCLUDE);
        }
        if (!qParams.parentAction) {
            return resultHandler(filteredByStateAndUser);
        }
        // For the parent action, need to go up the hierarchy
        function checkParentAction(currentModel) {
            currentModel.once('ready', function () {
                var parentActionRef = currentModel.get('parentAction');
                if (!parentActionRef) {
                    resultHandler(context._filters.EXCLUDE);
                } else if (parentActionRef === qParams.parentAction) {
                    resultHandler(context._filters.INCLUDE);
                } else {
                    var parentModel = context.getServerModel(parentActionRef, 'Action');
                    checkParentAction(parentModel);
                }
            });
            currentModel.once('error', function () {
                // If the model or parent does not exist, context._filters.EXCLUDE it
                resultHandler(context._filters.EXCLUDE);
            });
        }
        checkParentAction(model);
    }

    function alertFilter(collection, model, resultHandler) {
        var qParams = collection.getQueryParameters() || {};
        if (qParams.searchText) {
            var fieldsToSearch = ['eventTitle', 'eventDescription', 'eventResponse', 'eventAction', 'targetName'];
            var searchText = qParams.searchText.toLowerCase();
            var searchMatches = _.any(fieldsToSearch, function (field) {
                return _.isString(model.get(field)) && model.get(field).toLowerCase().indexOf(searchText) !== -1;
            });
            if (!searchMatches) {
                return resultHandler(context._filters.EXCLUDE);
            }
        }

        uberFilter(collection, model, resultHandler, ['searchText']);
    }

    function authorizationFilter(collection, model, resultHandler) {
        var qParams = collection.getQueryParameters() || {};
        if (qParams.effective) {
            return resultHandler(context._filters.UNKNOWN);
        }

        uberFilter(collection, model, resultHandler);
    }

    function containerFilter(collection, model, resultHandler) {
        var qParams = collection.getQueryParameters() || {};
        if (qParams.validForSecureReplication) {
            /*
             * The server is checking masked flag and datalineage and other information that are not available on the
             * client side. So we just mark the status of the collection on the client dirty.
             */
            resultHandler(context._filters.UNKNOWN);
            return;
        }

        var res = context._filters._checkSameProps(['provisionContainer', 'group'], qParams, model);
        if (res !== context._filters.INCLUDE || !(qParams.noJSDataSource || qParams.noJSContainerDataSource)) {
            resultHandler(res);
            return;
        }

        var dataSources = context.getServerCollection('JSDataSource');
        var dataSourcesPromise = dataSources.$$list({
            container: model.get('reference')
        });
        dataSourcesPromise.then(function (dataSources) {
            if (dataSources.length === 0) {
                resultHandler(context._filters.INCLUDE);
                return;
            } else if (qParams.noJSContainerDataSource) {
                var isInUseByContainer = dataSources.some(function (dataSource) {
                    var dataLayout = dataSource.get('dataLayout');
                    return dataLayout.indexOf('JSDataContainer') === 0;
                });
                if (isInUseByContainer) {
                    resultHandler(context._filters.EXCLUDE);
                } else {
                    resultHandler(context._filters.INCLUDE);
                }
                return;
            }
            resultHandler(context._filters.EXCLUDE);
        });
    }

    function hostFilter(collection, model, resultHandler) {
        var qParams = collection.getQueryParameters() || {};
        if (!qParams.environment) {
            return resultHandler(context._filters.INCLUDE);
        }

        var env = context.getServerModel(qParams.environment, 'SourceEnvironment');
        env.once('ready', function () {
            if (env.instanceOf('HostEnvironment')) {
                var result = env.get('host') === model.get('reference') ? context._filters.INCLUDE : context._filters.EXCLUDE;
                resultHandler(result);
            } else {
                var nodeType = env.instanceOf('OracleCluster') ? 'OracleClusterNode' : 'WindowsClusterNode';
                var nodes = context.getServerCollection(nodeType);
                nodes.$$list({
                    cluster: env.get('reference')
                }, {
                    success: function success() {
                        var anyMatches = nodes.any(function (node) {
                            return node.get('host') === model.get('reference');
                        });
                        var result = anyMatches ? context._filters.INCLUDE : context._filters.EXCLUDE;
                        resultHandler(result);
                    },
                    error: function error() {
                        resultHandler(context._filters.EXCLUDE);
                    }
                });
            }
        });
        env.once('error', function () {
            resultHandler(context._filters.EXCLUDE);
        });
    }

    /*
     * A bookmark belongs to a template if it has that value as a query parameter.  It belongs to a container if either
     * its template or container property matches the query parameter.
     */
    function jsBookmarkFilter(collection, model, resultHandler) {
        var qParams = collection.getQueryParameters() || {};
        if (_.isEmpty(qParams)) {
            resultHandler(context._filters.INCLUDE);
            return;
        }

        if (_.has(qParams, 'template')) {
            if (model.get('bookmarkType') === 'DATA_TEMPLATE' && qParams.template === model.get('template')) {
                resultHandler(context._filters.INCLUDE);
            } else {
                resultHandler(context._filters.EXCLUDE);
            }
            return;
        } else if (_.has(qParams, 'container')) {
            if (qParams.container === undefined) {
                resultHandler(context._filters.INCLUDE);
                return;
            } else if (qParams.container === model.get('container')) {
                resultHandler(context._filters.INCLUDE);
                return;
            } else {
                var container = context.getServerModel(qParams.container, 'JSDataContainer');
                container.once('ready', function () {
                    if (container.get('template') === model.get('template') && model.get('shared')) {
                        resultHandler(context._filters.INCLUDE);
                    } else {
                        resultHandler(context._filters.EXCLUDE);
                    }
                });

                container.once('error', function () {
                    resultHandler(context._filters.EXCLUDE);
                });
            }
        } else {
            dxUtil.fail('Unsupported query parameters: ' + JSON.stringify(qParams));
            return;
        }
    }

    function jsDataContainerFilter(collection, model, resultHandler) {
        var qParams = collection.getQueryParameters() || {};

        if (_.has(qParams, 'owner')) {
            var jetStreamUserRolePromise = dxUserUtil.getJetStreamUser();

            var authorizationsPromise = context.getServerCollection('Authorization').$$list({
                target: model.get('reference')
            });

            var roleAndAuthPromise = $.when(jetStreamUserRolePromise, authorizationsPromise);

            roleAndAuthPromise.then(function (jetStreamUserRole, auths) {
                var jetStreamUserRoleReference = jetStreamUserRole.get('reference');

                var item = _.find(auths.models, function (a) {
                    return a.get('role') === jetStreamUserRoleReference && a.get('user') === qParams.owner;
                });

                if (item) {
                    resultHandler(context._filters.INCLUDE);
                } else {
                    resultHandler(context._filters.EXCLUDE);
                }
            });
        } else {
            uberFilter(collection, model, resultHandler);
        }
    }

    function jsOperationFilter(collection, model, resultHandler) {
        function excludeByDataLayoutAndBranch(qParams, model) {
            if (_.has(qParams, 'dataLayout')) {
                return context._filters._checkSameProps(['dataLayout'], qParams, model) === context._filters.EXCLUDE;
            } else if (_.has(qParams, 'branch')) {
                return context._filters._checkSameProps(['branch'], qParams, model) === context._filters.EXCLUDE;
            } else {
                dxUtil.fail('JSOperation query parameters specifies missing required dataLayout or branch');
            }
        }

        var qParams = collection.getQueryParameters() || {};

        if (_.has(qParams, 'dataTime')) {
            if (excludeByDataLayoutAndBranch(qParams, model)) {
                resultHandler(context._filters.EXCLUDE);
                return;
            }

            /*
             * We don't really know if this event would have matched the query parameters, as we can't tell
             * how the beforeCount and afterCount are reflected in the current collection. As a result we
             * return UNKNOWN, which will trigger a dirty event. Caller can subscribe to the dirty event
             * and reissue the query.
             */
            resultHandler(context._filters.UNKNOWN);
        } else if (_.has(qParams, 'dataStartTime') && _.has(qParams, 'dataEndTime')) {
            if (excludeByDataLayoutAndBranch(qParams, model)) {
                resultHandler(context._filters.EXCLUDE);
                return;
            }

            var dataTime = model.get('dataTime');

            /*
             * An operation currently in progress has a dataTime of null, which really means 'now'. We simulate
             * this by using the startTime of the operation.
             */
            if (dxUtil.isNone(dataTime)) {
                dataTime = model.get('startTime');
            }

            if (qParams.dataStartTime <= dataTime && dataTime <= qParams.dataEndTime) {
                resultHandler(context._filters.INCLUDE);
            } else {
                resultHandler(context._filters.EXCLUDE);
            }
        } else {
            resultHandler(context._filters._checkSameProps(['dataLayout', 'branch'], qParams, model));
        }
    }

    function msSqlAvailabilityGroupListenerFilter(collection, model, resultHandler) {
        var qParams = collection.getQueryParameters() || {};

        /*
         * MSSqlAvailabilityGroupListener's do not have references, so there is no way to check if they belong to an
         * availability group.
         */
        if (qParams.availabilitygroup) {
            resultHandler(context._filters.UNKNOWN);
        } else {
            resultHandler(context._filters.INCLUDE);
        }
    }

    function msSqlClusterInstanceFilter(collection, model, resultHandler) {
        var qParams = collection.getQueryParameters() || {};

        /*
         * MSSqlClusterInstance's do not have references, so there is no way to check if they belong to an availability
         * group.
         */
        if (qParams.availabilitygroup) {
            resultHandler(context._filters.UNKNOWN);
        } else {
            resultHandler(context._filters.INCLUDE);
        }
    }

    function sourceFilter(collection, model, resultHandler) {
        var qParams = collection.getQueryParameters() || {};

        // query parameters for Source are mutually exclusive, meaning we can only $$list by one at a time
        if (_.keys(qParams).length > 1) {
            dxUtil.fail('You cannot provide more than one query parameter for $$list for Source.');
        }

        uberFilter(collection, model, resultHandler);
    }

    function timeflowSnapshotFilter(collection, model, resultHandler) {
        var qParams = collection.getQueryParameters() || {};

        if (qParams.traverseTimeflows === true) {
            dxUtil.fail('traverseTimeflows query parameter is not yet supported by the filter.');
        }

        uberFilter(collection, model, resultHandler);
    }

    function jobFilter(collection, model, resultHandler) {
        uberFilter(collection, model, resultHandler, 'addEvents'); // ignore addEvents
    }

    /*
     * Do the real work.
     */
    context = context || this;
    dxFilter._initFilters(context);
    context._filters = context._filters || {};
    var genericFilter = context._filters._genericFilter;
    var uberFilter = context._filters._uberFilter;

    _.extend(context._filters, {
        Action: actionFilter,
        Alert: alertFilter,
        AlertProfile: genericFilter,
        Toolkit: genericFilter,
        Authorization: authorizationFilter,
        Container: containerFilter,
        CurrentConsumerCapacityData: genericFilter,
        CurrentGroupCapacityData: genericFilter,
        DatabaseTemplate: genericFilter,
        EnvironmentUser: uberFilter,
        Fault: uberFilter,
        FaultEffect: uberFilter,
        Group: genericFilter,
        HistoricalConsumerCapacityData: uberFilter,
        HistoricalGroupCapacityData: uberFilter,
        HistoricalSystemCapacityData: uberFilter,
        Host: hostFilter,
        HostPrivilegeElevationProfile: genericFilter,
        Job: jobFilter,
        JSBookmark: jsBookmarkFilter,
        JSBranch: uberFilter,
        JSDailyOperationDuration: uberFilter,
        JSDataContainer: jsDataContainerFilter,
        JSDataSource: uberFilter,
        JSDataTemplate: genericFilter,
        JSOperation: jsOperationFilter,
        JSWeeklyOperationCount: uberFilter,
        LdapServer: genericFilter,
        MSSqlAvailabilityGroupListener: msSqlAvailabilityGroupListenerFilter,
        MSSqlClusterInstance: msSqlClusterInstanceFilter,
        Namespace: genericFilter,
        NetworkInterface: genericFilter,
        NetworkLatencyTest: genericFilter,
        NetworkRoute: genericFilter,
        NetworkThroughputTest: genericFilter,
        Notification: genericFilter,
        OperationTemplate: genericFilter,
        OracleClusterNode: uberFilter,
        OracleListener: uberFilter,
        OraclePDBConfig: uberFilter,
        Permission: genericFilter,
        ReplicationSpec: genericFilter,
        Role: genericFilter,
        SNMPManager: genericFilter,
        Source: sourceFilter,
        SourceConfig: uberFilter,
        SourceEnvironment: uberFilter,
        SourceRepository: uberFilter,
        SnapshotCapacityData: uberFilter,
        Statistic: genericFilter,
        StatisticSlice: genericFilter,
        StorageDevice: genericFilter,
        SystemVersion: genericFilter,
        Timeflow: uberFilter,
        TimeflowBookmark: uberFilter,
        TimeflowSnapshot: timeflowSnapshotFilter,
        TypedObject: genericFilter,
        User: uberFilter,
        WindowsClusterNode: uberFilter,
        X509Certificate: genericFilter
    });
};

},{"dxcore/data/layer2/js/filter.js":9,"dxcore/js/userUtil.js":22,"dxcore/js/util.js":23}],2:[function(require,module,exports){
/*
 * Copyright (c) 2014, 2015 by Delphix. All rights reserved.
 */

/* global _, Backbone, ko */

'use strict';

var dxUtil = require('dxcore/js/util.js'),
    dxScreen = require('dxcore/js/screen.js');

/*
 * Defines a new proxy, using the specified mapping. The mapping must have one of the following forms:
 * {
 *    attributeName: 'attribute.path.to.desired.attribute',
 *    ...
 * }
 * or
 * {
 *    attributeName: {
 *       path: 'attribute.path.to.desired.attribute'[,
 *       setter: function(name, value) {...}]
 *    ...
 * }
 *
 * The path may include "$name", where that is a reference to a delphix backbone model, where there is a backbone
 * attribute named "name" potentially available.
 *
 * If a setter is provided, then when the set() method is called on the proxy, the provided function will be called.
 * This allows one to respond to changes input by the user without directly modifying the underlying objects (which
 * should be being treated as read-only objects.
 *
 * The leaf attribute in the chain may be a model or a non-model value.  Each intermediate segment, however, must be
 * a Backbone model. If one is not, then the proxy will not traverse beyond it, until it is changed to a Backbone model.
 *
 * A proxy sets up a set of attribute change listeners, one for each model on the chain. Any time any segment in the
 * path changes, the proxy will re-evaluate following segments in the path.
 *
 * A single segment in the path can change at any time, and may take on null, undefined, or other values at any
 * time. If a path can not be traversed then the proxy's attribute is set to undefined.
 *
 * Memory Management:
 * In order to avoid a proxy from being leaked (due to listeners on the models referencing it), a proxy will schedule
 * itself to be "destroyed" when the screen changes. Destruction means that it releases all of its attribute listeners
 * and removes its knowledge of the properties it was passed.  However, when the screen changes, if the proxy itself
 * has listeners listening to it, then it will reschedule itself to be destroyed on the next screen change. Thus, as
 * long as you are are listening for events on the proxy, it will stay around.
 */
module.exports.newProxy = function newProxy(sourceMapping) {
    // The model this is currently looking up properties from
    var baseModel;

    // the proxy's attributes and their associated attribute-paths
    var proxyAttrToAttrPaths = {};

    // Current values of the proxy attributes
    var proxyAttrValues = {};

    // Functions used to remove listeners watching each attribute path
    var proxyAttrsRemovers = {};

    /*
     * Examines the next link in the attribute path.  If it is a backbone model, set up listeners for it, otherwise
     * the object is the end of the path, so cache the value in the proxyAttrValues.
     *
     * anObject: The object at the next link in the path. Can be anything including null or undefined.
     * attrPath: The remainder of the attribute path that should be examined. May be an empty array.
     * proxyAttr: The attribute this is currently concerned with.
     */
    function examineNextPathSegment(proxy, anObject, attrPath, proxyAttr) {
        /*
         * If any of these conditions are met, we've reached the current end of the attribute path.  So, store the
         * object as the current value of the attribute and fire a change event.
         */
        if (_.isEmpty(attrPath) || _.isUndefined(anObject) || _.isNull(anObject) || !(anObject instanceof Backbone.Model)) {
            if (!_.isEmpty(attrPath)) {
                anObject = undefined;
            }

            if (proxyAttrValues[proxyAttr] !== anObject) {
                proxyAttrValues[proxyAttr] = anObject;
                proxy.trigger('change:' + proxyAttr);
            }

            return function () {/* do nothing, as there are no listeners to remove */};
        }

        /*
         * As we now know we have a backbone model, prepare to start listen to it. Note that we do some special-casing
         * since the next attribute in the attribute path might be an ordinary backbone property, or it might be one
         * of our custom referenced-object accessors.
         */
        var modelAttr = attrPath[0];
        var basicAttr = modelAttr.charAt(0) === '$' ? modelAttr.substring(1) : modelAttr;

        return listenToModel(proxy, anObject, basicAttr, modelAttr, attrPath.slice(1), proxyAttr);
    }

    /*
     * Set up a listener on the specified model, and then start the same process on models further down the
     * attribute chain.
     *
     * This returns a function which, when called, will remove the listener that this created.
     *
     * model: The model that this will be listening to. This is always a Backbone model
     * baseAttr: The attribute that this will be listening to
     * fullAttr: The full name of the attribute (same as baseAttr, unless this starts with $)
     * attrSubPath: An array of strings that are the remaining attributes along the attribute path
     * proxyAttr: The proxy attribute that all of this is related to.
     */
    function listenToModel(proxy, model, baseAttr, fullAttr, attrSubPath, proxyAttr) {
        var subPathRemover;
        var readyRemover;

        /*
         * Examine the next path segment. If it results in a changed value, fire a change event
         */
        function examineNextPathAndTriggerIfChange(newModel, before) {
            subPathRemover = examineNextPathSegment(proxy, newModel, attrSubPath, proxyAttr);
            if (before !== proxyAttrValues[proxyAttr]) {
                proxy.trigger('change');
            }
        }
        /*
         * Listener for this model+modelAttribute. When the model attribute changes, this will remove any previously
         * existing listeners, and then build new listeners for sub-models in the attribute path
         */
        function changeListener(changedModel) {
            subPathRemover();

            var newModel = changedModel.get(fullAttr);
            if (isDelphixModel(newModel)) {
                var readyHandler = function readyHandler() {
                    examineNextPathAndTriggerIfChange(newModel, proxyAttrValues[proxyAttr]);
                };
                newModel.once('ready', readyHandler);
                readyRemover = function () {
                    newModel.off('ready', readyHandler);
                };
            } else {
                examineNextPathAndTriggerIfChange(newModel, proxyAttrValues[proxyAttr]);
            }
        }

        /*
         * Routine used to remove the listener that will have been set up just below, as well as any sub-listeners
         */
        function changeListenerRemover() {
            model.off('change:' + baseAttr, changeListener);
            if (subPathRemover) {
                subPathRemover();
            }
            if (readyRemover) {
                readyRemover();
            }
        }

        var newModel = model.get(fullAttr);
        if (isDelphixModel(newModel)) {
            var readyHandler = function readyHandler() {
                examineNextPathAndTriggerIfChange(newModel, proxyAttrValues[proxyAttr]);
            };
            newModel.once('ready', readyHandler);
            readyRemover = function () {
                newModel.off('ready', readyHandler);
            };
        } else {
            subPathRemover = examineNextPathSegment(proxy, newModel, attrSubPath, proxyAttr);
        }

        model.on('change:' + baseAttr, changeListener);

        return changeListenerRemover;
    }

    /*
     * Iterate over each of the proxy attribute --> attribute paths mapping values, and build a chain of listeners
     * for each.
     */
    function listenToBaseModel(proxy, newModel) {
        function processModel() {
            processBaseModel(proxy, baseModel);
        }
        // clean up any remaining listeners
        _.each(proxyAttrsRemovers, function (remover) {
            remover();
        });

        if (isDelphixModel(baseModel)) {
            baseModel.off('ready', processModel);
        }

        baseModel = newModel;

        if (isDelphixModel(baseModel)) {
            baseModel.once('ready', processModel);
        } else {
            processModel();
        }
    }

    /*
     * Iterate over all the proxy attributes, set up listeners and fire change event if appropriate.
     */
    function processBaseModel(proxy, baseModel) {
        var changes = false;

        _.each(proxyAttrToAttrPaths, function (attrPath, proxyAttr) {
            var before = proxyAttrValues[proxyAttr];
            proxyAttrsRemovers[proxyAttr] = examineNextPathSegment(proxy, baseModel, attrPath.path, proxyAttr);
            if (before !== proxyAttrValues[proxyAttr]) {
                changes = true;
            }
        });

        if (changes) {
            proxy.trigger('change');
        }
    }

    /*
     * Return true if the object is a data model
     */
    function isDelphixModel(value) {
        return value instanceof Backbone.Model && value._dxSchema;
    }

    /*
     * Try to add this to the screen system for automatic cleanup.
     */
    function registerForDestruction() {
        dxScreen.registerCleanupCallback(function () {
            destroy();
        });
    }

    /*
     * If no one is listening for events from this proxy, then destroy the listers it has on its models, and
     * reset all of the cached values
     */
    function destroy() {
        var nonZeroEventCount = 0;
        _.each(proxyModel._events, function (eventInfo) {
            if (eventInfo.length !== 0) {
                nonZeroEventCount++;
            }
        });
        if (nonZeroEventCount) {
            registerForDestruction();
            return;
        }

        _.each(proxyAttrsRemovers, function (remover) {
            remover();
        });
        proxyAttrsRemovers = {};
        proxyAttrValues = {};
    }

    /*
     * Sets the specified backbone model (or null or undefined) to be the new base model for this proxy. This will
     * recompute all values for each of the attributes in the mapping, sending any appropriate change events.
     */
    function setModel(model) {
        if (dxUtil.isNone(model) || model instanceof Backbone.Model) {
            listenToBaseModel(this, model);
            return;
        }

        throw dxUtil.fail('models must be an extension of Backbone.Model');
    }

    function getModel() {
        return baseModel;
    }

    /*
     * Return the current value of the proxy's attribute.
     */
    function get(attrName) {
        return proxyAttrValues[attrName];
    }

    /*
     * Calls the setter for the associated attribute.  If there is no setter, log an error.  Fire a change event
     * so clients will be able to automatically change their display to show the old value.
     */
    function set(attrName, value) {
        if (_.isObject(attrName)) {
            _.each(attrName, function (individualValue, key) {
                this.set(key, individualValue);
            }, this);
            return;
        }

        if (!proxyAttrToAttrPaths[attrName].setter) {
            dxUtil.fail('Tried to call a setter on ' + attrName + ' but no setter defined');
        } else {
            proxyAttrToAttrPaths[attrName].setter(attrName, value);
        }

        this.trigger('change:' + attrName);
        this.trigger('change');
    }

    /*
     * Given a proxy, return an object where each member is a read-only observable that maps to the corresponding
     * property in the proxy. Changes to the observable are not propagated to the proxy or underlying model.
     */
    function toObservable() {
        var self = this;

        var result = {};
        _.each(proxyAttrValues, function (proxyValue, proxyAttr) {
            result[proxyAttr] = ko.observable(proxyValue);
            self.on('change:' + proxyAttr, function () {
                result[proxyAttr](self.get(proxyAttr));
            });
        });

        return result;
    }

    // Initialize our copy of the mapping and our cache of attribute values
    _.each(sourceMapping, function (attrPath, proxyAttr) {
        var newAttrPath;

        if (_.isObject(attrPath)) {
            if (!_.isString(attrPath.path) || _.has(attrPath, 'setter') && !_.isFunction(attrPath.setter)) {
                dxUtil.fail('Attribute path for ' + proxyAttr + ' must have a path property that is a string');
            }
            newAttrPath = {
                path: attrPath.path,
                setter: attrPath.setter
            };
        } else if (_.isString(attrPath)) {
            if (attrPath === '') {
                dxUtil.fail('Attribute path for ' + proxyAttr + ' is empty. This is not allowed');
            }
            newAttrPath = { path: attrPath };
        } else {
            dxUtil.fail('Attribute path for ' + proxyAttr + ' must be a string or an object');
        }

        newAttrPath.path = newAttrPath.path.split('.');
        proxyAttrToAttrPaths[proxyAttr] = newAttrPath;
        proxyAttrValues[proxyAttr] = undefined;
    });

    var proxyModel = {
        setModel: setModel,
        getModel: getModel,
        set: set,
        get: get,
        destroy: destroy,
        toObservable: toObservable
    };
    _.extend(proxyModel, Backbone.Events);
    registerForDestruction();

    return proxyModel;
};

},{"dxcore/js/screen.js":19,"dxcore/js/util.js":23}],3:[function(require,module,exports){
/*
 * Copyright (c) 2013, 2015 by Delphix. All rights reserved.
 */

/* global $, _, Backbone, XRegExp */

'use strict';

/*
 * Misc data-related utilities.  Generally not needed unless you are bypassing data in some fashion.
 */
var MAX_NAME_LENGTH = 256;

var dxUtil = require('dxcore/js/util.js'),
    dxLocale = require('dxcore/js/locale.js');

/*
 * Take an APIError and return a string of validation errors containing html that can be displayed in an error alert
 */
function processErrorResultDetails(apiError) {
    if (!(apiError instanceof Backbone.Model) || apiError.get('type') !== 'APIError') {
        dxUtil.fail('processErrorResultDetails expects an APIError model as an argument.');
    }

    apiError = apiError.toJSON();
    apiError.details = apiError.details ? apiError.details : '';

    if (typeof apiError.details === 'string') {
        return apiError.details;
    }

    var resultList = [];
    _.each(apiError.details, function (subError, field) {
        buildValidationErrorList(field, subError, resultList);
    });

    var elem = $('<ul>');
    _.each(resultList, function (error) {
        $('<li>').text(error.field + ': ' + error.details).appendTo(elem);
    });

    /*
     * .html() gets the inner html of the element in question, and we want to include 'elem' in the output string,
     * so append to a dummy div
     */
    return $('<div>').append(elem).html();
}

/*
 * Helper method to build a list of validation errors in DFS order. This expects to either get an APIError object, or
 * an object whose keys are property names and values are themselves more of the same (either an APIError or an object
 * with keys as prop names).
 */
function buildValidationErrorList(fieldStr, error, errorList) {
    var apiErrorKeys = _.intersection(_.keys(error), ['id', 'details', 'action']);

    // The 'id' property tells us this is an APIError, rather than a hash of nested validation errors
    // Also, check to see if the object has the primary properties of an APIError, and if so consider it an APIError
    if (error.type === 'APIError' || apiErrorKeys.length === 3) {
        errorList.push({
            action: error.action,
            details: error.details,
            field: fieldStr
        });
    } else {
        _.each(error, function (subError, subField) {
            buildValidationErrorList(fieldStr + '.' + subField, subError, errorList);
        });
    }
}

/*
 * Allow unicode with the exception of the "Other" category which includes (control characters,
 * format characters, private use characters, surrogate characters, and unassigned characters) and %'`
 */
var badCharsRegex = XRegExp('[\\p{C}%\'`]+');

/*
 * Validates that a name matches the constraints our server puts on object names.  This returns an object with these
 * properties:
 *    valid: true|false   If the provided name is valid
 *    tooLong: true|false If the provided value exceeds our length limits
 *    badChars: String    The set of characters found that are invalid. Useful for showing in error messages.
 *
 * Note that this is being done 'by hand' because the schemas do not presently provide this information to clients.
 * Consult the following resources to quickly figure out if this is still valid:
 *     appliance/server/cms/src/java/com/delphix/appliance/server/json/validation/impl/ObjectNameFormatConstraint.java
 *     http://docs.oracle.com/javase/6/docs/api/java/util/regex/Pattern.html
 */
function validateName(name) {
    var tooLong = false,
        badChars = '';

    if (!dxUtil.isNone(name)) {
        if (name.length > MAX_NAME_LENGTH) {
            tooLong = true;
        }

        var result = XRegExp.exec(name, badCharsRegex);

        _.each(result, function (value) {
            if (badChars.indexOf(value) === -1) badChars += value;
        });
    }

    return {
        valid: !tooLong && badChars === '',
        tooLong: tooLong,
        badChars: badChars
    };
}

/*
 * Validates that a name matches the constraints our server puts on object names. This returns undefined if the name
 * is valid, an localized error message otherwise.
 */
function getNameValidationErrorIfAny(name) {
    if (_.isUndefined(name) || name.trim() === '') {
        return dxLocale.gls('dx.core.name_empty.msg');
    }

    // Check some invalid name problems (too long, unsupported characters)
    var result = module.exports.validateName(name);
    if (!result.valid) {
        if (result.tooLong) {
            return dxLocale.gls('dx.core.name_too_long.msg', MAX_NAME_LENGTH);
        } else if (result.badChars) {
            return dxLocale.gls('dx.core.name_invalidChars.msg', result.badChars);
        } else {
            dxUtil.fail('Name validator has returned a new error condition. Must cope with that here.');
        }
    }

    return undefined;
}

module.exports = {
    processErrorResultDetails: processErrorResultDetails,
    validateName: validateName,
    getNameValidationErrorIfAny: getNameValidationErrorIfAny
};

},{"dxcore/js/locale.js":17,"dxcore/js/util.js":23}],4:[function(require,module,exports){
/*
 * Copyright (c) 2015 by Delphix. All rights reserved.
 */

/* global delphixSchema*/

'use strict';

var setupData = require('dxcore/data/layer3/js/api.js').setupDataSystem,
    setupDelphixFilters = require('dxcore/data/delphix/js/filter.js')._initDelphixFilters;

module.exports.initialize = function () {
    setupData(delphixSchema, module.exports);
    setupDelphixFilters(module.exports);
};

},{"dxcore/data/delphix/js/filter.js":1,"dxcore/data/layer3/js/api.js":11}],5:[function(require,module,exports){
/*
 * Copyright (c) 2014, 2015 by Delphix. All rights reserved.
 */

/* global _ */

'use strict';

var dxUtil = require('dxcore/js/util.js'),
    dxConstants = require('dxcore/js/constants.js');

/*
 * Do top-level processing of each schema. This involves:
 *  1) If the schema has no name, replace it with a name, based on the schemaKey, that can be used as a Javascript
 *     identifier.
 *  2) Replace the extends schemaKey (if present) with the name of the parent schema.
 *  3) Add a parentSchema property with a reference to the parent schema, if any.
 *  4) Add the name of the closest ancestor schema type that had a root property.
 *  5) Inherit the parent's root property, if this itself doesn't have one.
 */
function processSchema(schema, schemaKey, sourceSchemas, newSchemas, preserveUnneeded) {
    /*
     * Most schemas have a name. However, not all do.  We must nevertheless expose those schemas as they have root
     * operations on them. Thus, we convert the key into a form that can be used to identify them.
     */
    schema.name = schemaKeyToTypeName(schemaKey, sourceSchemas);

    // If this schema has already been processed (see recursive call, below), return it
    if (newSchemas[schema.name]) {
        return newSchemas[schema.name];
    }

    newSchemas[schema.name] = schema;

    if (schema.root) {
        schema.rootTypeName = schema.name;
    }

    // Process the parent schema, if any. This assumes all extends schemas have just a $ref property.
    var parentSchema = schema['extends'];
    if (parentSchema) {
        schema.parentSchema = processSchema(sourceSchemas[parentSchema.$ref], parentSchema.$ref, sourceSchemas, newSchemas);
        parentSchema.$ref = schemaKeyToTypeName(parentSchema.$ref, sourceSchemas);
        parentSchema = schema.parentSchema;

        if (!schema.rootTypeName) {
            schema.rootTypeName = parentSchema.rootTypeName;
        }

        schema.root = schema.root || parentSchema.root;
    }

    if (!preserveUnneeded) {
        delete schema.description;
    }

    processProperties(schema, parentSchema, sourceSchemas, preserveUnneeded);
    processOperations(schema, parentSchema, sourceSchemas);

    return schema;
}

/*
 * The schemaKeys we get are often of the form /some-name.json. Some of the characters that show up there can not be
 * used as a Javascript identifier, and so we modify the above into a Javascript compatible form. For example the
 * above would become some_name.
 */
function schemaKeyToTypeName(schemaKey, schemas) {
    if (!schemas[schemaKey]) {
        dxUtil.fail('Could not find a schema entry for ' + schemaKey);
    }

    if (schemas[schemaKey].name) {
        return schemas[schemaKey].name;
    }

    var newString = schemaKey.replace(/\.json$/, '').replace(/-/g, '_').replace(/\//g, '');

    return newString;
}

/*
 * Process the properties. As far as this is concerned, properties are one of:
 * A simple primitive value
 *     propertyName: {
 *         type: string|number|integer|boolean|null,
 *         [default: value]
 *     }
 *  or a simple object
 *     propertyName: {
 *         type: object
 *     }
 *  or an 'embedded object'
 *     propertyName: {
 *         type: object,
 *         $ref: schemaKey
 *     }
 *  or a 'referenced object'
 *     propertyName: {
 *         type: string,
 *         format: objectReference,
 *         [referenceTo: schemaKey]
 *     }
 *  or an array
 *     propertyName: {
 *         type: array,
 *         [items: {
 *             type: string|number|integer|boolean|null|object,
 *             [$ref: schemaKey]
 *         }]
 *     }
 *  note: $ref may only present if the type is object.
 * Also the type can be an array of any of the things above.
 *
 * Any one of these may also have these values:
 *         [create: required|optional|readonly,]
 *         [update: required|optional|readonly,]
 *         [required: true|false]
 * Note that there are many other validation related properties, but they are not altered by this processing.
 *
 * This does two things:
 *  1) provides 'property inheritance' by copying the parent's properties (if any) and replacing them as appropriate
 *     with this schema's properties.
 *  2) Replaces any references to schema types with the type name of the target types.
 */
function processProperties(schema, parentSchema, sourceSchemas, preserveUnneeded) {
    if (!schema.properties && !(parentSchema && parentSchema.properties)) {
        return;
    }

    var parentProps = parentSchema && parentSchema.properties ? _.clone(parentSchema.properties) : {};
    var propKeys = _.keys(schema.properties || {});
    schema.properties = _.extend(schema.properties || {}, _.omit(parentProps, propKeys));

    // Modify any of the schemas own properties
    _.each(propKeys, function (propName) {
        var propData = schema.properties[propName];

        convertTypeReference(propData, sourceSchemas);

        if (!preserveUnneeded) {
            delete propData.description;
        }
    });
}

/*
 * Process all operations. these look like the following:
 *     operations: {
 *         operationName: { ... details ... },
 *         ...
 *     }
 * or
 *     rootOperations: {
 *         operationName: { ... details ... },
 *         ...
 *     }
 * or one of the following
 *     create: { ... details ... }
 *     read: { ... details ... }
 *     list: { ... details ... }
 *     update: { ... details ... }
 *     delete: { ... details ... }
 *
 * This makes the following changes to these schemas:
 *  1) Schemas that are extensions of a root schema will inherit their parents' operations
 *  2) Standard operations update, delete and read are propogated down to child objects. List and create are not
 */
function processOperations(schema, parentSchema, sourceSchemas) {
    // Do some schema validation
    var schemaOps = _.pick(schema, ['operations', 'rootOperations', 'create', 'read', 'list', 'update', 'delete']);
    if (!schema.root && !_.isEmpty(schemaOps)) {
        dxUtil.fail('Found ' + _.keys(schemaOps) + ' on a non-root schema.');
    }

    if (schema.operations && parentSchema && parentSchema.operations) {
        dxUtil.fail('Both ' + parentSchema.name + ' and ' + schema.name + ' have operations. This isn\'t supported.');
    }

    var parentOps = parentSchema && parentSchema.operations ? parentSchema.operations : {};
    var opKeys = schema.operations ? _.keys(schema.operations) : [];
    var myOperations = _.extend(schema.operations || {}, _.omit(parentOps, opKeys));

    if (!_.isEmpty(myOperations)) {
        schema.operations = myOperations;

        _.each(opKeys, function (opName) {
            processOperation(schema.operations[opName], opName, sourceSchemas);
        });
    }

    _.each(schema.rootOperations, function (opInfo, opName) {
        processOperation(opInfo, opName, sourceSchemas);
    });

    var pSchema = parentSchema || {};
    _.each(['create', 'update', 'read', 'list', 'delete'], function (opName) {
        var opDef = schema[opName];
        if (!dxUtil.isNone(opDef)) {
            if (opName === 'create' || opName === 'update') {
                opDef.validateAs = opDef.validateAs || opName;
            }

            processOperation(opDef, opName, sourceSchemas);
        }

        if (opName !== 'create' && opName !== 'list') {
            schema[opName] = opDef || pSchema[opName];
        }
    });
}

/*
 * Process each operation. This generalizes across standard, object and root operations. These are expected to be of
 * the form:
 *     operationName: {
 *         payload: {
 *             [type: 'object',
 *             $ref: url-to-type]
 *         }
 *         [validateAs: create|update]
 *         [required: true|false]
 *         [return: ...]
 *     }
 * or
 *     operationName: {
 *         parameters: {
 *             ...
 *         }
 *         [return: ...]
 *     }
 * or the following, which means a GET with no parameters
 *     operationName: {
 *     }
 * Any one of those may have a 'sub-operation' of the same form (though, the last, with neither payload nor
 * parameters defined will be recognized, simply because it is ambiguous with other entries).
 *         subOpName: {
 *             payload: {...},
 *             [validateAs: create|update]
 *             [return: ...]
 *          }
 * or
 *         subOpName: {
 *             parameters: {...},
 *             [return: ...]
 *          }
 * The parameters are expected to be one of the following forms:
 *     paramName: {
 *         type: typeName,
 *         [format: formatValue],
 *         [enum: [values...]],
 *         [default: defaultValue]
 *         [required: true|false]
 *     }
 * or
 *     paramName: {
 *         type: 'string',
 *         format: 'objectReference',
 *         referenceTo: schemaKey
 *         [required: true|false]
 *     }
 * While, the return value is expected to be one of the following:
 *     return : {
 *        type: typeName,
 *         [format: formatValue]
 *     }
 * or
 *     return : {
 *        type: typeName,
 *         [$ref: schemaKey]
 *     }
 * or
 *     return : {
 *        type: 'array',
 *         [items: {
 *             $ref: schemaKey
 *         }]
 *     }
 * or
 *     return : {
 *        type: 'array',
 *         [items: {
 *             referenceTo: schemaKey
 *         }]
 *     }
 * These will be modified in these ways:
 *  1) $ref and referenceTo's will be set to type name of the relevant schemas
 *  2) Any sub-operation is extracted from its default location, and put into a sub-object called dxOperations
 *  3) in the case of a 'missing' parameters, an empty one will be inserted.
 *  4) Any $ref in the return value or the return.items value will be replaced with the type name of the schema.
 * Thus, we get:
 * {
 *     payload: {
 *         ...payload properties...
 *         $ref: <related schema>
 *     }
 *     validateAs: create|update,
 *     [dxOperations: {
 *         // sub-operations
 *     }]
 * }
 * or
 * {
 *     parameters: {
 *         ... parameters info, with any referenceTo's set to the actual related schema ...
 *     },
 *     [dxOperations: {
 *         // sub-operations
 *     }]
 * }
 */
function processOperation(opDef, opName, sourceSchemas) {
    if (opDef.payload) {
        if (opDef.parameters) {
            dxUtil.fail('Found both a payload and a parameters for the operation ' + opName + '.');
        }
        if (opDef.payload.$ref) {
            opDef.payload.$ref = schemaKeyToTypeName(opDef.payload.$ref, sourceSchemas);
        }
    } else {
        opDef.parameters = opDef.parameters || {};

        _.each(opDef.parameters, function (value) {
            if (value.referenceTo) {
                value.referenceTo = schemaKeyToTypeName(value.referenceTo, sourceSchemas);
            }
        });
    }

    if (opDef['return']) {
        convertTypeReference(opDef['return'], sourceSchemas);
    }

    // Move any sub-operations into a sub-object
    _.each(opDef, function (value, key) {
        if (key === 'payload' || key === 'parameters') {
            return;
        }
        if (value.payload || value.parameters) {
            opDef.dxOperations = opDef.dxOperations || {};
            opDef.dxOperations[key] = processOperation(value, opName + '.' + key, sourceSchemas);
            delete opDef[key];
        }
    });

    return opDef;
}

/*
 * Given a type reference (a property type definition, or a return value definition), convert any references to
 * schema types from schemaKey format to the actual type name.
 */
function convertTypeReference(propData, sourceSchemas) {
    function convertReferences(type, propData) {
        if (type === 'array' && _.has(propData, 'items')) {
            if (_.has(propData.items, '$ref')) {
                propData.items.$ref = schemaKeyToTypeName(propData.items.$ref, sourceSchemas);
            } else if (_.has(propData.items, 'referenceTo')) {
                propData.items.referenceTo = schemaKeyToTypeName(propData.items.referenceTo, sourceSchemas);
            }
        }

        if (type === 'string' && propData.format === 'objectReference' && propData.referenceTo) {
            propData.referenceTo = schemaKeyToTypeName(propData.referenceTo, sourceSchemas);
        }

        if (type === 'object' && propData.$ref) {
            propData.$ref = schemaKeyToTypeName(propData.$ref, sourceSchemas);
        }
    }

    if (_.isArray(propData.type)) {
        _.each(propData.type, function (typeItem) {
            convertReferences(typeItem, propData);
        });
    } else {
        convertReferences(propData.type, propData);
    }
}

/*
 * Walk through each list operation, and add a dxFilterMode property to each. The values are:
 *    none: There are no query parameters, no filter is needed
 *    uber: Every parameter has a mapsTo property, so the uberFilter can be used
 *    custom: Not enough information. A custom filter will be needed.
 */
function markListOperations(schemas) {
    _.each(schemas, function (schema) {
        if (schema.list) {
            if (_.isEmpty(schema.list.parameters)) {
                schema.list.dxFilterMode = dxConstants.LIST_TYPES.NONE;
            } else {
                var missingMapsTo = false;
                _.any(schema.list.parameters, function (param) {
                    if (!param.mapsTo) {
                        missingMapsTo = true;
                        return true;
                    }
                });
                schema.list.dxFilterMode = missingMapsTo ? dxConstants.LIST_TYPES.CUSTOM : dxConstants.LIST_TYPES.UBER;
            }
        }
    });
}

/*
 * Given a set of schemas, modify them so that they are more easily consumable by other layers of the data system.
 *
 * Specifically, this expects the schemas to come in the form:
 * {
 *     'schemaKey': {
 *        [name: typeName,]
 *        [singleton: true|false,]
 *        [extends: { $ref: 'schemaKey' },]
 *        [root: 'url-fragment',]
 *        [properties: {...},]
 *        [create: {...},]
 *        [read: {...},]
 *        [list: {...},]
 *        [update: {...},]
 *        [delete: {...},]
 *        [operations: {...},]
 *        [rootOperations: {...}]
 *     },
 *     ...
 * }
 * Each schema may include other properties, but this will ignore them.
 *
 * The return value from this routine is a new version of the schemas, with modifications as discussed in each section
 * below.
 *
 * schemas:               The set of schemas to be prepared.  This is the only parameter that must be provided.
 * copySchemas:           If truthy, this will make a copy of the provided schemas before making changes to them.
 *                        Otherwise the original schema objects will be altered.
 * preserveUnneeded:      If truthy, properties like 'description' that aren't needed will not be deleted.
 */
function prepareSchemas(schemas, copySchemas, preserveUnneeded) {
    var newSchemas = {};

    if (!_.isObject(schemas)) {
        dxUtil.fail('Must provide a schemas object.');
    }

    // Always copy the schemas at this time, as it caused model-generator to be unhappy.
    if (copySchemas || true) {
        schemas = dxUtil.deepClone(schemas);
    }

    _.each(schemas, function (value, key) {
        processSchema(value, key, schemas, newSchemas, preserveUnneeded);
    });

    /*
     * Finally, add a flag to each list operation to determine whether it can be generically filtered, or whether
     * it needs help
     */
    markListOperations(newSchemas);

    return newSchemas;
}

/*
 * Given a set of prepared schemas, this will find enums that are properties of a type and enums that are defined as
 * parameters of list, object, and root operations.  The expected input format of the prepared schemas is as follows:
 *
 *  {
 *      typeName: {
 *          [properties: {
 *              propertyName: {
 *                  enum: [value, ...]
 *              },
 *              arrayPropertyName: {
 *                  items: {
 *                      enum: [value, ...]
 *                  }
 *              }
 *          },]
 *          [list: {
 *              parameters: {
 *                  parameterName: {
 *                      enum: [value, ...]
 *                  }
 *              }
 *          },]
 *          [rootOperations|operations: {
 *              operationName: {
 *                  parameters: {...}
 *              }
 *          }]
 *      }
 *  }
 *
 * No specific types, properties or parameters are required, and excess properties will be ignored.  The output is an
 * object where each type and its enums can be accessed as properties:
 *
 *  {
 *      typeName: {
 *          (property|operation)Name: {
 *              value: value
 *              ...
 *          }
 *      }
 *  }
 *
 */
function prepareEnums(schemas) {
    var enums = {};

    if (!_.isObject(schemas)) {
        dxUtil.fail('Must provide a set of prepared schemas.');
    }

    function processEnum(type, name, definition) {
        var enumType = enums[type] = enums[type] || {};
        var enumProp = enumType[name] = enumType[name] || {};
        _.each(definition['enum'], function (enumVal) {
            enumProp[enumVal] = enumVal;
        });
    }

    function processParameters(type, opDef) {
        _.each(opDef.parameters, function (paramDef, paramName) {
            if (paramDef['enum']) {
                processEnum(type, paramName, paramDef);
            }
        });
    }

    _.each(schemas, function (schema, type) {
        _.each(schema.properties, function (propDef, propName) {
            if (propDef['enum']) {
                processEnum(type, propName, propDef);
                // Array of enums
            } else if (propDef.items && propDef.items['enum']) {
                    processEnum(type, propName, propDef.items);
                }
        });

        // Collect enums from list, root operation, and object operation parameters
        if (schema.list) {
            processParameters(type, schema.list);
        }
        _.each(schema.rootOperations, function (rootOpDef) {
            processParameters(type, rootOpDef);
        });
        _.each(schema.operations, function (opDef) {
            processParameters(type, opDef);
        });
    });

    return enums;
}

module.exports = {
    _prepareSchemas: prepareSchemas,
    _prepareEnums: prepareEnums
};

},{"dxcore/js/constants.js":15,"dxcore/js/util.js":23}],6:[function(require,module,exports){
/*
 * Copyright (c) 2014, 2015 by Delphix. All rights reserved.
 */

/* global _, Backbone */

'use strict';

var dxUtil = require('dxcore/js/util.js');

function dumpEventListners(eventLadenObject) {
    var functionNameRegEx = /.*function *([^ \(]*) *\(/;
    _.each(eventLadenObject._events, function (listenerArray, eventName) {
        var anonymousCount = 0;
        var callbackNames = _.reduce(listenerArray, function (memo, item) {
            if (item.callback) {
                var functionString = item.callback.toString();
                var functionName = functionString.match(functionNameRegEx);
                if (functionName && functionName[1] !== '') {
                    memo.push(functionName[1]);
                } else {
                    anonymousCount++;
                }
            }
            return memo;
        }, []);

        // Don't show the internal callbacks used by this cache to mange the models. These never affect prune().
        if (callbackNames.length === 1 && (eventName === 'badReference' && callbackNames[0] === 'handle404' || eventName === 'change' && callbackNames[0] === 'updateCollections')) {
            return;
        }
        var suffix = callbackNames.length === 0 ? '' : '. ' + callbackNames.join(',');
        if (anonymousCount > 0) {
            suffix += ' (' + anonymousCount + ' anonymous)';
        }
        dxUtil.info('   ' + eventName + ' : ' + listenerArray.length + ' callbacks' + suffix);
    });
}

/*
 * A simple cache of subscribers (collections or notification listeners).  Note that these are stored by the type that
 * the list operation for the specified type returns, which in some cases is different than the specified type.
 * This is a private type, so it does no checking of arguments.
 */
function ModelSubscriberStore() {
    var modelSubscribersByType = {};

    function forEachSubscription(functionToApply) {
        _.each(modelSubscribersByType, function (subscriber) {
            _.each(subscriber, functionToApply);
        });
    }

    function add(subscriber) {
        var baseType = subscriber._dxInfo.baseType;
        modelSubscribersByType[baseType] = modelSubscribersByType[baseType] || [];

        if (modelSubscribersByType[baseType].indexOf(subscriber) === -1) {
            modelSubscribersByType[baseType].push(subscriber);
        }
    }

    function remove(subscriber) {
        var baseType = subscriber._dxInfo.baseType;
        var index = modelSubscribersByType[baseType].indexOf(subscriber);
        if (index !== -1) {
            if (subscriber instanceof Backbone.Collection) {
                subscriber.clear();
            }
            modelSubscribersByType[baseType].splice(index, 1);

            if (_.isEmpty(modelSubscribersByType[baseType])) {
                delete modelSubscribersByType[baseType];
            }
        }
    }

    function hasType(typeName) {
        return !!modelSubscribersByType[typeName];
    }

    function getAllOfType(typeName) {
        return modelSubscribersByType[typeName] || [];
    }

    /*
     * Forcibly empty all collections in the store, and then remove all subscribers
     */
    function reset() {
        var toRemove = [];

        // accumulate the items to remove
        forEachSubscription(function (subscriber) {
            toRemove.push(subscriber);
        });

        // now remove them (removing while accumulating can mess up the loops)
        _.each(toRemove, remove);
    }

    /*
     * Remove all subscribers that have no more listeners
     */
    function prune() {
        var toRemove = [];

        forEachSubscription(function (subscriber) {
            if (subscriber instanceof Backbone.Collection) {
                if (_.isEmpty(subscriber._events)) {
                    toRemove.push(subscriber);
                }
            } else if (!subscriber.inUse) {
                // it is a creation Listener
                toRemove.push(subscriber);
            }
        });

        _.each(toRemove, remove);
    }

    /*
     * Returns:
     *    true: If the store has no subscribers
     *    false: if the store has one or more subscribers
     */
    function isEmpty() {
        return _.isEmpty(modelSubscribersByType);
    }

    /*
     * Write out the subscribers.
     */
    function dump() {
        dxUtil.info('SUBSCRIBERS');
        dxUtil.info('===========');
        dxUtil.info(modelSubscribersByType);
    }

    function dumpText() {
        dxUtil.info('SUBSCRIBERS');
        dxUtil.info('===========');
        if (_.isEmpty(modelSubscribersByType)) {
            dxUtil.info('None.');
        }
        var types = _.keys(modelSubscribersByType);
        _.each(types.sort(), function (typeName) {
            dxUtil.info(typeName);
            dxUtil.info('-------------');
            _.each(modelSubscribersByType[typeName], function (subscriber) {
                if (subscriber instanceof Backbone.Collection) {
                    var collection = subscriber;
                    var references = collection.reduce(function (memo, item) {
                        if (item.id) {
                            memo.push(item.id);
                        }
                        return memo;
                    }, []);

                    var suffix = references.length === 0 ? '' : '. IDs: ' + references.join(', ');
                    dxUtil.info('   ' + collection.length + ' model collection' + suffix);
                    dumpEventListners(collection);
                } else {
                    var qp = subscriber.getQueryParameters();
                    dxUtil.info('Notification Listener with query params: ' + (qp ? JSON.stringify(qp) : 'None'));
                }
            });
        });
    }

    return {
        _modelSubscribers: modelSubscribersByType,
        add: add,
        remove: remove,
        hasType: hasType,
        getAllOfType: getAllOfType,
        reset: reset,
        dump: dump,
        prune: prune,
        isEmpty: isEmpty,
        dumpText: dumpText
    };
}

/*
 * A simple cache of singletons.  This is a private type, so it does no checking of arguments.
 */
function SingletonStore() {
    var singletons = {};

    function add(singleton) {
        singletons[singleton.get('type')] = singleton;
    }

    function get(typeName) {
        return singletons[typeName];
    }

    function remove(singleton) {
        if (!_.isUndefined(singletons[singleton.get('type')])) {
            delete singletons[singleton.get('type')];
        }
    }

    function hasType(typeName) {
        return !!singletons[typeName];
    }

    /*
     * Forcibly remove all singletons
     */
    function reset() {
        _.each(_.keys(singletons), function (typeName) {
            delete singletons[typeName];
        });
    }

    /*
     * Remove all singletons that have no more listeners
     */
    function prune() {
        var toRemove = _.filter(singletons, function (singleton) {
            return _.isEmpty(singleton._events);
        });

        _.each(toRemove, function (model) {
            delete singletons[model.get('type')];
        });
    }

    /*
     * Returns:
     *    true: If the store has no singletons
     *    false: if the store has one or more singletons
     */
    function isEmpty() {
        return _.isEmpty(singletons);
    }

    /*
     * Write out the singletons.
     */
    function dump() {
        dxUtil.info('SINGLETONS');
        dxUtil.info('==========');
        dxUtil.info(singletons);
    }

    function dumpText() {
        dxUtil.info('SINGLETONS');
        dxUtil.info('==========');
        if (_.isEmpty(singletons)) {
            dxUtil.info('None.');
        }
        _.each(singletons, function (singleton, typeName) {
            dxUtil.info(typeName);
            dumpEventListners(singleton);
        });
    }

    return {
        _singletons: singletons,
        add: add,
        get: get,
        remove: remove,
        hasType: hasType,
        reset: reset,
        dump: dump,
        prune: prune,
        isEmpty: isEmpty,
        dumpText: dumpText
    };
}

/*
 * A simple cache of models.  These are organized by root type, then reference. This is a private type, so it does no
 * signifianct checking of arguments.
 */
function ModelStore(context) {
    var modelsByTypeThenRef = {};

    function forEachModel(functionToApply) {
        _.each(modelsByTypeThenRef, function (models) {
            _.each(models, functionToApply);
        });
    }

    function add(model) {
        var rootType = context._getRootType(model.get('type'));
        var reference = model.get('reference');
        modelsByTypeThenRef[rootType] = modelsByTypeThenRef[rootType] || {};

        if (dxUtil.isNone(reference)) {
            dxUtil.fail('Can not cache a model with no reference (type is: ' + model.get('type') + ').');
        }

        modelsByTypeThenRef[rootType][reference] = model;
    }

    // typeName is optional
    function get(reference, typeName) {
        if (_.isUndefined(typeName)) {
            var result;
            _.find(modelsByTypeThenRef, function (models) {
                return _.find(models, function (model, modelReference) {
                    if (modelReference === reference) {
                        result = model;
                        return true;
                    }
                });
            });
            return result;
        } else {
            return modelsByTypeThenRef[typeName] ? modelsByTypeThenRef[typeName][reference] : undefined;
        }
    }

    function remove(model) {
        var rootType = context._getRootType(model.get('type'));
        var reference = model.get('reference');
        modelsByTypeThenRef[rootType] = modelsByTypeThenRef[rootType] || [];
        model.off(undefined, undefined, context);

        delete modelsByTypeThenRef[rootType][reference];

        if (_.isEmpty(modelsByTypeThenRef[rootType])) {
            delete modelsByTypeThenRef[rootType];
        }
    }

    function hasModel(reference) {
        return !!get(reference);
    }

    /*
     * Forcibly remove all models
     */
    function reset() {
        var toRemove = [];

        forEachModel(function (model) {
            toRemove.push(model);
        });

        _.each(toRemove, remove);
    }

    /*
     * Remove all models that have no more listeners
     */
    function prune() {
        var toRemove = {};

        forEachModel(function (model, reference) {
            var events = model._events || {};
            /*
             * Our model creation system currently sets up listeners on badReference.  If a model has
             * only one listener for that event, we want to ignore it when we consider whether the model has any
             * listeners that should prevent it from being pruned. (we don't mind pruning something that only has
             * listeners set up by the model creation system)
             */
            var hasCachingListeners = events.badReference && events.badReference.length === 1;
            var listeners = hasCachingListeners ? _.omit(events, ['badReference']) : events;

            if (_.isEmpty(listeners)) {
                toRemove[reference] = model;
            }
        });

        _.each(toRemove, remove);
    }

    /*
     * Returns:
     *    true: If the store has no models
     *    false: if the store has one or more models
     */
    function isEmpty() {
        return _.isEmpty(modelsByTypeThenRef);
    }

    /*
     * Write out the models.
     */
    function dump() {
        dxUtil.info('SERVER MODELS');
        dxUtil.info('=============');
        dxUtil.info(modelsByTypeThenRef);
    }

    function dumpText() {
        dxUtil.info('SERVER MODELS');
        dxUtil.info('=============');
        if (_.isEmpty(modelsByTypeThenRef)) {
            dxUtil.info('None.');
        }
        var types = _.keys(modelsByTypeThenRef);
        _.each(types.sort(), function (typeName) {
            dxUtil.info(typeName);
            dxUtil.info('-------------');
            var references = _.keys(modelsByTypeThenRef[typeName]);
            _.each(references.sort(), function (reference) {
                var model = modelsByTypeThenRef[typeName][reference];
                dxUtil.info(reference);
                dumpEventListners(model);
            });
        });
    }

    return {
        _models: modelsByTypeThenRef,
        add: add,
        get: get,
        remove: remove,
        hasModel: hasModel,
        reset: reset,
        dump: dump,
        prune: prune,
        isEmpty: isEmpty,
        dumpText: dumpText
    };
}

/*
 * This portion of the data system provides a cache of models and subscribers, collections and notification listeners.
 * It ensures that models are unique (that is, there is only one instance for a particular reference), it makes sure
 * all collections contain the models that they legitimately could contain, and subscribers are notified of new
 * models.
 *
 * There are four primary uses:
 *   - Someone retrieves data from the server. It would call getCachedModelFromProperties() which will create or update
 *     a model using those properties, and return the model to the caller.
 *   - Someone wants to retrieve a particular model. It calls getCachedModel(), which returns the requested model (and
 *     does a fetch on it, if necessary)
 *   - Someone wants to get a singleton: so it calls getCachedSingleton() which returns the unique singleton instance.
 *   - Someone wants a collection or notification subscribers of a particular type. They create the data structure
 *     and call _modelSubscribersStore.add to make sure the subscribers gets notified of changes and collections
 *     updated.
 *
 * This entire cache system is 'private' to the data system, and should not be called from outside.
 *
 * Unless reset() is called, at this time models and collections are never discarded.
 *
 * As with other parts of the data system, this takes a 'context' object, and attaches a _cache object to that one,
 * where private (to the data system) caching routines reside. The intent here is to make sure that if needed multiple
 * data systems can co-exist.
 */
module.exports._initCache = function _initCache(context) {
    /*
     * Return a singleton of the specified type. If it doesn't already exist, a new model is created, cached, and
     * returned.  If 'update' is true, then this will fetch new data for the model.
     * typeName:   The type of the singleton
     * options:    JSON object with these optional properties:
     *               update: {true|false}  Will cause an update (fetch) on the model
     *               success: A function to call when the model is ready
     *               error: A function to call when an error occurred during a fetch
     */
    function getCachedSingleton(typeName, options) {
        if (!_.isString(typeName)) {
            dxUtil.fail('A type name must be passed to get the singleton.');
        }
        options = options || {};
        var model;
        var isNew;
        if (context._singletonStore.hasType(typeName)) {
            model = context._singletonStore.get(typeName);
            if (options.success) {
                options.success(model);
            }
        } else {
            var schema = assertTypeAndGetModelSchema(typeName);

            if (!schema.singleton) {
                dxUtil.fail(typeName + ' is not a singleton.');
            }

            model = context._newServerModel(typeName);
            context._singletonStore.add(model);
            isNew = true;
        }

        if (options.update || isNew) {
            var fetchOpts = options;
            if (isNew) {
                fetchOpts = {
                    success: options.success,
                    error: function error(result) {
                        context._singletonStore.remove(model);
                        if (options.error) {
                            options.error(result);
                        } else if (!options.suppressDefaultErrorHandler) {
                            context.reportErrorResult(result);
                        }
                    }
                };
            }
            model._dxFetch(fetchOpts);
        }

        return model;
    }

    /*
     * Given a set of properties, either update an existing model with the same reference as in the properties
     * object, or create a new server model, populate it with these properties, cache it and return it.
     *
     * properties: A JSON object containing properties that can be set() on a DSB model
     * options:    Backbone options
     */
    function getCachedModelFromProperties(properties, options) {
        var model;

        if (!_.isObject(properties) || !_.isString(properties.type)) {
            dxUtil.fail('Must be called with an object that has a type property that is a string value.');
        }

        if (!context._modelConstructors[properties.type]) {
            dxUtil.fail('Don\'t know how to create a model of type ' + properties.type + '.');
        }

        // Not all types have a reference property. Those that do not are not cachable. Assume this is a client model
        if (!isTypeCachable(properties.type) || dxUtil.isNone(properties.reference)) {
            model = context._newClientModel(properties.type);
            model._dxSet(properties);
            return model;
        }

        var rootType = context._getRootType(properties.type);
        model = context._modelStore.get(properties.reference, rootType);
        if (_.isUndefined(model)) {
            model = makeModel(properties, properties.type, rootType);
            model._dxMakeReady();
            addModel(model, rootType, options);
        } else {
            model._dxSet(properties);
        }

        return model;
    }

    /*
     * Returns a cached model with the specified reference.  If the model isn't in the cache, this will return
     * a new model, which it will also fetch. If the update argument is true, it will be
     * fetched regardless of whether it is new or old.
     *
     * reference:  The reference of the model to retrieve
     * typeName:   The type of the model @@@@ why isn't this the root type?
     * options:    JSON object with these optional properties:
     *               update: {true|false}  Will cause an update (fetch) on the model
     *               cacheOnlyIfNeeded: {true|false} Add to the cache (and return) only if there are already
     *                  collections that would use it.
     *               suppressDefaultErrorHandler: {true|false} Do not trigger the default error handler on dxFetch
     */
    function getCachedModel(reference, typeName, options) {
        if (!_.isString(reference) || !_.isString(typeName)) {
            dxUtil.fail('A reference and a type must be passed to get the model.');
        }
        options = options || {};

        var isNew = false;
        var rootType = context._getRootType(typeName);
        var mustCache = !options.cacheOnlyIfNeeded;
        var haveSubscriptionWhichNeedsModel = context._modelSubscribersStore.getAllOfType(rootType).length !== 0;
        var addToCache = mustCache || haveSubscriptionWhichNeedsModel;

        var model = context._modelStore.get(reference, rootType);
        if (_.isUndefined(model) && addToCache) {
            model = makeModel({ reference: reference }, typeName, rootType);
            isNew = true;
        }

        if (model && (options.update || isNew)) {
            model._dxFetch({
                success: function success() {
                    if (isNew) {
                        addModel(model, rootType);
                    }
                },
                error: function error(result) {
                    if (isNew) {
                        context._modelStore.remove(model);
                    }
                    if (!options || !options.suppressDefaultErrorHandler) {
                        context.reportErrorResult(result);
                    }
                }
            });
        }

        return model;
    }

    /*
     * Returns true if the cache contains a model with the specified reference
     */
    function containsCachedModel(reference, typeName) {
        if (!_.isString(reference) || !_.isString(typeName)) {
            dxUtil.fail('A reference and a type must be passed to check on the model.');
        }

        return !_.isUndefined(context._modelStore.get(reference, context._getRootType(typeName)));
    }

    /*
     * Deletes the model. This means removing it from the cache, as well as from any
     * collections that contain it, and clears the model's properties.
     * If the dontTriggerDelete flag is not set, this will also trigger a 'delete' event on the model.
     */
    function deleteCachedModel(reference, typeName, dontTriggerDelete) {
        if (!_.isString(reference) || !_.isString(typeName)) {
            dxUtil.fail('A reference and a type must be passed to delete a model.');
        }

        var rootType = context._getRootType(typeName);
        var doomed = context._modelStore.get(reference, rootType);
        if (!doomed) {
            return;
        }

        _.each(context._modelSubscribersStore.getAllOfType(rootType), function (subscriber) {
            if (subscriber instanceof Backbone.Collection) {
                subscriber._dxRemoveModel(doomed);
            }
        });

        if (!dontTriggerDelete) {
            doomed.trigger('delete', doomed);
        }
        doomed.off(null, null, context);
        context._modelStore.remove(doomed);
        doomed._dxClear();
        doomed._dxDeleted = true;
    }

    /*
     * Remove all references we have to both singletons and server models.
     */
    function resetCache() {
        context._modelSubscribersStore.reset();
        context._singletonStore.reset();
        context._modelStore.reset();
    }

    /*
     * Dump the types (for singletons) and references (for server models) as text for all objects in the cache.
     */
    function dumpCacheAsText() {
        context._modelSubscribersStore.dumpText();
        dxUtil.info('');

        context._singletonStore.dumpText();
        dxUtil.info('');

        context._modelStore.dumpText();
    }

    /*
     * Dump the internal singletons and model data structures.  This is usable on most browsers.
     */
    function dumpCache() {
        context._modelSubscribersStore.dump();
        dxUtil.info('');

        context._singletonStore.dump();
        dxUtil.info('');

        context._modelStore.dump();
        dxUtil.info('');
    }

    function prune() {
        context._modelSubscribersStore.prune();
        context._singletonStore.prune();
        context._modelStore.prune();
    }

    function isEmpty() {
        return context._modelSubscribersStore.isEmpty() && context._singletonStore.isEmpty() && context._modelStore.isEmpty();
    }

    /*
     * Creates a model, sticks it in the cache, and sets up to cope with badReferences
     */
    function makeModel(properties, typeName, rootType) {
        var model = context._newServerModel(typeName);
        model._dxSet(properties);
        context._modelStore.add(model);
        model.on('badReference', function handle404() {
            deleteCachedModel(properties.reference, rootType, true);
        }, context);

        return model;
    }

    /*
     * Adds the specified model to the collections
     */
    function addModel(model, rootType, options) {
        notifySubscriptionsOfModel(model, rootType, options);
    }

    /*
     * Indicates that a model may have changed, and the cache should recheck whether the model should be added or
     * removed from any collections.
     */
    function modelMayHaveChanged(model, rootType) {
        if (!(model instanceof Backbone.Model)) {
            dxUtil.fail('Must pass a Backbone Model.');
        }
        if (!_.isString(rootType)) {
            dxUtil.fail('rootType must be a string.');
        }

        notifySubscriptionsOfModelChanged(model, rootType);
    }

    /*
     * Adds the specified model to all relevant subscribers (collections or notification listeners).
     */
    function notifySubscriptionsOfModel(model, rootType, options) {
        _.each(context._modelSubscribersStore.getAllOfType(rootType), function (subscriber) {
            subscriber._dxAddOrRemove(model, options);
        });
    }

    /*
     * Notifies collections that the model has changed.
     */
    function notifySubscriptionsOfModelChanged(model, rootType, options) {
        _.each(context._modelSubscribersStore.getAllOfType(rootType), function (subscriber) {
            if (subscriber instanceof Backbone.Collection) {
                subscriber._dxAddOrRemove(model, options);
            }
        });
    }

    /*
     * Asserts that the type is a valid model type, and returns its schema.
     */
    function assertTypeAndGetModelSchema(typeName) {
        var ModelConstructor = context._modelConstructors[typeName];

        if (!ModelConstructor) {
            dxUtil.fail(typeName + ' is not a known type name.');
        }

        return ModelConstructor.prototype._dxSchema;
    }

    /*
     * Examines the type, and returns a truthy value if it is cachable
     */
    function isTypeCachable(type) {
        var Constructor = context._modelConstructors[type];
        if (!Constructor) {
            return false;
        }
        var typeDef = Constructor.prototype._dxSchema;
        var propDefs = typeDef.properties || {};

        return !!propDefs.reference;
    }

    context = context || this;
    context._modelSubscribersStore = new ModelSubscriberStore();
    context._singletonStore = new SingletonStore();
    context._modelStore = new ModelStore(context);

    /*
     * Make all of our public routines available.
     */
    context._cache = {
        _ModelSubscriberStore: ModelSubscriberStore,
        _SingletonStore: SingletonStore,
        _ModelStore: ModelStore,
        getCachedSingleton: getCachedSingleton,
        getCachedModelFromProperties: getCachedModelFromProperties,
        getCachedModel: getCachedModel,
        modelMayHaveChanged: modelMayHaveChanged,
        deleteCachedModel: deleteCachedModel,
        containsCachedModel: containsCachedModel,
        reset: resetCache,
        dumpText: dumpCacheAsText,
        dump: dumpCache,
        prune: prune,
        isEmpty: isEmpty,
        isTypeCachable: isTypeCachable
    };
};

},{"dxcore/js/util.js":23}],7:[function(require,module,exports){
/*
 * Copyright (c) 2014, 2015 by Delphix. All rights reserved.
 */

/* global $, _, Backbone */

'use strict';

var dxUtil = require('dxcore/js/util.js'),
    dxConstants = require('dxcore/js/constants.js');

/*
 * This takes a set of schemas (modified by _prepareSchemas), and creates a set of Backbone Collection constructor
 * functions (and, by implication, functionality upon the collections generated by those functions). These will be
 * used by the 'level3' API's to provide final collections to consumers of the data layer.
 *
 * See the comment for level2-models for a list of the specialized terminology used here (e.g. DSB).
 *
 * CONSTRUCTOR FUNCTIONS
 * The collections created by these constructor functions contain groups of DSB Models that all share a common parent
 * type.  These collections can only have their contents changed by way of $$list() operations and the notification
 * system. Unlike DSB models, there are no 'Client' collections.  To have a fully-alterable collection of models,
 * use an ordinary Backbone Collection.
 *
 * EVENTS
 * ready : readyHandler(collection)
 * If you want to know if a collection is ready to be used (has retrieved at least one set of results via $$list()),
 * use the 'ready' event, which is unique to DSB collections.
 * Ready indicates that the collection has retrieved an initial set of models.  Unlike ordinary events, if a ready
 * handler is assigned to a collection that is already ready, that handler (and no others) will be triggered
 * immediately. Ready handlers receive the collection as their first (and only) argument.
 *
 * dirty : dirtyHandler(collection)
 * Indicates that the collection may be out of sync with the server and should be re-$$list()'ed
 *
 * POPULATION
 * Server collections are populated in two ways:
 *   1) A call to $$list() will fill the collection with the current set of models from the server
 *   2) The notification system, if enabled, may cause models to be added and removed from the collection at any time.
 * The operation of $$list() is straightforward.  Notifications are a little less clear.  As the notification system
 * learns of object changes, it will inform the caching system about the changes.  That, in turn will cause the
 * caching system to try to update any collections, adding and removing those models to collections as needed.
 * The decision of whether a model should be added will depend on the query parameters that currently govern the
 * collection (the ones last passed to $$list(), if any).  In some cases, a collection may have a paged set of results,
 * and at that point it can be difficult to determine whether the model should be added to the collection.
 * The filter system (level2-filter) provides per-type filters. It is their responsibility to determine how the model
 * should be dealt with. If it can't determine (as in the case with paging), the collection will trigger a 'dirty'
 * event, which the client of the collection can use to decide how to handle this case. If setAutoPageRefresh(true) has
 * been called on the collection, then in these circumstances, in addition to firing the 'dirty' event, the collection
 * will automatically re-call $$list() with the original query parameters. In this case, the original success and error
 * handlers will be called again after the list operation returns.
 *
 * OPERATIONS
 * The collections created by these constructor functions have these similarities and differences compared to the
 * standard Backbone collections.
 *
 * Standard Backbone properties (none of these should be changed)
 *     models     : -- : The set of models in the collection. Don't access directly. Use at() instead.
 *     length     :    : Standard behavior.
 *
 * Standard Backbone functions
 *     model      : -- : Must not use. Collections can not create their own models.
 *     toJSON     :    : Standard behavior.
 *     Underscore :    : Standard behavior. These are the 'underscore' functions can all be applied to collections.
 *     add        : -- : Do not use. Use $$list() instead.
 *     remove     : -- : Do not use. Use $$list() instead.
 *     reset      : -- : Do not use. Use $$list() instead.
 *     set        : -- : Do not use. Use $$list() instead.
 *     get        :    : Standard behavior.
 *     at         :    : Standard behavior.
 *     push       : -- : Do not use. Use $$list() instead.
 *     pop        : -- : Do not use. Use $$list() instead.
 *     unshift    : -- : Do not use. Use $$list() instead.
 *     shift      : -- : Do not use. Use $$list() instead.
 *     slice      :    : Standard behavior.
 *     comparator :    : Standard behavior.
 *     sort       :    : Standard behavior.
 *     pluck      :    : Standard behavior.
 *     where      :    : Standard behavior.
 *     findWhere  :    : Standard behavior.
 *     url        : -- : Internal use. Don't use.
 *     parse      : -- : Internal use. Don't use. Handles return values from the Delphix Engine
 *     clone      :    : Standard behavior. However, the returned collection is an ordinary Backbone Collection.
 *     fetch      : -- : Do not use. Use $$list() instead.
 *     create     : -- : Do not use. DSB Models have more complex creation semantics. use rootOps..$$create().
 *
 * DSB Collection functions
 *     $$list             :    : Populates the collection with a selection of models from the server.
 *     getQueryParameters :    : Returns the query parameters used to populate this collection via $$list
 *     clear              :    : Removes all models from the collection, empties any query parameters, and blocks any
 *                               models from being auto-added until another $$list is issued
 *
 * Private to dxCore Data
 *     context._collectionConstructors : The set of collection constructor functions
 *     context._newServerCollection    : Creates a new Server Collection
 *
 * Parameters:
 *     schemas: The set of schemas this should generate constructors from.
 *     context: The object to put the resulting constructors (_collectionConstructors) on. If not specified, puts them
 *              on 'this'.
 */
module.exports._generateCollectionConstructors = function _generateCollectionConstructors(schemas, context) {
    var LISTINGMODE_IDLE = 0;
    var LISTINGMODE_LISTING = 1;

    /*
     * ========================================
     * Collection functions
     * ========================================
     */

    /*
     * Backbone defines this as: Bind a callback function to an object. The callback will be invoked whenever the event
     * is fired.
     *
     * For DSB collections, we provide standard behavior for this, but do some special processing if someone is
     * listening for the 'ready' event. In that case, if we have done a $$list() successfully, then we trigger the
     * ready event immediately.
     */
    function dxOn(name, callback, context) {
        Backbone.Events.on.call(this, name, callback, context);
        if (name === 'ready' && this._dxIsReady) {
            this.trigger('ready', this);
        } else if (name === 'error' && this._dxIsErrored) {
            this.trigger('error', this);
        }
    }

    /*
     * Backbone defines this as: [This] performs a 'smart' update of the collection with the passed list of models.
     *
     * In general, we do not allow this to be called, since server models are supposed to be read only. However,
     * in some cases, internally, we need to add models to the collection, and wish to partake of the functionality
     * already defined by Backbone. So, if this is called with { _dxAllowSetPassthrough:true }, it will call
     * Backbone.Collection.set() normally.
     *
     * This is not simply a dxAdd function, since we need to support calls from within backbone back to model.set()
     * that may have been triggered by other actions we have taken.
     */
    function dxSet(models, options) {
        options = options || {};
        if (!options._dxAllowSetPassthrough) {
            operationNotAllowed();
        }

        assertModelsCompatible(models, this);
        return Backbone.Collection.prototype.set.call(this, models, _.extend(options, {
            merge: false,
            remove: false
        }));
    }

    /*
     * Backbone defines this as: parse is called by Backbone whenever a collection's models are returned by the server,
     * in fetch. The function is passed the raw response object, and should return the array of model attributes to be
     * added to the collection. The default implementation is a no-op, simply passing through the JSON response.
     * Override this if you need to work with a preexisting API, or better namespace your responses.
     *
     * This expects the response to always have a type attribute. If it is an ErrorResult, it gets reported through the
     * standard error handler. If it is a ListResult, we return just the result array. Otherwise we throw an error.
     */
    function dxParse(response) {
        if (!response || !response.type) {
            dxUtil.fail('Got a response without a type.');
        } else if (response.type !== 'ListResult') {
            dxUtil.fail('Got an unexpected type of response (' + response.type + ') in parse().');
        }

        return response.result;
    }

    /*
     * Entirely block the standard Backbone fetch() routine. We want users to call $$list(), as that has a more
     * constrained API, better matches the api we're providing for operations and rootOperations, and, more directly
     * maps to our schemas.
     */
    function dxFetch() {
        dxUtil.fail('Do not call fetch() directly. Instead, call $$list().');
    }

    /*
     * Entirely block the standard Backbone create() routine. Creation is more complex for DSB models, and so should be
     * done through the $$create operations.
     */
    function dxCreate() {
        dxUtil.fail('Do not call create() directly. Instead, call rootOps.' + this._dxInfo.baseType + '.$$create().');
    }

    /*
     * Removes all models from the collection, but leaves it 'live'.  This is used for testing purposes.
     */
    function dxEmpty() {
        Backbone.Collection.prototype.remove.call(this, this.models, { silent: true });
    }

    /*
     * Removes all models from the collection (not silently), removes the query parameters,
     * if any, and marks the collection as not ready, which means it must have another $$list() call in order to get
     * new models
     */
    function dxClear() {
        this._dxIsReady = false;
        this._queryParameters = undefined;
        Backbone.Collection.prototype.remove.call(this, this.models, { silent: true });
        this.trigger('reset', this);
    }

    /*
     * Given a model, this will either add it to the collection, if it should be in the collection, ignore it if it
     * shouldn't be in the collection (and isn't there already), or remove it if it shouldn't be in the collection and
     * is.  This takes into account any query parameters associated with the collection, and uses collection filters
     * if defined.
     *
     * Note that models can be neither added nor removed if this is not ready.
     */
    function dxAddOrRemove(model, options) {
        assertModelsCompatible(model, this);
        if (!this._dxIsReady) {
            return;
        }
        options = _.extend({
            _dxAllowSetPassthrough: true
        }, options);
        var self = this;
        var rootType = this._dxInfo.baseType;

        if (self._listingMode === LISTINGMODE_LISTING) {
            return;
        }

        var filter = context._filters[rootType];
        if (!filter) {
            if (self._dxInfo.paramDefs.dxFilterMode === dxConstants.LIST_TYPES.NONE) {
                dxSet.call(self, model, options);
                return;
            }

            filter = context._filters._uberFilter;
        }

        filter(this, model, function (placement) {
            if (model._dxDeleted) {
                /*
                 * Since some filters use asynchronous requests to determine the inclusion of an object,
                 * it is possible for an object to be deleted while a filter is executed.
                 * We need to make sure that even if the filter determines that the object should be
                 * included in the list, the collection discards deleted objects.
                 */
                return;
            }
            switch (placement) {
                case context._filters.INCLUDE:
                    dxSet.call(self, model, options);
                    break;
                case context._filters.EXCLUDE:
                    self._dxRemoveModel(model, options);
                    break;
                case context._filters.UNKNOWN:
                    if (self._listingMode === LISTINGMODE_IDLE) {
                        triggerDirty(self);
                    }
                    break;
                default:
                    dxUtil.fail('Filter returned an invalid value.');
            }
        });
    }

    /*
     * Sets the autoPageRefresh property.
     */
    function setAutoPageRefresh(value) {
        this._autoPageRefresh = value;
    }

    /*
     * Return the autoPageRefresh property.
     */
    function getAutoPageRefresh() {
        return this._autoPageRefresh;
    }

    /*
     * Remove the models from this collection that are being obsoleted by the contents of the rawPropsArray. In
     * general, we remove the models that the collection currently contains that are not part of the rawPropsArray,
     * but if the rawPropsArray don't have a reference attribute, then we can't tell if the models are the same or not
     * so we reset.
     *
     * Return whether we are resetting the collection. This is true if we're removing all elements, or if
     * collection._resetOnList is true.
     */
    function removeUnneededModels(collection, rawPropsArray) {
        var resetting = false;

        if (rawPropsArray.length !== 0 && _.isUndefined(rawPropsArray[0].reference)) {
            Backbone.Collection.prototype.remove.call(collection, collection.models, { silent: true });
            resetting = true;
        } else {
            var newReferences = _.map(rawPropsArray, function (attributes) {
                return attributes.reference;
            });

            // Figure out which models to remove (by reference). reset if removing all
            var modelsToRemove = [];
            collection.each(function (model) {
                if (!_.contains(newReferences, model.id)) {
                    modelsToRemove.push(model);
                }
            });

            if (collection._resetOnList || modelsToRemove.length === collection.length) {
                resetting = true;
            }

            _.each(modelsToRemove, function (model) {
                Backbone.Collection.prototype.remove.call(collection, model, { silent: resetting });
            });
        }
        return resetting;
    }

    /*
     * Retrieve a set of models from the server, entirely replacing the contents of this collection with those models.
     * This is a reflection of the list standard operation found in Delphix schemas.  This takes a set of query
     * parameters as an argument, and will populate the collection with the results of that query.
     *
     * Note that if multiple requests are issued, this will only honor the last request sent. Models are added/removed
     * only when the last issued request returns. This also means that ready/error events are triggered and promises
     * resolved/rejected only once the last request issued returns.
     *
     * Parameters:
     *     parameters: An object hash containing the parameters to this list operation. For example, if this is a
     *         Container collection, you might call
     *             myCollection.$$list({
     *                 group: 'GROUP-1',
     *                 parent: 'CONTAINER-23'
     *             });
     *     successError: A standard object that contains a success and/or error callback routine.
     * Events:
     *     ready:  Triggered for the collection once all the models have been added and removed. Handler argument is
     *             the collection.
     *             Also triggered for each model marked as ready. Handler argument is a model.
     *     reset:  Triggered if this results in all the existing models being removed, or the _resetOnList flag has
     *             been set to true. Argument is the collection.
     *     remove: Triggered for each model removed, iff only some of the models are removed. Argument is the model.
     *     add:    Triggered for each added model, iff only some of the models were removed. Argument is the model.
     */
    function dxList(parameters, successError) {
        var sendableParams = context._checkAndConvertParameters(parameters, this._dxInfo.paramDefs.parameters);
        var self = this;
        var rootType = this._dxInfo.baseType;

        // No filter function. Complain so someone writes one, and blindly add the model
        if (dxUtil.isNone(context._filters[rootType]) && self._dxInfo.paramDefs.dxFilterMode === dxConstants.LIST_TYPES.CUSTOM) {
            dxUtil.fail('No filter function found for collections of type ' + rootType + '. Add one to ' + ' core data _filters. In the mean time, all models will be added to the collection.');
        }

        self._dxIsReady = false;
        self._dxIsErrored = false;
        // Keep track of latest outstanding request. We only honor a response if it came from the latest issued request.
        self._latestListToken++;
        var currListToken = self._latestListToken;

        self.sync('read', self, {
            parse: true,
            data: sendableParams,
            success: function success(resp) {
                if (self._latestListToken !== currListToken) {
                    return; // Another list request has been issued
                }

                if (resp && resp.type === 'ErrorResult') {
                    var processedResult = context._newClientModel(resp.type);
                    processedResult.set(resp);
                    if (successError && successError.error) {
                        successError.error(processedResult);
                    } else {
                        context.reportErrorResult(processedResult);
                    }
                    self.trigger('error', self);
                    self._dxIsErrored = true;
                    return;
                }

                var resetting = false;
                self._queryParameters = dxUtil.deepClone(parameters);
                self._listSuccessError = successError; // save for auto-relisting
                self._dxIsReady = true;
                self._listingMode = LISTINGMODE_LISTING;

                resp = self.parse(resp);

                resetting = removeUnneededModels(self, resp) || self._resetOnList;

                /*
                 * Add the new models.
                 */
                _.each(resp, function (attributes) {
                    var model = context._cache.getCachedModelFromProperties(attributes, { silent: resetting });
                    dxSet.call(self, model, { silent: resetting, _dxAllowSetPassthrough: true });
                });

                self._listingMode = LISTINGMODE_IDLE;

                // Report finishing events
                if (resetting) {
                    self.trigger('reset', self);
                }

                self.trigger('ready', self);

                if (successError && successError.success) {
                    successError.success();
                }
            },
            error: function error(xhr) {
                if (self._latestListToken !== currListToken) {
                    return; // Another list request has been issued
                }
                var errorResult = context._convertXhrToErrorResult(xhr);
                context._handleErrorResult(errorResult, successError);
                self.trigger('error', self);
                self._dxIsErrored = true;
            }
        });

        // Return a promise that is resolved once the model is ready, and rejected if the model reports an error
        var deferred = new $.Deferred();
        var listenerContext = {};

        self.once('ready', function () {
            deferred.resolve(self);
            self.off(undefined, undefined, listenerContext);
        }, listenerContext);

        // don't set up the error handler if ready was already triggered
        if (deferred.state() === 'pending') {
            self.once('error', function () {
                deferred.reject(self);
                self.off(undefined, undefined, listenerContext);
            }, listenerContext);
        }

        return deferred.promise();
    }

    /*
     * Retrieve the last set of query parameters passed to $$list().  This is useful if you want to see what this
     * collection currently contains.
     */
    function getQueryParameters() {
        return this._queryParameters;
    }

    /*
     * ========================================
     * Collection creation
     * ========================================
     */

    /*
     * Returns a new DSB collection which is set to be a server collection.
     *
     * resetOnList: If true, $$list()'s will only trigger a single 'reset' event rather than individual 'add' and
     *              'remove' events. Otherwise this happens only when the $$list() fully replaces the contents of the
     *              collection.
     */
    function newServerCollection(typeName, resetOnList) {
        if (dxUtil.isNone(typeName)) {
            dxUtil.fail('To create a new collection, a type name must be provided.');
        }

        if (!isSchemaType(typeName)) {
            dxUtil.fail(typeName + ' is not a known type with a list operation. Can not create this collection.');
        }

        var collection = new context._collectionConstructors[typeName]();
        collection.constructor = Backbone.Collection.extend(); // make clone() return an ordinary backbone collection.
        collection._resetOnList = !!resetOnList;

        return collection;
    }

    function operationNotAllowed() {
        dxUtil.fail('Can not call this operation on a Server Collection.');
    }

    /*
     * ========================================
     * Utility functions
     * ========================================
     */

    function isSchemaType(typeName) {
        return !!context._collectionConstructors[typeName];
    }

    /*
     * Return true if the type is the same as baseType or is a subtype.
     */
    function isACompatibleType(type, baseType) {
        if (!context._modelConstructors[type]) {
            return false;
        }

        var typeDef = context._modelConstructors[type].prototype._dxSchema;
        while (typeDef) {
            if (typeDef.name === baseType) {
                return true;
            }
            typeDef = typeDef.parentSchema;
        }

        return false;
    }

    /*
     * Throws error if model (Backbone.Model or attributes) is not compatible with the specified type.
     */
    function assertModelCompatible(aModel, baseType) {
        var type;
        if (aModel instanceof Backbone.Model) {
            type = aModel.get('type');
        } else {
            dxUtil.fail('Can not add an arbitrary set of attributes. Must pass a Backbone Model.');
        }

        if (!isACompatibleType(type, baseType)) {
            dxUtil.fail('Can not add a model of type ' + type + ' to a collection with a base type of ' + baseType + '.');
        }
    }

    /*
     * Validates that all models are compatible with this collection's type.
     */
    function assertModelsCompatible(models, referenceModel) {
        if (dxUtil.isNone(models)) {
            dxUtil.fail('Can not call without a model.');
        }

        if (_.isArray(models)) {
            _.each(models, function (model) {
                assertModelCompatible(model, referenceModel._dxInfo.baseType);
            }, this);
        } else {
            assertModelCompatible(models, referenceModel._dxInfo.baseType);
        }
    }

    /*
     * Trigger a 'dirty' event, and if appropriate, set up another call to do a new list operation.
     */
    function triggerDirty(collection) {
        collection.trigger('dirty');
        if (collection.getAutoPageRefresh()) {
            setTimeout(function () {
                dxList.call(collection, collection.getQueryParameters(), collection._listSuccessError);
            }, 0);
        }
    }

    /*
     * ========================================
     * Actually do the work of this function
     * ========================================
     */

    context = context || this;
    context._collectionConstructors = context._collectionConstructors || {};

    _.each(schemas, function (schema, typeName) {
        if (schema.list) {
            // examine return values, in case the return type is not the same as the schema type
            var retObj = schema.list['return'];
            var retItemsObj = retObj ? retObj.items : undefined;
            var collectionType = retItemsObj ? retItemsObj.$ref : (retObj || {}).$ref;
            collectionType = collectionType || schema.name;

            context._collectionConstructors[typeName] = Backbone.Collection.extend({
                _dxInfo: {
                    baseType: collectionType,
                    paramDefs: schema.list
                },
                _dxIsReady: false,
                _dxIsErrored: false,
                _queryParameters: undefined,
                _autoPageRefresh: false,
                _listSuccessError: undefined,
                _listingMode: LISTINGMODE_IDLE,
                url: schema.root,
                _dxEmpty: dxEmpty,
                _dxRemoveModel: Backbone.Collection.prototype.remove,
                _dxAddOrRemove: dxAddOrRemove,
                model: function model() {
                    dxUtil.fail('Can not create a new model on a collection. Must use the cache.');
                },
                on: dxOn,
                add: operationNotAllowed,
                remove: operationNotAllowed,
                set: dxSet,
                reset: operationNotAllowed,
                push: operationNotAllowed,
                pop: operationNotAllowed,
                unshift: operationNotAllowed,
                shift: operationNotAllowed,
                parse: dxParse,
                fetch: dxFetch,
                create: dxCreate,
                $$list: dxList,
                _latestListToken: 0,
                _resetOnList: false,
                clear: dxClear,
                getQueryParameters: getQueryParameters,
                setAutoPageRefresh: setAutoPageRefresh,
                getAutoPageRefresh: getAutoPageRefresh
            });
        }
    });

    context._newServerCollection = newServerCollection;
};

},{"dxcore/js/constants.js":15,"dxcore/js/util.js":23}],8:[function(require,module,exports){
/*
 * Copyright (c) 2014, 2015 by Delphix. All rights reserved.
 */

/* global _ */

'use strict';

var dxUtil = require('dxcore/js/util.js');

/*
 * Creation listeners provide access to notification updates for API server objects creation in the form
 * of level2 models.
 *
 *   typeName         The schema type for which one receives notifications.
 *
 *   callback         A function to be invoked with a level2 model as argument for each create notification.
 *
 *   queryParams      Optional query parameters used to filter notifications.
 *
 *   context          The context to access other dxData content (cache, filters).
 */
module.exports.CreationListener = function CreationListener(settings) {
    var self = this;

    if (dxUtil.isNone(settings.typeName)) {
        dxUtil.fail('To create a new creation listener, a type name must be provided.');
    }
    var typeName = settings.typeName;
    var context = settings.context;
    if (!isListableType(typeName, context)) {
        dxUtil.fail(typeName + ' is not a known type with a list operation. Can not create this creation listener.');
    }
    if (!_.isFunction(settings.callback)) {
        dxUtil.fail('Callback must be provided as a function.');
    }

    self._dxInfo = {
        baseType: settings.typeName
    };

    self.inUse = true;

    self.getQueryParameters = function () {
        return settings.queryParams;
    };

    // The format must remain compatible with level2-collections and level2-cache.
    self._dxAddOrRemove = function (model) {
        if (!self.inUse) {
            return;
        }

        context._filters[typeName](self, model, function (placement) {
            switch (placement) {
                case context._filters.INCLUDE:
                    settings.callback(model);
                    break;
                case context._filters.EXCLUDE:
                    break;
                case context._filters.UNKNOWN:
                    dxUtil.fail('UNKNOWN filter result not supported by creation listeners');
                    break; // to keep ant check happy.
                default:
                    dxUtil.fail('Filter returned an invalid value.');
            }
        });
    };

    self.dispose = function () {
        self.inUse = false;
    };
};

function isListableType(typeName, context) {
    return !!context._collectionConstructors[typeName];
}

},{"dxcore/js/util.js":23}],9:[function(require,module,exports){
/*
 * Copyright (c) 2014, 2015 by Delphix. All rights reserved.
 */

/* global _, $, Backbone */

'use strict';

var dxUtil = require('dxcore/js/util.js'),
    dxConstants = require('dxcore/js/constants.js');

/*
 * Defines general purpose filter routines. These can be used to build type-specific filters.
 *
 * A filter is simply a function that reproduces the server's treatment of the query parameters on the list operation
 * for any type.  Each filter function has the signature
 *    filterFunction(collection, model, resultHandler)
 * The filter function should examine the query parameters on the collection, then examine the properties of the model
 * and call resultHandler with a value indicating how the model should be placed with respect to the collection:
 *    INCLUDE: The model can be put in the collection
 *    EXCLUDE: The model should not be put in the collection (and removed if it is there already)
 *    UNKNOWN: The filter can't determine what to do with the model. Most likely the collection should be re-fetched
 * The potentially asynchronous call to resultHandler is necessary since some query parameters will require retrieval
 * of models to make their determination.
 */
module.exports._initFilters = function _initFilters(context) {
    var EXCLUDE = 'EXCLUDE';
    var INCLUDE = 'INCLUDE';
    var UNKNOWN = 'UNKNOWN';

    var DATE_PROPS = ['fromDate', 'startDate', 'toDate', 'endDate'];

    /*
     * Helper for non-generated filters. In many cases, the property in the query parameter is the same as that of the
     * attribute in the model. This means we can make a decision synchronously, which keeps the logic in the filters
     * simpler (compare to checkQueryParam(), which returns a promise).
     * This compares the value in the query parameter with that of the model.
     *
     * properties: An array of property names to compare
     * qParams:    The query parameters to compare
     * model:      The model to compare
     */
    function checkSameProps(properties, qParams, model) {
        var result = INCLUDE;

        _.each(properties, function (property) {
            if (_.has(qParams, property) && qParams[property] !== model.get(property)) {
                result = EXCLUDE;
            }
        });

        return result;
    }

    /*
     * When a model is being compared against a collection that has been retrieved with paging, then we can't reliably
     * tell whether the model belongs in the collection. Note that this assumes not specifying a page size implicitly
     * sets it to a particular size (generally 25), while specifying 0 means 'all'
     */
    function checkPageSize(qParams) {
        if (!_.has(qParams, 'pageSize') || qParams.pageSize !== 0) {
            return UNKNOWN;
        }
        return INCLUDE;
    }

    /*
     * Helper function to check date-related query parameters. This assumes qParamName is a valid date property.
     * The caller is responsible for making sure that qParamName is one of DATE_PROPS
     */
    function checkDateProp(qParamVal, qParamName, qpSchema, model, attrName) {
        if (!_.has(qpSchema, 'inequalityType')) {
            dxUtil.fail('Date property "' + qParamName + '" missing "inequalityType" schema property');
        }
        if (dxUtil.isNone(model.get(attrName))) {
            return EXCLUDE;
        }

        if (_.contains(['fromDate', 'startDate'], qParamName)) {
            if (model.get(attrName).getTime() < qParamVal.getTime()) {
                return EXCLUDE;
            }
        } else if (model.get(attrName).getTime() > qParamVal.getTime()) {
            // toDate or endDate
            return EXCLUDE;
        }

        if (qpSchema.inequalityType === dxConstants.INEQUALITY_TYPES.STRICT && model.get(attrName).getTime() === qParamVal.getTime()) {
            return EXCLUDE;
        }

        return INCLUDE;
    }

    /*
     * Helper for the uberFilter to check an individual query parameter against the model. This may involve
     * asynchronous ServerModel fetches to resolve 'mapsTo' data mapping chains. As a result this returns a promise to
     * the caller. At the moment this only deals with query params that may result in INCLUDE or EXCLUDE - never
     * UNKNOWN.
     * The returned promise is either resolved with INCLUDE or rejected with EXCLUDE.
     */
    function checkQueryParam(qParamVal, qParamName, model, rootSchemaDef) {
        var qpSchema = rootSchemaDef.list.parameters[qParamName],
            deferred = $.Deferred(),
            mapsTo = qpSchema.mapsTo;

        if (!mapsTo) {
            dxUtil.fail('No mapsTo property found for query parameter ' + qParamName + '.');
        }

        var pathSegs = mapsTo.split('.');

        // We know the last seg will be property to compare. Anything before will be a chain of object references.
        var finalAttrName = pathSegs.pop();

        // Recursively walk the data mapping segments
        function followNextSeg(currModel) {
            currModel.once('error', deferred.reject);
            currModel.once('ready', function () {
                if (_.isEmpty(pathSegs)) {
                    // We've reached the end of the path. Do the actual check.
                    var result;

                    if (_.contains(DATE_PROPS, qParamName)) {
                        result = checkDateProp(qParamVal, qParamName, qpSchema, currModel, finalAttrName);
                    } else {
                        // simple property check
                        result = currModel.get(finalAttrName) === qParamVal ? INCLUDE : EXCLUDE;
                    }

                    if (result === INCLUDE) {
                        deferred.resolve(result);
                    } else {
                        deferred.reject(result);
                    }
                } else {
                    // recursive case - continue following path segments.
                    var currPart = '$' + pathSegs.shift();
                    var newModel = currModel.get(currPart);
                    followNextSeg(newModel);
                }
            });
        }

        followNextSeg(model);

        return deferred.promise();
    }

    function getRootedSchema(model) {
        function upwardFind(schema, schemaName) {
            if (dxUtil.isNone(schema)) {
                dxUtil.fail('Malformed type. Root schema type not found.');
            }

            if (schema.name === schemaName) {
                return schema;
            }

            return upwardFind(schema.parentSchema, schemaName);
        }

        if (!model._dxSchema.rootTypeName) {
            dxUtil.fail('Trying to filter a type that has no root type.');
        }

        return upwardFind(model._dxSchema, model._dxSchema.rootTypeName);
    }

    /*
     * This is the filter to rule all filters. It will filter models for a given collection based on the schema
     * definition and annotations. This may be used as a standalone filter or as a helper for another filter, usually
     * in conjunction with the 'skipParams' argument (see alertFilter).
     * The uberFilter can only handle 'standard' query parameters: simple equality checks, date comparisons, and
     * paging. Similarly there are instances of query parameters that the uberFilter should not attempt to handle.
     * These come in two flavors:
     * 1) Params that do not affect what comes back from the notification system are marked as 'excludeFromFilter' in
     *    the schemas.
     * 2) Params that require special handling can be passed to the uberFilter using the 'skipParams' array.
     */
    function uberFilter(collection, model, resultHandler, skipParams) {
        var qParams = collection.getQueryParameters() || {};
        var schemaDef = getRootedSchema(model);
        var listParams = schemaDef.list.parameters;

        // If the schema definition for list says there are no parameters, then the model can always be included
        if (_.isEmpty(schemaDef.list.parameters)) {
            resultHandler(INCLUDE);
        }

        qParams = _.omit(qParams, skipParams);

        /*
         * If a type could have pageSize, we may need to return UNKNOWN. Otherwise we can keep going in the filter.
         * Note that we don't care about paging params when dealing with creation listeners.
         */
        if (_.has(listParams, 'pageSize') && collection instanceof Backbone.Collection) {
            var pageSizeResult = checkPageSize(qParams);
            if (pageSizeResult === UNKNOWN) {
                return resultHandler(pageSizeResult);
            }
        }
        qParams = _.omit(qParams, ['pageSize', 'pageOffset']);

        if (_.isEmpty(qParams)) {
            return resultHandler(INCLUDE);
        }
        var promises = _.map(qParams, function (qParamVal, qParamName) {
            return checkQueryParam(qParamVal, qParamName, model, schemaDef);
        });

        /*
         * Wait until all query param checks have resolved to make a final decision. Params that might result in
         * UNKNOWN (paging and params we can't handle) are dealt with earlier. Therefore we know each of these promises
         * is either resolved with INCLUDE or rejected with EXCLUDE.
         */
        $.when.apply(undefined, promises).then(function () {
            resultHandler(INCLUDE);
        }).fail(function () {
            resultHandler(EXCLUDE);
        });
    }

    /*
     * Simple filter for any type that doesn't actually have query parameters on its list operation (e.g. Group).
     */
    function genericFilter(collection, model, resultHandler) {
        resultHandler(INCLUDE);
    }

    /*
     * Do the real work.
     */
    context = context || this;
    context._filters = context._filters || {};

    _.extend(context._filters, {
        EXCLUDE: EXCLUDE,
        INCLUDE: INCLUDE,
        UNKNOWN: UNKNOWN,
        Notification: uberFilter,
        _checkSameProps: checkSameProps,
        _genericFilter: genericFilter,
        _uberFilter: uberFilter
    });
};

},{"dxcore/js/constants.js":15,"dxcore/js/util.js":23}],10:[function(require,module,exports){
/*
 * Copyright (c) 2013, 2015 by Delphix. All rights reserved.
 */

/* global $, _, Backbone */

'use strict';

var dxUtil = require('dxcore/js/util.js'),
    dxAjax = require('dxcore/js/ajax.js');

/*
 * This takes a set of schemas (modified by _prepareSchemas), and creates a set of Backbone Model constructor functions
 * (and, by implication, functionality upon the models). This also creates a set of 'root operation' functions.
 * The constructor functions will be used by the level 3 API's to provide final collections to consumers of dxCore Data.
 *
 * CONSTRUCTOR FUNCTIONS
 * The models created by these constructor functions provide access to the data types that the Delphix Server works with
 * and implicitly manage the network connections to the server to get their data and perform operations on them. That
 * is, when using the models created by these constructor functions, the caller can work with the data in the server's
 * terms, and can remain insulated from managing network communication.
 *
 * Terminology notes:
 *     Attributes:       Backbone calls the name/value pairs on a Model 'attributes'.
 *     Client Model:     A model which is created on the client, and generally doesn't reflect data that exists on the
 *                       server. Most commonly, these are either parameters to operations on Server Models, or return
 *                       values from operations. Client Models are not maintained by the notification system.
 *     DSB Model:        Delphix-Schema-Based Model.  The models produced by the constructor functions this creates.
 *                       These are Backbone models that are constrained and enhanced to fit our Delphix Schema
 *                       requirements.
 *     Embedded Model:   A model that is placed 'within' another model via a object/referenceTo property in the schema.
 *     Properties:       The name/value pairs on an ordinary Javascript/JSON/JSON-Schema object are called 'properties'.
 *     Referenced Model: A model that is referenced via a string/objectReference property in another.
 *     Server Model:     A model which represents a corresponding object on the server.  These models may not be
 *                       modified from outside of the dxCore Data, since they are guaranteed to remain accurate and up
 *                       to date with the server's objects (as long as they are left inside of a collection)
 *
 * This routine (which should only be called from within the data system) consumes the schemas and creates a set of
 * Backbone Model constructor functions, one for each type in the schemas.
 *
 * The models constructed by these functions are very similar to ordinary Backbone Models, but also have a number of
 * significant differences. These differences include *incompatible* changes to the behavior of some Backbone Model
 * functions, as well as the addition of new ones.
 *
 * EVENTS
 * ready:        If you want to know if a model is ready to be used (has an initial set of data retrieved from the
 *               server), then make use of the 'ready' event, which is unique to DSB models. Ready indicates that the
 *               model has retrieved an initial set of data from the server. Unlike ordinary events, if a ready handler
 *               is assigned to a model that is already ready, that handler (and no others) will be triggered
 *               immediately. Ready handlers are  always passed the model as the first, and only, argument. The handler
 *               should have the signature (model)
 * sync:         This is triggered after fetching the model from the server successfully and after any properties have
 *               been updated.
 * badReference: This is triggered when a model is fetched, and a 404 is returned. The handler should have the signature
 *               (model, errorResult)
 * error:        This is reported when an error is returned from a fetch. Like ready, it will be also immediately
 *               trigger if the object is in a error state. Unlike ready, a model may go into and out of being in
 *               an error state, depending on the results of the last time it was fetched. The handler should have the
 *               signature (model, errorResult)
 * Note: The order of the triggering of badReference, error and the calling of the error handler passed to fetch are not
 * guaranteed.
 *
 * Standard Backbone properties (none of these should be changed)
 *     id              : -- : Standard
 *     idAttribute     : -- : Set to 'reference', as this is the unique ID property name for Delphix Schemas.
 *     cid             : -- : Standard
 *     attributes      : -- : Standard, but essentially private.
 *     changed         : -- : Standard, but essentially private. Use hasChanged() etc.
 *     defaults        : -- : This is not used by DSB Models
 *     validationError : -- : At this time not used.
 *     urlRoot
 *
 * Standard Backbone functions
 *     Unless otherwise noted, all functions accept only attribute names specified in the Delphix schema (they will
 *     throw an error if given something else). If an attribute is of type string/objectReference, then '$attribute' can
 *     be used to retrieve the referenced model. In the descriptions below, functions marked as S can be called on
 *     server models, while those marked as C can be called on client models.
 *
 *     get      : SC : Standard, as above.
 *     set      :  C : Standard, but accepts values for embedded models. Does not accept '$attribute' names.
 *     escape   : SC : Standard, as above. Note that Backbone's escape doesn't deal well with objects or arrays.
 *     has      : SC : Standard, as above.
 *     unset    :  C : Standard, as above. Sets attribute to default value. Embedded models clear()'ed.
 *     clear    :  C : Standard, as above. Sets attributes to default value. Embedded models clear()'ed.
 *     toJSON   : SC : Standard, as above. Recursively includes embedded models.
 *     sync     : -- : Do not use this.
 *     fetch    : -- : Do not use this. Use newClientModel() or getServerModel() instead.
 *     save     : -- : Do not use this. Use $$update() instead.
 *     destroy  : -- : Do not use this. Use $$delete() instead.
 *     keys     : SC : Standard. Does not return the '$attribute' keys.
 *     values   : SC : Standard. Returns Embedded Models, but not Referenced Models.
 *     pairs    : SC : Standard. Returns Embedded Models, but not Referenced Models.
 *     invert   : SC : Standard. Returns Embedded Models, but not Referenced Models.
 *     pick     : SC : Standard. Returns Embedded Models, but not Referenced Models.
 *     omit     : SC : Standard. Returns Embedded Models, but not Referenced Models.
 *     validate : -- : Do not use this. DSB Models do their own validation. Setting this may have bad effects.
 *     isValid  : -- : Do not use this. DSB Models always valid.
 *     url      : -- : Internal. Returns URL value used by some ajax routines
 *     parse    : -- : Internal. Processes values returned from the server.
 *     clone    : SC : Returns a Client Model which is a deep-copy of this model.
 *     isNew    : SC : Standard. (but pretty useless)
 *     hasChanged         : SC : Standard. Does not reflect $attribute names.
 *     changedAttributes  : SC : Standard. Does not reflect $attribute names.
 *     previous           : SC : Standard. Does not reflect $attribute names.
 *     previousAttributes : SC : Standard. Does not reflect $attribute names.
 *
 * DSB Model functions
 *     instanceOf    : SC : Returns whether the model is an instance of another type.
 *     isServerModel : SC : Returns true if this is a server model
 *     $$update      : S  : Updates the version of the model on the server
 *     $$delete      : S  : Deletes the server object
 *     $operation    : SC : Calls the relevant operation. Model must have a reference value to use these.
 *
 * Private to dxCore Data
 *     context._assertParametersGood    : Validate that a set of parameters are valid.
 *     context._newClientModel          : Makes a client model
 *     context._newServerModel          : Makes a server model
 *     context._getRootType             : Returns the most distant super type that has the same root property.
 *     context._convertXhrToErrorResult : Converts an xhr into an ErrorResult object.
 *
 * ROOT OPERATIONS
 * All root operations on schemas, and all create operations are stored in
 *     context.rootOps.Type.$rootOperation
 *     context.rootOps.Type.$$create
 *
 * Note: This does not alter the basic Backbone library in any way. This means this can co-exist with ordinary
 *     Backbone usage, or even other Backbone-based libraries (if they don't modify Backbone, of course).
 *
 * Parameters:
 *     schemas: The set of schemas this should generate constructors from.
 *     context: The object to put the resulting constructors (_modelConstructors) on. If not specified, puts them on
 *              'this'.
 */
module.exports._generateModelConstructors = function _generateModelConstructors(schemas, context) {
    // Note: 'context' is the only true 'global' within this closure. Please don't add others.

    /*
     * ========================================
     * Model functions.
     * ========================================
     */

    /*
     * Backbone defines this as: Bind a callback function to an object. The callback will be invoked whenever the event
     * is fired.
     *
     * For DSB models, we provide standard behavior for this, but do some special processing if someone is listening
     * for the 'ready' or 'error' event. In that case, if we have already fetched the model (or if this is a client
     * model), then trigger the ready event immediately.  Note that if the model is already ready or in error,
     * then we will react to 'ready' or 'error' immediately without storing the listener, since this is a one
     * time pseudo-event.
     */
    function dxOn(name, callback, context) {
        var transientTrigger;

        /*
         * If the user is asking for ready, and we are already ready or in error, then trigger the ready or
         * do nothing. There is no reason to keep the event listener around for more than this call.
         * Similarly if the user is asking for the error pseudo event.
         */
        if (name === 'ready') {
            if (this._dxIsReady) {
                transientTrigger = triggerReady;
            } else if (this._dxErrorResult) {
                return;
            }
        } else if (name === 'error') {
            if (this._dxErrorResult) {
                transientTrigger = triggerError;
            } else if (this._dxIsReady) {
                return;
            }
        }

        if (transientTrigger) {
            var tempContext = {};
            Backbone.Events.on.call(this, name, callback, tempContext);
            transientTrigger(this);
            Backbone.Events.off.call(this, name, callback, tempContext);
        } else {
            Backbone.Events.on.call(this, name, callback, context);
        }
    }

    /*
     * Either 'ready' or 'error' events is triggered once in the lifecycle of a model. Cleanup listeners as soon as
     * possible.
     *
     * Without this automatic cleanup, callers would have to setup 2 listeners and cancel each other when triggered.
     * Note that we look at the list of events before triggering events so as to allow event handlers to attach new
     * handlers.
     */
    function removeEventHandlers(model, events) {
        _.each(events, function (value, name) {
            _.each(value, function (event) {
                if (event.callback) {
                    model.off(name, event.callback);
                }
            });
        });
    }

    /*
     * Get a copy of the current event handlers.
     */
    function getEventHandlers(model) {
        if (!model._events) {
            return {};
        }
        return {
            error: (model._events.error || []).slice(0),
            ready: (model._events.ready || []).slice(0)
        };
    }

    /*
     * Trigger the 'ready' event and clean up error listeners
     */
    function triggerReady(model) {
        var handlers = getEventHandlers(model);
        model.trigger('ready', model);
        removeEventHandlers(model, handlers);
    }

    /*
     * Trigger the 'error' event and clean up ready listeners
     */
    function triggerError(model) {
        var handlers = getEventHandlers(model);
        model.trigger('error', model, model._dxErrorResult);
        removeEventHandlers(model, handlers);
    }

    /*
     * Backbone defines this as: Get the current value of an attribute from the model.
     *
     * For DSB models, this does the same thing, with two additional features. First, asking for an attribute that isn't
     * in the schema definition will cause an error to be thrown.  Second, if there is an attribute named 'attr' whose
     * schema property is of type string/objectReference, then one can also get('$attr'), and this will return the
     * corresponding DSB model.
     */
    function dxGet(attrName) {
        var info = assertAndGetAttrInfo(this, attrName);

        if (isObjectRefProp(info.propDef) && info.wantsModel) {
            var referenceValue = this.attributes[info.baseName];
            if (dxUtil.isNone(referenceValue)) {
                return;
            }
            if (_.isString(referenceValue)) {
                return context._cache.getCachedModel(referenceValue, getRootType(info.propDef.referenceTo));
            }
            dxUtil.fail('Tried to retrieve a related object with ' + attrName + ' but value was ' + referenceValue + '.');
        } else {
            return Backbone.Model.prototype.get.call(this, info.baseName);
        }
    }

    /*
     * Backbone defines this as: Set a hash of attributes (one or many) on the model. If any of the attributes change
     * the model's state, a 'change' event will be triggered on the model.
     *
     * For DSB Models, there are a number of differences.
     *     1) Only attributes defined in the schemas can be set.
     *     2) Attributes may only be set to values with the data type specified in the schemas.
     *     3) DSB models may contain 'embedded' DSB models (object/$ref)
     *
     * To set an attribute on an embedded DSB model, one must still specify values in JSON format. Thus:
     *     myModel.set({
     *         attr: 1,
     *         myEmbeddedModel: {
     *             embeddedAttr: 34
     *         }
     *     })
     * Note that it is legal, in some circumstances, to change the type of an embedded model with a set. Naturally,
     * on a ServerModel, only the server may do this, however on a ClientModel this can happen quite freely. The
     * important things to keep in mind are the following:
     *     a) When the type changes, the new type must be compatible with the type declared in the schema (which is to
     *        say you may change it to that type or any subtype, but may not change it to an unrelated type).
     *     b) Changing a type is equivalent to setting that embedded model to a new instance. That is, any values that
     *        were in the embedded model before the set are replaced with default values, and then the values specified
     *        to this set() routine are applied.
     *     c) However, listeners on this embedded model are not affected, and appropriate change notifications will be
     *        sent on setting.
     *
     * A DSB model may, legitimately, have an array or object that, itself, contains a DSB model (for example, an
     * APIError may contain a plain JSON object whose values are other APIErrors).  To deal with this properly, set()
     * will detect any object that has a 'type' property, whose value is a Delphix-schema type name, and create a
     * DSB model automatically. Without that type property, however, set() will treat the object as an ordinary
     * JSON object.
     *
     * Arrays in a Delphix schema may or may not have a type specified for items. If they do, set() will enforce that
     * type. If not, then the items in the array passed in will be examined and recursively processesed as appropriate.
     * Similarly, if a plain object is encountered, set() will process its values recursively (including turning them,
     * or their own properties, into DSB models as appropriate)
     *
     * A schema property defined with type=string and format=date gets some special treatment.  In that case, you can
     * pass a string in YYYY-MM-DDTHH:MM:SS.MMMZ format, or a Javascript Date object (the former will be converted to
     * a Date object internally, so immediately calling get() will not return the original string).
     */
    function dxSet(key, value, options) {
        var self = this;
        var newAttrs = {};
        var preConvertAttrs;
        var postConvertAttrs;

        if (_.isUndefined(key)) {
            return self;
        }

        if (_.isObject(key)) {
            newAttrs = key;
            options = value;

            if (newAttrs instanceof Backbone.Model) {
                newAttrs = newAttrs.toJSON();
            }
        } else {
            newAttrs[key] = value;
        }

        options = options || {};

        /*
         * Check whether this set would change the type of the model. This only allows changing to a subtype.
         */
        if (newAttrs.type && newAttrs.type !== self._dxSchema.name) {
            if (firstIsSubtypeOfSecond(newAttrs.type, self._dxSchema.name) || options._allowTypeConversion) {
                preConvertAttrs = _.clone(self.attributes);
                convertToType(self, newAttrs.type);
                postConvertAttrs = _.clone(self.attributes);
            } else {
                dxUtil.fail('Tried to change this from ' + self._dxSchema.name + ' to ' + newAttrs.type + '.');
            }
        }

        /*
         * Reject the set if any of the attributes aren't of the right type
         */
        var invalidAttrs = _.omit(newAttrs, _.keys(self._dxSchema.properties || {}));
        if (!_.isEmpty(invalidAttrs)) {
            dxUtil.fail(_.keys(invalidAttrs) + ' are not attributes of a model of type ' + self._dxSchema.name + '.');
        }

        /*
         * Validate types match, and prepare values to be set
         */
        var finalAttrs = {};
        var subModelsToSet = {};
        var subModelsToClear = [];
        var subModelsToConvert = {};

        _.each(newAttrs, function (newValue, newName) {
            var propDef = self._dxSchema.properties[newName];
            var newType = assertValueMatchesDefinition(newName, newValue, propDef);

            switch (newType) {
                case 'undefined':
                case 'boolean':
                case 'string':
                case 'number':
                case 'integer':
                    finalAttrs[newName] = newValue;
                    break;
                case 'null':
                    var nullable = _.any(propDef.type, function (type) {
                        return type === 'null';
                    });
                    if (self.get(newName) instanceof Backbone.Model && !nullable) {
                        subModelsToClear.push(newName);
                    } else {
                        finalAttrs[newName] = undefined;
                    }
                    break;
                case 'date':
                    if (newValue instanceof Date) {
                        finalAttrs[newName] = new Date(newValue.getTime());
                    } else {
                        finalAttrs[newName] = new Date(newValue);
                    }
                    break;
                case 'array':
                    finalAttrs[newName] = setupArray(newValue, propDef.items);
                    break;
                case 'object':
                    if (self.get(newName) instanceof Backbone.Model) {
                        if (newValue.type && self.get(newName).get('type') !== newValue.type) {
                            subModelsToConvert[newName] = newValue;
                        } else {
                            subModelsToSet[newName] = newValue;
                        }
                    } else if (propDef.$ref === 'Json') {
                        /*
                         * Deal with special Json type, which is object, but doesn't need any set up. It has a
                         * reference because the backend needs this to do its validation. The UI should consider
                         * instances of this type as a black box (e.g. don't validate its properties).
                         */
                        finalAttrs[newName] = jsonIze(newValue);
                    } else {
                        finalAttrs[newName] = setupObject(newValue);
                    }
                    break;
            }
        });

        /*
         * Finally, set all the values
         */
        _.each(subModelsToClear, function (attrName) {
            self.get(attrName)._dxClear(options);
        });

        var revisedOptions = _.extend(_.clone(options), { _allowTypeConversion: true });
        _.each(subModelsToConvert, function (value, key) {
            var subModel = self.get(key);
            subModel._dxSet(value, revisedOptions);
        });

        _.each(subModelsToSet, function (value, key) {
            self.get(key)._dxSet(value, options);
        });

        /*
         * If we did a type conversion, we need to make sure to send all the change:AttrName events before we send
         * the final change event.  Because we're relying on the Backbone set routine, it may think it needs to send
         * the change event when it is done, but we have the potential to send a variety of other events afterwards.
         * To work around this, we store all calls to trigger() until we are done.
         */
        if (preConvertAttrs) {
            interceptTrigger(self);
        }

        /*
         * This will set all the values, and trigger change:attr events for all the attributes that changed
         * Note that if this is doing a type conversion, this will trigger changes for:
         *   - attributes that were added (though conversion) and then changed
         *   - attributes that existed before and after conversion, and changed from their converted value
         */
        var result = Backbone.Model.prototype.set.call(self, finalAttrs, options);

        if (preConvertAttrs) {
            var removedAttrs = _.omit(preConvertAttrs, _.keys(postConvertAttrs));
            var addedAttrs = _.omit(postConvertAttrs, _.keys(preConvertAttrs));
            var continuedAttrs = _.pick(preConvertAttrs, _.keys(postConvertAttrs));

            // trigger change events for the attributes were removed
            _.each(removedAttrs, function (value, key) {
                self.trigger('change:' + key, self, undefined);
            });

            // trigger change events for the attributes that were added, by conversion, but not changed
            _.each(addedAttrs, function (value, key) {
                if (addedAttrs[key] === self.attributes[key]) {
                    self.trigger('change:' + key, self, self.attributes[key]);
                }
            });

            _.each(continuedAttrs, function (value, key) {
                /*
                 * Suppress a change:attrName event if if the attr changed during the set() to the same value as before
                 * the conversion suppress event/
                 */
                if (continuedAttrs[key] === self.attributes[key] && postConvertAttrs[key] !== self.attributes[key]) {
                    self._suppressEvents.push('change:' + key);
                }
                /*
                 * Trigger a change:attrName if the value changed during conversation, but then wasn't changed by set.
                 * For example: The original value was 1, then when we changed the type we put the default value of 2
                 * in, and then Backbone's set changed it to 2.  So, set() didn't send an event, but we know that
                 * there actually was a change from the client's point of view.
                 */
                if (continuedAttrs[key] !== postConvertAttrs[key] && postConvertAttrs[key] === self.attributes[key]) {
                    self.trigger('change:' + key, self, self.attributes[key]);
                }
            });

            replayTriggers(self);
        }

        return result;
    }

    /*
     * Intercept and queue for later restoration, all calls to trigger().
     * This also sets up a temporary property on the model, _suppressEvents, which is a list of events to not
     * send when replayTriggers is called.
     */
    function interceptTrigger(model) {
        model._queuedEvents = [];
        model._storedTriggerFunction = model.trigger;
        model._suppressEvents = [];
        model.trigger = function () {
            model._queuedEvents.push(arguments);
        };
    }

    /*
     * Send all paused events on their way, with some modifications including: suppressing certain named events, and
     * assuring a change event is sent after all change:attrName events (but not if there are none)
     */
    function replayTriggers(model) {
        var changeEvent;
        var seenAttrChange = false;
        model.trigger = model._storedTriggerFunction;
        delete model._storedTriggerFunction;

        _.each(model._queuedEvents, function (args) {
            // don't send the change event yet
            if (args[0] === 'change') {
                changeEvent = args;
                return;
            }

            // don't send events we are to suppress
            if (_.contains(model._suppressEvents, args[0])) {
                return;
            }

            if (args[0].indexOf('change:') === 0) {
                seenAttrChange = true;
            }
            model.trigger.apply(model, args);
        });
        delete model._queuedEvents;
        delete model._suppressEvents;

        if (changeEvent) {
            model.trigger(changeEvent);
        } else if (seenAttrChange) {
            model.trigger('change', model);
        }
    }

    /*
     * Backbone defines this as: Returns true if the attribute is set to a non-null or non-undefined value.
     */
    function dxHas(attrName) {
        if (!_.isString(attrName)) {
            dxUtil.fail('Must provide an attribute name.');
        }

        var info = getAttrInfo(this, attrName);

        // dxGet will throw an exception for unknown attributes, so reach directly into the attributes to avoid this
        return info.baseName && !dxUtil.isNone(this.attributes[info.baseName]);
    }

    /*
     * Backbone defines this as: Remove an attribute by deleting it from the internal attributes hash. Fires a 'change'
     * event unless silent is passed as an option.
     *
     * For DSB models, the behavior is a bit different:
     *  1) Calling unset() on a defined attribute will cause that to be reset to its default value, unless it is an
     *     embedded object, in which case it is equivalent to calling clear() on it.
     *  2) Calling unset() an attribute that isn't defined in the schemas will throw an error
     *  3) calling unset('$attribute') will unset 'attribute'
     *  4) This considers the default of a 'type' attribute to be the schema name, and so unset will never actually
     *     change it.
     */
    function dxUnset(attrName, options) {
        var info = assertAndGetAttrInfo(this, attrName);

        if (attrName === 'type') {
            return;
        }

        if (isEmbeddedProp(info.propDef)) {
            this.attributes[attrName].clear(options);
        } else {
            this.set(info.baseName, defaultFor(info.propDef, this._dxIsClientModel), options);
        }
    }

    /*
     * Backbone defines this as: Removes all attributes from the model, including the id attribute. Fires a 'change'
     * event unless silent is passed as an option.
     *
     * For DSB models, this resets all attributes to their default values, unless they are embedded objects, in which
     * case clear() is recursively called on them.
     */
    function dxClear(options) {
        var changes = {};
        _.each(this._dxSchema.properties, function (propDef, propName) {
            if (propName === 'type') {
                return;
            }
            if (isEmbeddedProp(propDef)) {
                this.attributes[propName]._dxClear(options);
            } else {
                changes[propName] = defaultFor(propDef, this._dxIsClientModel);
            }
        }, this);

        if (!_.isEmpty(changes)) {
            this._dxSet(changes, options);
        }
    }

    /*
     * Backbone defines this as: Return a copy of the model's attributes for JSON stringification. This can be used for
     * persistence, serialization, or for augmentation before being sent to the server.
     *
     * Our differences are that we will recursively call this on any embedded objects, and we do deep clones of any
     * objects or arrays.
     */
    function dxToJSON() {
        return jsonIze(this);
    }

    /*
     * Wrapper around standard Backbone url().  We do this because we build a common url access scheme that is
     * available to both root operations and object operations.
     */
    function dxUrl() {
        return this.url();
    }

    /*
     * Backbone defines this as: parse() is called whenever a model's data is returned by the server. The function is
     * passed the raw response object, and returns the attributes hash to be set on the model.
     *
     * Delphix values returned from the server come in several flavors:
     *  1) an ErrorResult. This means that whatever request got to us failed.
     *  2) an OKResult. This is the result of a successful call
     *  3) a 'naked' Delphix object type. This happens when a collection is parsing each object in its returned array.
     *  4) a ListResult, or other Delphix return value.  These should never happen here.
     *
     * In the case of problems (cases 1 and 4), we return undefined (we report the error result through the error result
     * handler).  For 2 we extract the object in the result and return that. For 3, assuming the type is one we know,
     * return that unchanged.  If it is an unknown type, however, we log an error and return undefined. An undefined
     * return value indicates that there is no data to be parsed out of the response.
     */
    function dxParse(response) {
        if (!response || !response.type) {
            dxUtil.warn('Got an undefined response, or one without a type in parse().');
            return;
        }

        if (response.type === 'OKResult') {
            return response.result;
        } else if (isSchemaType(response.type)) {
            return response;
        } else {
            dxUtil.warn('Got an unexpected type of response (' + response.type + ') in parse().');
            return;
        }
    }

    /*
     * Backbone defines this as: Returns a new instance of the model with identical attributes.
     *
     * For DSB models, this returns a client model that is a deep copy of the model. All embedded models are also
     * made as client models.
     */
    function dxClone() {
        var newModel = newClientModel(this._dxSchema.name);

        newModel.set(this.toJSON());
        newModel.changed = {}; // Shhh. we didn't actually change anything!

        return newModel;
    }

    /*
     * Returns true if the provided type name is this object's type name, or the type name of one of this model's
     * extended types.  Will throw an exception if the provided type name isn't one of the schema types.
     */
    function instanceOf(typeName) {
        if (!_.isString(typeName)) {
            dxUtil.fail('instanceOf() requires a type name as a parameter.');
        }

        if (!isSchemaType(typeName)) {
            dxUtil.fail(typeName + ' is not a known type name.');
        }

        var candidateTypeInfo = this._dxSchema;

        while (candidateTypeInfo) {
            if (candidateTypeInfo.name === typeName) {
                return true;
            }

            candidateTypeInfo = candidateTypeInfo.parentSchema;
        }

        return false;
    }

    function isServerModel() {
        return !this._dxIsClientModel;
    }

    /*
     * Entirely block the standard Backbone destroy() routine. We want users to call $$delete() instead.
     */
    function noDestroy() {
        dxUtil.fail('Do not call destroy() directly. Instead, call $$delete().');
    }

    /*
     * Delete this model on the server.  On success, this will clear() this model.  This will also fire
     * a 'request' event on the model before making the call, and a 'sync' and 'destroy' afterwards on success.
     * Depending on the underlying schema definition, this can be called in any of these ways:
     *    $$delete([successError])  // in case of no payload defined
     *    $$delete(payload[, successError])  // in case of payload required
     *    $$delete([payload][, successError])  // in case of payload optional
     */
    function dxDelete(arg1, arg2) {
        var opDef = this._dxSchema['delete'];

        if (arg1 instanceof Backbone.Model && !opDef.payload) {
            dxUtil.fail('$$delete does not allow a payload.');
        }

        var payload = arg1;
        var successError = arg2;
        if (!opDef.payload || !opDef.required && !(arg1 instanceof Backbone.Model)) {
            payload = undefined;
            successError = arg1;
        }

        assertHasReferenceAttr(this, '$delete', true);
        var preparedData = assertAndPreparePayload('$delete', opDef, payload);

        return callOperation(this, {
            data: preparedData,
            url: this.url()
        }, 'DELETE', opDef, successError);
    }

    /*
     * Create a new object on the server. It is normally called like this:
     *    $$create(payload[, successError])
     * However, it could be called in the following ways should a schema one day not require payload to do create
     *    $$create([successError])  // in case of no payload defined
     *    $$create([payload][, successError])  // in case of payload optional
     */
    function dxCreate(opDef, url, arg1, arg2) {
        if (arg1 instanceof Backbone.Model && !opDef.payload) {
            dxUtil.fail('$$create does not allow a payload.');
        }

        var payload = arg1;
        var successError = arg2;
        if (!opDef.payload || !opDef.required && !(arg1 instanceof Backbone.Model)) {
            payload = undefined;
            successError = arg1;
        }

        return callOperation({}, {
            data: assertAndPreparePayload('$create', opDef, payload),
            url: url
        }, 'POST', opDef, successError);
    }

    /*
     * Entirely block the standard Backbone save() routine. We want users to call $$update() instead.
     */
    function noSave() {
        dxUtil.fail('Do not call save() directly. Instead, call $$update().');
    }

    /*
     * Update the version of this model on the server. This sends to the server:
     *  1) Any required or update:required attributes defined for this type
     *  2) Any required:false or update:optional attributes from the set passed in this function
     */
    function dxUpdate(attributes, successError) {
        var opDef = this._dxSchema.update;

        if (dxUtil.isNone(attributes) || _.isEmpty(attributes)) {
            dxUtil.fail('$$update must be called with a non-empty set of attributes.');
        }
        assertHasReferenceAttr(this, '$update', !this._dxSchema.singleton);

        var newModel = this.clone();
        newModel.set(attributes);

        var preparedData = JSON.stringify(jsonIzeForUpdate(attributes, newModel, this, true));

        return callOperation(this, {
            data: preparedData,
            url: this._dxGetUrl()
        }, 'POST', opDef, successError);
    }

    /*
     * Entirely block the standard Backbone fetc() routine.
     */
    function noFetch() {
        dxUtil.fail('Do not call fetch() directly. Instead, call getServerModel().');
    }

    /*
     * Mark the specified model as 'ready'. The 'triggerNotify' parameter controls whether we trigger the 'ready'
     * event. This is exposed to the level3 API so that a collection can be marked as ready before notifying consumers.
     */
    function makeReady(model, triggerNotify) {
        model._dxIsReady = true;

        _.each(model._dxSchema.properties, function (propDef, propName) {
            if (isEmbeddedProp(propDef) && model.get(propName)) {
                makeReady(model.get(propName), triggerNotify);
            }
        });

        if (triggerNotify) {
            triggerReady(model);
        }
    }

    /*
     * Handle an error for a successError callback or an array of callbacks.
     * The context error handler is invoked once unless all callbacks define a custom error handler.
     */
    function handleErrorResult(processedResult, successError) {
        var callbacks = _.isArray(successError) ? successError : [successError];
        var reportedError = false;
        _.each(callbacks, function (successError) {
            if (successError && successError.error) {
                successError.error(processedResult);
            } else if (!reportedError && (!successError || !successError.suppressDefaultErrorHandler)) {
                context.reportErrorResult(processedResult);
                reportedError = true;
            }
        });
    }

    /*
     * Fetches a model from the server, using Backbone's sync() function under the hood.
     */
    function dxFetch(successError) {
        var model = this;
        model._dxFetchQueue = model._dxFetchQueue || [];
        model._dxFetchQueue.push(successError);
        if (model._dxFetchQueue.length === 1) {
            dxFetchNow(model);
        }
    }

    function dxFetchNow(model) {

        /*
         * Applies the handler to the pending request queue.
         *
         * If there is more than one callback in the queue, apply the response to entries 0..N-2 and issue a new
         * dxFetch for the most recent request.
         *
         * If dxFetch requests are issued during callback execution, they do not resolve immediately.
         */
        function makeHandler(mainHandler) {
            return function dxFetchCallbackHandler(arg) {
                var queue = model._dxFetchQueue;
                delete model._dxFetchQueue;
                var callbacks = _.first(queue, Math.max(1, queue.length - 1));
                mainHandler(arg, callbacks);
                if (queue.length > 1) {
                    model._dxFetch(_.last(queue));
                }
            };
        }

        var options = {
            parse: true,
            success: makeHandler(function (resp, callbacks) {
                if (resp && resp.type === 'ErrorResult') {
                    var processedResult = resultToModel(resp);
                    model._dxErrorResult = processedResult;
                    triggerError(model);
                    return handleErrorResult(processedResult, callbacks);
                }

                model._dxErrorResult = undefined;
                model._dxSet(model.parse(resp), options);

                makeReady(model, true);

                _.each(callbacks, function (successError) {
                    if (successError && successError.success) {
                        successError.success(model);
                    }
                });

                model.trigger('sync', model);
            }),
            error: makeHandler(function (xhr, callbacks) {
                var errorResult = convertXhrToErrorResult(xhr);
                handleErrorResult(errorResult, callbacks);
                if (xhr && xhr.status === 404) {
                    model.trigger('badReference', model, errorResult);
                }
                model._dxErrorResult = errorResult;
                triggerError(model);
            })
        };

        Backbone.sync('read', model, options);
    }

    /*
     * ========================================
     * Operations: creation and handling
     * ========================================
     */

    /*
     * Examine the operations provided, and add them to the target object.
     *
     * target:     The object to add the constructed functions to
     * operations: A JSON object with keys as the operation names, and  values as definitions of that operation.
     * namePrefix  A string to prefix to the name of the operation when adding to the target
     * urlPrefix:  A string to prefix to the constructed url for the operation
     * perObject:  Whether these operations are ones that require the object's reference.
     */
    function addOperations(target, operations, namePrefix, urlPrefix, perObject) {
        _.each(operations, function (opDef, opName) {
            var opFunction;
            var opUrl = urlPrefix === '' ? opName : urlPrefix + '/' + opName;

            if (!_.isUndefined(opDef.payload)) {
                opFunction = _.isEmpty(opDef.payload) ? function (successError) {
                    return noPayloadFunction(this, opUrl, opDef, perObject, successError);
                } : function (payload, successFailure) {
                    return payloadFunction(this, opUrl, opDef, perObject, payload, successFailure);
                };
            } else {
                opFunction = _.isEmpty(opDef.parameters) ? function (successError) {
                    return noParametersFunction(this, opUrl, opDef, perObject, successError);
                } : function (parameters, successFailure) {
                    return parametersFunction(this, opUrl, opDef, perObject, parameters, successFailure);
                };
            }

            if (_.has(opDef, 'dxOperations')) {
                addOperations(target, opDef.dxOperations, namePrefix + opName + '_', opUrl, perObject);
            }

            target['$' + namePrefix + opName] = opFunction;
        });
    }

    /*
     * Call a server function that has no payload.
     */
    function noPayloadFunction(caller, opName, opDef, perObject, successError) {
        assertHasReferenceAttr(caller, opName, perObject);

        if (successError instanceof Backbone.Model) {
            dxUtil.fail('$' + opName + ' can not be called with a payload (only a success/error object).');
        }

        return callOperation(caller, {
            url: caller._dxGetUrl() + '/' + opName
        }, 'POST', opDef, successError);
    }

    /*
     * Call a server function that has a payload (which is always a single DSB model).
     */
    function payloadFunction(caller, opName, opDef, perObject, payload, successError) {
        assertHasReferenceAttr(caller, opName, perObject);

        return callOperation(caller, {
            data: assertAndPreparePayload(opName, opDef, payload),
            url: caller._dxGetUrl() + '/' + opName
        }, 'POST', opDef, successError);
    }

    /*
     * Call a server function that is a 'GET', and takes no parameters.
     */
    function noParametersFunction(caller, opName, opDef, perObject, successError) {
        assertHasReferenceAttr(caller, opName, perObject);

        return callOperation(caller, {
            url: caller._dxGetUrl() + '/' + opName
        }, 'GET', opDef, successError);
    }

    /*
     * Call a server function that expects one or more parameters.
     */
    function parametersFunction(caller, opName, opDef, perObject, parameters, successError) {
        var sendableParams;
        assertHasReferenceAttr(caller, opName, perObject);

        if (!_.isObject(parameters) && !dxUtil.isNone(parameters)) {
            dxUtil.fail('$' + opName + ' must be passed a (possibly empty) hash of parameters.');
        }

        if (!dxUtil.isNone(parameters)) {
            sendableParams = checkAndConvertParameters(parameters, opDef.parameters);
        }

        return callOperation(caller, {
            data: sendableParams,
            url: caller._dxGetUrl() + '/' + opName
        }, 'GET', opDef, successError);
    }

    function assertHasReferenceAttr(model, opName, perObject) {
        if (!model.id && perObject) {
            dxUtil.fail('$' + opName + ' can not be called without a reference property set.');
        }
    }

    /*
     * Invoke whatever operation was set up, above, and then handle the return values.
     * Handling a return value means:
     *  1) If a success handler was provided, and OKResult (or subtype) was returned, pass that to the handler.
     *  2) IF an error handler was provided, and an ErrorResult was returned, pass the ErrorResult to the handler.
     *     Otherwise pass it on to the standard application-wide error handler, unless suppressErrorHandler was
     *     specified.
     *  3) IF some other error occurred, wrap the HTTP failure information into a new ErrorResult and either pass
     *     onto the provided handler or the system-wide hander, unless suppressErrorHandler was specified.
     */
    function callOperation(caller, options, type, opDef, successError) {
        if (successError && _.has(successError, 'success') && !_.isFunction(successError.success)) {
            dxUtil.fail('The success handler must be a function, but found a ' + typeof successError.success + '.');
        }

        if (successError && _.has(successError, 'error') && !_.isFunction(successError.error)) {
            dxUtil.fail('The error handler must be a function, but found a ' + typeof successError.error + '.');
        }

        var deferred = new $.Deferred();

        var params = {
            success: function success(result) {
                var processedResult;
                if (result && result.type === 'ErrorResult') {
                    processedResult = resultToModel(result);
                    handleErrorResult(processedResult, successError);
                    deferred.reject(processedResult);
                } else {
                    if (dxUtil.isNone(result) || dxUtil.isNone(result.type)) {
                        dxUtil.fail('Operation returned success, but without a typed object: ' + result);
                    }
                    if (dxUtil.isNone(opDef['return']) && result.result === '') {
                        delete result.result;
                    }
                    assertValueMatchesDefinition('(return value)', result.result, opDef['return']);
                    processedResult = resultToModel(result);
                    if (successError && successError.success) {
                        successError.success(processedResult);
                    }
                    if (successError && successError.jsonSuccess) {
                        successError.jsonSuccess(result);
                    }
                    deferred.resolve(processedResult);
                }
            },
            error: function error(xhr) {
                var errorResult = convertXhrToErrorResult(xhr);
                handleErrorResult(errorResult, successError);
                deferred.reject(errorResult);
            }
        };

        if (_.isFunction(caller.trigger)) {
            caller.trigger('request', caller);
        }

        _.extend(params, options);

        params.type = type;
        dxAjax.ajaxCall(params);
        return deferred.promise();
    }

    /*
     * Validate that the payload matches the definition for the operation.
     */
    function assertAndPreparePayload(opName, opDef, payload) {
        if (dxUtil.isNone(payload) && opDef.payload && opDef.payload.required) {
            dxUtil.fail('Must call $' + opName + ' with a payload of type ' + opDef.payload.$ref + '.');
        }

        if (!dxUtil.isNone(payload)) {
            if (!_.isObject(payload) || !(payload instanceof Backbone.Model)) {
                dxUtil.fail('Must call $' + opName + ' with a backbone model.');
            }

            if (!payload.instanceOf(opDef.payload.$ref)) {
                dxUtil.fail('Must call $' + opName + ' with an instance of ' + opDef.payload.$ref + '.');
            }

            return JSON.stringify(jsonIze(payload, opDef.validateAs || 'send'));
        }
    }

    /*
     * Given a parameters object (an ordinary JSON object), compare these with the parameter definitions from the
     * schemas.  If there are any type mismatches, parameters that are not supported, or required parameters that are
     * missing, throw an error.
     *
     * Return a copy of the parameters that are suitable for passing to an AJAX call (Date object converted to
     * the server date string format)
     */
    function checkAndConvertParameters(parameters, paramDefinitions) {
        parameters = parameters || {};
        var undefinedParams = _.omit(parameters, _.keys(paramDefinitions));
        if (!_.isEmpty(undefinedParams)) {
            dxUtil.fail(_.keys(undefinedParams).join(', ') + ' is not a valid parameter name.');
        }

        _.each(parameters, function (value, key) {
            if (_.isUndefined(value)) {
                dxUtil.fail('Can not send a request with an undefined parameter (' + key + ' is undefined).');
            }
        });

        _.each(paramDefinitions, function (paramDef, paramName) {
            if (_.has(parameters, paramName)) {
                assertValueMatchesDefinition(paramName, parameters[paramName], paramDef);
            } else if (paramDef.required) {
                dxUtil.fail(paramName + ' is required, but has not been passed.');
            }
        });

        // slightly misuse the jsonIze() routine. It does what we need, even if parameters isn't a Backbone model.
        return jsonIze(parameters, 'send');
    }

    /*
     * ========================================
     * Model creation functions
     * ========================================
     */

    /*
     * Returns a new DSB model which is set to be a server model.
     */
    function newServerModel(typeName) {
        var model = makeNewModel(typeName, false);

        makeIntoServerModel(model);

        return model;
    }

    /*
     * Returns a new DSB model which is set to be a client model.
     */
    function newClientModel(typeName) {
        var model = makeNewModel(typeName, true);
        makeReady(model, true);
        return model;
    }

    /*
     * Convert a JSON result object into a client model.
     */
    function resultToModel(result) {
        var model = newClientModel(result.type);
        model.set(result);
        return model;
    }

    /*
     * Create a new model instance. Aside from creating the model, we manually populate the default set of attributes,
     * since the Backbone system doesn't really understand embedded models.
     */
    function makeNewModel(typeName, isClient) {
        if (dxUtil.isNone(typeName)) {
            dxUtil.fail('To create a new model, a type name must be provided.');
        }

        if (!isSchemaType(typeName)) {
            dxUtil.fail(typeName + ' is not a known type name. Can not create one.');
        } else {
            var model = new context._modelConstructors[typeName]();
            model._dxIsClientModel = isClient;
            buildDefaultAttributes(model, model._dxSchema.properties || {});
            return model;
        }
    }

    /*
     * Fill in the defaults for all attributes on the specified model.  This directly manipulates the attributes
     * property, thus bypassing the normal set() semantics.  This is actually OK, as the default Backbone behavior is
     * not to change its changedAttributes() values (etc) at creation time. Additionally, we don't want to be triggering
     * events when doing this.
     */
    function buildDefaultAttributes(model, propDefs) {
        _.each(propDefs, function (propDef, propName) {
            model.attributes[propName] = defaultFor(propDef, model._dxIsClientModel);
        });

        if (!_.isUndefined(propDefs.type)) {
            model.attributes.type = model._dxSchema.name;
        }
    }

    /*
     * Given a type definition, return the default value for that type.
     */
    function defaultFor(propDef, isClientModel) {
        var defaultValue = propDef['default'];

        // Expose "null" from the server as "undefined" to our clients
        if (propDef['default'] === null) {
            defaultValue = undefined;
        }

        if (_.isUndefined(defaultValue) && propDef.type === 'object') {
            if (_.has(propDef, '$ref') && propDef.$ref !== 'Json') {
                defaultValue = isClientModel ? newClientModel(propDef.$ref) : newServerModel(propDef.$ref);
            }
        }

        return defaultValue;
    }

    /*
     * Changes the specified model (and its embedded models) into a server model.
     */
    function makeIntoServerModel(model) {
        model._dxIsClientModel = false;

        if (model._dxSchema['delete']) {
            model.$$delete = model._dxStandardOps.$$delete;
        }

        if (model._dxSchema.update) {
            model.$$update = model._dxStandardOps.$$update;
        }

        model.set = cantModifyServerModel;
        model.clear = cantModifyServerModel;
        model.unset = cantModifyServerModel;
        model.sync = cantModifyServerModel;

        _.each(model._dxSchema.properties, function (propDef, propName) {
            if (isEmbeddedProp(propDef)) {
                makeIntoServerModel(model.get(propName));
            }
        });
    }

    function cantModifyServerModel() {
        dxUtil.fail('Can not modify a server ' + this._dxSchema.name + ' instance.');
    }

    /*
     * Given a type, locate the root parent type (which will be, when walking up the inheritance chain, the last type
     * that has the same value in its root property)
     */
    function getRootType(childType) {
        if (!_.isString(childType)) {
            dxUtil.fail('Must call with a type name.');
        }

        if (!isSchemaType(childType)) {
            dxUtil.fail(childType + ' is not a known type name.');
        }

        return context._modelConstructors[childType].prototype._dxSchema.rootTypeName;
    }

    /*
     * Given xn XmlHttpRequest (or the equivalent), either extract the ErrorResult object from within it and return
     * that, or manufacture an ErrorResult object which contains the HTTP failure information and return that.
     */
    function convertXhrToErrorResult(xhr) {
        var responseInfo = xhr.responseText;

        // for testing xhr may not have getResponseHeader, and not all responses have a content-type!
        var contentType = dxUtil.isNone(xhr.getResponseHeader) ? undefined : xhr.getResponseHeader('content-type');

        if (!dxUtil.isNone(contentType) && contentType.indexOf('application/json') > -1 && !_.isObject(responseInfo)) {
            try {
                responseInfo = JSON.parse(responseInfo);
            } catch (e) {
                dxUtil.fail('Server response claimed to be application/json, but couldn\'t be parsed as JSON (' + xhr.responseText + ').');
            }
        }

        if (responseInfo && responseInfo.type === 'ErrorResult') {
            return resultToModel(responseInfo);
        } else {
            var errorResult = newClientModel('ErrorResult');
            errorResult.get('error').set({
                details: 'Communication Error',
                commandOutput: 'HTTP Error: ' + xhr.status + '\n' + 'Status text: ' + xhr.statusText + '\n' + 'Response text: ' + xhr.responseText
            });
            return errorResult;
        }
    }

    /*
     * ========================================
     * 'subroutines' and utility functions
     * ========================================
     */

    /*
     * Validates that the attribute name is a valid attribute name for the model. If so, this returns information about
     * the attribute (see getAttrInfo).
     */
    function assertAndGetAttrInfo(model, attrName) {
        var info = getAttrInfo(model, attrName);

        if (_.isUndefined(info.propDef)) {
            dxUtil.fail(attrName + ' is not a known attribute.');
        }

        return info;
    }

    /*
     * This returns information about the attribute, including its base name (if the value passed was $attr, this
     * returns 'attr'), whether this was a $-prefixed name (and thus it is actually asking for the referenced model),
     * and the definition of the schema property.
     */
    function getAttrInfo(model, attrName) {
        if (!_.isString(attrName)) {
            dxUtil.fail('Must provide an attribute name.');
        }

        var baseName = attrName;
        var wantsModel = false;
        if (baseName.charAt(0) === '$') {
            baseName = baseName.substring(1);
            wantsModel = true;
        }
        var props = model._dxSchema.properties;
        var propDef = props ? props[baseName] : undefined;

        return {
            baseName: baseName,
            wantsModel: wantsModel,
            propDef: propDef
        };
    }

    var dateStringRegex = /\d\d\d\d-\d\d-\d\dT\d\d:\d\d:\d\d.\d\d\dZ/;

    /*
     * Asserts that the specified value matches (is compatible with) the type specified by the definition.
     */
    function assertValueMatchesDefinition(name, value, def) {
        /*
         * Returns the type of the value.  The return values include Javascript typeof type (undefined, object,
         * boolean, number, string, etc) types, with JSON Schema type refinements (null, array, integer).
         */
        function typeOfValue(value) {
            if (_.isNull(value)) {
                return 'null';
            }

            if (_.isArray(value)) {
                return 'array';
            }

            if (typeof value === 'number') {
                return value === Math.floor(value) ? 'integer' : 'number';
            }

            if (value instanceof Date) {
                return 'date';
            }

            if (typeof value === 'string' && dateStringRegex.exec(value)) {
                return 'date-or-string'; // could be either.
            }

            return typeof value;
        }

        function isTypeCompatible(actualType, objectType, defType, defObjectType, defFormat) {
            if (actualType === 'integer' && defType === 'number') {
                return true;
            } else if (actualType === 'null' || actualType === 'undefined') {
                return true; // can assign null or undefined to all types
            } else if (actualType === 'date' && defType === 'string' && defFormat === 'date') {
                    return true;
                } else if (actualType === 'date-or-string' && defType === 'string') {
                    if (defFormat === 'date') {
                        type = 'date';
                    } else {
                        type = 'string';
                    }
                    return true;
                } else if (defType === 'object' && actualType === 'object') {
                    if (_.isUndefined(defObjectType) || // definition is typeless
                    !_.isUndefined(defObjectType) && _.isUndefined(objectType) || // new value is typeless
                    defObjectType === objectType || // types same
                    firstIsSubtypeOfSecond(objectType, defObjectType)) {
                        // new value is subtype
                        return true;
                    } else {
                        return false;
                    }
                } else {
                    return defType === actualType;
                }
        }

        var type = typeOfValue(value);
        var objectType = type === 'object' ? value.type : undefined;
        var typeMatches;

        if (_.isUndefined(def)) {
            if (dxUtil.isNone(value)) {
                return type;
            } else {
                dxUtil.fail(name + ' has a value, but it has no definition.');
            }
        }

        if (_.isArray(def.type)) {
            typeMatches = _.find(def.type, function (defType) {
                return isTypeCompatible(type, objectType, defType, def.$ref, def.format);
            });
        } else {
            typeMatches = isTypeCompatible(type, objectType, def.type, def.$ref, def.format);
        }

        if (!typeMatches) {
            if (!def.$ref) {
                dxUtil.fail(name + ' has to be type ' + (def.type === 'string' && def.format === 'date' ? 'date' : def.type) + ' but is ' + type + ' (' + JSON.stringify(value) + ')');
            } else {
                dxUtil.fail(name + ' has to be type ' + def.type + '/' + def.$ref + ' but is ' + type + '/' + objectType);
            }
        }

        /*
         * Note: def.enum throws an error in IE8.  We're also good with undefined/null from previous checks but those
         * values obviously aren't part of the enum
         */
        if (def['enum'] && !dxUtil.isNone(value) && !_.contains(def['enum'], value)) {
            dxUtil.fail(name + ' is an enum and has to be one of ' + JSON.stringify(def['enum']) + ' but is ' + JSON.stringify(value));
        }

        return type;
    }

    /*
     * Change the model to another type.  This is done "in place" since we want to preserve any listeners that may
     * have been attached to this object.
     *
     * This returns true if this removed any attributes (it also triggers a 'change:attrName' event for each)
     */
    function convertToType(model, newType) {
        var SourceConstructor = context._modelConstructors[model.get('type')];
        var TargetConstructor = context._modelConstructors[newType];

        // add metadata from the target type, overriding our own.
        model._dxSchema = TargetConstructor.prototype._dxSchema;
        model.urlRoot = TargetConstructor.prototype._dxSchema.root;

        // replace our attributes
        model.attributes = {};
        buildDefaultAttributes(model, model._dxSchema.properties);

        // Remove any operations we previously may have added to this object.
        _.each(model, function (value, name) {
            if (name.charAt(0) === '$') {
                delete model[name];
            }
        });

        /*
         * This is really sad. Since we can't change the prototype of the object at runtime, we necessarily inherit the
         * operations from its prototype.  But if by chance we are converting to a type that doesn't have those
         * operations, we should not allow someone to call them. Insert a dummy function on the leaf object in the
         * prototype chain to keep anyone from actually calling it.
         */
        _.each(SourceConstructor.prototype, function (value, name) {
            if (name.charAt(0) === '$') {
                model[name] = blockPrototypeOperation;
            }
        });

        // Now actually add the operations to this that it should have based on the type it is being converted to.
        _.each(TargetConstructor.prototype, function (value, name) {
            if (name.charAt(0) === '$') {
                model[name] = value;
            }
        });

        if (model._dxSchema['delete']) {
            model.$$delete = dxDelete;
        }

        if (model._dxSchema.update) {
            model.$$update = dxUpdate;
        }
    }

    function blockPrototypeOperation() {
        dxUtil.fail('This operation does not exist on this instance. (it has been converted from a type that had it).');
    }

    function firstIsSubtypeOfSecond(childType, parentType) {
        var candidateInfo = isSchemaType(childType) ? context._modelConstructors[childType].prototype._dxSchema : undefined;

        while (candidateInfo) {
            if (candidateInfo.name === parentType) {
                return true;
            }

            candidateInfo = candidateInfo.parentSchema;
        }

        return false;
    }

    /*
     * As part of the set() process, we can take a JSON array, and convert it into an array ready to be set on the
     * model. This involves two special processes: If an 'items' property has been specified, enforce the type
     * constraint expressed there, and if an object is found that could be converted into a DSB model, create a new
     * model and add it.
     */
    function setupArray(arrayValue, itemDef) {
        var newArray = [];

        _.each(arrayValue, function (value) {
            if (!_.isUndefined(itemDef)) {
                assertValueMatchesDefinition('(array item)', value, itemDef);
            }

            if (_.isArray(value)) {
                newArray.push(setupArray(value));
            } else if (_.isObject(value)) {
                newArray.push(setupObject(value));
            } else {
                newArray.push(value);
            }
        });

        return newArray;
    }

    /*
     * As part of the set() process, take the provided JSON object data, and either convert it into a DSB model, using
     * the type value in the JSON object, or recursively process all the elements in the object and set those on the
     * object this returns.
     */
    function setupObject(objectValue) {
        var newObj = {};

        if (objectValue instanceof Backbone.Model) {
            objectValue = objectValue.toJSON();
        }

        if (isSchemaType(objectValue.type)) {
            newObj = context._cache.getCachedModelFromProperties(objectValue);
        } else {
            _.each(objectValue, function (value, key) {
                if (_.isArray(value)) {
                    newObj[key] = setupArray(value);
                } else if (_.isObject(value)) {
                    newObj[key] = setupObject(value);
                } else {
                    newObj[key] = value;
                }
            });
        }

        return newObj;
    }

    /*
     * Return a version of this model in JSON format, according to the specified mode. The mode may have several values
     * which cause different versions of the model to be returned:
     *
     * undefined: Return all properties.
     * send: Return all non-null required and optional values.
     * create: Return all non-null create required and optional values, as well as required ones.
     * update: Return all non-null update required and optional values, as well as required ones.
     *
     * send, create and update all throw errors if a required attribute is null or undefined (unless that attribute
     * is of type 'null')
     */
    function jsonIze(value, mode) {
        var result;
        if (value instanceof Backbone.Model) {
            result = {};
            _.each(value._dxSchema.properties, function (propDef, key) {
                var attrValue = value.get(key);

                // ordinary jsonizing returns everything
                if (_.isUndefined(mode)) {
                    result[key] = jsonIze(attrValue, mode);
                    return;
                }

                // Don't include read-only properties when sending a property
                if (isReadOnly(propDef, mode)) {
                    return;
                }

                var required = isRequired(propDef, mode);

                // Don't send null when it won't be accepted
                if (dxUtil.isNone(attrValue) && !isNullableType(propDef)) {
                    if (required) {
                        dxUtil.fail('The attribute ' + key + ' is required to be non-null/non-undefined.');
                    }
                    return;
                }

                result[key] = jsonIze(attrValue, mode);
            });
        } else if (_.isArray(value)) {
            result = [];
            _.each(value, function (item) {
                result.push(jsonIze(item, mode));
            });
        } else if (_.isObject(value)) {
            if (value instanceof Date) {
                result = value.toJSON();
            } else {
                result = {};
                _.each(value, function (propValue, key) {
                    result[key] = jsonIze(propValue, mode);
                });
            }
        } else {
            result = _.isUndefined(value) ? null : value;
        }

        return result;
    }

    /*
     * Doing a $$update requires some special handling, hence it's own jsonize routine here.  The parameters to this are
     *    updateAttrs:   A raw object/hash of attributes that the user has asked to send as an update
     *                   This is needed because it gives us a direct view of which attributes the caller wants to send.
     *    updateModel:   A model that has been .set() with those attributes. This is needed because it has the forms of
     *                   the attributes that have already been fully processed by the overall model system here.
     *    baseModel:     The model that the update is related to. This is needed in order to retrieve some values that
     *                   must be included in the update but were not explicitly set. It also helps us determine when a
     *                   value doesn't need to be sent because the new value is the same as the old.
     *    propsRequired: Whether the properties generated by this call must be included. Always true at the top level,
     *                   and each recursive call sets it based on the schema definition.
     *
     * The basic algorithm here is:
     *    Go over each property in the schema definition
     *    If there is an update attribute for it, then add that to the hash of properties we will return
     *      (but use the jsonIzed version of that attribute from the updateModel, to get all the benefits of proper
     *      jsonization)
     *    However, there are some caveats:
     *       - If the update specifies a value which is not changed, don't send a duplicate
     *       - If a property is required for update, but isn't included in the attributes, grab it from the
     *         base model
     *       - If the update attributes specified an undefined value, and the property is allowed to be null,
     *         we send a null.
     *       - Embedded models need special handling.  If the embedded model is required, then we simply add it to
     *         the set of properties we are returning. If the embedded model is optional, however, then if there are no
     *         new values in that embedded model (even if there are required properties there) then it is not included
     *         in the update.  This, then, is the reason for the propsRequired parameter and the propCount in the
     *         routine.  We tell each subsequent call whether we want it to return the properties even if there is
     *         nothing new.
     */
    function jsonIzeForUpdate(rawUpdateObj, updateModel, baseModel, propsRequired) {
        var jsonUpdatePayload = {};
        var propCount = 0;
        _.each(updateModel._dxSchema.properties, function (propDef, key) {
            // Don't include read-only properties when sending a property
            if (isReadOnly(propDef, 'update')) {
                return;
            }

            var required = isRequired(propDef, 'update');

            if (isEmbeddedProp(propDef)) {
                var subProps = rawUpdateObj ? rawUpdateObj[key] : undefined;
                var baseEmbedded = baseModel.get(key);
                var updateEmbedded = updateModel.get(key);
                var embJson;
                /*
                 * The update may legitimately be trying to change the type of an embedded object. In this case we can't
                 * keep using the baseModel's embedded model to extract properties from (in particular, there may be
                 * properties in the 'update' data that aren't in the embedded model, so there's nothing to extract).
                 * Further, our definition of changing types in embedded models is that we do not preserve any
                 * properties properties that were there before, even if they could be. In this regard, changing the
                 * type isn't an overlay, but is instead a replace operation. To make this work here we create a new
                 * model to be used as the base model for the recursive call to jsonIzing.
                 */
                if (baseEmbedded.get('type') !== updateEmbedded.get('type')) {
                    // Doing an update that changes the type really means we are just sending the new data
                    embJson = jsonIze(updateEmbedded, 'update');
                } else {
                    embJson = jsonIzeForUpdate(subProps, updateEmbedded, baseEmbedded, required);
                }
                if (!_.isUndefined(embJson)) {
                    jsonUpdatePayload[key] = embJson;
                    propCount++;
                }
            } else {
                var baseAttrJson = jsonIze(baseModel.get(key), 'update');
                var updateAttrJson = jsonIze(updateModel.get(key), 'update');
                var updateValue = updateWithChangedValue(rawUpdateObj, key, baseAttrJson, updateAttrJson);

                if (updateValue) {
                    throwIfBadNull(updateAttrJson, propDef, key);
                    propCount++;
                    jsonUpdatePayload[key] = updateAttrJson;
                }
                if (required && !updateValue) {
                    throwIfBadNull(baseAttrJson, propDef, key);
                    jsonUpdatePayload[key] = baseAttrJson;
                }
            }
        });

        var returnValue = propsRequired || propCount > 0;

        return returnValue ? jsonUpdatePayload : undefined;
    }

    function updateWithChangedValue(rawUpdateObj, key, baseAttrJson, updateAttrJson) {
        return !_.isUndefined(rawUpdateObj) && _.has(rawUpdateObj, key) && !_.isEqual(baseAttrJson, updateAttrJson);
    }

    /*
     * Determine whether the specified property is 'read only' in the current jsonizing mode. It is readonly if
     * it there are no required or create/update settings, or if it is explicitly readonly.
     */
    function isReadOnly(propDef, mode) {
        var readOnly = mode === 'create' && (_.isUndefined(propDef.create) && _.isUndefined(propDef.required) || propDef.create === 'readonly') || mode === 'update' && (_.isUndefined(propDef.update) && _.isUndefined(propDef.required) || propDef.update === 'readonly');
        return readOnly;
    }

    /*
     * Determine whether the specified property is 'required' given the specified jsonizing mode.
     */
    function isRequired(propDef, mode) {
        var required = propDef.required === true || propDef.create === 'required' && mode === 'create' || propDef.update === 'required' && mode === 'update';
        return required;
    }

    /*
     * Determine whether the specified property is one that allows null values
     */
    function isNullableType(propDef) {
        return _.isArray(propDef.type) ? _.contains(propDef.type, 'null') : propDef.type === 'null';
    }

    function isEmbeddedProp(propDef) {
        return propDef.type === 'object' && _.has(propDef, '$ref') && propDef.$ref !== 'Json';
    }

    function isObjectRefProp(propDef) {
        if (_.isArray(propDef.type)) {
            return _.contains(propDef.type, 'string') && propDef.format === 'objectReference';
        }
        return propDef.type === 'string' && propDef.format === 'objectReference';
    }

    function throwIfBadNull(value, propDef, key) {
        if (dxUtil.isNone(value) && !isNullableType(propDef)) {
            dxUtil.fail('The attribute ' + key + ' is required to be non-null/non-undefined.');
        }
    }

    function isSchemaType(typeName) {
        return !!context._modelConstructors[typeName];
    }

    /*
     * ========================================
     * Actually do the work of this function
     * ========================================
     */

    context = context || this;
    context._modelConstructors = context._modelConstructors || {};
    context.rootOps = context.rootOps || {};

    _.each(schemas, function (schema, typeName) {
        var rwModel = {
            _dxSchema: schema,
            _dxIsReady: false,
            _dxErrorResult: undefined,
            _dxIsClientModel: false,
            _dxStandardOps: {},
            idAttribute: 'reference',
            urlRoot: schema.root,
            _dxSet: dxSet,
            _dxClear: dxClear,
            _dxFetch: dxFetch,
            _dxGetUrl: dxUrl,
            _dxMakeReady: function _dxMakeReady() {
                makeReady(this, false);
            },
            on: dxOn,
            get: dxGet,
            set: dxSet,
            has: dxHas,
            unset: dxUnset,
            clear: dxClear,
            toJSON: dxToJSON,
            fetch: noFetch,
            save: noSave,
            destroy: noDestroy,
            parse: dxParse,
            clone: dxClone,
            instanceOf: instanceOf,
            isServerModel: isServerModel
        };

        function getRootUrl() {
            return schema.root;
        }

        addOperations(rwModel, schema.operations, '', '', true);

        if (schema.rootOperations) {
            /*
             * Root operations on singletons are, essentially object operations, as far as the client object model
             * is concerned. So, treat those root operations as object operations.  However, there are also some
             * singleton 'pseudo-objects' (e.g. delphix_common) which only exist to hold a few operations, so those we
             * put on the rootOps object.  These pseudo-objects all prefixed by 'delphix_'.
             */
            if (schema.singleton && schema.name.indexOf('delphix_') !== 0) {
                addOperations(rwModel, schema.rootOperations, '', '', false);
            } else {
                context.rootOps[typeName] = {};
                context.rootOps[typeName]._dxGetUrl = getRootUrl;
                addOperations(context.rootOps[typeName], schema.rootOperations, '', '', false);
            }
        }

        if (schema.create) {
            context.rootOps[typeName] = context.rootOps[typeName] || {};
            context.rootOps[typeName].$$create = function (payload, successError) {
                return dxCreate(schema.create, getRootUrl(), payload, successError);
            };
        }

        if (schema['delete']) {
            rwModel._dxStandardOps.$$delete = dxDelete;
        }

        if (schema.update) {
            rwModel._dxStandardOps.$$update = dxUpdate;
        }

        context._modelConstructors[typeName] = Backbone.Model.extend(rwModel);
    });

    _.extend(context, {
        _checkAndConvertParameters: checkAndConvertParameters,
        _newServerModel: newServerModel,
        _newClientModel: newClientModel,
        _getRootType: getRootType,
        _convertXhrToErrorResult: convertXhrToErrorResult,
        _handleErrorResult: handleErrorResult
    });

    // Add a trivial function for reporting an ErrorResult.  This is added for testing and only if level3 isn't here.
    if (!context.reportErrorResult) {
        context.reportErrorResult = function () {};
    }
};

},{"dxcore/js/ajax.js":13,"dxcore/js/util.js":23}],11:[function(require,module,exports){
/*
 * Copyright (c) 2013, 2015 by Delphix. All rights reserved.
 */

/* global $, _, Backbone */

'use strict';

var dxUtil = require('dxcore/js/util.js'),
    dxCreationListener = require('dxcore/data/layer2/js/creationListener.js'),
    dxSchema = require('dxcore/data/layer1/js/schema.js'),
    dxCache = require('dxcore/data/layer2/js/cache.js'),
    dxModel = require('dxcore/data/layer2/js/model.js'),
    dxCollection = require('dxcore/data/layer2/js/collection.js'),
    dxNotification = require('dxcore/data/layer3/js/notification.js'),
    dxFilter = require('dxcore/data/layer2/js/filter.js');

/*
 * This defines the public API of the Delphix Data System. It relies heavily on the infrastructure built in the
 * files containing the level 1 and level 2 code.
 *
 * This provides several public functions to get at Delphix-Schema-Based models and collections:
 *     newClientModel                  Returns a 'read/write' model of the specified schema type.
 *
 *     getServerModel                  Returns a 'read-only' model of the specified schema type which is kept in
 *                                     sync with the server as long as it remains a member of a Server Collection.
 *
 *     getServerSingleton              Returns a 'read-only' model of the specified schema type.
 *
 *     getServerCollection             Returns a 'read-only' collection which contains Server Models of a particular
 *                                     type.
 *
 *     getCreationListener             Register a creation listener for a particular type.
 *
 *     getCollectionTypeFromModelType  Returns the name of the collection type that the specified model type belongs to.
 *
 *     setErrorCallback                Set an error callback function that will be called by reportErrorResult on an
 *                                     error.
 *
 *     reportErrorResult               Convenience routine which will display an ErrorResult object to the user on the
 *                                     screen. This is mainly useful if you have an operation error handler which,
 *                                     after examining the ErrorResult model, you still wish to show it to the user.
 */
module.exports.setupDataSystem = function setupDataSystem(schemas, context) {
    /*
     * Returns a new client model.
     *
     * typeName: The type of the model. If a DB2Container is desired, then DB2Container should be passed.
     */
    function newClientModel(typeName) {
        return context._newClientModel(typeName);
    }

    /*
     * Returns a Server Collection for the specified type.  Each call returns a new collection, which may contain
     * distinct elements from other collections of the same type.  The collection is 'read only', which means its
     * contents may not be directly manipulated. However, its contents may be changed with the $$list() operation on
     * the collection.
     *
     * typeName:    This should be the 'root type' for the collection type wanted. That is, if one wants a collection
     *              of DB2Containers, one should pass 'Container' here.
     * resetOnList: If true, $$list()'s will only trigger a single 'reset' event rather than individual 'add' and
     *              'remove' events. Otherwise this happens only when the $$list() fully replaces the contents of the
     *              collection.
     */
    function getServerCollection(typeName, resetOnList) {
        var collection = context._newServerCollection(typeName, resetOnList);
        context._modelSubscribersStore.add(collection);
        return collection;
    }

    /*
     * Returns a creation listener for the specified type. Each call returns a new listener, which must be disposed
     * so as to free resources.
     *
     *   typeName       The schema type for which one receives notifications.
     *
     *   callback       A function to be invoked with a level2 model as argument for each create notification.
     *
     *   queryParams    Optional query parameters used to filter notifications.
     */
    function getCreationListener(settings) {
        if (dxUtil.isNone(settings)) {
            dxUtil.fail('Settings must be specified.');
        }
        _.extend(settings, {
            context: context
        });

        var creationListener = new dxCreationListener.CreationListener(settings);
        context._modelSubscribersStore.add(creationListener);
        return creationListener;
    }

    /*
     * Returns the Server Model representing the specified singleton. If it already exists in the set of models the data
     * system is maintaining, that same instance will be returned. Otherwise a new instance will be returned and its
     * data asynchronously retrieved from the server.
     *
     * typeName:     The name of the type to fetch
     * options:      An object that may contain success and/or error callback functions. If the model is already present
     *               success will be invoked immediately. If it isn't present, success or error will be called once the
     *               underlying fetch has been completed. Additionally, one may set suppressDefaultErrorHandler as an
     *               option here to prevent the default error handler from being executed on error.
     */
    function getServerSingleton(typeName, options) {
        options = _.extend(_.clone(options || {}), {
            update: !context.notification.isStarted()
        });
        var model = context._cache.getCachedSingleton(typeName, options);

        if (!context.notification.isStarted()) {
            model._dxIsReady = false; // if someone sets a ready handler, don't let it fire until new data is back
        }

        return model;
    }

    /*
     * Return the Server Model instance with the specified reference and of the specified type. If the model already
     * is being maintained by the data system, this will return the same instance. If not, a new instance will be
     * returned, and a request to populate it from data on the server.  To determine if the model has at least an
     * initial set of data, one should assign a 'ready' event handler (probably with the once() function).
     *
     * reference:    The reference for the model
     * typeName:     The type for the model. If the desired model is a DB2Container, can be 'Container' or
     *               'DB2Container'. If the type is not known, assume the most general root type ('Container') should be
     *               passed.
     * suppressDefaultErrorHandler:      If truthy, the default error handled is not triggered on errors.
     */
    function getServerModel(reference, typeName, suppressDefaultErrorHandler) {
        var model = context._cache.getCachedModel(reference, typeName, { suppressDefaultErrorHandler: suppressDefaultErrorHandler });

        if (!context.notification.isStarted()) {
            model._dxIsReady = false; // if someone sets a ready handler, don't let it fire until new data is back
            model._dxFetch({ suppressDefaultErrorHandler: suppressDefaultErrorHandler });
        }

        return model;
    }

    /*
     * Gets a server model and returns a jQuery Promise.
     * This promise is resolved with the model if/when the model's ready' event is triggered.
     * It is rejected if/when the model's 'error' event is triggered.
     * For a description of the parameters see context.getServerModel()
     */
    function getServerModelPromise(reference, typeName, suppressDefaultErrorHandler) {
        var deferred = new $.Deferred();
        var model = context.getServerModel(reference, typeName, suppressDefaultErrorHandler);

        return setupPromise(model, deferred);
    }

    /*
     * Gets a server singleton and returns a jQuery Promise.
     * This promise is resolved with the singleton if/when the model's ready' event is triggered.
     * It is rejected if/when the singleton's 'error' event is triggered.
     * For a description of the parameters see context.getServerSingleton()
     */
    function getServerSingletonPromise(typeName, successError) {
        var deferred = new $.Deferred();
        var model = context.getServerSingleton(typeName, successError);

        return setupPromise(model, deferred);
    }

    /*
     * Helper function for getServerModelPromise and getServerSingletonPromise.
     * Note: This is exposed as _setupPromise for testing purposes only.
     */
    function setupPromise(model, deferred) {
        function onReadyCallback() {
            deferred.resolve(model);
        }
        function onErrorCallback() {
            deferred.reject(model);
        }

        model.once('ready', onReadyCallback);
        model.once('error', onErrorCallback);

        // use promise() to lock to deferred, exposing only methods to attach callbacks
        return deferred.promise();
    }

    /*
     * Given a model type, return the name of the 'root type'. Given DB2Container, OracleContainer, or Container, this
     * will return Container.
     */
    function getCollectionTypeFromModelType(modelType) {
        return context._getRootType(modelType);
    }

    /*
     * Sets an error callback that will be called by reportErrorResult. This is useful for an external system to define
     * behavior that will be used by the dxData system when an ErrorResult is reported by an operation
     */
    var errorCallback;
    function setErrorCallback(func) {
        if (!_.isFunction(func)) {
            dxUtil.fail('setErrorCallback expects a function as an argument.');
        }
        errorCallback = func;
    }

    /*
     * Reports an ErrorResult model to the end user in the best fashion available at this time.
     */
    function reportErrorResult(errorResult) {
        if (!(errorResult instanceof Backbone.Model) || errorResult.get('type') !== 'ErrorResult') {
            dxUtil.fail('reportErrorResult expects an ErrorResult model as an argument.');
        }

        // errorCallback is set by an external source using setErrorCallback
        if (errorCallback) {
            errorCallback(errorResult);
        }

        dxUtil.warn('Error result: ' + JSON.stringify(errorResult.toJSON()));
    }

    /*
     * Start the real work here. Initialize everything 'below' us.
     */
    context = context || this;
    var parsedSchemas = dxSchema._prepareSchemas(schemas);
    var enums = dxSchema._prepareEnums(parsedSchemas);
    dxCache._initCache(context);
    dxFilter._initFilters(context);
    dxModel._generateModelConstructors(parsedSchemas, context);
    dxCollection._generateCollectionConstructors(parsedSchemas, context);
    dxNotification._setupNotificationSystem(context);

    _.extend(context, {
        parsedSchemas: parsedSchemas,
        enums: enums,
        getServerCollection: getServerCollection,
        getCreationListener: getCreationListener,
        getServerSingleton: getServerSingleton,
        newClientModel: newClientModel,
        getServerModel: getServerModel,
        setErrorCallback: setErrorCallback,
        getServerModelPromise: getServerModelPromise,
        getServerSingletonPromise: getServerSingletonPromise,
        _setupPromise: setupPromise, // Exposed for testing purposes
        reportErrorResult: reportErrorResult,
        getCollectionTypeFromModelType: getCollectionTypeFromModelType
    });
};

},{"dxcore/data/layer1/js/schema.js":5,"dxcore/data/layer2/js/cache.js":6,"dxcore/data/layer2/js/collection.js":7,"dxcore/data/layer2/js/creationListener.js":8,"dxcore/data/layer2/js/filter.js":9,"dxcore/data/layer2/js/model.js":10,"dxcore/data/layer3/js/notification.js":12,"dxcore/js/util.js":23}],12:[function(require,module,exports){
/*
 * Copyright (c) 2014, 2015 by Delphix. All rights reserved.
 */

/* global _ */

'use strict';

var dxUtil = require('dxcore/js/util.js'),
    dxLocale = require('dxcore/js/locale.js');

/*
 * This notification system receives updates from the server about objects that have been created, deleted or updated.
 * This system, in turn, converts those notifications into calls to the underlying cache system so all models and
 * collections being used are up to date with whatever information is in the server.  Without the notification system
 * turned on, the models and collections are not assured of being up to date with what the server knows about.
 *
 * To use the notification system, simply call the start() function at the start of your program. To stop receiving
 * notifications, call stop(). You can also call isStarted() to verify whether the notification system is turned on.
 */
module.exports._setupNotificationSystem = function _setupNotificationSystem(context) {

    /*
     * We use long polling to fetch notifications. We want to make sure our timeout is less than the browser timeout,
     * but otherwise the call will return as soon as data is available.
     */
    var TIMEOUT_SEC = 12;

    /*
     * If the call fails, we don't want to spin in a loop retrying. Attempt a new request after this time period.
     */
    var RETRY_SEC = 10;

    var date = new Date();
    var timeout;
    var stopped = true;
    var notification;
    var notificationChannel = date.getTime() + '_html';

    function processNotifications(notifications, reloadClient) {
        var uniqueObjectNotifications = {};
        var uniqueSingletonNotifications = {};

        /*
         * Pre-process notifications. Keep only the last notification for a particular object. Thus, should we receive a
         * create, update and delete notification for an object, we will only keep the delete. This assumes that we
         * never get a non-delete notification after getting a delete notification.
         */
        notifications.each(function (model) {
            switch (model.get('type')) {
                case 'ObjectNotification':
                    var reference = model.get('object');
                    uniqueObjectNotifications[reference] = model;
                    break;
                case 'SingletonUpdate':
                    var type = model.get('objectType');
                    if (!_.has(uniqueSingletonNotifications, type)) {
                        uniqueSingletonNotifications[type] = model;
                    }
                    break;
                case 'NotificationDrop':
                    reloadClient(dxLocale.gls('dx.notification_drop', model.get('dropCount')));
                    break;
                // we ignore all other types
            }
        });

        /*
         * With the uniquified set of object notifications, loop through them and retrieve or delete our copies of the
         * objects on the server
         */
        _.each(uniqueObjectNotifications, function (notification, objRef) {
            try {
                var type = notification.get('objectType');
                var rootType = context.getCollectionTypeFromModelType(type);

                switch (notification.get('eventType')) {
                    case 'CREATE':
                    case 'UPDATE':
                        var subscriptionUsesModel = context._modelSubscribersStore.hasType(rootType);
                        var hasModel = context._cache.containsCachedModel(objRef, rootType);
                        if (subscriptionUsesModel || hasModel) {
                            var model = context._cache.getCachedModel(objRef, rootType, {
                                update: true,
                                cacheOnlyIfNeeded: true,
                                suppressDefaultErrorHandler: true
                            });

                            var listenerContext = {};

                            /*
                             * After we've fetched the model, notify the cache that this model may need to be added or
                             * removed from collections.
                             * In the case of a badReference (e.g. the model has been deleted), make sure we clean up
                             * the sync listener. We do not use the "error" event because it's a one time event for the
                             * first fetch. For fetching errors other than badReference, we would technically leak these
                             * listeners, but realistically this likely indicates something bad happened on the server
                             * that will require special attention.
                             */
                            model.once('sync', function () {
                                model.off(undefined, undefined, listenerContext);
                                context._cache.modelMayHaveChanged(model, rootType);
                            }, listenerContext);
                            model.once('badReference', function () {
                                model.off(undefined, undefined, listenerContext);
                            }, listenerContext);
                        }
                        break;
                    case 'DELETE':
                        context._cache.deleteCachedModel(objRef, rootType);
                        break;
                    default:
                        dxUtil.warn('Unknown event type: ' + notification.get('eventType'));
                }
            } catch (e) {
                // We really don't want notification processing to stop, so swallow any exception and keep going
                dxUtil.warn('notification processing failed: ' + e.message);
            }
        });

        /*
         * Finally, update all the singletons that have been changed, as well.
         */
        _.each(uniqueSingletonNotifications, function (notification, type) {
            try {
                context._cache.getCachedSingleton(type, { update: true });
            } catch (e) {
                // We really don't want notification processing to stop, so swallow any exception and keep going
                dxUtil.warn('notification processing failed: ' + e.message);
            }
        });
    }

    function fetchNotifications(reloadClient) {
        timeout = undefined;

        notification.$$list({
            timeout: '' + TIMEOUT_SEC * 1000,
            channel: notificationChannel
        }, {
            success: function success() {
                // We want to make sure notifications don't ever stall, even if there is some unknown problem
                if (!stopped) {
                    try {
                        processNotifications(notification, reloadClient);
                    } finally {
                        fetchNotifications(reloadClient);
                    }
                }
            },
            error: function error() {
                if (!stopped) {
                    dxUtil.warn('Notification call failed.');
                }

                if (stopped) {
                    return;
                }

                timeout = setTimeout(function () {
                    fetchNotifications(reloadClient);
                }, RETRY_SEC * 1000);
            }
        });
    }

    /*
     * For testing purposes. This returns the timeout used for retries for predictable results.
     */
    function _getRetryTimeout() {
        return RETRY_SEC * 1000;
    }

    function start(reloadClient) {
        if (_.isUndefined(notification)) {
            notification = context.getServerCollection('Notification');
        } else {
            dxUtil.fail('Notification system already started.');
        }
        stopped = false;
        fetchNotifications(reloadClient);
    }

    function isStarted() {
        return !stopped;
    }

    function stop() {
        if (notification) {
            notification = undefined;
        }
        if (timeout) {
            clearTimeout(timeout);
        }
        stopped = true;
    }

    context = context || this;
    context.notification = context.notification || {};
    _.extend(context.notification, {
        _getRetryTimeout: _getRetryTimeout,
        start: start,
        isStarted: isStarted,
        stop: stop
    });
};

},{"dxcore/js/locale.js":17,"dxcore/js/util.js":23}],13:[function(require,module,exports){
/*
 * Copyright (c) 2013, 2015 by Delphix. All rights reserved.
 */

/* global $, _ */

'use strict';

var dxUtil = require('dxcore/js/util.js');

/*
 * shorthand for POST ajax calls
 *    config - $.ajax configuration object.
 */
function post(config) {
    if (dxUtil.isNone(config)) {
        dxUtil.fail('post() requires a set of jQuery ajax options.');
    }
    config.type = 'POST';
    ajaxCall(config);
}

/*
 * shorthand for GET ajax calls
 *    config - $.ajax configuration object.
 */
function get(config) {
    if (dxUtil.isNone(config)) {
        dxUtil.fail('get() requires a set of jQuery ajax options.');
    }
    config.type = 'GET';
    ajaxCall(config);
}

/*
 * Wrapper function for jquery $.ajax function
 *    config - $.ajax configuration object.
 */
function ajaxCall(config) {
    if (config && config.url) {
        config.type = config.type || 'GET';
        config.contentType = config.contentType || 'application/json';
        config.dataType = config.dataType || 'json';

        config.xhrFields = config.xhrFields || {
            withCredentials: true
        };

        config.success = config.success || function (d) {
            dxUtil.debug(d);
        };

        config.error = config.error || function (e) {
            dxUtil.debug(e);
        };

        config.cache = config.cache || false;

        config.url = dxUtil.getWindowURLOrigin() + config.url;

        try {
            $.ajax(config);
        } catch (e) {
            dxUtil.fail(e.message);
        }
    } else {
        dxUtil.fail('Invalid configuration for jQuery ajax call. Unable to complete the operation.');
    }
}

/*
 * Sets the global ajax configuration and sets up CSRF header inclusion
 */
function ajaxSetup(config) {
    config = config || {};
    config.cache = config.cache || false;
    $.ajaxSetup(config);

    $.ajaxPrefilter((function () {
        var sessionRoute = /\/resources\/json\/delphix\/session/;
        return function (options) {
            var httpVerb = options.method || options.type;
            if ((!httpVerb || httpVerb === 'GET') && sessionRoute.test(options.url) || httpVerb && _.contains(['POST', 'DELETE', 'PUT'], httpVerb.toUpperCase())) {

                options.headers = options.headers || {};
                options.headers['X-Browser-Session'] = 'True';
            }
        };
    })());
}

/*
 * Routine which installs a handler to manage handling of any ajax errors at a global level. Note that with no
 * parameter, the default Delphix handler will be used.
 */
function ajaxErrorSetup(handler) {
    $(document).ajaxError(handler);
}

// Corresponding cleanup routine for ajaxErrorSetup
function ajaxErrorCleanup() {
    $(document).off('ajaxError');
}

module.exports = {
    post: post,
    get: get,
    ajaxCall: ajaxCall,
    ajaxSetup: ajaxSetup,
    ajaxErrorSetup: ajaxErrorSetup,
    ajaxErrorCleanup: ajaxErrorCleanup
};

// Immediately set up default ajax configuration and CSRF header inclusion
ajaxSetup();

},{"dxcore/js/util.js":23}],14:[function(require,module,exports){
/*
 * Copyright (c) 2013, 2015 by Delphix. All rights reserved.
 */

/* global Modernizr, window, _ */

'use strict';

/*
 * Container for all browser-specific workarounds, as well as access to wrappers around parts of the browser that
 * can't be mockec.
 */
/*
 * Provide access to window.location.  This is primarily to allow tests to override access to this member
 * which is often not very maleable in real browsers.
 */
function getWindowLocation() {
    return window.location;
}

/*
 * Sets the window.location.hash value. This is done because we can't spy on the location properties in tests.
 */
function setWindowHash(newHash) {
    window.location.hash = newHash;
}

/*
 * Reloads the page.
 */
function locationReload() {
    window.location.reload(true);
}

/*
 * Open an URL.
 */
function open(url, target, feature, replace) {
    window.open(url, target, feature, replace);
}

/*
 * Generalized routine for writing to various console output 'streams'.  This is quite protective since some
 * versions of IE don't behave well (and, for that matter, window.console isn't part of a standard). Also,
 * IE9's console.log doesn't always have an apply() routine, and this may well be true of others too.
 */
function consoleReport(operation, originalArgs) {
    if (!_.isUndefined(window.console)) {
        if (window.console[operation]) {
            var hasApply = false;
            // The angular codebase says that IE11 in IE8 emulation mode will throw an exception if reading apply
            try {
                hasApply = !!window.console[operation].apply;
            } catch (e) {
                // empty
            }
            if (hasApply) {
                window.console[operation].apply(window.console, originalArgs);
            } else {
                window.console[operation](originalArgs[0]);
            }
        } else if (operation !== 'log') {
            module.exports.consoleReport('log', originalArgs);
        }
    }
}

/*
 * Wrapper around interaction with the console
 */
function consoleLog() {
    module.exports.consoleReport('log', arguments);
}

/*
 * Wrapper around interaction with the console
 */
function consoleInfo() {
    module.exports.consoleReport('info', arguments);
}

/*
 * Wrapper around interaction with the console
 */
function consoleWarn() {
    module.exports.consoleReport('warn', arguments);
}

/*
 * Wrapper around interaction with the console
 */
function consoleError() {
    module.exports.consoleReport('error', arguments);
}

/*
 * Wrapper around interaction with the console
 */
function consoleDebug() {
    module.exports.consoleReport('debug', arguments);
}

/*
 * Return the appropriate change event for checkbox under different browsers. The problem with this one is that IE8's
 * change event is fired before the actual change was made and it was impossible to query for the updated value.
 */
function checkboxChangeEvent(element) {
    var hasNewEvent = Modernizr.hasEvent('change', element);
    return hasNewEvent ? 'change' : 'propertychange';
}

/*
 * Please do not use this routine. Try to use Modernizr instead. This is only provided for the extreme case that one
 * really needs to care that the browser in question is IE.
 */
function isIE() {
    // see http://stackoverflow.com/questions/19999388/jquery-check-if-user-is-using-ie
    var ua = window.navigator.userAgent;
    var msie = ua.indexOf('MSIE ');
    return msie > 0 || !!navigator.userAgent.match(/Trident.*rv\:11\./);
}

/*
 * Please do not use this routine, either.
 */
function isIE9or10() {
    // see http://stackoverflow.com/questions/19999388/jquery-check-if-user-is-using-ie
    var ua = window.navigator.userAgent;
    var msie = ua.indexOf('MSIE ');
    return msie > 0;
}

/*
 * Sets the title in the browser tab
 * If the hostname is an IP address, we leave it as is.
 * If it's a 'normal' URL, we strip off the domain name (everything after the first '.')
 * Accepts a suffix which will be appended after the hostname
 */
function setTitle(suffix) {
    var title,
        isIPAddress,
        hostname = module.exports.getWindowLocation().hostname,
        hostnameSegs = hostname ? hostname.split('.') : [];

    // we're fairly sure it's an IP address if last segment has a numeric character
    isIPAddress = /\d/.test(hostnameSegs[hostnameSegs.length - 1]);

    title = isIPAddress ? hostname : hostnameSegs[0];

    // append suffix
    if (suffix) title += ' - ' + suffix;

    document.title = title;
    return title; // Used for testing purposes
}

module.exports = {
    getWindowLocation: getWindowLocation,
    setWindowHash: setWindowHash,
    locationReload: locationReload,
    open: open,
    consoleLog: consoleLog,
    consoleInfo: consoleInfo,
    consoleWarn: consoleWarn,
    consoleError: consoleError,
    consoleDebug: consoleDebug,
    consoleReport: consoleReport,
    checkboxChangeEvent: checkboxChangeEvent,
    isIE: isIE,
    isIE9or10: isIE9or10,
    setTitle: setTitle
};

},{}],15:[function(require,module,exports){
/*
 * Copyright (c) 2013, 2015 by Delphix. All rights reserved.
 */

/*
 * This file contains a map of common constants.
 */

'use strict';

var SECOND_IN_MILLISECONDS = 1000,
    MINUTE_IN_MILLISECONDS = SECOND_IN_MILLISECONDS * 60,
    HOUR_IN_MILLISECONDS = MINUTE_IN_MILLISECONDS * 60,
    DAY_IN_MILLISECONDS = HOUR_IN_MILLISECONDS * 24,
    WEEK_IN_MILLISECONDS = DAY_IN_MILLISECONDS * 7,
    MONTH_IN_MILLISECONDS = DAY_IN_MILLISECONDS * 30,
    YEAR_IN_MILLISECONDS = DAY_IN_MILLISECONDS * 365;

var inequalityTypes = {
    STRICT: 'STRICT',
    NON_STRICT: 'NON-STRICT'
};

var listTypes = {
    NONE: 'NONE',
    UBER: 'UBER',
    CUSTOM: 'CUSTOM'
};

module.exports = {
    LDAP: 'LDAP',
    VERSION_MAJOR: 1,
    VERSION_MINOR: 7,
    VERSION_MICRO: 0,
    // Time constants
    SECOND_IN_MILLISECONDS: 1000,
    MINUTE_IN_MILLISECONDS: MINUTE_IN_MILLISECONDS,
    HOUR_IN_MILLISECONDS: HOUR_IN_MILLISECONDS,
    DAY_IN_MILLISECONDS: DAY_IN_MILLISECONDS,
    WEEK_IN_MILLISECONDS: WEEK_IN_MILLISECONDS,
    MONTH_IN_MILLISECONDS: MONTH_IN_MILLISECONDS,
    YEAR_IN_MILLISECONDS: YEAR_IN_MILLISECONDS,
    INEQUALITY_TYPES: inequalityTypes,
    LIST_TYPES: listTypes
};

},{}],16:[function(require,module,exports){
/*
 * Copyright (c) 2014, 2015 by Delphix. All rights reserved.
 */

/* global _ */

'use strict';

/*
 * Delphix framework/top-level namespace
 */

window.dx = window.dx || {};

if (_.isUndefined(window.dx.namespace)) {
    _.extend(window.dx, {
        namespace: function namespace(_namespace) {
            var current = window;
            _.each(_namespace.split('.'), function (pName) {
                current = current[pName] = current[pName] || {};
            });
            return current;
        }
    });
}

module.exports = window.dx;

},{}],17:[function(require,module,exports){
/*
 * Copyright (c) 2014, 2015 by Delphix. All rights reserved.
 */

/* global $, _ */

'use strict';

var dxUtil = require('dxcore/js/util.js');

/*
 * this function sets up the locale
 *     localeConfig - conforming to the i18n jquery plugin config.
 */
function setupLocale(localeConfig) {
    // check to if an array of locale config is passed
    try {
        if (localeConfig instanceof Array) {
            for (var i in localeConfig) {
                if (localeConfig[i]) {
                    localeConfig[i].mode = 'map';
                    $.i18n.properties(localeConfig[i]);
                }
            }
        } else {
            localeConfig.mode = 'map';
            $.i18n.properties(localeConfig);
        }
    } catch (e) {
        if (dxUtil.isNone($.i18n)) {
            dxUtil.fail('Error: Localized text cannot be initialized.');
        } else {
            throw e;
        }
    }
}

/*
 * Get the user's preferred locale, which is set in a cookie by the login screen. If not set, it defaults to English.
 */
function getCurrentLocale() {
    var locale = dxUtil.getCookie('locale') || 'en-US';
    // $.i18n looks for message files with underscores.
    locale = locale.replace('-', '_');

    return locale;
}

/*
 * gls == getLocaleString.  This function gets a constants value initialized by localization library. The first
 * parameter is the locale key to look up the localized string. Additional optional parameters are used for
 * substitutions as {0}, {1}, etc.
 */
function gls() {
    if ($.i18n && $.i18n.prop) {
        return $.i18n.prop.apply(undefined, arguments);
    } else {
        return 'Error: Localized text failed to initialize.';
    }
}

function scaleDecimalNumberAsString(value, units) {
    return numberToString(value, 'decimal', units);
}

function numberToString(value, baseString, units) {
    if (!_.isNumber(value)) {
        return '';
    }
    if (baseString && ['decimal', 'binary'].indexOf(baseString) === -1) {
        dxUtil.fail('baseString must be "decimal" (or undefined), "binary". Received: ' + baseString + '.');
    }

    var base = baseString === 'binary' ? 1024 : 1000;
    var prefixes = ['', 'K', 'M', 'G', 'T', 'P', 'E'];
    var index;
    for (index = 0; value >= base && index < prefixes.length - 1; index++) {
        value /= base;
    }

    if (value > base || Math.round(value) === value) {
        value = Math.round(value).toString();
    } else if (value < 10) {
        value = value.toFixed(2);
    } else {
        value = value.toPrecision(4);
    }

    return value + prefixes[index] + (!_.isUndefined(units) ? module.exports.gls(units) : '');
}

// Define the public api
module.exports = {
    gls: gls,
    getCurrentLocale: getCurrentLocale,
    setupLocale: setupLocale,
    scaleDecimalNumberAsString: scaleDecimalNumberAsString,
    numberToString: numberToString
};

},{"dxcore/js/util.js":23}],18:[function(require,module,exports){
/*
 * Copyright (c) 2014, 2015 by Delphix. All rights reserved.
 */

/* global $, _ */

'use strict';

var modalVisible = null,
    namedModal = {};

var dxUtil = require('dxcore/js/util.js'),
    dxLocale = require('dxcore/js/locale.js'),
    dxTemplate = require('dxcore/js/template.js');

/*
 * modal.show(options)
 *
 * Displays a modal dialog. Only one modal dialog can be shown at a time. The 'options' argument takes the
 * following values:
 *
 *      content         Content for the dialog, as a jQuery node.
 *
 *      title           An optional title for the dialog.
 *
 *      noclose         By default, all modal dialogs have a close button in the top right corner that dismisses
 *                      the dialog. If this is explicitly set to 'true', then this close box is hidden.
 *
 *      cssClass        This is an optional parameter. If provided, it will override the default css for the
 *                      modal window by adding the provided css class reference to the container div.
 *
 *      template        By default, we use the dxcore/template/modal/dialog.hjs template for this modal dialog.
 *                      However, if the developer needs to pop-up an entirely different kind of modal, he/she can
 *                      pass in path to their template and modal will render it.
 *
 *      buttons         An optional array of objects that specify a set of buttons to display in the footer. These
 *                      button objects include the following attributes:
 *
 *                          label       Text label for the button.
 *
 *                          onClick     Callback invoked when the button is clicked.
 *
 *                          primary     If true, then this button is given the 'btn-primary' class to indicate it is
 *                                      the default action. It does not bind the enter key to actually trigger the
 *                                      the button.
 *
 *                          iconClass   Optional parameter. If present, allows for an icon to be shown in the button
 *
 *      cancel          Convenience alias. If set to 'true', prepend a standard cancel button to the button list
 *                      that dismisses the current dialog.
 *
 *      ok              Convenience alias. If set to 'true', append a standard OK button to the button list that
 *                      dismisses the current dialog. If this is a function, then the function is invoked when the
 *                      button is pressed instead of dismissing the dialog.
 *
 *      onShow          A callback that is invoked when the dialog element is visible.
 */
function show(options) {
    var self = this;

    if (modalVisible) {
        dxUtil.fail('attempt to show multiple modal dialogs at once');
    }

    var buttons = options.buttons || [];

    // Default cancel button
    if (options.cancel) {
        buttons.unshift({
            label: dxLocale.gls('button.cancel'),
            onClick: hide
        });
    }

    // Default OK button
    if (options.ok) {
        buttons.push({
            label: dxLocale.gls('button.ok'),
            onClick: _.isFunction(options.ok) ? options.ok : hide,
            primary: true,
            iconClass: 'icon-accept'
        });
    }

    // Basic layout
    var templateLocation = options.template || 'dxcore/template/modal/dialog';
    self.hideModal = hide;

    var dialogElem = dxTemplate.template(templateLocation, {
        title: options.title,
        hasClose: !options.noclose,
        hasFooter: buttons.length !== 0
    });

    // Construct the button bar
    var buttonBar = $('<div></div>');
    _.each(buttons, function (buttonDef) {

        var buttonElem = dxTemplate.template('dxcore/template/modal/button', {
            label: buttonDef.label,
            iconClass: buttonDef.iconClass
        });

        if (buttonDef.primary) {
            buttonElem.addClass('btn-primary');
        }

        buttonElem.on('click', buttonDef.onClick);
        buttonBar.append(buttonElem);
    });

    if (options.cssClass) {
        dialogElem.removeClass('modal-div');
        dialogElem.addClass(options.cssClass);
    }

    // Set the dynamic content
    dialogElem.children('.modal-body').append(options.content);
    dialogElem.children('.modal-footer').append(buttonBar);

    // Now set the modal holder and show it
    $('#modalHolder').empty();
    $('#modalHolder').append(dialogElem);

    dialogElem.on('hidden.bs.modal', function () {
        modalVisible = null;
    });

    if (options.onShow && _.isFunction(options.onShow)) {
        dialogElem.on('shown.bs.modal', function () {
            options.onShow();
        });
    }

    modalVisible = dialogElem;
    dialogElem.modal({
        backdrop: 'static'
    });
}

/*
 * modal.hide()
 *
 * Hide the current modal dialog. This has no effect if no modal dialog is currently shown.
 */
function hide() {
    if (modalVisible) {
        modalVisible.modal('hide');
    }
}

/*
 * Modal dialogs can be registered by name, allowing consumers to display content without needing to call directly
 * into the implementation. This is just a wrapper around callback registration.
 */
function registerNamed(path, callback) {
    if (!_.isFunction(callback)) {
        dxUtil.fail('attempt to register named dialog "' + path + '" with invalid callback');
    }

    namedModal[path] = callback;
}

function showNamed(path) {
    namedModal[path]();
}

module.exports = {
    show: show,
    hide: hide,
    registerNamed: registerNamed,
    showNamed: showNamed
};

},{"dxcore/js/locale.js":17,"dxcore/js/template.js":21,"dxcore/js/util.js":23}],19:[function(require,module,exports){
/*
 * Copyright (c) 2013, 2015 by Delphix. All rights reserved.
 */

/* global $, Backbone, _, ko */

'use strict';

var dxUtil = require('dxcore/js/util.js'),
    dxModal = require('dxcore/js/modal.js'),
    dxBrowser = require('dxcore/js/browser.js');

// Backbone router instance
var DelphixRouter = Backbone.Router.extend();
var delphixRouter;
var queuedCalls = [];
var routerStarted = false;

// State for remembering preserved screen state
var savedScreens = {};

// State for implementing onExit()
var currentScreen;
var currentScreenOptions;

// Callbacks to be called up when existing a screen, unless preserveContent is true
var screenCleanup = [];

// tracks number of route calls, for testing purposes
var routeCalls = 0;

/*
 * Register a screen in the application. Each application is grouped into 'screens' of content, where each screen
 * replaces the main content of the page (not including navbar and other navigational elements). In addition to the
 * content, every screen has a path associated it, which is tracked in the URL ('#path/to/thing') and allows for
 * bookmarks and forward / back browser navigation. To register a screen, you call the following from global context
 * or a $().ready() handler:
 *
 *      screen.register({
 *          path: 'path/to/screen',
 *          constructor: MyScreen
 *      });
 *
 * This will build a 'MyScreen' object whenever the user navigates to that given path (either from a bookmark,
 * forward/back, or programmatically). Paths follow the Backbone router model:
 *
 *      /route/:path/item:id
 *
 * Any parameters will be provided to the onEnter() callback as arguments in the order they appear in the path. More
 * information can be found in the backbone router documentation:
 *
 *      http://backbonejs.org/#Router
 *
 * The screen infrastructure will build the object and showing the content within the UI. By default, it will destroy
 * and recreate the object each time the user navigates to the screen (but not when the user navigates to a screen with
 * already showing that same screen. in that case navigating is a no-op), but the screen can also be registered with
 * 'preserveContent: true' to have the content state be kept as-is off screen. This should only be used for complex
 * screens where maintaining state (selected objects, etc) provides an improved user experience that is worth the
 * memory cost. Preserved content is tracked by the registered path (/path/:foo) not the actual path (/path/bar), so
 * there can be only one preserved state when using substitutions. Screens must implement the following method:
 *
 *      getContent()        Return a jQuery or DOM object that is the root of the screen content. This is what is
 *                          displayed in the main content.
 *
 * The following methods are optional:
 *
 *      beforeEnter()       Invoked when the screen content is going to be displayed. This is needed if one must do
 *                          some kind of setup before generating the content.
 *
 *      onEnter()           Invoked when the screen content is displayed. This is really only useful for screens that
 *                          are registered with 'preserveContent' set, and can be used to kick off asynchronous
 *                          activity specific to the screen.
 *
 *      onExit()            Invoked when the screen content is removed. This can be used to cancel any asynchronous
 *                          activity.
 */
function register(options) {
    if (!delphixRouter) {
        queuedCalls.push(options);
        return;
    }

    delphixRouter.route(options.path, options.path, function () {
        routeCalls++;

        var htmlContent = $('#htmlContent');

        // Navigate away from the current screen
        if (currentScreen) {
            // Invoke onExit if supported by the current screen
            if (currentScreen.onExit) {
                currentScreen.onExit();
            }

            if (currentScreenOptions.preserveContent) {
                // Preserve the current content if requested
                savedScreens[currentScreenOptions.path] = currentScreen;
                currentScreen.getContent().detach();
            } else {
                // Otherwise discard current content
                currentScreen.getContent().remove();
                var toBeCalled = _.clone(screenCleanup);
                screenCleanup = [];
                _.each(toBeCalled, function (callback) {
                    callback();
                });
            }
        }

        // Re-use preserved content if requested
        if (savedScreens[options.path]) {
            currentScreen = savedScreens[options.path];
        } else {
            currentScreen = new options.constructor();
        }
        currentScreenOptions = options;

        // Hide any modal dialog that might be present
        dxModal.hide();

        // Invoke beforeEnter() if provided
        if (currentScreen.beforeEnter) {
            currentScreen.beforeEnter.apply(currentScreen, arguments);
        }

        // Update the currentRoute observable
        module.exports.currentRoute(options.path);

        // Attach the content
        htmlContent.append(currentScreen.getContent());
        if (!options.startWithContentHidden) {
            htmlContent.show();
        }

        // Invoke onEnter() if provided
        if (currentScreen.onEnter) {
            currentScreen.onEnter.apply(currentScreen, arguments);
        }
    });
}

/*
 * Actively change the screen to the given path, invoking the onEnter()/onExit() callbacks in the process.
 */
function navigate(path, skipHistory) {
    delphixRouter.navigate(path, { trigger: true, replace: skipHistory });
}

/*
 *
 */
function internalDeepLinkNavigate(path, skipHistory, details) {
    if (!_.isObject(details)) {
        dxUtil.fail('Must pass a details object when doing deep linking.');
    }

    navigate(path, skipHistory);

    // does the destination page support deep linking?
    if (!currentScreen.doDeepLink) {
        dxUtil.fail('Attempt to deep link to a page which doesn\'t support this.');
    }

    currentScreen.doDeepLink(details);
}

/*
 * Update the URL for the page, without doing a navigation
 */
function updateWithoutNavigation(path, skipHistory) {
    delphixRouter.navigate(path, { trigger: false, replace: skipHistory });
}

/*
 * Navigate to an external url. This will leave the current html file entirely. This expects to receive the full
 * pathname and hash portion of the url. That is, it is something like /myapp/#library.
 */
function navigateExternal(url) {
    window.location.href = dxUtil.getWindowURLOrigin() + url;
}

/*
 * Hide the current full screen content, exposing the flex application underneath. It will also call onExit of the
 * currently visible JS screen. This is called from the flex/html hybrid code when switching to a flex screen, so
 * that every route need not do this in an onExit handler.
 * This will have no effect if the screen content is currently hidden.
 */
function hide() {
    var htmlContent = $('#htmlContent');

    // Check that the html content is actually visible in case it was hidden by some other source.
    if (htmlContent.is(':visible') && currentScreen && currentScreen.onExit) {
        currentScreen.onExit();
        currentScreen = null;
    }

    htmlContent.hide();
}

/*
 * This special function is called directly from the $().ready() handler in the main index.html file. This ensures that
 * it is called after any screen.register() calls invoked from other ready handlers, and it's safe to
 * call history.start() and redirect to any routes based on hashchange events.
 */
function start() {
    delphixRouter = new DelphixRouter();

    /*
     * Register a default route that ignores unknown routes (if a user manually types a path, for example). Note that
     * this may also be a legitimate view in the Flex application, so we make sure to hide the html content.
     */
    delphixRouter.route('*path', '*path', function () {
        routeCalls++;
        module.exports.hide();
    });

    _.each(queuedCalls, register);

    Backbone.history.start();
    routerStarted = true;
}

/*
 * Adds a function that will be called when the current screen exits. This is intended to allow code to do any cleanup
 * that is needed. Note that cleanup will make a copy of the items to be cleaned, before starting the cleanup cycle.
 * This means that if you have registered a cleanup routine, and discover at cleanup time that you can't cleanup now,
 * you can recall this routine to re-register yourself without problems.  This isn't encouraged, but it is sometimes
 * needed.
 */
function registerCleanupCallback(callback) {
    if (!_.isFunction(callback)) {
        dxUtil.fail('Must pass a function to cleanupOnPageExit()');
    }

    screenCleanup.push(callback);
}

/*
 * Updates a query parameter in the hash-portion of the url, causing a new navigation to happen.
 *
 * That is, if the current page is:
 *    http://www.example.com/#exiting-route
 * and we call updateParam('level', 'high'), then the user will be navigated to:
 *    http://www.example.com/#exiting-route?level=high
 * Similarly if the current page is:
 *    http://www.example.com/#exiting-route?fun=necessary&level=high&urls=fun
 * and we call updateParam('level', 'exponential'), then the user will be navigated to:
 *    http://www.example.com/#exiting-route?fun=necessary&level=exponential&urls=fun
 * (these navigations are not recorded on the back-history)
 *
 * Both name and value must be strings, and both will be escaped in case they contain url-unsafe characters.
 */
function updateParam(name, value) {
    if (!_.isString(name)) {
        dxUtil.fail('Must specify a string for name to updateParam()');
    }

    if (!_.isString(value)) {
        dxUtil.fail('Must specify a string for value to updateParam()');
    }

    var newParams;
    var found;
    var newPair;

    var currentHash = dxBrowser.getWindowLocation().hash;
    var paramsLoc = currentHash.indexOf('?');
    var beforeParams = currentHash;
    var params = '';

    name = encodeURIComponent(name);
    newPair = name + '=' + encodeURIComponent(value);

    if (paramsLoc !== -1) {
        beforeParams = currentHash.substr(0, paramsLoc);
        params = currentHash.substring(paramsLoc + 1);
    }

    var pairs = params.split('&');

    if (pairs.length === 1 && pairs[0] === '') {
        pairs = [];
    }

    _.each(pairs, function (pair, index) {
        if (pair.substring(0, name.length + 1) === name + '=') {
            pairs[index] = newPair;
            found = true;
        }
    });

    if (!found) {
        pairs.push(newPair);
    }

    newParams = pairs.join('&');

    module.exports.updateWithoutNavigation(beforeParams + '?' + newParams);
}

/*
 * Internal function for testing, which clears any existing state. There is no supported way to clear existing
 * route handlers. We could reach into the History object and clear the handlers array, but since new routes take
 * preference over old ones, we leave it across each clear() invocation.
 */
function _clear() {
    if (routerStarted) {
        Backbone.history.stop();
    }
    currentScreen = undefined;
    savedScreens = {};
    screenCleanup = [];
    routerStarted = false;
    routeCalls = 0;
    queuedCalls = [];
    delphixRouter = undefined;
    module.exports.currentRoute('');
}

/*
 * Access to internal state for testing purposes.
 */
function _getRouteCalls() {
    return routeCalls;
}

module.exports = {
    // Expose an observable with the current route
    currentRoute: ko.observable(''),
    register: register,
    navigate: navigate,
    internalDeepLinkNavigate: internalDeepLinkNavigate,
    updateWithoutNavigation: updateWithoutNavigation,
    navigateExternal: navigateExternal,
    hide: hide,
    start: start,
    registerCleanupCallback: registerCleanupCallback,
    updateParam: updateParam,
    _clear: _clear,
    _getRouteCalls: _getRouteCalls
};

},{"dxcore/js/browser.js":14,"dxcore/js/modal.js":18,"dxcore/js/util.js":23}],20:[function(require,module,exports){
/*
 * Copyright (c) 2013, 2015 by Delphix. All rights reserved.
 */

/* global $ */

'use strict';

var dxWindow = require('dxcore/js/window.js'),
    dxData = require('dxcore/data/js/index.js'),
    dxConstants = require('dxcore/js/constants.js'),
    dxBrowser = require('dxcore/js/browser.js'),
    dxUtil = require('dxcore/js/util.js'),
    dxLocale = require('dxcore/js/locale.js');

/*
 * This provides various session-related utility routines.
 *    checkSessionIsAuthenticatedOrEnd()
 *       Starts a process where this will attempt to repeatedly get a session from the Delphix engine.  This is useful
 *       in case of transient network problems. Specifically, this will:
 *          1)  Repeatedly ask the Delphix Engine to create a session (or return the current if there is already one)
 *              *) If, after 5 seconds, we don't get a session, display an alert inviting the user to log off, but keep
 *                 trying to get a session while the user thinks about this.
 *          2)  If we do get a session, then try to get the current users, which is another way of saying: is this an
 *              authenticated session?  If we get a current user, then we have an authenticated session, all is good.
 *              However, if we do not get a user, then log out.
 *
 *    endSession()
 *       Ends the current session, if any.
 */
var CHECKING_TIMEOUT = 2500;
var TIMES_TO_CHECK_BEFORE_ALERT = 2;
var alreadyChecking = false;
var alertWindow;
var shuttingDown = false;

function showAlert() {
    alertWindow = dxWindow.connectivityErrorAlert({
        logout: function logout() {
            endSessionLocally();
            alertWindow = undefined;
        },
        endSession: endSession
    });
}

function closeAlert() {
    if (alertWindow) {
        dxWindow._close.apply(alertWindow);
    }
    alertWindow = undefined;
}

/*
 * Repeatedly try to get a session from the server until we succeed or the user chooses to log off.  If we fail to get
 * a session after a couple tries, put up an alert for the user to let them know what is going on.
 */
function keepCheckingForAuthSession(timesUntilAlert, _success, failure) {
    var createSessionPayload = dxData.newClientModel('APISession');
    createSessionPayload.set({
        version: {
            major: dxConstants.VERSION_MAJOR,
            minor: dxConstants.VERSION_MINOR,
            micro: dxConstants.VERSION_MICRO
        }
    });
    if (shuttingDown) {
        return;
    }

    if (timesUntilAlert === 0) {
        showAlert();
    }

    dxData.rootOps.APISession.$$create(createSessionPayload, {
        success: function success() {
            closeAlert();
            dxData.rootOps.User.$current({
                success: _success,
                error: failure
            });
        },
        error: function error() {
            setTimeout(function () {
                keepCheckingForAuthSession(timesUntilAlert - 1, _success, failure);
            }, CHECKING_TIMEOUT);
        }
    });
}

function clearCheckingFlag() {
    alreadyChecking = false;
}

function checkSessionIsAuthenticatedOrEnd() {
    if (alreadyChecking) {
        return;
    }
    alreadyChecking = true;
    keepCheckingForAuthSession(TIMES_TO_CHECK_BEFORE_ALERT, clearCheckingFlag, internalEndSession);
}

function internalEndSession() {
    closeAlert();
    endSessionLocally();
}

function endSession() {
    dxData.rootOps.delphix_common.$logout({
        success: endSessionLocally,
        error: endSessionLocally
    });
}

function endSessionLocally() {
    shuttingDown = true;
    dxBrowser.getWindowLocation().href = dxUtil.getWindowURLOrigin() + '/login/index.html';
}

function resetForTesting() {
    closeAlert();
    shuttingDown = false;
    alreadyChecking = false;
}

function reloadClient(reason) {
    /* eslint-disable no-alert */
    if (window.confirm(dxLocale.gls('reload.' + reason)) === true) {
        dxBrowser.locationReload();
    }
    /* eslint-enable no-alert */
}

/*
 * A GENERAL NOTE ABOUT OUR HANDLING OF AJAX ERRORS
 *
 * At this time our stack has several major systems which make http requests through jQuery's ajax system, including
 * our i18n system, Backbone, and of course the above ajaxCall(). The clients of these are responsible for handling
 * all their own HTTP errors.
 *
 * Our standard global ajax handler gets called any time jQuery reports an error (which jQuery considers to any status
 * other than 200-300 or 304).  At this global level, we only respond to things we think of as 'catastrophic'. This
 * includes status 0 and 403.
 *
 * For status 403, we simply force the UI to log out.
 *
 * Status 0 is when jQuery couldn't get a proper response and status from the server (such as if the entire network
 * has gone down, and the HTTP request couldn't be initiated, etc. (note: Things already in flight have a
 * browser-dependent timeout, which is infinite in the case of Chrome). In this case, this could be a transient problem
 * which we really don't care about at a global level (individual callers should handle this on their own, of course).
 * To distinguish the transient from the permanent, we ask the session system to poll the server periodically and try
 * to get a working session again. If this fails, it will log the user off.
 */
function defaultDelphixErrorHandler(event, jqxhr) {
    switch (jqxhr.status) {
        case 0:
            module.exports.checkSessionIsAuthenticatedOrEnd();
            break;
        case 403:
            module.exports.endSessionLocally();
            break;
    }

    // filtering out HTML tags
    dxUtil.debug($.trim(dxUtil.isNone(jqxhr.responseText) ? '' : jqxhr.responseText.replace(/(<([^>]+)>)/ig, ' ')));
}

module.exports = {
    checkSessionIsAuthenticatedOrEnd: checkSessionIsAuthenticatedOrEnd,
    endSessionLocally: endSessionLocally,
    endSession: endSession,
    _resetForTesting: resetForTesting,
    keepCheckingForAuthSession: keepCheckingForAuthSession,
    closeAlert: closeAlert,
    reloadClient: reloadClient,
    defaultDelphixErrorHandler: defaultDelphixErrorHandler
};

},{"dxcore/data/js/index.js":4,"dxcore/js/browser.js":14,"dxcore/js/constants.js":15,"dxcore/js/locale.js":17,"dxcore/js/util.js":23,"dxcore/js/window.js":24}],21:[function(require,module,exports){
/*
 * Copyright (c) 2013, 2015 by Delphix. All rights reserved.
 */

/* global dx, $, Handlebars, ko */

'use strict';

// _templates is deliberately exposed this way. See below.
require('dxcore/js/delphix.js').namespace('dx.core._templates');

var dxUtil = require('dxcore/js/util.js'),
    dxLocale = require('dxcore/js/locale.js');

/*
 * Returns a jQuery object for the given template, optionally bound to the given knockback viewmodel. The viewmodel is
 * also passed to the Handlebars templating engine, so static string-based templating can also be used. Knockback will
 * not do anything if there are no data-bind attributes to be found, so it can be used in either fashion.
 *
 * Templates are delivered within the HTML structure as:
 *
 *  /<app>/[module/]/template/<path>.hjs
 *
 * These templates are referred to by the path minus the '.hjs' extension. As part of the build process, we precompile
 * these templates and deliver them as single .js files that populate the '_templates' object. We also load
 * templates dynamically via AJAX so that we don't need an explicit compilation step when making local changes.
 */
function template(name, options) {
    var templates = dx.core._templates;
    options = options || {};

    if (!templates[name]) {
        $.ajax({
            url: '/' + name + '.hjs',
            datatype: 'text/javascript',
            success: function success(response, status, jqXHR) {
                templates[name] = Handlebars.compile(jqXHR.responseText);
            },
            error: function error() {
                dxUtil.fail('Unknown template: ' + name);
            },
            async: false
        });
    }

    // filter() strips out any text or comment nodes
    var elems = $(templates[name](options)).filter('*');

    if (options.vm) {
        // Handle the case where there is more than one top level element in the template
        elems.each(function () {
            ko.applyBindings(options.vm, this);
        });
    }

    return elems;
}

/*
 * Register a handlebars helper to get localized text. To use this helper:
 *
 *      <div>{{gls 'some.locale.constant'}}</div>
 *
 * The parameters passed to this function are of the form: key, substitutions ...
 */
Handlebars.registerHelper('gls', function () {
    return dxLocale.gls.apply(undefined, arguments);
});

module.exports = {
    template: template
};

},{"dxcore/js/delphix.js":16,"dxcore/js/locale.js":17,"dxcore/js/util.js":23}],22:[function(require,module,exports){
/*
 * Copyright (c) 2013, 2015 by Delphix. All rights reserved.
 */

/* global _, $ */

'use strict';

var dxUtil = require('dxcore/js/util.js'),
    dxData = require('dxcore/data/js/index.js');

/*
 * This file handles a number of tasks related to users and permissions. Among other things, this provides a cache for
 * getting system-defined default roles.
 */
var roleCache = {};

function reset() {
    roleCache = {};
}

/*
 * Private helper function for getting a role from the roleCache if present, otherwise retrieving it from the server
 * role               a string corresponding to the name of the root operation for the role to retrieve
 * successCallback    the function that is called on success and is passed a Role model
 * returns a JQuery Promise
 */
function getRole(role, successCallback) {
    if (successCallback && !_.isFunction(successCallback)) {
        dxUtil.fail('The success callback must be a function');
    }

    if (!roleCache[role]) {
        roleCache[role] = dxData.rootOps.Role['$' + role]().then(function (OKResult) {
            return OKResult.get('result');
        });
    }

    return roleCache[role].done(successCallback);
}

function getOwner(successCallback) {
    return getRole('ownerRole', successCallback);
}

function getProvisioner(successCallback) {
    return getRole('provisionerRole', successCallback);
}

function getJetStreamUser(successCallback) {
    return getRole('jetStreamUserRole', successCallback);
}

/*
 * successCallback is passed an object consisting of the default roles once they have all been resolved
 * returns a JQuery Promise
 */
function getDefaultRoles(successCallback) {
    var defaultRoles;

    return $.when(getOwner(), getProvisioner(), getJetStreamUser()).then(function (ownerRole, provisionerRole, jetStreamUserRole) {
        // package into an object to pass to callback
        defaultRoles = {
            ownerRole: ownerRole,
            provisionerRole: provisionerRole,
            jetStreamUserRole: jetStreamUserRole
        };

        if (successCallback) {
            successCallback(defaultRoles);
        }

        return defaultRoles;
    });
}

/*
 * Convenience methods for determining the 'type' of user from authorizations
 */

function isDelphixAdmin(userRef, authorizations, defaultRoles) {
    return authorizations.where({
        target: 'DOMAIN',
        user: userRef,
        role: defaultRoles.ownerRole.get('reference')
    }).length > 0;
}

function isDomainProvisioner(userRef, authorizations, defaultRoles) {
    // delphixAdmin and domainProvisioner are mutually exclusive. If both authorizations exist, delphixAdmin wins
    var isAdmin = isDelphixAdmin(userRef, authorizations, defaultRoles);

    return !isAdmin && authorizations.where({
        target: 'DOMAIN',
        user: userRef,
        role: defaultRoles.provisionerRole.get('reference')
    }).length > 0;
}

function isJetStreamUser(userRef, authorizations, defaultRoles) {
    // delphixAdmin and JetStreamUser are mutually exclusive. If both authorizations exist, delphixAdmin wins
    var isAdmin = isDelphixAdmin(userRef, authorizations, defaultRoles);

    return !isAdmin && authorizations.where({
        target: userRef,
        user: userRef,
        role: defaultRoles.jetStreamUserRole.get('reference')
    }).length > 0;
}

function start() {
    // preemptively fetch the default roles to populate the roleCache.
    getDefaultRoles();
}

// Define externally visible functions
module.exports = {
    getOwner: getOwner,
    getProvisioner: getProvisioner,
    getJetStreamUser: getJetStreamUser,
    getDefaultRoles: getDefaultRoles,
    isDelphixAdmin: isDelphixAdmin,
    isDomainProvisioner: isDomainProvisioner,
    isJetStreamUser: isJetStreamUser,
    start: start,
    _reset: reset // Used for testing
};

},{"dxcore/data/js/index.js":4,"dxcore/js/util.js":23}],23:[function(require,module,exports){
/*
 * Copyright (c) 2013, 2015 by Delphix. All rights reserved.
 */

/* global $, _, ko, window */

'use strict';

var dxBrowser = require('dxcore/js/browser.js');

/*
 * Report a failing message. Writes the info to the console and throws an error
 */
function fail() {
    dxBrowser.consoleError.apply(dxBrowser, arguments);
    throw new Error(arguments[0]);
}

/*
 * Report a warning message. Writes the info to the console
 */
function warn() {
    dxBrowser.consoleWarn.apply(dxBrowser, arguments);
}

/*
 * Report a warning message. Writes the info to the console
 */
function info() {
    dxBrowser.consoleInfo.apply(dxBrowser, arguments);
}

/*
 * if debug flag is 'on' this write the specified info to the console.
 */
function debug() {
    if (!module.exports.debugMode) {
        return false;
    }

    dxBrowser.consoleDebug.apply(dxBrowser, arguments);

    return true;
}

/*
 *  Allow timing of script execution.  It is based on console.time and console.timeEnd that are present in Chrome,
 *  Firefox, and IE9 but is missing from IE8.  In order for timing to record result, both module.exports.debugMode and
 *  module.exports.timingMode must be set to true
 *
 *  Usage:
 *  time(<key>); // where <key> is of type String
 *  // code that is being timed
 *  endTime(<key>);
 *
 *  Example:
 *  time('computeFoo');
 *  var foo = computeFoo();
 *  timeEnd('computeFoo');
 *
 *  Console Output:
 *  computeFoo: 23ms
 *
 *  Note: If someone already called time with one key, the second call to time with the same key is ignored.
 */
(function () {
    var timeCounters = {};
    var time, timeEnd;
    module.exports = module.exports || {};
    // Exposed just for testing
    module.exports._timeForOldBrowsers = function _timeForOldBrowsers(name) {
        if (!name || !isNone(timeCounters[name])) {
            return;
        }

        var time = new Date().getTime();
        timeCounters[name] = time;
    };

    // Exposed just for testing
    module.exports._timeEndForOldBrowsers = function _timeEndForOldBrowsers(name) {
        var time = new Date().getTime();

        if (!name || isNone(timeCounters[name])) {
            return;
        }

        var diff = time - timeCounters[name];
        var label = name + ': ' + diff + 'ms';
        module.exports.warn(label);
        delete timeCounters[name];
    };

    if (window.console && window.console.time) {
        time = window.console.time.bind(window.console);
    } else {
        time = module.exports._timeForOldBrowsers;
    }

    if (window.console && window.console.timeEnd) {
        timeEnd = window.console.timeEnd.bind(window.console);
    } else {
        timeEnd = module.exports._timeEndForOldBrowsers;
    }

    module.exports.time = function (name) {
        if (!module.exports.timingMode) {
            return;
        }

        return time(name);
    };

    module.exports.timeEnd = function (name) {
        if (!module.exports.timingMode) {
            return;
        }

        return timeEnd(name);
    };
})();

/*
 * An easily accessible function to turn numbers into px values.
 */
function px(pixels) {
    return pixels + 'px';
}

/*
 * Returns true if parameter is null or undefined.
 */
function isNone(value) {
    return _.isNull(value) || _.isUndefined(value);
}

function getCookie(cookieName) {
    var name = cookieName + '=';
    var ca = document.cookie.split(';');
    for (var i = 0; i < ca.length; i++) {
        var c = $.trim(ca[i]);
        if (c.indexOf(name) === 0) return c.substring(name.length, c.length);
    }
}

/*
 * Sets sitewide cookie.
 */
function setCookie(cname, cvalue, exdays) {
    var d = new Date();
    d.setTime(d.getTime() + exdays * 24 * 60 * 60 * 1000);
    var expires = 'expires=' + d.toGMTString();
    document.cookie = cname + '=' + cvalue + '; ' + expires + '; path=/';
}

function deleteCookie(cname) {
    setCookie(cname, '', -1);
}

/*
 * this function simply returns the origin url of current page.
 */
function getWindowURLOrigin() {
    var loc = dxBrowser.getWindowLocation();
    if (isNone(loc.origin)) {
        return loc.protocol + '//' + loc.host;
    } else {
        return loc.origin;
    }
}

/*
 * Returns a new object with obj's ko unwrapped properties.
 */
function unwrapProperties(obj) {
    var result = {};

    _.each(obj, function (value, key) {
        result[key] = ko.unwrap(value);
    });

    return result;
}

/*
 * Bind the default event trigger to the input field.
 * You can then use it by calling 'inputField.bind('enterKey', acceptFunction);'
 */
function bindDefaultKeyTriggers(inputField) {
    var $inputField = $(inputField);

    if ($inputField.is('input') || $inputField.is('textarea')) {
        $inputField.keyup(function (e) {
            if (e.keyCode === 13) {
                $inputField.trigger('enterKey');
            } else if (e.keyCode === 27) {
                $inputField.trigger('escapeKey');
            }
        });
    } else {
        fail('bindDefaultKeyTriggers must be used with an input');
    }
}

/*
 * Returns a new object that is a deep clone of the input object.
 */
function deepClone(obj) {
    var result = obj;

    if (_.isArray(obj)) {
        result = [];
        _.each(obj, function (value, index) {
            result[index] = deepClone(value);
        });
    } else if (_.isObject(obj)) {
        if (obj instanceof Date) {
            result = new Date(obj.getTime());
        } else {
            result = {};
            _.each(obj, function (value, index) {
                result[index] = deepClone(value);
            });
        }
    }

    return result;
}

// Compare two dates, allowing either one to be undefined or null
function datesEqual(a, b) {
    if (isNone(a) || isNone(b)) return a === b;
    return a.getTime() === b.getTime();
}

/*
 * Performs a deep copy of the values from 'src' into 'dst', overlaying any conflicting properties. Because this is a
 * deep copy, this supports sparse overlays for objects. For example:
 *
 *      overlayProperties({ child: { one: 'foo', two: 'bar' }}, { child: { two: 'baz' }});
 *      => { child: { one: 'foo', two: 'baz' }}
 *
 * Notice that the entirety of the the 'child' property isn't overridden, only those specified in the source. Objects
 * that don't exist in the source will be created. Arrays are more difficult, and are copied over whole if specified in
 * 'src'. Alse note that Date objects are given special treatment and copied over whole.
 */
function overlayProperties(dst, src, prefix) {
    prefix = prefix || '';

    _.each(src, function (propval, propname) {
        var fullname = prefix + propname;
        if (_.isArray(propval)) {
            dst[propname] = _.clone(propval);
        } else if (_.isObject(propval)) {
            if (!_.isObject(dst[propname])) {
                dst[propname] = {};
            }

            if (_.isDate(propval)) {
                // Date isn't a normal object and so must be handled specially and copied over whole
                dst[propname] = new Date(propval.getTime());
            } else {
                overlayProperties(dst[propname], propval, fullname + '.');
            }
        } else {
            dst[propname] = propval;
        }
    });

    return dst;
}

function arrayToMap(array, keyPropertyName) {
    var map = {};
    _.each(array, function (item) {
        var id = item[keyPropertyName];
        if (!_.isUndefined(id)) {
            map[id] = item;
        }
    });

    return map;
}

(function () {
    var counter = 0;

    /*
     * Returns a new unique id on the fly with the prefix.
     */
    module.exports.makeUniqueId = function makeUniqueId(prefix) {
        prefix = prefix || 'uniqid';

        var id = prefix + '' + counter++;

        if ($('#' + id).length === 0) {
            return id;
        } else {
            return module.exports.makeUniqueId(prefix);
        }
    };

    module.exports._resetUniqueIdCounter = function _resetUniqueIdCounter() {
        counter = 0;
    };
})();

/*
 * Checks to see if DOM elemenet in question is in the visible viewport or not.
 * @param {DOM element} el - DOM element to be checked.
 */
function isElementInViewport(el) {
    var rect = el.getBoundingClientRect();

    return rect.top >= 0 && rect.left >= 0 && rect.bottom <= (window.innerHeight || document.documentElement.clientHeight) && rect.right <= (window.innerWidth || document.documentElement.clientWidth);
}

/*
 * Return a human readable date string
 */
function dateToRFC1123String(date) {
    var stringValue = date.toUTCString();

    /*
     * Ugly hack. Some browsers report 'Tue, 01 Jan 2013', while others report 'Tue, 1 Jan 2013'. This removes the 0.
     * Both are legal RTC1123 date strings, but it causes testing problems when the string format isn't predictable.
     */
    if (stringValue.charAt(5) === '0') {
        stringValue = stringValue.substr(0, 5) + stringValue.substr(6);
    }

    return stringValue.replace('UTC', 'GMT');
}

/*
 * Checks if the passed in string has a valid email format or not.
 */
function isValidEmail(email) {
    var regex = /^\S+@\S+$/;
    return regex.test(email);
}

function extendPrototype(subType, prototype, subTypeMembers) {
    _.extend(subType.prototype, prototype, subTypeMembers);
    return subType;
}

/*
 * Retrieves a value that are deep down in the object chain. This also works with array mixed with the object.
 * For example: if host is { a: 5, b: [4, 'me'] } and you ask for 'b.1', it will return 'me'.
 */
function getDeepProperty(host, theChain, defaultValue) {
    if (!host) return defaultValue;
    var chains = theChain.split('.');
    var currentContext = host;
    var aChain;

    for (var i = 0; i < chains.length; i++) {
        aChain = chains[i];
        if (_.has(currentContext, aChain)) {
            currentContext = currentContext[aChain];
        } else {
            return defaultValue;
        }
    }

    return currentContext;
}

// Define the public api
_.extend(module.exports, {
    // debug mode flag
    debugMode: false,
    // timing mode flag
    timingMode: false,
    debug: debug,
    isNone: isNone,
    setCookie: setCookie,
    getCookie: getCookie,
    deleteCookie: deleteCookie,
    isValidEmail: isValidEmail,
    getWindowURLOrigin: getWindowURLOrigin,
    deepClone: deepClone,
    unwrapProperties: unwrapProperties,
    bindDefaultKeyTriggers: bindDefaultKeyTriggers,
    datesEqual: datesEqual,
    overlayProperties: overlayProperties,
    arrayToMap: arrayToMap,
    isElementInViewport: isElementInViewport,
    dateToRFC1123String: dateToRFC1123String,
    extendPrototype: extendPrototype,
    getDeepProperty: getDeepProperty,
    fail: fail,
    warn: warn,
    info: info,
    px: px
});

},{"dxcore/js/browser.js":14}],24:[function(require,module,exports){
/*
 * Copyright (c) 2013, 2015 by Delphix. All rights reserved.
 */

/* global $, _, ko, Backbone */

'use strict';

var namedModal = {};
var modalCounter = 0;
var nonModalWindowQueue = [];

var dxLocale = require('dxcore/js/locale.js'),
    dxUtil = require('dxcore/js/util.js'),
    dxTemplate = require('dxcore/js/template.js'),
    dxUserUtil = require('dxcore/data/delphix/js/util.js');

/*
 * window.* (options)
 *
 * We have five variations of dialog types, most of them are a wrapper over the basic dialog:
 * window.confirm / window.alert / window.errorAlert / window.connectivityErrorAlert and window.dialog
 *
 * For most of the dialog types the 'options' argument takes the following common values:
 *
 *      title           An optional title for the dialog.
 *
 *      closeOnEscape   Specifies whether the dialog should close when it has focus and the user presses the escape
 *                      (ESC) key.
 *
 *      noClose         If true, the dialog would not have a [x] on the top right.
 *
 *      dialogClass     The specified class name(s) will be added to the dialog, for additional theming.
 *
 *      template        if the developer needs to pop-up an entirely different kind of dialog, he/she can
 *                      pass in path to their template and window will render it.
 *
 *      buttons         An optional array of objects that specify a set of buttons to display in the footer. These
 *                      button objects include the following attributes:
 *
 *                          text       Text label for the button.
 *
 *                          click      Callback invoked when the button is clicked.
 *
 *                          'class'    CSS class for button
 *
 *                          icons      CSS class for button icon
 *
 *      cancel          Convenience alias. If set to 'true', prepend a standard cancel button to the button list
 *                      that dismisses the current dialog.If this is a function, then the function is invoked when
 *                      the button is pressed instead of dismissing the dialog.
 *
 *      ok              Convenience alias. If set to 'true', append a standard OK button to the button list that
 *                      dismisses the current dialog. If this is a function, then the function is invoked when the
 *                      button is pressed instead of dismissing the dialog.
 *
 *                      It is important to note that callback for any of the buttons must return 'true' IF they want
 *                      to keep the dialog open after the click event.
 *
 *      open            A callback that is invoked when the dialog element is visible.
 *
 *      create          A callback that is triggered when the dialog is created.
 *
 *      close           A callback that is invoked when the dialog is dismissed.
 *
 *      beforeClose     triggered when a dialog is about to close. If the function returns false, the dialog will
 *                      not close.
 *
 */

/*
 * Pops up a modal confirm dialog with Yes and No buttons.
 * It accepts:
 *      - title
 *      - message - an optional details message
 *      - questionMessage - a question message
 *      - checkboxLabel - if present, a single checkbox is shown with this label. A boolean is passed to the ok
 *                           callback; true if the checkbox is checked and false otherwise. For forms more
 *                           complicated than a single checkbox, customControlsConstructor should be used instead.
 *                           checkboxLabel and customControlsConstructor are mutually exclusive.
 *      - customControlsConstructor - A constructor function that should produce a ko ViewModel. The view
 *                           will be attached to the confirm window. The view model will be passed to any OK or
 *                           cancel callbacks.  This will .dispose() the resulting view model. This option is
 *                           mutually exclusive with the checkboxLabel option.
 *      - ok - callback for Yes/OK.
 *      - okLabel - default is Yes, but you can pass your own.
 *      - cancel - callback for No/Cancel
 *      - cancelLabel - default is No, but you can pass your own.
 */
function confirm(options) {
    options = _.clone(options);
    options.template = options.template || 'dxcore/template/dialog/confirm';
    options.modal = true;
    options.noClose = true;
    options.ok = options.ok || true;
    options.okLabel = options.okLabel || dxLocale.gls('button.yes');
    options.cancel = options.cancel || true;
    options.cancelLabel = options.cancelLabel || dxLocale.gls('button.no');
    options.dialogClass = 'confirmDialog';
    options.title = options.title || dxLocale.gls('generic.label.confirm');

    if (options.checkboxLabel && options.customControlsConstructor) {
        dxUtil.fail('checkboxLabel and customControlsConstructor are mutually exclusive options.');
    }

    var dialogOptions = {
        message: options.message,
        questionMessage: options.questionMessage,
        checkboxLabel: options.checkboxLabel
    };

    // Call the specified callback (if defined) with the viewmodel, then dispose viewModel
    function callBackAndCleanUp(callback, viewModel) {
        var result;

        if (_.isFunction(callback)) {
            result = callback(viewModel);
        }

        viewModel.dispose();
        return result;
    }

    var $dialogElem = dxTemplate.template(options.template, dialogOptions);

    if (options.checkboxLabel && _.isFunction(options.ok)) {
        options.ok = _.wrap(options.ok, function (cb) {
            var checkboxChecked = $dialogElem.find('.sid-confirm-checkbox').is(':checked');
            return cb(checkboxChecked);
        });
    } else if (options.customControlsConstructor) {
        var viewModel = new options.customControlsConstructor();
        var view = viewModel.attachView();
        $dialogElem.find('.sid-optional-controls').append(view);
        options.ok = _.bind(callBackAndCleanUp, undefined, options.ok, viewModel);
        options.cancel = _.bind(callBackAndCleanUp, undefined, options.cancel, viewModel);
    }

    options.content = $dialogElem;

    return _show(options);
}

/*
 * Pops up a modal file upload dialog.
 * The dialog will let the user pick a file to upload.
 * It accepts:
 *      - title - the title of the dialog
 *      - message - an optional details message
 *      - uploadUrl - the url to post the file upload to
 *      - uploadToken - the upload token that's required to upload the file
 *      - close - boolean value or callback function for closing
 *      - cancel - boolean value or callback function for cancel
 *      - success - callback for successful uploading
 *      - start - callback for uploading start
 *      - fail - callback for failed uploading
 * There must one of close/cancel options be specified. Specifying both of them is now allowed.
 */
function upload(options) {
    options = _.clone(options);
    options.template = options.template || 'dxcore/template/dialog/file-upload';
    options.modal = true;
    options.noClose = true;
    options.ok = false;
    options.cancel = options.cancel || false;
    options.close = options.close || false;
    options.dialogClass = 'fileUploadDialog';
    options.title = options.title || dxLocale.gls('window.title.fileUpload');

    if (options.close && options.cancel) {
        dxUtil.fail('Invalid configuration for upload(). Must specify only one of cancel/close options');
    }

    if (!options.close && !options.cancel) {
        dxUtil.fail('Invalid configuration for upload(). Must specify one of cancel/close options');
    }

    var uploadViewModel = {
        progress: ko.observable(0),
        progressText: ko.observable(''),
        errorText: ko.observable(''),
        uploadStarted: ko.observable(false)
    };

    var dialogElem = dxTemplate.template(options.template, {
        message: options.message,
        questionMessage: options.questionMessage,
        vm: uploadViewModel
    });
    var form = dialogElem.find('form');
    var jqXHR;
    form.fileupload({
        url: options.uploadUrl,
        dataType: 'json',
        formData: {
            token: options.uploadToken
        },
        done: function done(e, data) {
            jqXHR = undefined;
            if (data.result.status === 'OK') {
                uploadViewModel.progress(100);
                uploadViewModel.progressText(dxLocale.gls('window.fileUpload.progress.done'));
                if (options.success) {
                    options.success(data.result);
                }
            } else {
                dxUtil.warn('File upload failed.');
                uploadViewModel.progressText(dxLocale.gls('window.fileUpload.progress.error'));
                uploadViewModel.errorText(!_.isUndefined(data.result.error) ? data.result.error.details : '');
                if (options.fail) {
                    options.fail(data.result);
                }
            }
        },
        fail: function fail(e, data) {

            // don't handle event if upload was cancelled (aborted)
            if (data.errorThrown !== 'abort') {
                jqXHR = undefined;
                uploadViewModel.progressText(dxLocale.gls('window.fileUpload.progress.error'));
                if (options.fail) {
                    options.fail(data.result);
                }
            }
        },
        progressall: function progressall(e, data) {
            var progress = parseInt(data.loaded / data.total * 100, 10);
            uploadViewModel.progress(progress);
            uploadViewModel.progressText(dxLocale.gls('window.fileUpload.progress.completed', [progress]));
        },
        add: function add(e, data) {
            dialogElem.find('form').hide();
            jqXHR = data.submit();
        },
        start: function start() {
            uploadViewModel.progress(0);
            uploadViewModel.progressText('');
            uploadViewModel.uploadStarted(true);
            uploadViewModel.errorText('');
            if (options.start) {
                options.start();
            }
        },
        autoUpload: true,
        limitMultiFileUploads: 1,

        // prevents propagating progressall event after failed/aborted event
        recalculateProgress: false
    });

    options.content = dialogElem;

    if (options.close) {
        options.buttons = [{
            text: dxLocale.gls('General.Close'),
            'class': 'btn btn-close'
        }];
        var originalClose = options.close;
        options.close = function () {
            var self = this;
            _.each(dialogElem, ko.cleanNode);
            if (_.isFunction(originalClose)) {
                originalClose.call(self);
            }
        };
    }

    if (options.cancel) {
        var originalCancel = options.cancel;
        options.cancel = function () {
            var self = this;
            _.each(dialogElem, ko.cleanNode);
            if (jqXHR) {
                jqXHR.abort();
                jqXHR = undefined;
            }
            if (_.isFunction(originalCancel)) {
                originalCancel.call(self);
            }
        };
    }

    return _show(options);
}

/*
 * Pops up a modal alert dialog.
 * It accepts:
 *      - title
 *      - message
 *      - ok - optional callback for OK.
 */
function alert(options) {
    options = _.clone(options);
    options.template = options.template || 'dxcore/template/dialog/alert';
    options.modal = true;
    options.ok = options.ok || true;
    options.buttons = null;
    options.cancel = null;
    options.dialogClass = 'alertDialog';
    options.title = options.title || dxLocale.gls('generic.label.alert');

    var dialogElem = dxTemplate.template(options.template, {
        message: options.message
    });

    options.content = dialogElem;
    return _show(options);
}

/*
 * Pops up a modal error alert dialog.
 * It accepts:
 *      - title
 *      - message - the error message.
 *      - errorCode - error code returned by the server.
 *      - suggestedAction - any action server may want to suggest to the user.
 *      - commandOutput - optional command output, if any.
 *      - diagnoses - optional list of diagnosing information, if any.
 *      - ok - optional callback for OK.
 */
function errorAlert(options) {
    options = _.clone(options);
    options.template = options.template || 'dxcore/template/dialog/error';
    options.modal = true;
    options.ok = options.ok || true;
    options.buttons = null;
    options.cancel = null;
    options.dialogClass = 'errorDialog';
    options.title = options.title || dxLocale.gls('generic.label.error');

    options.errorCode = options.errorCode || '';
    options.message = options.message || '';
    options.suggestedAction = options.suggestedAction || '';
    options.commandOutput = options.commandOutput ? options.commandOutput.split('\n') : undefined;
    options.diagnoses = options.diagnoses || [];

    var dialogElem = dxTemplate.template(options.template, {
        message: options.message,
        errorCode: options.errorCode,
        suggestedAction: options.suggestedAction,
        commandOutput: options.commandOutput,
        diagnoses: options.diagnoses
    });

    options.content = dialogElem;
    var dialog = _show(options);

    var $scrollTarget = dialog.find('.scroll-target');

    /*
     * In some versions of IE setting 'height' to 'auto' can result in rounding errors which can result in
     * incorrectly showing a scrollbar. Detect this by checking if the scrollHeight is one pixel (or less) greater
     * than the height.
     */
    if ($scrollTarget.length !== 0 && $scrollTarget[0].scrollHeight - $scrollTarget.height() > 1) {

        // We support two different scrollbar plugins. Do simple feature detection to decide which to use.
        if (_.isFunction($.fn.jScrollPane)) {
            // Setup scrollbar and scroll to top. Note: jScrollPane needs the element to already be on screen
            $scrollTarget.jScrollPane({ showArrows: true }).data('jsp').scrollToY(0);
        } else if (_.isFunction($.fn.perfectScrollbar)) {
            $scrollTarget.perfectScrollbar({
                suppressScrollX: true,
                minScrollbarLength: 20
            });
        }
    }

    return dialog;
}

/*
 * Pops up a modal connectivity error dialog that displays a single 'logout' button that, when clicked, will log out
 * the user.
 *
 * It accepts:
 *      - title
 *      - message
 *      - logout - optional callback to perform when clicking logout. If provided, you must do the logging out!
 */
function connectivityErrorAlert(options) {
    if (!_.isNull(module.exports.manager.get('connectivity-error-alert-dialog'))) {
        return module.exports.manager.get('connectivity-error-alert-dialog');
    }

    options = _.clone(options) || {};
    options.id = 'connectivity-error-alert-dialog';
    options.template = options.template || 'dxcore/templadisplayErrorAlertte/dialog/connectivity-error';
    options.modal = true;
    options.noClose = true;
    options.ok = false;
    options.buttons = [{
        text: dxLocale.gls('generic.ajax.failure.logoutButton'),
        icons: {
            primary: 'icon-button icon-accept'
        },
        click: function click() {
            if (options.logout) {
                options.logout();
            } else {
                options.endSession();
            }
        },
        'class': 'btn btn-primary'
    }];
    options.cancel = null;
    options.dialogClass = 'connectivityErrorDialog';
    options.closeOnEscape = false;
    options.title = options.title || dxLocale.gls('generic.label.connectivityError');
    options.content = dxLocale.gls('generic.ajax.server.unreachable');
    return _show(options);
}

/*
 * Pops up a generic dialog. This is totally customizable and a user can utilize all the underlying jquery-ui
 * options to build the dialog. No checking/constraining is done on this form of dialog.
 * Developer can pass jQuery elements in 'content' construct directly. This will essentially let the user pass in
 * a compiled template which may have a ViewModel with observables attached to it.
 */
function dialog(options) {
    options = _.clone(options);
    options.template = options.template || 'dxcore/template/dialog/generic';
    options.title = options.title || 'Delphix';

    if (!options.content) {
        var dialogElem = dxTemplate.template(options.template, {
            message: options.message
        });

        options.content = dialogElem;
    }

    return _show(options);
}

/*
 * Internal function to build and show a pop-up.
 */
function _show(options) {
    var config = options || {};
    var buttons = [];

    config.id = options.id || dxUtil.makeUniqueId('dialog');
    config.resizable = false;
    config.closeText = '';
    config.dialogClass = 'dialog ' + (options.dialogClass || '');
    config.close = options.close || _close;
    config.create = options.create || null;
    config.open = options.open || null;
    config.height = options.height || 'auto';
    config.width = options.width || 'auto';
    config.maxHeight = options.maxHeight || 'auto';
    config.maxWidth = options.maxWidth || 'auto';
    config.title = options.title || '';
    config.beforeClose = options.beforeClose || null;
    config.noClose = config.noClose || false;

    if (config.noClose) {
        config.dialogClass += ' no-close ';
    }

    var onClickFunction = function onClickFunction(callback) {
        var keepDialogOpen = false;
        if (_.isFunction(callback)) {
            keepDialogOpen = callback();
        }

        if (keepDialogOpen === true) {
            return;
        } else {
            _close.apply(this);
        }
    };

    _.each(config.buttons, function (buttonDef) {
        buttons.push({
            text: buttonDef.text,
            click: function click() {
                onClickFunction.call(this, buttonDef.click);
            },
            icons: buttonDef.icons || {},
            'class': buttonDef['class'] || ''
        });
    });

    // Default cancel button
    if (options.cancel) {
        buttons.unshift({
            text: options.cancelLabel || dxLocale.gls('button.cancel'),
            click: function click() {
                onClickFunction.call(this, options.cancel);
            },
            icons: {
                primary: 'icon-button icon-button-separator icon-cancel'
            },
            'class': 'btn sid-cancel-button'
        });
    }

    // Default OK button
    if (options.ok) {
        buttons.push({
            text: options.okLabel || dxLocale.gls('button.ok'),
            icons: {
                primary: 'icon-button icon-button-separator icon-accept'
            },
            click: function click() {
                onClickFunction.call(this, options.ok);
            },
            'class': 'btn btn-primary sid-accept-button'
        });
    }

    config.buttons = buttons;

    var dialogContainer = $('<div>');
    dialogContainer.attr('id', config.id);
    dialogContainer.append(options.content);

    module.exports.manager.add(dialogContainer);

    /*
     * If we have modal dialogs on display, we cannot pop-up regular dialogs.
     * So just queue and pop them up when all modal dialogs are cleared out.
     */
    if (modalCounter > 0 && !config.modal) {
        nonModalWindowQueue.push({ dialogContainer: dialogContainer, config: config });
        return null;
    }

    if (config.modal) {
        modalCounter++;
    }

    return dialogContainer.dialog(config);
}

// takes dialog (jquery node) as input and adds into its queue based on its ID.
function add(dialog) {
    module.exports.manager = module.exports.manager || {};
    var dialogs = module.exports.manager._dialogs = module.exports.manager._dialogs || {};
    var id = dialog.attr('id');
    if (!_.has(dialogs, id)) {
        dialogs[id] = dialog;
    }
}

// returns back the dialog (jquery node) given its ID.
function get(dialogId) {
    module.exports.manager = module.exports.manager || {};
    var dialogs = module.exports.manager._dialogs = module.exports.manager._dialogs || {};
    if (_.has(dialogs, dialogId)) {
        return dialogs[dialogId];
    } else {
        return null;
    }
}

// in case we need to close all the windows on screen
function closeAll() {
    module.exports.manager = module.exports.manager || {};
    var dialogs = module.exports.manager._dialogs = module.exports.manager._dialogs || {};
    _.each(dialogs, function (dialog, id) {
        dialog.dialog('destroy').remove();
        delete dialogs[id];
        modalCounter--;
    });
}

// Hides the current dialog. This has no effect if the dialog is not currently shown.
function _close() {
    module.exports.manager = module.exports.manager || {};
    var dialogs = module.exports.manager._dialogs = module.exports.manager._dialogs || {};

    if ($(this).dialog('option', 'modal') && modalCounter > 0) {
        modalCounter--;
    }

    $(this).dialog('close');

    try {
        if (!$(this).dialog('isOpen')) {
            $(this).remove();
        }
    } catch (e) {
        /*
         * In some instances, for reasons beyond my grasp, the jQuery-UI stack calls back this method twice, even
         * when dialog has already been closed and un-initialized. So, calling dialog('isOpen') in such cases would
         * throw an error back. This try catch is to handle such scenarios.
         */
        $(this).remove();
    }

    delete dialogs[this.id || this.attr('id')];

    if (modalCounter === 0 && nonModalWindowQueue.length) {
        _.each(nonModalWindowQueue, function (dialogState) {
            dialogState.dialogContainer.dialog(dialogState.config);
        });
        nonModalWindowQueue = [];
    }
}

/*
 * Dialogs can be registered by name, allowing consumers to display content without needing to call directly
 * into the implementation. This is just a wrapper around callback registration.
 */
function registerNamed(path, callback) {
    if (!_.isFunction(callback)) {
        throw new Error('attempt to register named dialog "' + path + '" with invalid callback');
    }

    namedModal[path] = callback;
}

function showNamed(path) {
    namedModal[path]();
}

/*
 * When given an ErrorResult, this will display an error alert to the user
 */
function displayErrorAlert(errorResult) {
    if (!(errorResult instanceof Backbone.Model) || errorResult.get('type') !== 'ErrorResult') {
        dxUtil.fail('displayErrorAlert expects an ErrorResult model as an argument.');
    }

    // Get the APIError
    var apiError = errorResult.get('error');

    module.exports.errorAlert({
        message: dxUserUtil.processErrorResultDetails(apiError),
        errorCode: apiError.get('id') || '',
        suggestedAction: apiError.get('action') || '',
        commandOutput: apiError.get('commandOutput') || ''
    });
}

module.exports = {
    confirm: confirm,
    upload: upload,
    alert: alert,
    errorAlert: errorAlert,
    connectivityErrorAlert: connectivityErrorAlert,
    dialog: dialog,
    showNamed: showNamed,
    _show: _show,
    _close: _close,
    registerNamed: registerNamed,
    displayErrorAlert: displayErrorAlert,
    // window manager keeps track of all the windows that pop-up
    manager: {
        add: add,
        get: get,
        closeAll: closeAll,
        _dialogs: {}
    }
};

},{"dxcore/data/delphix/js/util.js":3,"dxcore/js/locale.js":17,"dxcore/js/template.js":21,"dxcore/js/util.js":23}],25:[function(require,module,exports){
/*
 * Copyright (c) 2014, 2015 by Delphix. All rights reserved.
 */

/* global _, ko, Backbone, jQuery */

'use strict';

var dxSystem = require('dxcore/ko/js/system.js'),
    dxUtil = require('dxcore/js/util.js'),
    dxData = require('dxcore/data/js/index.js'),
    dxComplexObservableAttrs = require('dxcore/ko/js/ComplexObservableAttributes.js'),
    dxObservableAttr = require('dxcore/ko/js/ObservableAttribute.js'),
    dxProxy = require('dxcore/data/delphix/js/proxy.js'),
    dxOperation = require('dxcore/ko/js/operation.js');

/*
 * ServerObject(reference, type, options)
 * ====================================================
 * Creates an object that contains a set of observables that correspond to properties of a schema based object. When
 * called, this will try to retrieve an object from the server with the specified reference and the specified root type,
 * and then set up an observable for each of its properties, or a sub-observable server object for any embedded objects.
 *
 * ServerObject constructs a Javascript object with the following properties
 * (note: the dx prefix is to avoid a name conflict with the schema properties).
 *    schema-props                : Discussed more below
 * it will also have these functions.
 *    dxDispose                   : Clean up all dependencies held by the server object.
 *    dxSetDebug                  : Turn on or off a debugging flag. all data updates will be reported.
 *
 * The options parameter may contain any or none of these values. If none are present, the server object will contain
 * all of the properties defined in the server object.
 *    dataMapping                 : A mapping of names to property paths. Each name will be added to the server object
 *                                  as a new observable, and the proxy system will be used to generate the
 *                                 value
 *    onlyUseMapping              : If truthy, the server object will only contain values defined in the data mapping.
 *                                  Otherwise, it will contain all the properties from server object plus those from
 *                                  the mapping.
 *    writer                      : A routine passed to all individual attributes. Provides a way to manage any writes
 *                                  to these properties. See ObservableAttribute for more details.
 *    suppressDefaultErrorHandler : If truthy, the default error handled is not triggered on errors.
 *    disposalContext             : The disposal context this should be added to. By default it will be added to the
 *                                  page context.
 *
 * ClientObject(type, options)
 * ====================================================
 * Creates an object that contains a set of observables that correspond to properties in the schema based object.
 * This is a 'client object', which means it is not tied to the server in any way, and can be directly read and written
 * to.
 *
 * makeServerObjectFromModel(model, options)
 * =========================================
 * Given a model as provided by data routines, return an object which contains an observable for each property
 * in the model.  The object returned has the same properties as discussed above. The options is also the same as
 * documented above.
 */

// Add a single property from the data mapping onto the server object.
function updateProxyAttribute(theObject, attrName, proxy, disposalContext) {
    var value = proxy.get(attrName);
    var existingObservable = theObject[attrName];

    if (!_.isUndefined(existingObservable)) {
        var contents = existingObservable.peek();
        if (contents && contents.dxDispose) {
            contents.dxDispose();
        }
    }

    /*
     * If the value is a backbone model, and what we have set up currently isn't a backbone model, then wrap the model
     * as an observable object.  This can happen in a couple ways: First, when the proxy is first set up, the proxy
     * attribute may point to nothing yet, and so may be undefined. Thus, the first time this is called, we'd set up
     * an ordinary observable. The second situation would be where the proxy points to different types each time it is
     * updated (unlikely, but possible)
     */
    if (value instanceof Backbone.Model) {
        if (_.isUndefined(existingObservable)) {
            theObject[attrName] = ko.observable(makeObjectFromModel(value, { disposalContext: disposalContext }));
        } else {
            existingObservable(makeObjectFromModel(value, { disposalContext: disposalContext }));
        }
        return;
    }

    /*
     * In contrast, if the current observable doesn't exist, or is a model, we'll want to set up an ordinary
     * observable.
     */
    if (_.isUndefined(existingObservable)) {
        theObject[attrName] = ko.observable(value);
        return;
    }

    // Nah, it's just an ordinary observable, and we're updating it in an ordinary way.
    existingObservable(value);
}

// for each data mapped property, set up an observable.
function addProxyAttributes(proxy, proxyDef, theObject, disposalContext) {
    _.each(proxyDef, function (value, name) {
        updateProxyAttribute(theObject, name, proxy, disposalContext);
        proxy.on('change:' + name, function () {
            updateProxyAttribute(theObject, name, proxy, disposalContext);
            if (theObject._dxDebug) {
                dxUtil.debug('MAPPED ATTR CHANGE: ' + name + '=' + proxy.get(name) + ' IN ' + JSON.stringify(theObject._dxModel.attributes));
            }
        }, theObject._dxSelfIdentifier);
    }, this);
}

/*
 * Invoke an operation.  Convert aguments to backbone equivalents, and call the corresponding operation on the model
 */
function callOperation(model, operationName, otherArgs) {
    return dxOperation._callOperation(model, isSchemaObject, makeObjectFromModel, operationName, otherArgs);
}

// add an object- or standard-operation to the object
function addOperation(model, funcName, theObject) {
    theObject[funcName] = function () {
        return callOperation(model, funcName, arguments);
    };
}

/*
 * For each property defined in the schema of the model, set up an observable for that property. We use the non-public
 * schema definition, since we can't infer types accurately just by looking at what is in model.attributes
 */
function addSchemaProperties(model, oso, options) {
    if (options.onlyUseMapping) {
        return;
    }

    _.each(model._dxSchema.properties, function (propDef, propName) {
        // Don't replace any existing props (data mapped properties (they take precedence) or ones already added)
        if (!_.isUndefined(oso[propName])) {
            return;
        }

        /*
         * Here we deal with a strange case that requires some explanation, both because it is not obvious, and because
         * this is not a 100% solution.  Some schema types are declared as arrays of types (most prominently, look at
         * the result property of OKResult). In these cases, we don't necessarily know what kind of observable to
         * create.  We go through a couple steps to try to cope with this (see inline comments below).
         *
         * One potential flaw in this process is that this assumes a model attribute can not change type during the
         * course of the model's existence (and even then, we don't care about changes from, say, string to null. But
         * just between objects, arrays and simple types).  Theoreticaly this is possible, but in practice it doesn't
         * happen.  If you are reading this comment and cursing, it means that assumption is no longer valid and you'll
         * need to create an observable which can 'morph', which is doable but just more work.
         *
         * One actual flaw in this is that if you try to create a client object that is an OKResult or another which
         * has an array or object as one of the possible types in that array of types, this won't ever create the
         * observable for that.
         */
        var type = propDef.type;
        if (_.isArray(propDef.type)) {
            type = 'simpleValue';

            // Check if a non-simple type exists in the array of types
            var hasNonSimpleType = _.find(propDef.type, function (aType) {
                return aType === 'array' || aType === 'object';
            });

            /*
             * It does. If the model has undefined for this property, then we just don't create an observable.
             * Eventually this will be called when the model is ready, in which case we'll have an actual value. In that
             * case, use that type to guide the construction of the observable, below.
             */
            if (hasNonSimpleType) {
                var value = model.get(propName);
                if (_.isUndefined(value) && !model._dxIsReady) {
                    return;
                }
                if (_.isArray(value)) {
                    type = 'array';
                } else if (_.isObject(value)) {
                    type = 'object';
                }
            }
        }

        switch (type) {
            case 'array':
                oso[propName] = dxComplexObservableAttrs.makeObservableArrayAttribute(model, propName, makeObjectFromModel, options);
                break;
            case 'object':
                // Don't use model for creating Json object, because we consider instances of this type as black box
                if (_.has(propDef, '$ref') && propDef.$ref !== 'Json') {
                    // Only pass on disposalContext, other params like dataMapping don't apply to children
                    var newOptions = _.pick(options, 'disposalContext');

                    oso[propName] = ko.observable(makeObjectFromModel(model.get(propName), newOptions));
                } else {
                    oso[propName] = dxComplexObservableAttrs.makeObservableObjectAttribute(model, propName, makeObjectFromModel, options);
                }
                break;
            default:
                oso[propName] = dxObservableAttr.makeObservableAttribute(model, propName, options);
                break;
        }
    });

    if (!_.has(options, 'addObjectOpHandlers') || options.addObjectOpHandlers) {
        for (var propName in model) {
            // can't use _.each() as it won't get the values from the prototype
            if (propName.charAt(0) === '$' && _.isFunction(model[propName]) && _.isUndefined(oso[propName])) {
                addOperation(model, propName, oso);
            }
        }
    }
}

function setDebug(value, identifier) {
    this._dxDebug = value;
    this._dxDebugIdentifier = identifier;
}

function instanceOf(typeName) {
    return this._dxModel.instanceOf(typeName);
}

// Clean up the object, by disconnecting as much as possible so gc can happen more easily.
function dispose() {
    if (this._dxDebug) {
        dxUtil.debug('DISPOSING: ' + JSON.stringify(this._dxModel ? this._dxModel.attributes : 'already disposed'));
    }

    if (this._dxProxy) {
        this._dxProxy.setModel(undefined);
        this._dxProxy.off(undefined, undefined, this._dxSelfIdentifier);
    }

    if (this._dxModel) {
        this._dxModel.off(undefined, undefined, this._dxSelfIdentifier);
    }

    _.each(this, function (item) {
        if (item) {
            if (!_.isUndefined(item.dispose)) {
                item.dispose();
            } else if (isSchemaObject(ko.unwrap(item))) {
                ko.unwrap(item).dxDispose();
            }
        }
    });

    this._dxIsDisposed = true;
}

function isDisposed() {
    var self = this;
    return !!self._dxIsDisposed;
}

/*
 * Given a model, construct an object from it. Options are documented above.
 */
function createClientOrServerObject(theObject, backboneModel, options) {
    var deferred = new jQuery.Deferred();
    theObject._dxSelfIdentifier = {
        clientServerObjects: true // help identify what kind of object has a hold on the model
    };
    options = options || {};

    // check args
    if (!_.isUndefined(options) && !_.isObject(options)) {
        dxUtil.fail('Options, if provided, must be an object.');
    }
    if (!_.isUndefined(options.dataMapping) && !_.isObject(options.dataMapping)) {
        dxUtil.fail('Data mapping must be an object.');
    }
    if (!options.dataMapping && options.onlyUseMapping) {
        dxUtil.fail('Must provide a dataMapping when onlyUseMapping is specified.');
    }

    theObject.dxDataReady = deferred.promise();
    theObject.dxReadyState = ko.observable();
    theObject._dxModel = backboneModel;
    // build the proxy if needed
    if (options.dataMapping) {
        var proxy = dxProxy.newProxy(options.dataMapping);
        proxy.setModel(backboneModel);
        addProxyAttributes(proxy, options.dataMapping, theObject, options.disposalContext);
        theObject._dxProxy = proxy;
    }

    // Add the model's current properties
    addSchemaProperties(backboneModel, theObject, options);

    // report once the model is ready to go (and update properties in case there was a type upgrade)
    backboneModel.once('ready', function () {
        addSchemaProperties(backboneModel, theObject, options);
        backboneModel.off(undefined, undefined, theObject._dxSelfIdentifier);
        deferred.resolve(theObject);
        theObject.dxReadyState(true);
    }, theObject._dxSelfIdentifier);

    backboneModel.once('error', function (model, errorResult) {
        backboneModel.off(undefined, undefined, theObject._dxSelfIdentifier);
        deferred.reject(dxOperation._prepResult(errorResult, makeObjectFromModel));
        theObject.dxReadyState(false);
    }, theObject._dxSelfIdentifier);

    backboneModel.once('delete', function () {
        theObject.dxDispose();
    }, theObject._dxSelfIdentifier);

    // Define the new public api
    _.extend(theObject, {
        dxDispose: dispose,
        dxSetDebug: setDebug,
        dxInstanceOf: instanceOf,
        dxIsDisposed: isDisposed
    });

    dxSystem.addToDisposalContext(theObject, options.disposalContext);

    return theObject;
}

// get a server model, and return a server object around it.
function ServerObject(reference, type, options) {
    if (!(this instanceof ServerObject)) {
        dxUtil.fail('Must call with new.');
    }
    var model = arguments[3]; // if we passed a 4th argument, this is an internal call where we already have the model
    if (_.isUndefined(model)) {
        var suppressErrorHandler = options && options.suppressDefaultErrorHandler;
        model = dxData.getServerModel(reference, type, suppressErrorHandler);
    }
    return createClientOrServerObject(this, model, options);
}

function ServerSingletonObject(type, options) {
    if (!(this instanceof ServerSingletonObject)) {
        dxUtil.fail('Must call with new.');
    }
    var model = arguments[2]; // if we passed a 3rd argument, this is an internal call where we already have the model
    if (_.isUndefined(model)) {
        var suppressErrorHandler = options && options.suppressDefaultErrorHandler;
        model = dxData.getServerSingleton(type, { suppressDefaultErrorHandler: suppressErrorHandler });
    }
    return createClientOrServerObject(this, model, options);
}

// create a client model, and return a client object around it.
function ClientObject(type, options) {
    if (!(this instanceof ClientObject)) {
        dxUtil.fail('Must call with new.');
    }
    var model = arguments[2]; // if we passed a 3rd argument, this is an internal call where we already have the model
    if (_.isUndefined(model)) {
        model = dxData.newClientModel(type);
    }
    return createClientOrServerObject(this, model, options);
}

// given a model, return the appropriate server or client object
function makeObjectFromModel(model, options) {
    if (_.isUndefined(model)) {
        dxUtil.fail('Must provide a model.');
    }

    /*
     * Call the public constructor functions, so folks can still do instanceof, but then pass the model we already
     * have as a secret parameter to the constructor functions so they won't try to retrieve a new one.
     */
    if (model.isServerModel()) {
        if (model._dxSchema.singleton) {
            return new ServerSingletonObject(undefined, options, model);
        } else {
            return new ServerObject(undefined, undefined, options, model);
        }
    } else {
        return new ClientObject(undefined, options, model);
    }
}

/*
 * Identifies if an object is a Client or Server Object
 *
 * Parameters:
 *   value: anything.
 * Return:
 *   true if the object is an instance of ServerObject, ClientObject or ServerSingletonObject.
 */
function isSchemaObject(value) {

    return value instanceof ServerObject || value instanceof ClientObject || value instanceof ServerSingletonObject;
}

/*
 * Make sure that the handler is called at exactly one time when the specified serverObject is "ready".
 */
function checkAndSubscribeToServerObject(serverObject, handler, disposalContext) {
    if (!isSchemaObject(serverObject)) {
        dxUtil.fail('Must call checkAndSubscribeToServerObject() with a schema object.');
    }
    if (!handler) {
        dxUtil.fail('Must call checkAndSubscribeToServerObject() with a handler.');
    }

    function processResult() {
        handler(serverObject.dxReadyState.peek(), serverObject);
    }

    if (!_.isUndefined(serverObject.dxReadyState.peek())) {
        processResult();
        // return a dummy subscription so caller does not need to protect itself against undefined
        return ko.observable().subscribe(function dummyFunction() {});
    }

    return dxSystem.subscribeOnce(serverObject.dxReadyState, processResult, undefined, undefined, disposalContext);
}

// Define the public api
module.exports = {
    makeObjectFromModel: makeObjectFromModel,
    ServerObject: ServerObject,
    ServerSingletonObject: ServerSingletonObject,
    ClientObject: ClientObject,
    isSchemaObject: isSchemaObject,
    checkAndSubscribeToServerObject: checkAndSubscribeToServerObject
};

},{"dxcore/data/delphix/js/proxy.js":2,"dxcore/data/js/index.js":4,"dxcore/js/util.js":23,"dxcore/ko/js/ComplexObservableAttributes.js":26,"dxcore/ko/js/ObservableAttribute.js":27,"dxcore/ko/js/operation.js":28,"dxcore/ko/js/system.js":29}],26:[function(require,module,exports){
/*
 * Copyright (c) 2014, 2015 by Delphix. All rights reserved.
 */

/* global _, ko, Backbone */

'use strict';

var dxUtil = require('dxcore/js/util.js'),
    dxObservableAttr = require('dxcore/ko/js/ObservableAttribute.js');

/*
 * makeObservableArrayAttribute
 * ============================
 * An ObservableArrayAttribute is a special observableArray that wraps up access to an array attribute of a Backbone
 * Model. Do not create one of these yourself, but instead using higher-level things like ObservableServerObjects.
 *
 * Create an observableArrayAttribute like this:
 *   makeObservableArrayAttribute(myModel, 'name', makeObjectFromModel)
 * This returns an observableArray that can be used entirely like an ordinary observableArray
 * Any time the underlying model is updated, the observable will notice and notify its subscribers.
 *
 * ObservableArrayAttributes have the same writing semantics as an observableAttribute. See that for more details.
 * The thumbnail version is:
 *  - Client models are updated directly
 *  - Server models when a writer is not provided, $$update() is called on the model with the proposed new value for the
 *    attribute (the local data is not updated until the server responds).
 *  - Server models, when a writer is provided, call the writer.  In this case, the array passed to the writer may
 *    contain observableObjects, not the backbone equivalents. The writer can return WRITE_UNHANDLED in order to defer
 *    to the standard update behavior
 *
 * In addition to standard observable functions, ObservableAttribute also has these functions:
 *    dispose()  : disposes the observable. This includes removing listener(s) on the model.
 *    setDebug(value, id) : If the value is truthy, this will print debug messages at key places.  If an id is
 *                 provided, debug messages from this instance will include that id.
 *
 * The options object can accept these values:
 *    writer     : a function with the signature writer(observable, propertyName, value). It is up to the writer to
 *                 handle an update to the specified property.  If it chooses not to, it can return
 *                 WRITE_UNHANDLED, in which case the standard write behavior will be invoked.
 *
 * makeObservableObjectAttribute
 * ============================
 * An ObservableObjectAttribute is much like an observableArrayAttribute, except that it manages an object attribute of
 * a Backbone model. Reading and writing behavior, as well as dispose() and setDebug() behavior is the same as the
 * observableArrayAttribute.
 */
/*
 * Converts a value (which may contain backbone models in the elements of an array or values of an object's properties)
 * into forms usable by these observables. In particular, backbone models are converted into observableObjects.
 */
function prepareValue(sourceValue, asNonObservable, disposalContext, makeObjectFromModel) {
    if (_.isArray(sourceValue)) {
        var newArray = _.map(sourceValue, function (value) {
            return prepareValue(value, false, disposalContext, makeObjectFromModel);
        });
        return !asNonObservable ? ko.observableArray(newArray) : newArray;
    } else if (_.isObject(sourceValue)) {
        var result;
        if (sourceValue instanceof Backbone.Model) {
            result = makeObjectFromModel(sourceValue, { disposalContext: disposalContext });
        } else {
            var newObject = {};
            _.each(sourceValue, function (value, key) {
                newObject[key] = prepareValue(value, false, disposalContext, makeObjectFromModel);
            });
            result = newObject;
        }

        return !asNonObservable ? ko.observable(result) : result;
    } else {
        return !asNonObservable ? ko.observable(sourceValue) : sourceValue;
    }
}

/*
 * dispose any members of either array or object values.
 */
function disposeCurrentValue(observedValue) {
    if (_.isObject(observedValue)) {
        _.each(observedValue, function (value) {
            value = ko.unwrap(value);
            if (dxUtil.isNone(value)) {
                return;
            }

            if (value.dxDispose) {
                value.dxDispose();
            }
            if (value.dispose) {
                value.dispose();
            }
        });
    }
}

/*
 * The object attribute in a backbone model has changed.  Rebuild the object we are presenting and send notifications.
 */
function objectAttributeChanged() {
    var self = this;

    if (self._dxDebug) {
        showDebugMessage(self, 'Model changed');
    }
    self.valueWillMutate();

    var disposalContext = self._dxOptions && self._dxOptions.disposalContext;

    var bbObject = self._dxModel.get(self._dxAttrName);
    disposeCurrentValue(self._dxObservedValue);

    self._dxObservedValue = _.isUndefined(bbObject) ? {} : prepareValue(bbObject, true, disposalContext, self._makeObjectFromModel);

    self.valueHasMutated();
}

/*
 * The attribute on the backbone model changed.  reset the array this observable is managing, and rebuild it from the
 * backbone array
 */
function arrayAttributeChanged() {
    var self = this;

    if (self._dxDebug) {
        showDebugMessage(self, 'Model changed');
    }
    self.valueWillMutate();

    var disposalContext = self._dxOptions && self._dxOptions.disposalContext;

    var bbArray = self._dxModel.get(self._dxAttrName);
    disposeCurrentValue(self._dxObservedValue);
    self._dxObservedValue = _.isUndefined(bbArray) ? undefined : prepareValue(bbArray, true, disposalContext, self._makeObjectFromModel);

    self.valueHasMutated();
}

// Convert an array, which may contain observable objects, so we need to extract the backbone versions and json-ize them
function jsonify(sourceValue) {
    sourceValue = ko.unwrap(sourceValue);
    var result = sourceValue;

    if (_.isArray(sourceValue)) {
        result = _.map(sourceValue, function (element) {
            element = ko.unwrap(element);
            if (element._dxModel) {
                return element._dxModel.toJSON();
            }
            return jsonify(element);
        });
    } else if (sourceValue && _.isObject(sourceValue)) {
        result = {};
        _.each(sourceValue, function (value, key) {
            result[key] = value && value._dxModel ? value._dxModel.toJSON() : jsonify(value);
        });
    }

    return result;
}

// Write the specified array value.
function writeArrayValue(observable, value, options) {
    if (observable._dxDisposed) {
        dxUtil.debug(observable, 'Writing to a disposed observable');
        return;
    }

    if (!_.isArray(value)) {
        dxUtil.fail('Must write an array to an observable array attribute.');
    }

    // Do a simple check (don't worry about non-simple values) to try to catch cases where the array doesn't change.
    if (observable._dxObservedValue && observable._dxObservedValue.length === value.length) {
        var equal = true;
        for (var index = 0; index < value.length; index++) {
            if (!observable.equalityComparer(observable._dxObservedValue[index], value[index])) {
                equal = false;
                break;
            }
        }
        if (equal) {
            return observable;
        }
    }

    /*
     * convert the input array into a json form.  This is needed since if there are backbone models in there, we can't
     * directly set them on the model
     */
    var jsonArray = jsonify(value);

    if (_.isUndefined(observable._dxModel.isServerModel) || !observable._dxModel.isServerModel()) {
        showDebugMessage(observable, 'About to write to client model');
        observable._dxModel.set(observable._dxAttrName, jsonArray);
    } else {
        if (options.writer) {
            showDebugMessage(observable, 'About to write to writer for server model');
            var writerResult = options.writer(value, observable._dxAttrName, observable);

            if (writerResult !== dxObservableAttr.WRITE_UNHANDLED) {
                return observable;
            }
        }

        if (observable._dxModel.$$update) {
            showDebugMessage(observable, 'About to send $$update() for server model');
            var payload = {};
            payload[observable._dxAttrName] = jsonArray;
            observable._dxModel.$$update(payload);
        } else {
            dxUtil.fail('This kind of server object has no update standard operation.');
        }
    }

    return observable;
}

// Write the specified object value.
function writeObjectValue(observable, value, options) {
    if (observable._dxDisposed) {
        dxUtil.debug(observable, 'Writing to a disposed observable');
        return;
    }
    if (!_.isObject(value) && !dxUtil.isNone(value)) {
        dxUtil.fail('Observable value must be an object.');
    }

    value = jsonify(value);

    if (_.isUndefined(observable._dxModel.isServerModel) || !observable._dxModel.isServerModel()) {
        showDebugMessage(observable, 'About to write to client model');
        observable._dxModel.set(observable._dxAttrName, value);
    } else {
        if (options.writer) {
            showDebugMessage(observable, 'About to write to write to writer for a server model');
            var writerResult = options.writer(value, observable._dxAttrName, observable);
            if (writerResult !== dxObservableAttr.WRITE_UNHANDLED) {
                return observable;
            }
        }

        if (observable._dxModel.$$update) {
            showDebugMessage(observable, 'About to send $$update() for server model');
            var payload = {};
            payload[observable._dxAttrName] = value;
            observable._dxModel.$$update(payload);
        } else {
            dxUtil.fail('This kind of server model has no update standard operation.');
        }
    }

    return observable;
}

/*
 * Call an array-modification function on the observable array attribute. If the function exists on Array.prototype,
 * use that. For knockout specific functions such as destroy(), we make a dummy observable with a copy of the current
 * array and call the function on the dummy observable. We then get the resulting value and start our own write process
 * with it.
 * Note that while creating a dummy observable has overhead, it is the simplest solution
 * for making sure there are no side affects of the operation on our own observable.
 */
function arrayFunction() {
    var koOaFuncName = arguments[0];
    var newArray;
    var shallowCopy = this._dxObservedValue.slice(0);

    if (_.isFunction(Array.prototype[koOaFuncName])) {
        shallowCopy[koOaFuncName].apply(shallowCopy, _.rest(arguments, 1));
        newArray = shallowCopy;
    } else {
        var tempObservable = ko.observableArray(shallowCopy);
        tempObservable[koOaFuncName].apply(tempObservable, _.rest(arguments, 1));
        newArray = tempObservable();
    }

    writeArrayValue(this, newArray, this._dxOptions);
}

// return the current value of the observable, while setting up knockout dependencies
function readValue(observable, defaultValue) {
    ko.dependencyDetection.registerDependency(observable);

    return observable._dxObservedValue || defaultValue;
}

// Return the value of the underlying model's property without setting up any knockout dependencies.
function peek() {
    return this._dxObservedValue;
}

// Notify subscribers that the observable's value is about to change
function valueWillMutate() {
    this.notifySubscribers(this._dxObservedValue, 'beforeChange');
}

// Notify subscribers that the observable's value has changed
function valueHasMutated() {
    this.notifySubscribers(this._dxObservedValue);
}

// Clean up this observable. Release everything we can.
function dispose() {
    this._dxModel.off(undefined, undefined, this._dxSelfIdentifier);
    disposeCurrentValue(this._dxObservedValue);
    this._dxDisposed = true;
}

function showDebugMessage(observable, message) {
    var attribute = observable._dxModel.get(observable._dxAttrName);
    var id = observable._dxDebugId || 'Observable';
    dxUtil.debug(id + ' with model ' + observable._dxModel.id + ': ' + message + ': ' + observable._dxAttrName + (_.isArray(attribute) ? ' with ' + (attribute ? attribute.length : 0) + ' elements' : ''), attribute);
}

function setDebug(value, identifier) {
    this._dxDebug = value;
    this._dxDebugId = identifier;
}

function assertParamsGood(model, attrName, makeObjectFromModel, options) {
    if (!(model instanceof Backbone.Model)) {
        dxUtil.fail('A backbone model must be provided as the first argument.');
    }

    if (!_.isString(attrName)) {
        dxUtil.fail('A property name must be provided as the second argument.');
    }

    if (_.isUndefined(makeObjectFromModel) || !_.isObject(makeObjectFromModel)) {
        dxUtil.fail('makeObjectFromModel must be provided as the third argument.');
    }

    if (!_.isUndefined(options) && !_.isObject(options)) {
        dxUtil.fail('Options, if provided, must be an object.');
    }
}

/*
 * Attach a bunch of data and functions to the observable function.  Note that these are attached to the function,
 * rather than its prototype, because one can't give a function a special prototype.
 */
function setBasicObservableProperties(observable, model, attrName, makeObjectFromModel, options) {
    ko.subscribable.call(observable);
    ko.utils.extend(observable, ko.observable.fn);
    _.extend(observable, {
        _dxModel: model,
        _dxAttrName: attrName,
        _makeObjectFromModel: makeObjectFromModel,
        _dxOptions: options,
        _dxSelfIdentifier: {}, // arbitray object used to track of our listeners on the model
        valueHasMutated: valueHasMutated,
        valueWillMutate: valueWillMutate,
        peek: peek,
        setDebug: setDebug,
        dispose: dispose
    });
}

/*
 * Create an observable array attribute from the specified model
 */
function makeObservableArrayAttribute(model, attrName, makeObjectFromModel, options) {
    function observableArray() {
        if (arguments.length > 0) {
            return writeArrayValue(observableArray, arguments[0], options || {});
        } else {
            return readValue(observableArray, []);
        }
    }

    assertParamsGood(model, attrName, makeObjectFromModel, options);
    setBasicObservableProperties(observableArray, model, attrName, makeObjectFromModel, options);

    /*
     * Add all the standard observableArray functions, so this looks and feels like an observableArray.
     * Note that because ko.observableArray.fn has the Function prototype in it's prototype chain (as of knockout
     * 3.1.0), we cannot use _.each directly to get it's properties (because functions have a length property).
     */
    _.each(_.keys(ko.observableArray.fn), function (koOaFuncName) {
        var koOaFunc = ko.observableArray.fn[koOaFuncName];

        if (_.contains(['slice', 'reverse', 'sort'], koOaFuncName)) {
            observableArray[koOaFuncName] = koOaFunc;
            return;
        }
        observableArray[koOaFuncName] = function () {
            Array.prototype.unshift.call(arguments, koOaFuncName);
            arrayFunction.apply(observableArray, arguments);
        };
    });

    model.on('change:' + attrName, _.bind(arrayAttributeChanged, observableArray), observableArray._dxSelfIdentifier);
    arrayAttributeChanged.call(observableArray);

    return observableArray.extend({ trackArrayChanges: true });
}

/*
 * Create an observable object attribute from the specified model
 */
function makeObservableObjectAttribute(model, attrName, makeObjectFromModel, options) {
    function ooAttribute() {
        if (arguments.length > 0) {
            return writeObjectValue(ooAttribute, arguments[0], options || {});
        } else {
            return readValue(ooAttribute);
        }
    }

    assertParamsGood(model, attrName, makeObjectFromModel, options);
    setBasicObservableProperties(ooAttribute, model, attrName, makeObjectFromModel, options);

    model.on('change:' + attrName, _.bind(objectAttributeChanged, ooAttribute), ooAttribute._dxSelfIdentifier);
    objectAttributeChanged.call(ooAttribute);

    return ooAttribute;
}

/*
 * Add these this to the public API
 */
module.exports = {
    makeObservableArrayAttribute: makeObservableArrayAttribute,
    makeObservableObjectAttribute: makeObservableObjectAttribute
};

},{"dxcore/js/util.js":23,"dxcore/ko/js/ObservableAttribute.js":27}],27:[function(require,module,exports){
/*
 * Copyright (c) 2014, 2015 by Delphix. All rights reserved.
 */

/* global _, ko, Backbone */

'use strict';

var dxUtil = require('dxcore/js/util.js');

/*
 * An observableAttribute is a special observable that 'wraps up' access to an attribute on a Backbone model, with
 * support for some of the semantics of our Delphix Schema-Based models.  You should rarely, if ever, be creating one
 * of these yourself.  Instead they are created and managed by higher level things, like ObservableServerObject's.
 *
 * Create an observableAttribute like this:
 *   makeObservableAttribute(myModel, 'name')
 * This returns an observable that can be used entirely like an ordinary observable.
 * Any time the underlying model is updated, the observable will notice and notify its subscribers.
 *
 * ObservableAttributes have several special behaviors when it comes to writing to them.
 *
 * If the model is a client model (or an ordinary Backbone model) updating the observable will update the model
 * directly.
 *
 * If the model is a server model, then one of two things will happen. The default behavior is that when the
 * observable is set (e.g. observable('new value')), the observable will send an update standard operation to the
 * server. Once the server has processed the update and delivered a notification, the underlying server model will be
 * updated and the observable will be updated.
 *
 * In the case you want a different behavior for writing, you can pass a 'writer' in an options object to the creation
 * routine.  This will then be invoked when there is a change. You can then handle this change in your writer routine,
 * or return WRITE_UNHANDLED, in which case the above update behavior will be carried out.
 *
 * In addition to standard observable functions, ObservableAttribute also has these functions:
 *    dispose()  : disposes the observable. This includes removing listener(s) on the model.
 *    setDebug(value, id) : If the value is truthy, this will print debug messages at key places.  If an id is
 *                 provided, debug messages from this instance will include that id.
 *
 * The options object can accept these values:
 *    writer     : a function with the signature writer(observable, propertyName, value). It is up to the writer to
 *                 handle an update to the specified property.  If it chooses not to, it can return
 *                 WRITE_UNHANDLED, in which case the standard write behavior will be invoked.
 */
var WRITE_UNHANDLED = 'WRITE UNHANDLED';

// Return the value of the underlying model's property without setting up any knockout dependencies.
function peek() {
    return this._dxModel.get(this._dxPropName);
}

// Clean up this observable. Release everything we can.
function dispose() {
    this._dxModel.off(undefined, undefined, this._dxSelfIdentifier);
    this._dxDisposed = true;
}

function showDebugMessage(observable, message) {
    if (observable._dxDebug) {
        dxUtil.debug((observable._dxDebugIdentifier || 'Observable') + ' with model ' + observable._dxModel.id + ': ' + message + ': ' + observable._dxPropName + '=' + observable._dxModel.get(observable._dxPropName));
    }
}

/*
 * Respond to a change in the model's property. Note that this briefly invokes 'previous mode' since we need to be sure
 * to return the 'previous' value (from Backbone's standpoint) during the 'beforeChange' notification.
 */
function modelChanged() {
    showDebugMessage(this, 'Model changed');
    this._dxInPreviousMode = true;
    this.valueWillMutate();
    this._dxInPreviousMode = false;
    this.valueHasMutated();
}

// Notify subscribers that the observable's value is about to change
function valueWillMutate() {
    this.notifySubscribers(this._dxModel.previous(this._dxPropName), 'beforeChange');
}

// Notify subscribers that the observable's value has changed
function valueHasMutated() {
    this.notifySubscribers(this._dxModel.get(this._dxPropName));
}

/*
 * Update the observable only if the value has changed.  If the model is a client model, just update the model.
 * If it is a server model, then if we've been given a writer, give that a chance to handle the write. If that doesn't
 * exist or doesn't want to handle the write, issue a $$update() standard operation to the server.
 */
function writeValue(observable, value, options) {
    if (observable._dxDisposed) {
        dxUtil.debug(observable, 'Writing to a disposed observable');
        return;
    }
    if (observable.equalityComparer && observable.equalityComparer(observable._dxModel.get(observable._dxPropName), value)) {
        return;
    }

    if (_.isUndefined(observable._dxModel.isServerModel) || !observable._dxModel.isServerModel()) {
        showDebugMessage(observable, 'About to write to client model');
        observable._dxModel.set(observable._dxPropName, value);
    } else {
        if (options.writer) {
            showDebugMessage(observable, 'About to write to writer for server model');
            var writerResult = options.writer(value, observable._dxPropName, observable);
            if (writerResult !== WRITE_UNHANDLED) {
                return;
            }
        }

        if (observable._dxModel.$$update) {
            showDebugMessage(observable, 'About to send $$update() for server model');
            var payload = {};
            payload[observable._dxPropName] = value;
            observable._dxModel.$$update(payload);
        } else {
            dxUtil.fail('This kind of server object has no update standard operation.');
        }
    }
}

/*
 * Return the 'current' value of the observable.  if we're in the middle of updating the observable, the current value
 * is the 'previous' backbone value
 */
function readValue(observable) {
    ko.dependencyDetection.registerDependency(observable);

    if (observable._dxInPreviousMode) {
        return observable._dxModel.previous(observable._dxPropName);
    } else {
        return observable._dxModel.get(observable._dxPropName);
    }
}

function setDebug(value, identifier) {
    this._dxDebug = value;
    this._dxDebugIdentifier = identifier;
}

/*
 * Construct the observable attribute.
 *
 * Note that this observable function has as little code in it as possible so as to minimize the size of the object
 * in memory.
 */
function makeObservableAttribute(model, propName, options) {
    function observableAttribute() {
        if (arguments.length > 0) {
            writeValue(observableAttribute, arguments[0], options || {});
        } else {
            return readValue(observableAttribute);
        }
    }

    if (!(model instanceof Backbone.Model)) {
        dxUtil.fail('A backbone model must be provided as the first argument.');
    }
    if (!_.isString(propName)) {
        dxUtil.fail('A property name must be provided as the second argument.');
    }
    if (!_.isUndefined(options) && !_.isObject(options)) {
        dxUtil.fail('Options, if provided, must be an object.');
    }

    /*
     * Because the observable is a function, we can't actually put all these function in its prototype, so we must
     * add them to each new instance.
     */
    ko.subscribable.call(observableAttribute);
    ko.utils.extend(observableAttribute, ko.observable.fn);
    _.extend(observableAttribute, {
        _dxModel: model,
        _dxPropName: propName,
        _dxSelfIdentifier: {}, // arbitray object used to keep track of our listeners on the model
        _dxInPreviousMode: false,
        peek: peek,
        setDebug: setDebug,
        valueWillMutate: valueWillMutate,
        valueHasMutated: valueHasMutated,
        dispose: dispose
    });

    model.on('change:' + propName, _.bind(modelChanged, observableAttribute), observableAttribute._dxSelfIdentifier);

    return observableAttribute;
}

/*
 * Add these things to the public API
 */
module.exports = {
    WRITE_UNHANDLED: WRITE_UNHANDLED,
    makeObservableAttribute: makeObservableAttribute
};

},{"dxcore/js/util.js":23}],28:[function(require,module,exports){
/*
 * Copyright (c) 2015 by Delphix. All rights reserved.
 */

/* global _, Backbone, ko*/

'use strict';

var dxUtil = require('dxcore/js/util.js'),
    dxData = require('dxcore/data/js/index.js');

/*
 * This contains some private utility routines used by the ko system, as well as an initialization routine.
 * This should be run after setting up the data system.
 */
/*
 * Convert the result of a call to an operation on the backbone model into a ko-compatible Client or Server object.
 */
function prepResult(result, makeObjectFromModel, disposalContext) {
    return result instanceof Backbone.Model ? makeObjectFromModel(result, { disposalContext: disposalContext }) : result;
}

/*
 * Identify if an object is an options object
 * Parameter:
 *   value: the value to test
 * Return:
 *   truthy if the value is an object, it has success, error, and/or disposalContext properties and no other
 */
function looksLikeOptionsObject(value) {
    var validOptions = ['success', 'error', 'disposalContext'];

    return _.isObject(value) && _.isEmpty(_.omit(value, validOptions)) && !_.isEmpty(_.pick(value, validOptions));
}

/*
 * Parameters:
 *   otherArgs: An array of arguments to a ko root, standard, or object operation
 * Return:
 *   An object containing the success and error callbacks, as well as optional disposal context, that may have been
 *   specified in the parameters
 */
function extractOptions(isSchemaObject, otherArgs) {
    var optionsObject = _.find(otherArgs, function (arg) {
        /*
         * Return truthy when we find an argument that is an object that isn't a client or server object, and that
         * has a success, error, and/or disposalContext property but no others.
         */
        return looksLikeOptionsObject(arg) && !isSchemaObject(arg);
    });

    return optionsObject || {};
}

/*
 * Parameters:
 *   otherArgs: An array-like object of arguments to a ko root, standard, or object operation
 * Return:
 *   a modified version of these arguments including:
 *     (a) any ko objects converted to their data equivalents
 *     (b) successError replaced with an empty object (we handle the callbacks in the promise)
 *     (c) unwrap any ko.observables in other arguments
 */
function convertToDxDataArgs(otherArgs) {
    var newArgs = [];
    _.each(otherArgs, function (arg) {
        if (!_.isUndefined(arg._dxModel)) {
            newArgs.push(arg._dxModel);
            /*
             * only process the element if it only has success, error, and/or disposalContext properties. We have to be
             * careful here. If the underlying operation is one that takes parameters, then it can take betwee 0 and 2
             * arguments, any of which are objects. To avoid modifying the parameters rather than the options object,
             * we consider the object to be the options only if it contains nothing other than success, error, or
             * disposalContext properties.
             */
        } else if (looksLikeOptionsObject(arg)) {
                var patchedCallbacks = {};
                newArgs.push(patchedCallbacks);
                if (arg.error) {
                    patchedCallbacks.suppressDefaultErrorHandler = true; // we handle this in the call's promise
                }
            } else if (_.isObject(arg)) {
                    var unwrapped = {};
                    _.each(arg, function (value, key) {
                        unwrapped[key] = ko.unwrap(value);
                    });
                    newArgs.push(unwrapped);
                } else {
                    dxUtil.fail('Must pass a parameters object.');
                }
    });

    return newArgs;
}

/*
 * Call an object operation, converting arguments to data format, and convert return results to the ko form.
 */
function callKoObjectOperation(koObject, isSchemaObject, makeObjectFromModel, funcName) {
    if (!isSchemaObject(koObject)) {
        dxUtil.fail('koObject must be a Server or Client Object.');
    }
    var funcArgs = _.rest(arguments, 4);
    return callOperation(koObject._dxModel, isSchemaObject, makeObjectFromModel, '$' + funcName, funcArgs);
}

function callOperation(dxCoreDataObject, isSchemaObject, makeObjectFromModel, funcName, funcArgs) {
    var newArgs = convertToDxDataArgs(funcArgs);
    var options = extractOptions(isSchemaObject, funcArgs);

    return dxCoreDataObject[funcName].apply(dxCoreDataObject, newArgs).then(function (doneResult) {
        var result = prepResult(doneResult, makeObjectFromModel, options.disposalContext);
        if (options.success) {
            options.success(result);
        }
        return result;
    }, function (failedResult) {
        var result = prepResult(failedResult, makeObjectFromModel, options.disposalContext);
        if (options.error) {
            options.error(result);
        }
        return result;
    });
}

/*
 * Call a root operation, converting arguments to data format, and convert return results to the ko form.
 */
function callRootOperation(typeName, isSchemaObject, makeObjectFromModel, opName, otherArgs) {
    var typeObject = dxData.rootOps[typeName];
    return callOperation(typeObject, isSchemaObject, makeObjectFromModel, opName, otherArgs);
}

module.exports = {
    _callOperation: callOperation,
    callKoObjectOperation: callKoObjectOperation,
    callRootOperation: callRootOperation,
    _prepResult: prepResult
};

},{"dxcore/data/js/index.js":4,"dxcore/js/util.js":23}],29:[function(require,module,exports){
/*
 * Copyright (c) 2014, 2015 by Delphix. All rights reserved.
 */

/* global dx, _, ko */

'use strict';

var dxUtil = require('dxcore/js/util.js'),
    dxScreen = require('dxcore/js/screen.js'),
    dxData = require('dxcore/data/js/index.js');

/*
 * Given an array of objects, call dispose() on any elements with a dispose() function, and dxDispose() on any objects
 * with a dxDispose() function.
 */
function disposeItems(elements) {
    if (!_.isArray(elements)) {
        dxUtil.fail('Must pass an array of elements to be disposed.');
    }

    var serverObjects = [];
    var otherDispose = [];

    // First dispose all computed's and subscriptions
    _.each(elements, function (element) {
        if (element.dxDispose) {
            serverObjects.push(element);
        } else if (element.setDebug) {
            otherDispose.push(element);
        } else if (element.dispose) {
            element.dispose();
        }
    });

    _.invoke(otherDispose, 'dispose');

    // Then dispose the stuff that might trigger those computed's and subscriptions
    _.each(serverObjects, function (element) {
        element.dxDispose();
    });
}

/*
 * Initialize the ko system. At the moment, this just involves setting up the root operations.
 */
function initialize(callRootOperation, isSchemaObject, makeObjectFromModel) {
    dxScreen.registerCleanupCallback(cleanupPageContext);

    module.exports.rootOps = {};
    module.exports.enums = dxData.enums;

    _.each(dxData.rootOps, function (opsObject, typeName) {
        module.exports.rootOps[typeName] = module.exports.rootOps[typeName] || {};
        _.each(opsObject, function (opFunction, opName) {
            if (!_.isFunction(opFunction) || opName.charAt(0) !== '$') {
                return;
            }

            module.exports.rootOps[typeName][opName] = function () {
                return callRootOperation(typeName, isSchemaObject, makeObjectFromModel, opName, arguments);
            };
        });
    });
}

/*
 * This is an object which can gather ko and ko objects and then dispose them at some appropriate time.  At the time of
 * this writing, there is one disposal context, which is the page context, but should someone need a more specific
 * context (e.g. they are creating many objects in a short time and want to free them up sooner than page transition)
 * this can be used for that purpose.
 *
 * A disposal context is given one public function which is:
 *  dxKoDispose()
 * which will dispose all the objects in the context.
 */
function DisposalContext() {
    var self = this;
    if (!(self instanceof DisposalContext)) {
        dxUtil.fail('Call constructor function DisposalContext with new.');
    }
    self._dxKoDisposalList = [];
    self.dxKoDispose = function () {
        disposeItems(self._dxKoDisposalList);
        self._dxKoDisposalList.length = 0;
    };
    return self;
}

/*
 * Creates a ko.computed, and adds it to a disposal context.
 *
 * By default, this will be put in the page disposal context, however, if a different disposal context is added in the
 * options, it will be added to that, instead.
 */
function makeComputed(evaluator, target, options) {
    options = options || {};
    var computed = ko.computed(evaluator, target, options);
    addToDisposalContext(computed, options.disposalContext);
    return computed;
}

/*
 * Create a ko subscription on the specified observable.  Adds the subscription to a disposal context and will return it
 * Parameters
 *    observable: The observable to subscribe to
 *    handler: As defined by knockout
 *    handlerTarget: as defined by knockout
 *    event: as defined by knockout
 *    disposalContext: (optional) the context to put the subscription in. By default will go into the page context.
 */
function subscribeToObservable(observable, handler, handlerTarget, event, disposalContext) {
    var subscription = observable.subscribe(handler, handlerTarget, event);
    addToDisposalContext(subscription, disposalContext);
    return subscription;
}

/*
 * Create a ko subscription on the specified observable that will only receive a single update, and then automatically
 * be disposed.  Adds the subscription to a disposal context before returning it.
 *
 * Parameters
 *    observable: The observable to subscribe to
 *    handler: As defined by knockout
 *    handlerTarget: as defined by knockout
 *    event: as defined by knockout
 *    disposalContext: (optional) the context to put the subscription in. By default will go into the page context.
 */
function subscribeToObservableForOneUpdate(observable, handler, handlerTarget, event, disposalContext) {
    var subscription = observable.subscribe(function () {
        handler.apply(handlerTarget, arguments);
        subscription.dispose();
    }, handlerTarget, event);
    addToDisposalContext(subscription, disposalContext);

    return subscription;
}

var DEFAULT_EVENT = 'change';
/*
 * Given an ordinary observable and a handler, if the value is null/undefined subscribe, otherwise trigger handler
 * immediately and subscribe.
 */
function checkAndSubscribe(observable, handler, handlerTarget, event, disposalContext) {
    if (!ko.isObservable(observable)) {
        dxUtil.fail('Must call checkAndSubscribe() with an observable.');
    }
    if (!handler) {
        dxUtil.fail('Must call checkAndSubscribe() with a handler.');
    }

    event = event || DEFAULT_EVENT;
    if (!dxUtil.isNone(observable()) && event === DEFAULT_EVENT) {
        try {
            ko.dependencyDetection.begin();
            handler.call(handlerTarget, observable.peek(), DEFAULT_EVENT);
        } finally {
            ko.dependencyDetection.end();
        }
    }

    return subscribeToObservable(observable, handler, handlerTarget, event, disposalContext);
}

/*
 * Given a Stated Observable (such as returned by promiseToObservable()) make sure the handler is called once when the
 * state transitions to non-undefined, or is already non-undefined. Always returns a subscription, though it may be
 * a dummy one if the handler has already been called
 *
 * A stated obserable has these characteristics:
 * - It is itself an observable
 * - It has a property, which is an observable, called state
 * - The main observable is initially undefined until some criteria has been met, in which case it will have some value
 *   (possibly undefined), and state will be either true or false based on whether the criteria was successful or
 *   a failure.
 * - The stated observable broadcasts two values to subscribed functions: state and value
 */
function checkAndSubscribeToStatedObservable(observable, handler, handlerTarget, event, disposalContext) {
    if (!ko.isObservable(observable)) {
        dxUtil.fail('Must call checkAndSubscribeToStatedObservable() with an observable.');
    }
    if (!handler) {
        dxUtil.fail('Must call checkAndSubscribeToStatedObservable() with a handler.');
    }
    if (!observable.state || !ko.isObservable(observable.state)) {
        dxUtil.fail('Must pass a stated observable to checkAndSubscribeToStatedObservable().');
    }
    event = event || DEFAULT_EVENT;

    function handleStatedObservableChange() {
        handler.apply(handlerTarget, [observable.state.peek(), observable.peek()]);
    }

    if (!_.isUndefined(observable.state.peek()) && event === DEFAULT_EVENT) {
        handleStatedObservableChange();
        // return a dummy subscription so caller does not need to protect itself against undefined
        return ko.observable().subscribe(function dummyFunction() {});
    }

    return subscribeToObservableForOneUpdate(observable.state, handleStatedObservableChange, undefined, event, disposalContext);
}

/*
 * Returns a computed representing the combined state of the passed in "state" observables.
 * Accepts an array.
 * The value of the returned computed is:
 *  - true if all input observables are truthy (all have resolved)
 *  - false if any are false (at least one has failed)
 *  - undefined otherwise (some are pending and none have failed)
 */
function makeMergedStateObservable(stateObservables) {
    var options = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];

    return module.exports.computed(function () {
        var stateValues = _.map(stateObservables, function (obs) {
            return obs();
        });

        if (_.all(stateValues)) {
            return true;
        } else if (_.some(stateValues, function (val) {
            return val === false;
        })) {
            return false;
        }
    }, { disposalContext: options.disposalContext });
}

/*
 * Adds the specified object to a disposal context. If none is specified, use the page context.
 */
function addToDisposalContext(item, context) {
    context = context || module.exports._pageContext;
    if (!context._dxKoDisposalList) {
        dxUtil.fail('Invalid context object.');
    }

    context._dxKoDisposalList.push(item);
}

/*
 * Dispose all objects in all contexts managed by the ko system (which is to say, the page context, 'eternal
 * context', etc. but not individual ones managed by app developers).
 */
function disposeAll() {
    module.exports._pageContext.dxKoDispose();
    module.exports.eternalContext.dxKoDispose();

    if (dx.core.pageContext._angularPageContext) {
        dx.core.pageContext._angularPageContext.dxKoDispose();
    }
}

/*
 * Routine called by the screen system on page transition to clean up the page context on page transition.
 */
function cleanupPageContext() {
    module.exports._pageContext.dxKoDispose();
    dxScreen.registerCleanupCallback(cleanupPageContext);
}

/*
 * Function to be used for testing to make sure the page context has nothing in its disposal list.
 */
function assertPageContextEmpty() {
    if (module.exports._pageContext._dxKoDisposalList.length !== 0) {
        dxUtil.fail('Page context is not empty!');
    }
}

module.exports = {
    rootOps: {},
    initialize: initialize,
    disposeAllForTesting: disposeAll,
    assertPageContextEmpty: assertPageContextEmpty,
    DisposalContext: DisposalContext,
    addToDisposalContext: addToDisposalContext,
    disposeItems: disposeItems,
    eternalContext: new DisposalContext(),
    _pageContext: new DisposalContext(),
    computed: makeComputed,
    subscribe: subscribeToObservable,
    subscribeOnce: subscribeToObservableForOneUpdate,
    checkAndSubscribe: checkAndSubscribe,
    checkAndSubscribeToStatedObservable: checkAndSubscribeToStatedObservable,
    makeMergedStateObservable: makeMergedStateObservable
};

},{"dxcore/data/js/index.js":4,"dxcore/js/screen.js":19,"dxcore/js/util.js":23}],30:[function(require,module,exports){
/*
 * Copyright (c) 2014, 2015 by Delphix. All rights reserved.
 */

'use strict';

var dxData = require('dxcore/data/js/index.js'),
    dxSystem = require('dxcore/ko/js/system.js'),
    dxOperation = require('dxcore/ko/js/operation.js'),
    dxCSObjects = require('dxcore/ko/js/ClientServerObjects.js');

/*
 * Initialize/start up any dxCore systems
 */

module.exports = function initialize() {
    dxData.initialize();
    dxSystem.initialize(dxOperation.callRootOperation, dxCSObjects.isSchemaObject, dxCSObjects.makeObjectFromModel);
};

},{"dxcore/data/js/index.js":4,"dxcore/ko/js/ClientServerObjects.js":25,"dxcore/ko/js/operation.js":28,"dxcore/ko/js/system.js":29}],31:[function(require,module,exports){
/*
 * Copyright (c) 2014, 2015 by Delphix. All rights reserved.
 */

/* global $, _, ko */

'use strict';

var dxCSObjects = require('dxcore/ko/js/ClientServerObjects.js'),
    dxLocale = require('dxcore/js/locale.js'),
    dxUtil = require('dxcore/js/util.js'),
    dxData = require('dxcore/data/js/index.js'),
    dxScreen = require('dxcore/js/screen.js'),
    dxUserUtil = require('dxcore/js/userUtil.js'),
    dxSystem = require('dxcore/ko/js/system.js'),
    dxSession = require('dxcore/js/session.js'),
    dxConstants = require('dxcore/js/constants.js');

/*
 * This file contains the logic to initiate session/login calls to verify credentials of a user
 * and log him into the system.
 *
 * On page load we check for presence of a session and if a valid session is found, we retrieve the current user
 * and redirect to either the main app or the system app.
 */
module.exports.loginViewModel = function (browserDeprecated, browserUnsupported) {
    // --------------------------------------
    // private properties`core

    // --------------------------------------
    var self = this,
        currentUser;

    var loginRequestModel = new dxCSObjects.ClientObject('LoginRequest'),

    // constants
    DOMAIN = 'DOMAIN',
        SYSTEM = 'SYSTEM',
        SAP = 'sap';

    // --------------------------------------
    // view model properties
    // --------------------------------------
    self.username = loginRequestModel.username;
    self.password = loginRequestModel.password;

    // The app the user is attempting to log into
    self.target = loginRequestModel.target;
    self.isDomainLogin = ko.computed(function () {
        return self.target() === DOMAIN;
    });
    self.isSystemLogin = ko.computed(function () {
        return self.target() === SYSTEM;
    });

    self.showAdminLogo = ko.computed(function () {
        return self.isDomainLogin() && !self.expressProduct();
    });

    self.showFreeAdminLogo = ko.computed(function () {
        return self.isDomainLogin() && self.expressProduct();
    });

    self.showSetupLogo = ko.computed(function () {
        return self.isSystemLogin() && !self.expressProduct();
    });

    self.showFreeSetupLogo = ko.computed(function () {
        return self.isSystemLogin() && self.expressProduct();
    });

    self.submitInProgress = ko.observable(false);
    self.cancelInProgress = ko.observable(false);
    self.fatalErrorMessage = ko.observable(undefined);
    self.suggestedActionMessage = ko.observable(undefined);
    self.banner = ko.observableArray();

    self.hasFatalError = ko.computed(function () {
        return !_.isUndefined(self.fatalErrorMessage());
    });

    // Helps set input focus for login form
    self.awaitingLogin = ko.observable(false);
    self.awaitingPassword = ko.observable(false);

    self.isSAPEdition = ko.observable(false);
    self.expressProduct = ko.observable(false);
    self.bodyCss = ko.observable('main-body default');

    // First time login
    self.passwordUpdateRequested = ko.observable(false);
    self.confirmPassword = ko.observable('');
    self.newPassword = ko.observable('');
    // Only a delphix admin needs to enter their email - all other users provided an email address when created
    self.isEmailRequired = ko.observable(false);
    self.email = ko.observable('');
    var systemLocale = ko.observable('');

    self.message = ko.observable('');
    self.invalidEmailMessage = ko.observable('');
    self.passwordChangeMessage = ko.observable(dxLocale.gls('password.change.message'));

    // Initialize with defaults
    self.username('');
    self.password('');
    self.target(DOMAIN);

    // Use parameters to set up a warning to the user about the browser version
    self.browserMessage = ko.observable('');
    if (browserUnsupported) {
        self.browserMessage(dxLocale.gls('browser.unsupported'));
    } else if (browserDeprecated) {
        self.browserMessage(dxLocale.gls('browser.deprecated'));
    }

    // --------------------------------------
    // view model functions
    // --------------------------------------

    /*
     * login gets invoked when user submits the login form.
     */
    self.login = function () {
        // If user clicks 'continue' while cancel is in progress, don't do login
        if (self.cancelInProgress()) {
            return;
        }

        /*
         * This is a hack to allow username/password values to be reflected in observables in case they have been
         * filled in automatically by browsers.
         */
        $('#username,#password').trigger('change');

        self.message('');
        self.fatalErrorMessage(undefined);
        self.suggestedActionMessage(undefined);
        if (self.username() !== '') {
            self.submitInProgress(true);
            // It's possible we've lost our API session since initially obtaining it
            createSession(postLogin);
        } else {
            self.message(dxLocale.gls('username.required.prompt'));
        }
    };

    /*
     * postLogin initiates the login. On success, the current user information is fetched.
     */
    function postLogin() {
        dxSystem.rootOps.delphix_common.$login(loginRequestModel, {
            success: function success() {
                getCurrentUser();
            },
            error: function error(errorResult) {
                self.submitInProgress(false);
                showError(errorResult._dxModel); // showError expects a backbone model
            }
        });
    }

    /*
     * showError accepts an errorResult object, fishes out error message and updates the view model message binding.
     */
    function showError(errorResult) {
        self.message(errorResult.get('error').get('details'));
    }

    /*
     * showError accepts an errorResult object, fishes out error message and updates the view model message binding.
     */
    self.showConnectivityError = function () {
        self.message(dxLocale.gls('generic.login.failure'));
    };

    /*
     * getCurrentUser invokes current object operation on user object.
     * On success, if passwordUpdateRequested flag is found to be false then user is redirected to requested app,
     * otherwise the user is requested a new password (achieved by passwordUpdateRequested View Binding)
     */
    function getCurrentUser() {
        dxData.rootOps.User.$current({
            success: function success(okResult) {
                /*
                 * Note: currentUser can be undefined if the Delphix Engine isn't set up. However, to get this point
                 * in the process, it has to have been set up.
                 */
                currentUser = okResult.get('result');
                if (currentUser.get('passwordUpdateRequested') === true) {
                    self.submitInProgress(false);
                    self.passwordUpdateRequested(true);
                    self.awaitingPassword(true);
                    self.username(currentUser.get('name'));
                    self.email(currentUser.get('emailAddress'));

                    if (self.username() === 'delphix_admin' && _.isEmpty(self.email())) {
                        self.isEmailRequired(true);
                        self.passwordChangeMessage(dxLocale.gls('password.and.email.change.message'));
                    }
                } else {
                    var locale = currentUser.get('locale');

                    if (_.isString(locale)) {
                        if (locale === 'default') {
                            locale = systemLocale();
                        }

                        /*
                         * The frontend locale handlers used by both flex and the JS GUI don't like our
                         * 2-dashed locale. Given our pseudolocalization locale, modify it for the front
                         * end to this non-existing locale code.
                         */
                        if (locale === 'en-US-psaccent') {
                            locale = 'en-PS';
                        }

                        dxUtil.setCookie('locale', locale, 30);
                    }

                    redirectUser();
                }
            },
            error: function error(errorResult) {
                self.submitInProgress(false);
                showError(errorResult);
            }
        });
    }

    /*
     * Can be triggered by the user clicking 'cancel' in the update user form
     */
    self.cancelLogin = function () {
        /*
         * After submitting updated password, the cancel button is still enabled.
         * Make sure the user doesn't click cancel while submit is in progress.
         */
        if (self.submitInProgress()) {
            return;
        }

        self.cancelInProgress(true);
        dxSession.endSession();
    };

    /*
     * updateUser checks for valid password and then then triggers update password method.
     * Triggered from clicking 'continue' in the update user form
     */
    self.updateUser = function () {
        self.invalidEmailMessage('');
        self.message('');

        if (self.isEmailRequired()) {
            if (self.email() === '') {
                self.invalidEmailMessage(dxLocale.gls('email.required.prompt'));
            } else if (!dxUtil.isValidEmail(self.email())) {
                self.invalidEmailMessage(dxLocale.gls('invalid.email.prompt'));
            }
        }

        if (self.newPassword() === '') {
            self.message(dxLocale.gls('password.required.prompt'));
        } else if (self.newPassword() !== self.confirmPassword()) {
            self.message(dxLocale.gls('passwords.not.matching.prompt'));
        } else if (self.isEmailRequired()) {
            if (self.invalidEmailMessage() === '') {
                currentUser.$$update({
                    emailAddress: self.email()
                }, {
                    success: updatePassword,
                    error: function error() {
                        self.message(dxLocale.gls('generic.login.failure'));
                    }
                });
            }
        } else {
            updatePassword();
        }
    };

    /*
     * updatePassword fires updateCredential operation on user object to update user password.
     */
    function updatePassword() {
        var updateParameters = dxData.newClientModel('CredentialUpdateParameters');
        updateParameters.get('oldCredential').set('password', self.password());
        updateParameters.get('newCredential').set('password', self.confirmPassword());

        self.submitInProgress(true);
        currentUser.$updateCredential(updateParameters, {
            success: function success() {
                self.password(self.confirmPassword());
                self.login();
            },
            error: function error(errorResult) {
                self.submitInProgress(false);
                showError(errorResult);
            }
        });
    }

    /*
     * This function redirects the user to an appropriate app after a successful login.
     */
    function redirectUser() {
        var userType = currentUser.get('userType').toUpperCase(),
            userRef = currentUser.get('reference');

        if (userType === DOMAIN && self.target() === DOMAIN) {
            var rolesPromise = dxUserUtil.getDefaultRoles(),
                authorizationsPromise = dxData.getServerCollection('Authorization').$$list({
                user: userRef
            });

            // Wait until we've gotten all relevant user info to handle permission and redirect logic
            $.when(authorizationsPromise, rolesPromise).then(function (authorizations, defaultRoles) {
                var isJetStreamUser = dxUserUtil.isJetStreamUser(userRef, authorizations, defaultRoles),
                    isAdmin = dxUserUtil.isDelphixAdmin(userRef, authorizations, defaultRoles);

                if (isJetStreamUser && !isAdmin) {
                    dxScreen.navigateExternal('/jetstream/#data-mgmt');
                } else {
                    dxScreen.navigateExternal('/Server.html');
                }
            }).fail(function () {
                self.message(dxLocale.gls('generic.login.failure'));
            });
        } else if (userType === SYSTEM && self.target() === SYSTEM) {
            dxScreen.navigateExternal('/ServerSetup.html');
        } else {
            self.submitInProgress(false);
            self.message(dxLocale.gls('invalid.credentials.prompt'));
        }
    }

    /*
     * getPublicSystemInfo method fetches the PublicSystemInfo singleton object to verify if the server
     * has been configured or not. If it has been configured, it fires the getCurrentUser method otherwise
     * redirects the user to setup app.
     * On error, it is assumed that server is unreachable and a retry is issued every 100ms.
     */
    function getPublicSystemInfo() {
        var publicSystemInfo = dxData.getServerSingleton('PublicSystemInfo');
        function successHandler() {
            // Clear error message in case this call had previously failed
            self.message('');

            if (!publicSystemInfo.get('configured')) {
                dxScreen.navigateExternal('/Setup.html');
            }

            self.isSAPEdition(publicSystemInfo.get('productType') === SAP);

            if (publicSystemInfo.get('banner')) {
                // Represent as an array of lines to make multiline banners with <br> easier
                self.banner(publicSystemInfo.get('banner').split('\n'));
            }

            if (publicSystemInfo.get('currentLocale')) {
                systemLocale(publicSystemInfo.get('currentLocale'));
            }

            // Set whether or not this is the express edition product
            var productType = publicSystemInfo.get('productType');
            self.expressProduct(productType === 'express');
        }
        publicSystemInfo.once('ready', successHandler);
        publicSystemInfo.once('error', function () {
            self.message(dxLocale.gls('generic.login.failure'));
            setTimeout(getPublicSystemInfo, 100);
        });
    }

    function createSession(continuation) {
        var sessionPayload = dxData.newClientModel('APISession');

        sessionPayload.set({
            version: {
                major: dxConstants.VERSION_MAJOR,
                minor: dxConstants.VERSION_MINOR,
                micro: dxConstants.VERSION_MICRO
            }
        });

        dxData.rootOps.APISession.$$create(sessionPayload, {
            success: continuation,
            error: function error(_error) {
                self.fatalErrorMessage(_error.get('error').get('details'));
                self.suggestedActionMessage(_error.get('error').get('action'));
            }
        });
    }

    // --------------------------------------
    // fetch models/collections from server
    // --------------------------------------

    /*
     * Session is where it all begins.
     * We first check existence of a valid session, if not found a session is created and then getPublicSystemInfo
     * is triggered.
     */
    dxData.getServerSingleton('APISession', {
        success: getPublicSystemInfo,
        error: function error() {
            createSession(getPublicSystemInfo);
        }
    });
};

},{"dxcore/data/js/index.js":4,"dxcore/js/constants.js":15,"dxcore/js/locale.js":17,"dxcore/js/screen.js":19,"dxcore/js/session.js":20,"dxcore/js/userUtil.js":22,"dxcore/js/util.js":23,"dxcore/ko/js/ClientServerObjects.js":25,"dxcore/ko/js/system.js":29}],32:[function(require,module,exports){
/*
 * Copyright (c) 2013, 2015 by Delphix. All rights reserved.
 */

/* global $, ko, loginVM */

'use strict';

var dxLocale = require('dxcore/js/locale.js'),
    dxUtil = require('dxcore/js/util.js');

/*
 * This file contains configuration for knockout binding handlers, delphix ajax calls, locale settings and
 * some miscellaneous view configuration.
 */
function loginAjaxErrorHandler(event, jqxhr) {
    if (jqxhr.status === 0) {
        loginVM.showConnectivityError();
    }
    // filtering out HTML tags
    dxUtil.debug($.trim(dxUtil.isNone(jqxhr.responseText) ? '' : jqxhr.responseText.replace(/(<([^>]+)>)/ig, ' ')));
}

module.exports = function setupConfig() {
    /*
     * fadeVisible is a custom handler for knockout that uses jQuery's fade methods to hide/show elements.
     */
    ko.bindingHandlers.fadeVisible = {
        update: function update(element, valueAccessor) {
            var shouldDisplay = valueAccessor();
            if (shouldDisplay) {
                $(element).fadeIn('slow');
            } else {
                $(element).fadeOut('fast');
            }
        }
    };

    /*
     * Locale configuration.
     */
    dxLocale.setupLocale([{
        name: 'messages',
        path: '../dxcore/locale/',
        language: 'en_US'
    }, {
        name: 'messages',
        path: 'locale/',
        language: 'en_US'
    }]);

    $(document).ajaxError(loginAjaxErrorHandler);
};

},{"dxcore/js/locale.js":17,"dxcore/js/util.js":23}],33:[function(require,module,exports){
/*
 * Copyright (c) 2013, 2015 by Delphix. All rights reserved.
 */

/* global Backbone */

'use strict';

/*
 * This file contains router configuration for login application workflow.
 */
function setupRouter(loginViewModel) {
    /*
     * Backbone router to handle URL route requests.
     */
    var AppRouter = Backbone.Router.extend({
        routes: {
            serverSetup: 'routeToServerSetup',
            '*actions': 'defaultRoute'
        }
    });

    var app_router = new AppRouter();
    app_router.on('route:routeToServerSetup', function () {
        toggleLoginScreen('SYSTEM');
    });

    app_router.on('route:defaultRoute', function () {
        toggleLoginScreen('DOMAIN');
    });

    /*
     * Toggles the Delphix Engine/Setup logo and links.
     *     screen - DOMAIN or SYSTEM screen.
     */
    function toggleLoginScreen(screen) {
        loginViewModel.target(screen);
        loginViewModel.message('');
        loginViewModel.awaitingLogin(true);
    }
}

module.exports = function start(loginViewModel) {
    setupRouter(loginViewModel);
    Backbone.history.start();
};

},{}],34:[function(require,module,exports){
/*
 * Copyright (c) 2012, 2015 by Delphix. All rights reserved.
 */

/* global $, dx, ko */

'use strict';

// Expose namespace to be called from html
require('dxcore/js/delphix.js').namespace('dx.login');

var dxTemplate = require('dxcore/js/template.js'),
    dxInitialize = require('dxcore/main/js/startDxCore.js'),
    dxSetupConfig = require('login/js/login-config.js'),
    dxPasswordStrengthMeter = require('login/js/password-strength-meter.js'),
    dxStartRouter = require('login/js/login-router.js'),
    dxLoginVM = require('login/js/LoginViewModel.js');

/*
 * Entrypoint for the login app
 */

function append(elem, vm) {
    if (!vm) vm = new dxLoginVM.loginViewModel();
    var loginTemplate = dxTemplate.template('login/template/login');
    if (elem) elem.append(loginTemplate);
    ko.applyBindings(vm, loginTemplate.get(0));
    return loginTemplate;
}

/*
 * Begins the login process.
 * Parameters:
 * broswerDeprecated: true/false indicating that a message should be displayed
 *    to the effect that support for the user's browser will be removed in a
 *    subsequent release.
 * browserUnsupported: true/false indicating that a message should be displayed
 *    to the effect that the user's broswer is not supported and that behavior
 *    of the app cannot be predicted. Takes precedence over deprecated.
 */
function startLogin(browserDeprecated, broswerUnsupported) {
    dxInitialize();
    dxSetupConfig();
    var vm = new dxLoginVM.loginViewModel(browserDeprecated, broswerUnsupported);
    append($('body'), vm);
    dxPasswordStrengthMeter.setupPasswordStrengthMeter();
    dxStartRouter(vm);
}

module.exports = {
    // Exposed for testing
    _append: append
};

dx.login.startLogin = startLogin;

},{"dxcore/js/delphix.js":16,"dxcore/js/template.js":21,"dxcore/main/js/startDxCore.js":30,"login/js/LoginViewModel.js":31,"login/js/login-config.js":32,"login/js/login-router.js":33,"login/js/password-strength-meter.js":35}],35:[function(require,module,exports){
/*
 * Copyright (c) 2013, 2015 by Delphix. All rights reserved.
 */

/* global $ */

'use strict';

var dxLocale = require('dxcore/js/locale.js');

/*
 * This file contains configuration password strength meter used on the login page while initializing a user.
 */
function setupPasswordStrengthMeter() {
    /*
     * Bindings for the password strength monitor.
     */
    $('#newPassword').keyup(function () {
        var verdict = passwordStrengthMonitor($(this).val());
        updatePasswordStrengthMeter(verdict);
    });

    /*
     * This function updates the password strength meter based on the new password entered by the user.
     */
    function updatePasswordStrengthMeter(strength) {
        var strengthLabel = $('#strengthLabel');

        if (strength !== strengthLabel.html()) {
            $('div[id*=strengthMeter]').each(function () {
                $(this).addClass('bar-neutral').removeClass('progress-bar-success progress-bar-warning progress-bar-error');
            });

            if (strength === dxLocale.gls('password.strength.veryweak')) {
                $('#strengthMeter1').removeClass('bar-neutral');
            } else if (strength === dxLocale.gls('password.strength.weak')) {
                $('div[id*=strengthMeter]:lt(2)').each(function () {
                    $(this).removeClass('bar-neutral');
                });
            } else if (strength === dxLocale.gls('password.strength.strong')) {
                $('div[id*=strengthMeter]:lt(3)').each(function () {
                    $(this).removeClass('bar-neutral').addClass('progress-bar-warning');
                });
            } else if (strength === dxLocale.gls('password.strength.verystrong')) {
                $('div[id*=strengthMeter]').each(function () {
                    $(this).removeClass('bar-neutral').addClass('progress-bar-success');
                });
            }

            strengthLabel.html(strength);
        }
    }
}

/*
 * Password strength monitor function ripped off from flex code.
 * @param {Object} passwd
 */
function passwordStrengthMonitor(passwd) {
    var score = 0;
    var verdict = dxLocale.gls('password.strength.veryweak');

    // PASSWORD LENGTH
    if (passwd.length < 8) {
        score -= 3;
    } else if (passwd.length > 7 && passwd.length < 15) {
        // length between 7 and 14
        score += 12;
    } else {
        // length 15 or more
        score += 18;
    }

    // LETTERS
    if (passwd.match(/[a-z]/)) {
        // [verified] at least one lower case letter
        score += 1;
    }
    if (passwd.match(/[A-Z]/)) {
        // [verified] at least one upper case letter
        score += 5;
    }

    // NUMBERS
    if (passwd.match(/\d+/)) {
        // [verified] at least one number
        score += 6;
    }

    if (passwd.match(/(\d.*\d.*\d)/)) {
        // [verified] at least three numbers
        score += 7;
    }

    // SPECIAL CHARACTERS
    if (passwd.match(/[!,@#$%\^&*?_~]/)) {
        // [verified] at least one special character
        score += 6;
    }

    if (passwd.match(/([!,@#$%\^&*?_~].*[!,@#$%\^&*?_~])/)) {
        // [verified] at least two special characters
        score += 7;
    }

    // COMBINATIONS
    if (passwd.match(/[a-z]/) && passwd.match(/[A-Z]/)) {
        // [verified] both upper and lower case
        score += 3;
    }

    if (passwd.match(/\d/) && passwd.match(/\D/)) {
        // [verified] both letters and numbers
        score += 4;
    }

    // [Verified] Upper Letters, Lower Letters, numbers and special characters
    if (passwd.match(/[a-z]/) && passwd.match(/[A-Z]/) && passwd.match(/\d/) && passwd.match(/[!,@#$%\^&*?_~]/)) {
        score += 4;
    }

    // the string 'delphix' makes password easier to guess. hence negative marks
    if (passwd.toLowerCase().indexOf('delphix') !== -1) {
        score -= 10;
    }

    // compute final verdict.
    if (score < 16) {
        verdict = dxLocale.gls('password.strength.veryweak');
    } else if (score > 15 && score < 35) {
        verdict = dxLocale.gls('password.strength.weak');
    } else if (score > 34 && score < 45) {
        verdict = dxLocale.gls('password.strength.strong');
    } else {
        verdict = dxLocale.gls('password.strength.verystrong');
    }

    if (passwd.length === 0) {
        verdict = '';
        score = 0;
    }

    return verdict;
}

module.exports = {
    setupPasswordStrengthMeter: setupPasswordStrengthMeter,
    passwordStrengthMonitor: passwordStrengthMonitor
};

},{"dxcore/js/locale.js":17}]},{},[34])
//# sourceMappingURL=data:application/json;charset:utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9icm93c2VyLXBhY2svX3ByZWx1ZGUuanMiLCIvZGF0YS9uaWdodGx5LWJ1aWxkL2RlbHBoaXhfNS4wLjIuMC9hcHAtZ2F0ZS9hcHBsaWFuY2UvY2xpZW50L2R4Y29yZS9kYXRhL2RlbHBoaXgvanMvZmlsdGVyLmpzIiwiL2RhdGEvbmlnaHRseS1idWlsZC9kZWxwaGl4XzUuMC4yLjAvYXBwLWdhdGUvYXBwbGlhbmNlL2NsaWVudC9keGNvcmUvZGF0YS9kZWxwaGl4L2pzL3Byb3h5LmpzIiwiL2RhdGEvbmlnaHRseS1idWlsZC9kZWxwaGl4XzUuMC4yLjAvYXBwLWdhdGUvYXBwbGlhbmNlL2NsaWVudC9keGNvcmUvZGF0YS9kZWxwaGl4L2pzL3V0aWwuanMiLCIvZGF0YS9uaWdodGx5LWJ1aWxkL2RlbHBoaXhfNS4wLjIuMC9hcHAtZ2F0ZS9hcHBsaWFuY2UvY2xpZW50L2R4Y29yZS9kYXRhL2pzL2luZGV4LmpzIiwiL2RhdGEvbmlnaHRseS1idWlsZC9kZWxwaGl4XzUuMC4yLjAvYXBwLWdhdGUvYXBwbGlhbmNlL2NsaWVudC9keGNvcmUvZGF0YS9sYXllcjEvanMvc2NoZW1hLmpzIiwiL2RhdGEvbmlnaHRseS1idWlsZC9kZWxwaGl4XzUuMC4yLjAvYXBwLWdhdGUvYXBwbGlhbmNlL2NsaWVudC9keGNvcmUvZGF0YS9sYXllcjIvanMvY2FjaGUuanMiLCIvZGF0YS9uaWdodGx5LWJ1aWxkL2RlbHBoaXhfNS4wLjIuMC9hcHAtZ2F0ZS9hcHBsaWFuY2UvY2xpZW50L2R4Y29yZS9kYXRhL2xheWVyMi9qcy9jb2xsZWN0aW9uLmpzIiwiL2RhdGEvbmlnaHRseS1idWlsZC9kZWxwaGl4XzUuMC4yLjAvYXBwLWdhdGUvYXBwbGlhbmNlL2NsaWVudC9keGNvcmUvZGF0YS9sYXllcjIvanMvY3JlYXRpb25MaXN0ZW5lci5qcyIsIi9kYXRhL25pZ2h0bHktYnVpbGQvZGVscGhpeF81LjAuMi4wL2FwcC1nYXRlL2FwcGxpYW5jZS9jbGllbnQvZHhjb3JlL2RhdGEvbGF5ZXIyL2pzL2ZpbHRlci5qcyIsIi9kYXRhL25pZ2h0bHktYnVpbGQvZGVscGhpeF81LjAuMi4wL2FwcC1nYXRlL2FwcGxpYW5jZS9jbGllbnQvZHhjb3JlL2RhdGEvbGF5ZXIyL2pzL21vZGVsLmpzIiwiL2RhdGEvbmlnaHRseS1idWlsZC9kZWxwaGl4XzUuMC4yLjAvYXBwLWdhdGUvYXBwbGlhbmNlL2NsaWVudC9keGNvcmUvZGF0YS9sYXllcjMvanMvYXBpLmpzIiwiL2RhdGEvbmlnaHRseS1idWlsZC9kZWxwaGl4XzUuMC4yLjAvYXBwLWdhdGUvYXBwbGlhbmNlL2NsaWVudC9keGNvcmUvZGF0YS9sYXllcjMvanMvbm90aWZpY2F0aW9uLmpzIiwiL2RhdGEvbmlnaHRseS1idWlsZC9kZWxwaGl4XzUuMC4yLjAvYXBwLWdhdGUvYXBwbGlhbmNlL2NsaWVudC9keGNvcmUvanMvYWpheC5qcyIsIi9kYXRhL25pZ2h0bHktYnVpbGQvZGVscGhpeF81LjAuMi4wL2FwcC1nYXRlL2FwcGxpYW5jZS9jbGllbnQvZHhjb3JlL2pzL2Jyb3dzZXIuanMiLCIvZGF0YS9uaWdodGx5LWJ1aWxkL2RlbHBoaXhfNS4wLjIuMC9hcHAtZ2F0ZS9hcHBsaWFuY2UvY2xpZW50L2R4Y29yZS9qcy9jb25zdGFudHMuanMiLCIvZGF0YS9uaWdodGx5LWJ1aWxkL2RlbHBoaXhfNS4wLjIuMC9hcHAtZ2F0ZS9hcHBsaWFuY2UvY2xpZW50L2R4Y29yZS9qcy9kZWxwaGl4LmpzIiwiL2RhdGEvbmlnaHRseS1idWlsZC9kZWxwaGl4XzUuMC4yLjAvYXBwLWdhdGUvYXBwbGlhbmNlL2NsaWVudC9keGNvcmUvanMvbG9jYWxlLmpzIiwiL2RhdGEvbmlnaHRseS1idWlsZC9kZWxwaGl4XzUuMC4yLjAvYXBwLWdhdGUvYXBwbGlhbmNlL2NsaWVudC9keGNvcmUvanMvbW9kYWwuanMiLCIvZGF0YS9uaWdodGx5LWJ1aWxkL2RlbHBoaXhfNS4wLjIuMC9hcHAtZ2F0ZS9hcHBsaWFuY2UvY2xpZW50L2R4Y29yZS9qcy9zY3JlZW4uanMiLCIvZGF0YS9uaWdodGx5LWJ1aWxkL2RlbHBoaXhfNS4wLjIuMC9hcHAtZ2F0ZS9hcHBsaWFuY2UvY2xpZW50L2R4Y29yZS9qcy9zZXNzaW9uLmpzIiwiL2RhdGEvbmlnaHRseS1idWlsZC9kZWxwaGl4XzUuMC4yLjAvYXBwLWdhdGUvYXBwbGlhbmNlL2NsaWVudC9keGNvcmUvanMvdGVtcGxhdGUuanMiLCIvZGF0YS9uaWdodGx5LWJ1aWxkL2RlbHBoaXhfNS4wLjIuMC9hcHAtZ2F0ZS9hcHBsaWFuY2UvY2xpZW50L2R4Y29yZS9qcy91c2VyVXRpbC5qcyIsIi9kYXRhL25pZ2h0bHktYnVpbGQvZGVscGhpeF81LjAuMi4wL2FwcC1nYXRlL2FwcGxpYW5jZS9jbGllbnQvZHhjb3JlL2pzL3V0aWwuanMiLCIvZGF0YS9uaWdodGx5LWJ1aWxkL2RlbHBoaXhfNS4wLjIuMC9hcHAtZ2F0ZS9hcHBsaWFuY2UvY2xpZW50L2R4Y29yZS9qcy93aW5kb3cuanMiLCIvZGF0YS9uaWdodGx5LWJ1aWxkL2RlbHBoaXhfNS4wLjIuMC9hcHAtZ2F0ZS9hcHBsaWFuY2UvY2xpZW50L2R4Y29yZS9rby9qcy9DbGllbnRTZXJ2ZXJPYmplY3RzLmpzIiwiL2RhdGEvbmlnaHRseS1idWlsZC9kZWxwaGl4XzUuMC4yLjAvYXBwLWdhdGUvYXBwbGlhbmNlL2NsaWVudC9keGNvcmUva28vanMvQ29tcGxleE9ic2VydmFibGVBdHRyaWJ1dGVzLmpzIiwiL2RhdGEvbmlnaHRseS1idWlsZC9kZWxwaGl4XzUuMC4yLjAvYXBwLWdhdGUvYXBwbGlhbmNlL2NsaWVudC9keGNvcmUva28vanMvT2JzZXJ2YWJsZUF0dHJpYnV0ZS5qcyIsIi9kYXRhL25pZ2h0bHktYnVpbGQvZGVscGhpeF81LjAuMi4wL2FwcC1nYXRlL2FwcGxpYW5jZS9jbGllbnQvZHhjb3JlL2tvL2pzL29wZXJhdGlvbi5qcyIsIi9kYXRhL25pZ2h0bHktYnVpbGQvZGVscGhpeF81LjAuMi4wL2FwcC1nYXRlL2FwcGxpYW5jZS9jbGllbnQvZHhjb3JlL2tvL2pzL3N5c3RlbS5qcyIsIi9kYXRhL25pZ2h0bHktYnVpbGQvZGVscGhpeF81LjAuMi4wL2FwcC1nYXRlL2FwcGxpYW5jZS9jbGllbnQvZHhjb3JlL21haW4vanMvc3RhcnREeENvcmUuanMiLCIvZGF0YS9uaWdodGx5LWJ1aWxkL2RlbHBoaXhfNS4wLjIuMC9hcHAtZ2F0ZS9hcHBsaWFuY2UvY2xpZW50L2xvZ2luL2pzL0xvZ2luVmlld01vZGVsLmpzIiwiL2RhdGEvbmlnaHRseS1idWlsZC9kZWxwaGl4XzUuMC4yLjAvYXBwLWdhdGUvYXBwbGlhbmNlL2NsaWVudC9sb2dpbi9qcy9sb2dpbi1jb25maWcuanMiLCIvZGF0YS9uaWdodGx5LWJ1aWxkL2RlbHBoaXhfNS4wLjIuMC9hcHAtZ2F0ZS9hcHBsaWFuY2UvY2xpZW50L2xvZ2luL2pzL2xvZ2luLXJvdXRlci5qcyIsIi9kYXRhL25pZ2h0bHktYnVpbGQvZGVscGhpeF81LjAuMi4wL2FwcC1nYXRlL2FwcGxpYW5jZS9jbGllbnQvbG9naW4vanMvbG9naW4uanMiLCIvZGF0YS9uaWdodGx5LWJ1aWxkL2RlbHBoaXhfNS4wLjIuMC9hcHAtZ2F0ZS9hcHBsaWFuY2UvY2xpZW50L2xvZ2luL2pzL3Bhc3N3b3JkLXN0cmVuZ3RoLW1ldGVyLmpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBOzs7Ozs7O0FDTUEsWUFBWSxDQUFDOztBQUViLElBQU0sTUFBTSxHQUFHLE9BQU8sQ0FBQyxtQkFBbUIsQ0FBQztJQUN2QyxVQUFVLEdBQUcsT0FBTyxDQUFDLHVCQUF1QixDQUFDO0lBQzdDLFFBQVEsR0FBRyxPQUFPLENBQUMsaUNBQWlDLENBQUMsQ0FBQzs7Ozs7O0FBTTFELE1BQU0sQ0FBQyxPQUFPLENBQUMsbUJBQW1CLEdBQUcsU0FBUyxtQkFBbUIsQ0FBQyxPQUFPLEVBQUU7Ozs7QUFJdkUsYUFBUyxZQUFZLENBQUMsVUFBVSxFQUFFLEtBQUssRUFBRSxhQUFhLEVBQUU7QUFDcEQsWUFBSSxP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QUUsMEJBQTBCO0FBQ3RELDJCQUF1QixFQUFFLHVCQUF1QjtDQUNuRCxDQUFDIiwiZmlsZSI6ImdlbmVyYXRlZC5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzQ29udGVudCI6WyIoZnVuY3Rpb24gZSh0LG4scil7ZnVuY3Rpb24gcyhvLHUpe2lmKCFuW29dKXtpZighdFtvXSl7dmFyIGE9dHlwZW9mIHJlcXVpcmU9PVwiZnVuY3Rpb25cIiYmcmVxdWlyZTtpZighdSYmYSlyZXR1cm4gYShvLCEwKTtpZihpKXJldHVybiBpKG8sITApO3ZhciBmPW5ldyBFcnJvcihcIkNhbm5vdCBmaW5kIG1vZHVsZSAnXCIrbytcIidcIik7dGhyb3cgZi5jb2RlPVwiTU9EVUxFX05PVF9GT1VORFwiLGZ9dmFyIGw9bltvXT17ZXhwb3J0czp7fX07dFtvXVswXS5jYWxsKGwuZXhwb3J0cyxmdW5jdGlvbihlKXt2YXIgbj10W29dWzFdW2VdO3JldHVybiBzKG4/bjplKX0sbCxsLmV4cG9ydHMsZSx0LG4scil9cmV0dXJuIG5bb10uZXhwb3J0c312YXIgaT10eXBlb2YgcmVxdWlyZT09XCJmdW5jdGlvblwiJiZyZXF1aXJlO2Zvcih2YXIgbz0wO288ci5sZW5ndGg7bysrKXMocltvXSk7cmV0dXJuIHN9KSIsIi8qXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTQsIDIwMTUgYnkgRGVscGhpeC4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqL1xuXG4vKiBnbG9iYWwgXyAsICQgKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCBkeFV0aWwgPSByZXF1aXJlKCdkeGNvcmUvanMvdXRpbC5qcycpLFxuICAgIGR4VXNlclV0aWwgPSByZXF1aXJlKCdkeGNvcmUvanMvdXNlclV0aWwuanMnKSxcbiAgICBkeEZpbHRlciA9IHJlcXVpcmUoJ2R4Y29yZS9kYXRhL2xheWVyMi9qcy9maWx0ZXIuanMnKTtcblxuLypcbiAqIERlZmluZXMgYSBzcGVjaWFsIGluaXRpYWxpemF0aW9uIHJvdXRpbmUgb24gZGF0YSB3aGljaCBpcyB1c2VkIHRvIHNldCB1cCBkZWxwaGl4IFNjaGVtYSBzcGVjaWZpYyBmaWxlcnMuXG4gKiBJbiBwYXJ0aWN1bGFyLCBhbGwgZmlsdGVycyB3aGljaCBjYW4gbm90IGJlIGhhbmRsZWQgYnkgdGhlIHN0YW5kYXJkIHViZXJGaWx0ZXIgYXJlIGltcGxlbWVudGVkIGhlcmUuXG4gKi9cbm1vZHVsZS5leHBvcnRzLl9pbml0RGVscGhpeEZpbHRlcnMgPSBmdW5jdGlvbiBfaW5pdERlbHBoaXhGaWx0ZXJzKGNvbnRleHQpIHtcbiAgICAvKlxuICAgICAqIEZpbHRlciBmdW5jdGlvbnMgZm9yIHR5cGVzIHRoYXQgY2Fubm90IGJlIChmdWxseSkgYXV0b2dlbmVyYXRlZFxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGFjdGlvbkZpbHRlcihjb2xsZWN0aW9uLCBtb2RlbCwgcmVzdWx0SGFuZGxlcikge1xuICAgICAgICB2YXIgcVBhcmFtcyA9IGNvbGxlY3Rpb24uZ2V0UXVlcnlQYXJhbWV0ZXJzKCkgfHwge307XG4gICAgICAgIGlmIChfLmlzRW1wdHkocVBhcmFtcykpIHtcbiAgICAgICAgICAgIHJldHVybiByZXN1bHRIYW5kbGVyKGNvbnRleHQuX2ZpbHRlcnMuSU5DTFVERSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCEhcVBhcmFtcy5yb290QWN0aW9uT25seSAmJiAhIW1vZGVsLmdldCgncGFyZW50QWN0aW9uJykpIHtcbiAgICAgICAgICAgIHJldHVybiByZXN1bHRIYW5kbGVyKGNvbnRleHQuX2ZpbHRlcnMuRVhDTFVERSk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgZmlsdGVyZWRCeVN0YXRlQW5kVXNlciA9IGNvbnRleHQuX2ZpbHRlcnMuX2NoZWNrU2FtZVByb3BzKFsnc3RhdGUnLCAndXNlciddLCBxUGFyYW1zLCBtb2RlbCk7XG4gICAgICAgIGlmIChmaWx0ZXJlZEJ5U3RhdGVBbmRVc2VyID09PSBjb250ZXh0Ll9maWx0ZXJzLkVYQ0xVREUpIHtcbiAgICAgICAgICAgIHJldHVybiByZXN1bHRIYW5kbGVyKGNvbnRleHQuX2ZpbHRlcnMuRVhDTFVERSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFxUGFyYW1zLnBhcmVudEFjdGlvbikge1xuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdEhhbmRsZXIoZmlsdGVyZWRCeVN0YXRlQW5kVXNlcik7XG4gICAgICAgIH1cbiAgICAgICAgLy8gRm9yIHRoZSBwYXJlbnQgYWN0aW9uLCBuZWVkIHRvIGdvIHVwIHRoZSBoaWVyYXJjaHlcbiAgICAgICAgZnVuY3Rpb24gY2hlY2tQYXJlbnRBY3Rpb24oY3VycmVudE1vZGVsKSB7XG4gICAgICAgICAgICBjdXJyZW50TW9kZWwub25jZSgncmVhZHknLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICB2YXIgcGFyZW50QWN0aW9uUmVmID0gY3VycmVudE1vZGVsLmdldCgncGFyZW50QWN0aW9uJyk7XG4gICAgICAgICAgICAgICAgaWYgKCFwYXJlbnRBY3Rpb25SZWYpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0SGFuZGxlcihjb250ZXh0Ll9maWx0ZXJzLkVYQ0xVREUpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAocGFyZW50QWN0aW9uUmVmID09PSBxUGFyYW1zLnBhcmVudEFjdGlvbikge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHRIYW5kbGVyKGNvbnRleHQuX2ZpbHRlcnMuSU5DTFVERSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHBhcmVudE1vZGVsID0gY29udGV4dC5nZXRTZXJ2ZXJNb2RlbChwYXJlbnRBY3Rpb25SZWYsICdBY3Rpb24nKTtcbiAgICAgICAgICAgICAgICAgICAgY2hlY2tQYXJlbnRBY3Rpb24ocGFyZW50TW9kZWwpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgY3VycmVudE1vZGVsLm9uY2UoJ2Vycm9yJywgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgLy8gSWYgdGhlIG1vZGVsIG9yIHBhcmVudCBkb2VzIG5vdCBleGlzdCwgY29udGV4dC5fZmlsdGVycy5FWENMVURFIGl0XG4gICAgICAgICAgICAgICAgcmVzdWx0SGFuZGxlcihjb250ZXh0Ll9maWx0ZXJzLkVYQ0xVREUpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgY2hlY2tQYXJlbnRBY3Rpb24obW9kZWwpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGFsZXJ0RmlsdGVyKGNvbGxlY3Rpb24sIG1vZGVsLCByZXN1bHRIYW5kbGVyKSB7XG4gICAgICAgIHZhciBxUGFyYW1zID0gY29sbGVjdGlvbi5nZXRRdWVyeVBhcmFtZXRlcnMoKSB8fCB7fTtcbiAgICAgICAgaWYgKHFQYXJhbXMuc2VhcmNoVGV4dCkge1xuICAgICAgICAgICAgdmFyIGZpZWxkc1RvU2VhcmNoID0gWydldmVudFRpdGxlJywgJ2V2ZW50RGVzY3JpcHRpb24nLCAnZXZlbnRSZXNwb25zZScsICdldmVudEFjdGlvbicsICd0YXJnZXROYW1lJ107XG4gICAgICAgICAgICB2YXIgc2VhcmNoVGV4dCA9IHFQYXJhbXMuc2VhcmNoVGV4dC50b0xvd2VyQ2FzZSgpO1xuICAgICAgICAgICAgdmFyIHNlYXJjaE1hdGNoZXMgPSBfLmFueShmaWVsZHNUb1NlYXJjaCwgZnVuY3Rpb24oZmllbGQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gXy5pc1N0cmluZyhtb2RlbC5nZXQoZmllbGQpKSAmJiBtb2RlbC5nZXQoZmllbGQpLnRvTG93ZXJDYXNlKCkuaW5kZXhPZihzZWFyY2hUZXh0KSAhPT0gLTE7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGlmICghc2VhcmNoTWF0Y2hlcykge1xuICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHRIYW5kbGVyKGNvbnRleHQuX2ZpbHRlcnMuRVhDTFVERSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICB1YmVyRmlsdGVyKGNvbGxlY3Rpb24sIG1vZGVsLCByZXN1bHRIYW5kbGVyLCBbJ3NlYXJjaFRleHQnXSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gYXV0aG9yaXphdGlvbkZpbHRlcihjb2xsZWN0aW9uLCBtb2RlbCwgcmVzdWx0SGFuZGxlcikge1xuICAgICAgICB2YXIgcVBhcmFtcyA9IGNvbGxlY3Rpb24uZ2V0UXVlcnlQYXJhbWV0ZXJzKCkgfHwge307XG4gICAgICAgIGlmIChxUGFyYW1zLmVmZmVjdGl2ZSkge1xuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdEhhbmRsZXIoY29udGV4dC5fZmlsdGVycy5VTktOT1dOKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHViZXJGaWx0ZXIoY29sbGVjdGlvbiwgbW9kZWwsIHJlc3VsdEhhbmRsZXIpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNvbnRhaW5lckZpbHRlcihjb2xsZWN0aW9uLCBtb2RlbCwgcmVzdWx0SGFuZGxlcikge1xuICAgICAgICB2YXIgcVBhcmFtcyA9IGNvbGxlY3Rpb24uZ2V0UXVlcnlQYXJhbWV0ZXJzKCkgfHwge307XG4gICAgICAgIGlmIChxUGFyYW1zLnZhbGlkRm9yU2VjdXJlUmVwbGljYXRpb24pIHtcbiAgICAgICAgICAgIC8qXG4gICAgICAgICAgICAgKiBUaGUgc2VydmVyIGlzIGNoZWNraW5nIG1hc2tlZCBmbGFnIGFuZCBkYXRhbGluZWFnZSBhbmQgb3RoZXIgaW5mb3JtYXRpb24gdGhhdCBhcmUgbm90IGF2YWlsYWJsZSBvbiB0aGVcbiAgICAgICAgICAgICAqIGNsaWVudCBzaWRlLiBTbyB3ZSBqdXN0IG1hcmsgdGhlIHN0YXR1cyBvZiB0aGUgY29sbGVjdGlvbiBvbiB0aGUgY2xpZW50IGRpcnR5LlxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICByZXN1bHRIYW5kbGVyKGNvbnRleHQuX2ZpbHRlcnMuVU5LTk9XTik7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgcmVzID0gY29udGV4dC5fZmlsdGVycy5fY2hlY2tTYW1lUHJvcHMoWydwcm92aXNpb25Db250YWluZXInLCAnZ3JvdXAnXSwgcVBhcmFtcywgbW9kZWwpO1xuICAgICAgICBpZiAocmVzICE9PSBjb250ZXh0Ll9maWx0ZXJzLklOQ0xVREUgfHwgIShxUGFyYW1zLm5vSlNEYXRhU291cmNlIHx8IHFQYXJhbXMubm9KU0NvbnRhaW5lckRhdGFTb3VyY2UpKSB7XG4gICAgICAgICAgICByZXN1bHRIYW5kbGVyKHJlcyk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgZGF0YVNvdXJjZXMgPSBjb250ZXh0LmdldFNlcnZlckNvbGxlY3Rpb24oJ0pTRGF0YVNvdXJjZScpO1xuICAgICAgICB2YXIgZGF0YVNvdXJjZXNQcm9taXNlID0gZGF0YVNvdXJjZXMuJCRsaXN0KHtcbiAgICAgICAgICAgIGNvbnRhaW5lcjogbW9kZWwuZ2V0KCdyZWZlcmVuY2UnKVxuICAgICAgICB9KTtcbiAgICAgICAgZGF0YVNvdXJjZXNQcm9taXNlLnRoZW4oZnVuY3Rpb24oZGF0YVNvdXJjZXMpIHtcbiAgICAgICAgICAgIGlmIChkYXRhU291cmNlcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICByZXN1bHRIYW5kbGVyKGNvbnRleHQuX2ZpbHRlcnMuSU5DTFVERSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChxUGFyYW1zLm5vSlNDb250YWluZXJEYXRhU291cmNlKSB7XG4gICAgICAgICAgICAgICAgdmFyIGlzSW5Vc2VCeUNvbnRhaW5lciA9IGRhdGFTb3VyY2VzLnNvbWUoZnVuY3Rpb24oZGF0YVNvdXJjZSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgZGF0YUxheW91dCA9IGRhdGFTb3VyY2UuZ2V0KCdkYXRhTGF5b3V0Jyk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBkYXRhTGF5b3V0LmluZGV4T2YoJ0pTRGF0YUNvbnRhaW5lcicpID09PSAwO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGlmIChpc0luVXNlQnlDb250YWluZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0SGFuZGxlcihjb250ZXh0Ll9maWx0ZXJzLkVYQ0xVREUpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdEhhbmRsZXIoY29udGV4dC5fZmlsdGVycy5JTkNMVURFKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmVzdWx0SGFuZGxlcihjb250ZXh0Ll9maWx0ZXJzLkVYQ0xVREUpO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBob3N0RmlsdGVyKGNvbGxlY3Rpb24sIG1vZGVsLCByZXN1bHRIYW5kbGVyKSB7XG4gICAgICAgIHZhciBxUGFyYW1zID0gY29sbGVjdGlvbi5nZXRRdWVyeVBhcmFtZXRlcnMoKSB8fCB7fTtcbiAgICAgICAgaWYgKCFxUGFyYW1zLmVudmlyb25tZW50KSB7XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0SGFuZGxlcihjb250ZXh0Ll9maWx0ZXJzLklOQ0xVREUpO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGVudiA9IGNvbnRleHQuZ2V0U2VydmVyTW9kZWwocVBhcmFtcy5lbnZpcm9ubWVudCwgJ1NvdXJjZUVudmlyb25tZW50Jyk7XG4gICAgICAgIGVudi5vbmNlKCdyZWFkeScsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgaWYgKGVudi5pbnN0YW5jZU9mKCdIb3N0RW52aXJvbm1lbnQnKSkge1xuICAgICAgICAgICAgICAgIHZhciByZXN1bHQgPSAoZW52LmdldCgnaG9zdCcpID09PSBtb2RlbC5nZXQoJ3JlZmVyZW5jZScpKSA/IGNvbnRleHQuX2ZpbHRlcnMuSU5DTFVERSA6XG4gICAgICAgICAgICAgICAgICAgIGNvbnRleHQuX2ZpbHRlcnMuRVhDTFVERTtcbiAgICAgICAgICAgICAgICByZXN1bHRIYW5kbGVyKHJlc3VsdCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHZhciBub2RlVHlwZSA9IGVudi5pbnN0YW5jZU9mKCdPcmFjbGVDbHVzdGVyJykgPyAnT3JhY2xlQ2x1c3Rlck5vZGUnIDogJ1dpbmRvd3NDbHVzdGVyTm9kZSc7XG4gICAgICAgICAgICAgICAgdmFyIG5vZGVzID0gY29udGV4dC5nZXRTZXJ2ZXJDb2xsZWN0aW9uKG5vZGVUeXBlKTtcbiAgICAgICAgICAgICAgICBub2Rlcy4kJGxpc3Qoe1xuICAgICAgICAgICAgICAgICAgICBjbHVzdGVyOiBlbnYuZ2V0KCdyZWZlcmVuY2UnKVxuICAgICAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAgICAgICAgc3VjY2VzczogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgYW55TWF0Y2hlcyA9IG5vZGVzLmFueShmdW5jdGlvbihub2RlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5vZGUuZ2V0KCdob3N0JykgPT09IG1vZGVsLmdldCgncmVmZXJlbmNlJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciByZXN1bHQgPSBhbnlNYXRjaGVzID8gY29udGV4dC5fZmlsdGVycy5JTkNMVURFIDogY29udGV4dC5fZmlsdGVycy5FWENMVURFO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0SGFuZGxlcihyZXN1bHQpO1xuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICBlcnJvcjogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHRIYW5kbGVyKGNvbnRleHQuX2ZpbHRlcnMuRVhDTFVERSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIGVudi5vbmNlKCdlcnJvcicsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcmVzdWx0SGFuZGxlcihjb250ZXh0Ll9maWx0ZXJzLkVYQ0xVREUpO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICAvKlxuICAgICAqIEEgYm9va21hcmsgYmVsb25ncyB0byBhIHRlbXBsYXRlIGlmIGl0IGhhcyB0aGF0IHZhbHVlIGFzIGEgcXVlcnkgcGFyYW1ldGVyLiAgSXQgYmVsb25ncyB0byBhIGNvbnRhaW5lciBpZiBlaXRoZXJcbiAgICAgKiBpdHMgdGVtcGxhdGUgb3IgY29udGFpbmVyIHByb3BlcnR5IG1hdGNoZXMgdGhlIHF1ZXJ5IHBhcmFtZXRlci5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBqc0Jvb2ttYXJrRmlsdGVyKGNvbGxlY3Rpb24sIG1vZGVsLCByZXN1bHRIYW5kbGVyKSB7XG4gICAgICAgIHZhciBxUGFyYW1zID0gY29sbGVjdGlvbi5nZXRRdWVyeVBhcmFtZXRlcnMoKSB8fCB7fTtcbiAgICAgICAgaWYgKF8uaXNFbXB0eShxUGFyYW1zKSkge1xuICAgICAgICAgICAgcmVzdWx0SGFuZGxlcihjb250ZXh0Ll9maWx0ZXJzLklOQ0xVREUpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKF8uaGFzKHFQYXJhbXMsICd0ZW1wbGF0ZScpKSB7XG4gICAgICAgICAgICBpZiAobW9kZWwuZ2V0KCdib29rbWFya1R5cGUnKSA9PT0gJ0RBVEFfVEVNUExBVEUnICYmIHFQYXJhbXMudGVtcGxhdGUgPT09IG1vZGVsLmdldCgndGVtcGxhdGUnKSkge1xuICAgICAgICAgICAgICAgIHJlc3VsdEhhbmRsZXIoY29udGV4dC5fZmlsdGVycy5JTkNMVURFKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0SGFuZGxlcihjb250ZXh0Ll9maWx0ZXJzLkVYQ0xVREUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9IGVsc2UgaWYgKF8uaGFzKHFQYXJhbXMsICdjb250YWluZXInKSkge1xuICAgICAgICAgICAgaWYgKHFQYXJhbXMuY29udGFpbmVyID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICByZXN1bHRIYW5kbGVyKGNvbnRleHQuX2ZpbHRlcnMuSU5DTFVERSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChxUGFyYW1zLmNvbnRhaW5lciA9PT0gbW9kZWwuZ2V0KCdjb250YWluZXInKSkge1xuICAgICAgICAgICAgICAgIHJlc3VsdEhhbmRsZXIoY29udGV4dC5fZmlsdGVycy5JTkNMVURFKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHZhciBjb250YWluZXIgPSBjb250ZXh0LmdldFNlcnZlck1vZGVsKHFQYXJhbXMuY29udGFpbmVyLCAnSlNEYXRhQ29udGFpbmVyJyk7XG4gICAgICAgICAgICAgICAgY29udGFpbmVyLm9uY2UoJ3JlYWR5JywgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjb250YWluZXIuZ2V0KCd0ZW1wbGF0ZScpID09PSBtb2RlbC5nZXQoJ3RlbXBsYXRlJykgJiYgbW9kZWwuZ2V0KCdzaGFyZWQnKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0SGFuZGxlcihjb250ZXh0Ll9maWx0ZXJzLklOQ0xVREUpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0SGFuZGxlcihjb250ZXh0Ll9maWx0ZXJzLkVYQ0xVREUpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICBjb250YWluZXIub25jZSgnZXJyb3InLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0SGFuZGxlcihjb250ZXh0Ll9maWx0ZXJzLkVYQ0xVREUpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZHhVdGlsLmZhaWwoJ1Vuc3VwcG9ydGVkIHF1ZXJ5IHBhcmFtZXRlcnM6ICcgKyBKU09OLnN0cmluZ2lmeShxUGFyYW1zKSk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBqc0RhdGFDb250YWluZXJGaWx0ZXIoY29sbGVjdGlvbiwgbW9kZWwsIHJlc3VsdEhhbmRsZXIpIHtcbiAgICAgICAgdmFyIHFQYXJhbXMgPSBjb2xsZWN0aW9uLmdldFF1ZXJ5UGFyYW1ldGVycygpIHx8IHt9O1xuXG4gICAgICAgIGlmIChfLmhhcyhxUGFyYW1zLCAnb3duZXInKSkge1xuICAgICAgICAgICAgdmFyIGpldFN0cmVhbVVzZXJSb2xlUHJvbWlzZSA9IGR4VXNlclV0aWwuZ2V0SmV0U3RyZWFtVXNlcigpO1xuXG4gICAgICAgICAgICB2YXIgYXV0aG9yaXphdGlvbnNQcm9taXNlID0gY29udGV4dC5nZXRTZXJ2ZXJDb2xsZWN0aW9uKCdBdXRob3JpemF0aW9uJykuJCRsaXN0KHtcbiAgICAgICAgICAgICAgICB0YXJnZXQ6IG1vZGVsLmdldCgncmVmZXJlbmNlJylcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICB2YXIgcm9sZUFuZEF1dGhQcm9taXNlID0gJC53aGVuKGpldFN0cmVhbVVzZXJSb2xlUHJvbWlzZSwgYXV0aG9yaXphdGlvbnNQcm9taXNlKTtcblxuICAgICAgICAgICAgcm9sZUFuZEF1dGhQcm9taXNlLnRoZW4oKGpldFN0cmVhbVVzZXJSb2xlLCBhdXRocykgPT4ge1xuICAgICAgICAgICAgICAgIHZhciBqZXRTdHJlYW1Vc2VyUm9sZVJlZmVyZW5jZSA9IGpldFN0cmVhbVVzZXJSb2xlLmdldCgncmVmZXJlbmNlJyk7XG5cbiAgICAgICAgICAgICAgICB2YXIgaXRlbSA9IF8uZmluZChhdXRocy5tb2RlbHMsIGEgPT4ge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gKGEuZ2V0KCdyb2xlJykgPT09IGpldFN0cmVhbVVzZXJSb2xlUmVmZXJlbmNlICYmIGEuZ2V0KCd1c2VyJykgPT09IHFQYXJhbXMub3duZXIpO1xuICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgaWYgKGl0ZW0pIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0SGFuZGxlcihjb250ZXh0Ll9maWx0ZXJzLklOQ0xVREUpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdEhhbmRsZXIoY29udGV4dC5fZmlsdGVycy5FWENMVURFKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB1YmVyRmlsdGVyKGNvbGxlY3Rpb24sIG1vZGVsLCByZXN1bHRIYW5kbGVyKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGpzT3BlcmF0aW9uRmlsdGVyKGNvbGxlY3Rpb24sIG1vZGVsLCByZXN1bHRIYW5kbGVyKSB7XG4gICAgICAgIGZ1bmN0aW9uIGV4Y2x1ZGVCeURhdGFMYXlvdXRBbmRCcmFuY2gocVBhcmFtcywgbW9kZWwpIHtcbiAgICAgICAgICAgIGlmIChfLmhhcyhxUGFyYW1zLCAnZGF0YUxheW91dCcpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNvbnRleHQuX2ZpbHRlcnMuX2NoZWNrU2FtZVByb3BzKFsnZGF0YUxheW91dCddLCBxUGFyYW1zLCBtb2RlbCkgPT09IGNvbnRleHQuX2ZpbHRlcnMuRVhDTFVERTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoXy5oYXMocVBhcmFtcywgJ2JyYW5jaCcpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNvbnRleHQuX2ZpbHRlcnMuX2NoZWNrU2FtZVByb3BzKFsnYnJhbmNoJ10sIHFQYXJhbXMsIG1vZGVsKSA9PT0gY29udGV4dC5fZmlsdGVycy5FWENMVURFO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBkeFV0aWwuZmFpbCgnSlNPcGVyYXRpb24gcXVlcnkgcGFyYW1ldGVycyBzcGVjaWZpZXMgbWlzc2luZyByZXF1aXJlZCBkYXRhTGF5b3V0IG9yIGJyYW5jaCcpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHFQYXJhbXMgPSBjb2xsZWN0aW9uLmdldFF1ZXJ5UGFyYW1ldGVycygpIHx8IHt9O1xuXG4gICAgICAgIGlmIChfLmhhcyhxUGFyYW1zLCAnZGF0YVRpbWUnKSkge1xuICAgICAgICAgICAgaWYgKGV4Y2x1ZGVCeURhdGFMYXlvdXRBbmRCcmFuY2gocVBhcmFtcywgbW9kZWwpKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0SGFuZGxlcihjb250ZXh0Ll9maWx0ZXJzLkVYQ0xVREUpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLypcbiAgICAgICAgICAgICAqIFdlIGRvbid0IHJlYWxseSBrbm93IGlmIHRoaXMgZXZlbnQgd291bGQgaGF2ZSBtYXRjaGVkIHRoZSBxdWVyeSBwYXJhbWV0ZXJzLCBhcyB3ZSBjYW4ndCB0ZWxsXG4gICAgICAgICAgICAgKiBob3cgdGhlIGJlZm9yZUNvdW50IGFuZCBhZnRlckNvdW50IGFyZSByZWZsZWN0ZWQgaW4gdGhlIGN1cnJlbnQgY29sbGVjdGlvbi4gQXMgYSByZXN1bHQgd2VcbiAgICAgICAgICAgICAqIHJldHVybiBVTktOT1dOLCB3aGljaCB3aWxsIHRyaWdnZXIgYSBkaXJ0eSBldmVudC4gQ2FsbGVyIGNhbiBzdWJzY3JpYmUgdG8gdGhlIGRpcnR5IGV2ZW50XG4gICAgICAgICAgICAgKiBhbmQgcmVpc3N1ZSB0aGUgcXVlcnkuXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIHJlc3VsdEhhbmRsZXIoY29udGV4dC5fZmlsdGVycy5VTktOT1dOKTtcbiAgICAgICAgfSBlbHNlIGlmIChfLmhhcyhxUGFyYW1zLCAnZGF0YVN0YXJ0VGltZScpICYmIF8uaGFzKHFQYXJhbXMsICdkYXRhRW5kVGltZScpKSB7XG4gICAgICAgICAgICBpZiAoZXhjbHVkZUJ5RGF0YUxheW91dEFuZEJyYW5jaChxUGFyYW1zLCBtb2RlbCkpIHtcbiAgICAgICAgICAgICAgICByZXN1bHRIYW5kbGVyKGNvbnRleHQuX2ZpbHRlcnMuRVhDTFVERSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgZGF0YVRpbWUgPSBtb2RlbC5nZXQoJ2RhdGFUaW1lJyk7XG5cbiAgICAgICAgICAgIC8qXG4gICAgICAgICAgICAgKiBBbiBvcGVyYXRpb24gY3VycmVudGx5IGluIHByb2dyZXNzIGhhcyBhIGRhdGFUaW1lIG9mIG51bGwsIHdoaWNoIHJlYWxseSBtZWFucyAnbm93Jy4gV2Ugc2ltdWxhdGVcbiAgICAgICAgICAgICAqIHRoaXMgYnkgdXNpbmcgdGhlIHN0YXJ0VGltZSBvZiB0aGUgb3BlcmF0aW9uLlxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBpZiAoZHhVdGlsLmlzTm9uZShkYXRhVGltZSkpIHtcbiAgICAgICAgICAgICAgICBkYXRhVGltZSA9IG1vZGVsLmdldCgnc3RhcnRUaW1lJyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChxUGFyYW1zLmRhdGFTdGFydFRpbWUgPD0gZGF0YVRpbWUgJiYgZGF0YVRpbWUgPD0gcVBhcmFtcy5kYXRhRW5kVGltZSkge1xuICAgICAgICAgICAgICAgIHJlc3VsdEhhbmRsZXIoY29udGV4dC5fZmlsdGVycy5JTkNMVURFKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0SGFuZGxlcihjb250ZXh0Ll9maWx0ZXJzLkVYQ0xVREUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmVzdWx0SGFuZGxlcihjb250ZXh0Ll9maWx0ZXJzLl9jaGVja1NhbWVQcm9wcyhbJ2RhdGFMYXlvdXQnLCAnYnJhbmNoJ10sIHFQYXJhbXMsIG1vZGVsKSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBtc1NxbEF2YWlsYWJpbGl0eUdyb3VwTGlzdGVuZXJGaWx0ZXIoY29sbGVjdGlvbiwgbW9kZWwsIHJlc3VsdEhhbmRsZXIpIHtcbiAgICAgICAgdmFyIHFQYXJhbXMgPSBjb2xsZWN0aW9uLmdldFF1ZXJ5UGFyYW1ldGVycygpIHx8IHt9O1xuXG4gICAgICAgIC8qXG4gICAgICAgICAqIE1TU3FsQXZhaWxhYmlsaXR5R3JvdXBMaXN0ZW5lcidzIGRvIG5vdCBoYXZlIHJlZmVyZW5jZXMsIHNvIHRoZXJlIGlzIG5vIHdheSB0byBjaGVjayBpZiB0aGV5IGJlbG9uZyB0byBhblxuICAgICAgICAgKiBhdmFpbGFiaWxpdHkgZ3JvdXAuXG4gICAgICAgICAqL1xuICAgICAgICBpZiAocVBhcmFtcy5hdmFpbGFiaWxpdHlncm91cCkge1xuICAgICAgICAgICAgcmVzdWx0SGFuZGxlcihjb250ZXh0Ll9maWx0ZXJzLlVOS05PV04pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmVzdWx0SGFuZGxlcihjb250ZXh0Ll9maWx0ZXJzLklOQ0xVREUpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbXNTcWxDbHVzdGVySW5zdGFuY2VGaWx0ZXIoY29sbGVjdGlvbiwgbW9kZWwsIHJlc3VsdEhhbmRsZXIpIHtcbiAgICAgICAgdmFyIHFQYXJhbXMgPSBjb2xsZWN0aW9uLmdldFF1ZXJ5UGFyYW1ldGVycygpIHx8IHt9O1xuXG4gICAgICAgIC8qXG4gICAgICAgICAqIE1TU3FsQ2x1c3Rlckluc3RhbmNlJ3MgZG8gbm90IGhhdmUgcmVmZXJlbmNlcywgc28gdGhlcmUgaXMgbm8gd2F5IHRvIGNoZWNrIGlmIHRoZXkgYmVsb25nIHRvIGFuIGF2YWlsYWJpbGl0eVxuICAgICAgICAgKiBncm91cC5cbiAgICAgICAgICovXG4gICAgICAgIGlmIChxUGFyYW1zLmF2YWlsYWJpbGl0eWdyb3VwKSB7XG4gICAgICAgICAgICByZXN1bHRIYW5kbGVyKGNvbnRleHQuX2ZpbHRlcnMuVU5LTk9XTik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXN1bHRIYW5kbGVyKGNvbnRleHQuX2ZpbHRlcnMuSU5DTFVERSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBzb3VyY2VGaWx0ZXIoY29sbGVjdGlvbiwgbW9kZWwsIHJlc3VsdEhhbmRsZXIpIHtcbiAgICAgICAgdmFyIHFQYXJhbXMgPSBjb2xsZWN0aW9uLmdldFF1ZXJ5UGFyYW1ldGVycygpIHx8IHt9O1xuXG4gICAgICAgIC8vIHF1ZXJ5IHBhcmFtZXRlcnMgZm9yIFNvdXJjZSBhcmUgbXV0dWFsbHkgZXhjbHVzaXZlLCBtZWFuaW5nIHdlIGNhbiBvbmx5ICQkbGlzdCBieSBvbmUgYXQgYSB0aW1lXG4gICAgICAgIGlmIChfLmtleXMocVBhcmFtcykubGVuZ3RoID4gMSkge1xuICAgICAgICAgICAgZHhVdGlsLmZhaWwoJ1lvdSBjYW5ub3QgcHJvdmlkZSBtb3JlIHRoYW4gb25lIHF1ZXJ5IHBhcmFtZXRlciBmb3IgJCRsaXN0IGZvciBTb3VyY2UuJyk7XG4gICAgICAgIH1cblxuICAgICAgICB1YmVyRmlsdGVyKGNvbGxlY3Rpb24sIG1vZGVsLCByZXN1bHRIYW5kbGVyKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiB0aW1lZmxvd1NuYXBzaG90RmlsdGVyKGNvbGxlY3Rpb24sIG1vZGVsLCByZXN1bHRIYW5kbGVyKSB7XG4gICAgICAgIHZhciBxUGFyYW1zID0gY29sbGVjdGlvbi5nZXRRdWVyeVBhcmFtZXRlcnMoKSB8fCB7fTtcblxuICAgICAgICBpZiAocVBhcmFtcy50cmF2ZXJzZVRpbWVmbG93cyA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgZHhVdGlsLmZhaWwoJ3RyYXZlcnNlVGltZWZsb3dzIHF1ZXJ5IHBhcmFtZXRlciBpcyBub3QgeWV0IHN1cHBvcnRlZCBieSB0aGUgZmlsdGVyLicpO1xuICAgICAgICB9XG5cbiAgICAgICAgdWJlckZpbHRlcihjb2xsZWN0aW9uLCBtb2RlbCwgcmVzdWx0SGFuZGxlcik7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gam9iRmlsdGVyKGNvbGxlY3Rpb24sIG1vZGVsLCByZXN1bHRIYW5kbGVyKSB7XG4gICAgICAgIHViZXJGaWx0ZXIoY29sbGVjdGlvbiwgbW9kZWwsIHJlc3VsdEhhbmRsZXIsICdhZGRFdmVudHMnKTsgIC8vIGlnbm9yZSBhZGRFdmVudHNcbiAgICB9XG5cbiAgICAvKlxuICAgICAqIERvIHRoZSByZWFsIHdvcmsuXG4gICAgICovXG4gICAgY29udGV4dCA9IGNvbnRleHQgfHwgdGhpcztcbiAgICBkeEZpbHRlci5faW5pdEZpbHRlcnMoY29udGV4dCk7XG4gICAgY29udGV4dC5fZmlsdGVycyA9IGNvbnRleHQuX2ZpbHRlcnMgfHwge307XG4gICAgdmFyIGdlbmVyaWNGaWx0ZXIgPSBjb250ZXh0Ll9maWx0ZXJzLl9nZW5lcmljRmlsdGVyO1xuICAgIHZhciB1YmVyRmlsdGVyID0gY29udGV4dC5fZmlsdGVycy5fdWJlckZpbHRlcjtcblxuICAgIF8uZXh0ZW5kKGNvbnRleHQuX2ZpbHRlcnMsIHtcbiAgICAgICAgQWN0aW9uOiBhY3Rpb25GaWx0ZXIsXG4gICAgICAgIEFsZXJ0OiBhbGVydEZpbHRlcixcbiAgICAgICAgQWxlcnRQcm9maWxlOiBnZW5lcmljRmlsdGVyLFxuICAgICAgICBUb29sa2l0OiBnZW5lcmljRmlsdGVyLFxuICAgICAgICBBdXRob3JpemF0aW9uOiBhdXRob3JpemF0aW9uRmlsdGVyLFxuICAgICAgICBDb250YWluZXI6IGNvbnRhaW5lckZpbHRlcixcbiAgICAgICAgQ3VycmVudENvbnN1bWVyQ2FwYWNpdHlEYXRhOiBnZW5lcmljRmlsdGVyLFxuICAgICAgICBDdXJyZW50R3JvdXBDYXBhY2l0eURhdGE6IGdlbmVyaWNGaWx0ZXIsXG4gICAgICAgIERhdGFiYXNlVGVtcGxhdGU6IGdlbmVyaWNGaWx0ZXIsXG4gICAgICAgIEVudmlyb25tZW50VXNlcjogdWJlckZpbHRlcixcbiAgICAgICAgRmF1bHQ6IHViZXJGaWx0ZXIsXG4gICAgICAgIEZhdWx0RWZmZWN0OiB1YmVyRmlsdGVyLFxuICAgICAgICBHcm91cDogZ2VuZXJpY0ZpbHRlcixcbiAgICAgICAgSGlzdG9yaWNhbENvbnN1bWVyQ2FwYWNpdHlEYXRhOiB1YmVyRmlsdGVyLFxuICAgICAgICBIaXN0b3JpY2FsR3JvdXBDYXBhY2l0eURhdGE6IHViZXJGaWx0ZXIsXG4gICAgICAgIEhpc3RvcmljYWxTeXN0ZW1DYXBhY2l0eURhdGE6IHViZXJGaWx0ZXIsXG4gICAgICAgIEhvc3Q6IGhvc3RGaWx0ZXIsXG4gICAgICAgIEhvc3RQcml2aWxlZ2VFbGV2YXRpb25Qcm9maWxlOiBnZW5lcmljRmlsdGVyLFxuICAgICAgICBKb2I6IGpvYkZpbHRlcixcbiAgICAgICAgSlNCb29rbWFyazoganNCb29rbWFya0ZpbHRlcixcbiAgICAgICAgSlNCcmFuY2g6IHViZXJGaWx0ZXIsXG4gICAgICAgIEpTRGFpbHlPcGVyYXRpb25EdXJhdGlvbjogdWJlckZpbHRlcixcbiAgICAgICAgSlNEYXRhQ29udGFpbmVyOiBqc0RhdGFDb250YWluZXJGaWx0ZXIsXG4gICAgICAgIEpTRGF0YVNvdXJjZTogdWJlckZpbHRlcixcbiAgICAgICAgSlNEYXRhVGVtcGxhdGU6IGdlbmVyaWNGaWx0ZXIsXG4gICAgICAgIEpTT3BlcmF0aW9uOiBqc09wZXJhdGlvbkZpbHRlcixcbiAgICAgICAgSlNXZWVrbHlPcGVyYXRpb25Db3VudDogdWJlckZpbHRlcixcbiAgICAgICAgTGRhcFNlcnZlcjogZ2VuZXJpY0ZpbHRlcixcbiAgICAgICAgTVNTcWxBdmFpbGFiaWxpdHlHcm91cExpc3RlbmVyOiBtc1NxbEF2YWlsYWJpbGl0eUdyb3VwTGlzdGVuZXJGaWx0ZXIsXG4gICAgICAgIE1TU3FsQ2x1c3Rlckluc3RhbmNlOiBtc1NxbENsdXN0ZXJJbnN0YW5jZUZpbHRlcixcbiAgICAgICAgTmFtZXNwYWNlOiBnZW5lcmljRmlsdGVyLFxuICAgICAgICBOZXR3b3JrSW50ZXJmYWNlOiBnZW5lcmljRmlsdGVyLFxuICAgICAgICBOZXR3b3JrTGF0ZW5jeVRlc3Q6IGdlbmVyaWNGaWx0ZXIsXG4gICAgICAgIE5ldHdvcmtSb3V0ZTogZ2VuZXJpY0ZpbHRlcixcbiAgICAgICAgTmV0d29ya1Rocm91Z2hwdXRUZXN0OiBnZW5lcmljRmlsdGVyLFxuICAgICAgICBOb3RpZmljYXRpb246IGdlbmVyaWNGaWx0ZXIsXG4gICAgICAgIE9wZXJhdGlvblRlbXBsYXRlOiBnZW5lcmljRmlsdGVyLFxuICAgICAgICBPcmFjbGVDbHVzdGVyTm9kZTogdWJlckZpbHRlcixcbiAgICAgICAgT3JhY2xlTGlzdGVuZXI6IHViZXJGaWx0ZXIsXG4gICAgICAgIE9yYWNsZVBEQkNvbmZpZzogdWJlckZpbHRlcixcbiAgICAgICAgUGVybWlzc2lvbjogZ2VuZXJpY0ZpbHRlcixcbiAgICAgICAgUmVwbGljYXRpb25TcGVjOiBnZW5lcmljRmlsdGVyLFxuICAgICAgICBSb2xlOiBnZW5lcmljRmlsdGVyLFxuICAgICAgICBTTk1QTWFuYWdlcjogZ2VuZXJpY0ZpbHRlcixcbiAgICAgICAgU291cmNlOiBzb3VyY2VGaWx0ZXIsXG4gICAgICAgIFNvdXJjZUNvbmZpZzogdWJlckZpbHRlcixcbiAgICAgICAgU291cmNlRW52aXJvbm1lbnQ6IHViZXJGaWx0ZXIsXG4gICAgICAgIFNvdXJjZVJlcG9zaXRvcnk6IHViZXJGaWx0ZXIsXG4gICAgICAgIFNuYXBzaG90Q2FwYWNpdHlEYXRhOiB1YmVyRmlsdGVyLFxuICAgICAgICBTdGF0aXN0aWM6IGdlbmVyaWNGaWx0ZXIsXG4gICAgICAgIFN0YXRpc3RpY1NsaWNlOiBnZW5lcmljRmlsdGVyLFxuICAgICAgICBTdG9yYWdlRGV2aWNlOiBnZW5lcmljRmlsdGVyLFxuICAgICAgICBTeXN0ZW1WZXJzaW9uOiBnZW5lcmljRmlsdGVyLFxuICAgICAgICBUaW1lZmxvdzogdWJlckZpbHRlcixcbiAgICAgICAgVGltZWZsb3dCb29rbWFyazogdWJlckZpbHRlcixcbiAgICAgICAgVGltZWZsb3dTbmFwc2hvdDogdGltZWZsb3dTbmFwc2hvdEZpbHRlcixcbiAgICAgICAgVHlwZWRPYmplY3Q6IGdlbmVyaWNGaWx0ZXIsXG4gICAgICAgIFVzZXI6IHViZXJGaWx0ZXIsXG4gICAgICAgIFdpbmRvd3NDbHVzdGVyTm9kZTogdWJlckZpbHRlcixcbiAgICAgICAgWDUwOUNlcnRpZmljYXRlOiBnZW5lcmljRmlsdGVyXG4gICAgfSk7XG59O1xuIiwiLypcbiAqIENvcHlyaWdodCAoYykgMjAxNCwgMjAxNSBieSBEZWxwaGl4LiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICovXG5cbi8qIGdsb2JhbCBfLCBCYWNrYm9uZSwga28gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCBkeFV0aWwgPSByZXF1aXJlKCdkeGNvcmUvanMvdXRpbC5qcycpLFxuICAgIGR4U2NyZWVuID0gcmVxdWlyZSgnZHhjb3JlL2pzL3NjcmVlbi5qcycpO1xuXG4vKlxuICogRGVmaW5lcyBhIG5ldyBwcm94eSwgdXNpbmcgdGhlIHNwZWNpZmllZCBtYXBwaW5nLiBUaGUgbWFwcGluZyBtdXN0IGhhdmUgb25lIG9mIHRoZSBmb2xsb3dpbmcgZm9ybXM6XG4gKiB7XG4gKiAgICBhdHRyaWJ1dGVOYW1lOiAnYXR0cmlidXRlLnBhdGgudG8uZGVzaXJlZC5hdHRyaWJ1dGUnLFxuICogICAgLi4uXG4gKiB9XG4gKiBvclxuICoge1xuICogICAgYXR0cmlidXRlTmFtZToge1xuICogICAgICAgcGF0aDogJ2F0dHJpYnV0ZS5wYXRoLnRvLmRlc2lyZWQuYXR0cmlidXRlJ1ssXG4gKiAgICAgICBzZXR0ZXI6IGZ1bmN0aW9uKG5hbWUsIHZhbHVlKSB7Li4ufV1cbiAqICAgIC4uLlxuICogfVxuICpcbiAqIFRoZSBwYXRoIG1heSBpbmNsdWRlIFwiJG5hbWVcIiwgd2hlcmUgdGhhdCBpcyBhIHJlZmVyZW5jZSB0byBhIGRlbHBoaXggYmFja2JvbmUgbW9kZWwsIHdoZXJlIHRoZXJlIGlzIGEgYmFja2JvbmVcbiAqIGF0dHJpYnV0ZSBuYW1lZCBcIm5hbWVcIiBwb3RlbnRpYWxseSBhdmFpbGFibGUuXG4gKlxuICogSWYgYSBzZXR0ZXIgaXMgcHJvdmlkZWQsIHRoZW4gd2hlbiB0aGUgc2V0KCkgbWV0aG9kIGlzIGNhbGxlZCBvbiB0aGUgcHJveHksIHRoZSBwcm92aWRlZCBmdW5jdGlvbiB3aWxsIGJlIGNhbGxlZC5cbiAqIFRoaXMgYWxsb3dzIG9uZSB0byByZXNwb25kIHRvIGNoYW5nZXMgaW5wdXQgYnkgdGhlIHVzZXIgd2l0aG91dCBkaXJlY3RseSBtb2RpZnlpbmcgdGhlIHVuZGVybHlpbmcgb2JqZWN0cyAod2hpY2hcbiAqIHNob3VsZCBiZSBiZWluZyB0cmVhdGVkIGFzIHJlYWQtb25seSBvYmplY3RzLlxuICpcbiAqIFRoZSBsZWFmIGF0dHJpYnV0ZSBpbiB0aGUgY2hhaW4gbWF5IGJlIGEgbW9kZWwgb3IgYSBub24tbW9kZWwgdmFsdWUuICBFYWNoIGludGVybWVkaWF0ZSBzZWdtZW50LCBob3dldmVyLCBtdXN0IGJlXG4gKiBhIEJhY2tib25lIG1vZGVsLiBJZiBvbmUgaXMgbm90LCB0aGVuIHRoZSBwcm94eSB3aWxsIG5vdCB0cmF2ZXJzZSBiZXlvbmQgaXQsIHVudGlsIGl0IGlzIGNoYW5nZWQgdG8gYSBCYWNrYm9uZSBtb2RlbC5cbiAqXG4gKiBBIHByb3h5IHNldHMgdXAgYSBzZXQgb2YgYXR0cmlidXRlIGNoYW5nZSBsaXN0ZW5lcnMsIG9uZSBmb3IgZWFjaCBtb2RlbCBvbiB0aGUgY2hhaW4uIEFueSB0aW1lIGFueSBzZWdtZW50IGluIHRoZVxuICogcGF0aCBjaGFuZ2VzLCB0aGUgcHJveHkgd2lsbCByZS1ldmFsdWF0ZSBmb2xsb3dpbmcgc2VnbWVudHMgaW4gdGhlIHBhdGguXG4gKlxuICogQSBzaW5nbGUgc2VnbWVudCBpbiB0aGUgcGF0aCBjYW4gY2hhbmdlIGF0IGFueSB0aW1lLCBhbmQgbWF5IHRha2Ugb24gbnVsbCwgdW5kZWZpbmVkLCBvciBvdGhlciB2YWx1ZXMgYXQgYW55XG4gKiB0aW1lLiBJZiBhIHBhdGggY2FuIG5vdCBiZSB0cmF2ZXJzZWQgdGhlbiB0aGUgcHJveHkncyBhdHRyaWJ1dGUgaXMgc2V0IHRvIHVuZGVmaW5lZC5cbiAqXG4gKiBNZW1vcnkgTWFuYWdlbWVudDpcbiAqIEluIG9yZGVyIHRvIGF2b2lkIGEgcHJveHkgZnJvbSBiZWluZyBsZWFrZWQgKGR1ZSB0byBsaXN0ZW5lcnMgb24gdGhlIG1vZGVscyByZWZlcmVuY2luZyBpdCksIGEgcHJveHkgd2lsbCBzY2hlZHVsZVxuICogaXRzZWxmIHRvIGJlIFwiZGVzdHJveWVkXCIgd2hlbiB0aGUgc2NyZWVuIGNoYW5nZXMuIERlc3RydWN0aW9uIG1lYW5zIHRoYXQgaXQgcmVsZWFzZXMgYWxsIG9mIGl0cyBhdHRyaWJ1dGUgbGlzdGVuZXJzXG4gKiBhbmQgcmVtb3ZlcyBpdHMga25vd2xlZGdlIG9mIHRoZSBwcm9wZXJ0aWVzIGl0IHdhcyBwYXNzZWQuICBIb3dldmVyLCB3aGVuIHRoZSBzY3JlZW4gY2hhbmdlcywgaWYgdGhlIHByb3h5IGl0c2VsZlxuICogaGFzIGxpc3RlbmVycyBsaXN0ZW5pbmcgdG8gaXQsIHRoZW4gaXQgd2lsbCByZXNjaGVkdWxlIGl0c2VsZiB0byBiZSBkZXN0cm95ZWQgb24gdGhlIG5leHQgc2NyZWVuIGNoYW5nZS4gVGh1cywgYXNcbiAqIGxvbmcgYXMgeW91IGFyZSBhcmUgbGlzdGVuaW5nIGZvciBldmVudHMgb24gdGhlIHByb3h5LCBpdCB3aWxsIHN0YXkgYXJvdW5kLlxuICovXG5tb2R1bGUuZXhwb3J0cy5uZXdQcm94eSA9IGZ1bmN0aW9uIG5ld1Byb3h5KHNvdXJjZU1hcHBpbmcpIHtcbiAgICAvLyBUaGUgbW9kZWwgdGhpcyBpcyBjdXJyZW50bHkgbG9va2luZyB1cCBwcm9wZXJ0aWVzIGZyb21cbiAgICB2YXIgYmFzZU1vZGVsO1xuXG4gICAgLy8gdGhlIHByb3h5J3MgYXR0cmlidXRlcyBhbmQgdGhlaXIgYXNzb2NpYXRlZCBhdHRyaWJ1dGUtcGF0aHNcbiAgICB2YXIgcHJveHlBdHRyVG9BdHRyUGF0aHMgPSB7fTtcblxuICAgIC8vIEN1cnJlbnQgdmFsdWVzIG9mIHRoZSBwcm94eSBhdHRyaWJ1dGVzXG4gICAgdmFyIHByb3h5QXR0clZhbHVlcyA9IHt9O1xuXG4gICAgLy8gRnVuY3Rpb25zIHVzZWQgdG8gcmVtb3ZlIGxpc3RlbmVycyB3YXRjaGluZyBlYWNoIGF0dHJpYnV0ZSBwYXRoXG4gICAgdmFyIHByb3h5QXR0cnNSZW1vdmVycyA9IHt9O1xuXG4gICAgLypcbiAgICAgKiBFeGFtaW5lcyB0aGUgbmV4dCBsaW5rIGluIHRoZSBhdHRyaWJ1dGUgcGF0aC4gIElmIGl0IGlzIGEgYmFja2JvbmUgbW9kZWwsIHNldCB1cCBsaXN0ZW5lcnMgZm9yIGl0LCBvdGhlcndpc2VcbiAgICAgKiB0aGUgb2JqZWN0IGlzIHRoZSBlbmQgb2YgdGhlIHBhdGgsIHNvIGNhY2hlIHRoZSB2YWx1ZSBpbiB0aGUgcHJveHlBdHRyVmFsdWVzLlxuICAgICAqXG4gICAgICogYW5PYmplY3Q6IFRoZSBvYmplY3QgYXQgdGhlIG5leHQgbGluayBpbiB0aGUgcGF0aC4gQ2FuIGJlIGFueXRoaW5nIGluY2x1ZGluZyBudWxsIG9yIHVuZGVmaW5lZC5cbiAgICAgKiBhdHRyUGF0aDogVGhlIHJlbWFpbmRlciBvZiB0aGUgYXR0cmlidXRlIHBhdGggdGhhdCBzaG91bGQgYmUgZXhhbWluZWQuIE1heSBiZSBhbiBlbXB0eSBhcnJheS5cbiAgICAgKiBwcm94eUF0dHI6IFRoZSBhdHRyaWJ1dGUgdGhpcyBpcyBjdXJyZW50bHkgY29uY2VybmVkIHdpdGguXG4gICAgICovXG4gICAgZnVuY3Rpb24gZXhhbWluZU5leHRQYXRoU2VnbWVudChwcm94eSwgYW5PYmplY3QsIGF0dHJQYXRoLCBwcm94eUF0dHIpIHtcbiAgICAgICAgLypcbiAgICAgICAgICogSWYgYW55IG9mIHRoZXNlIGNvbmRpdGlvbnMgYXJlIG1ldCwgd2UndmUgcmVhY2hlZCB0aGUgY3VycmVudCBlbmQgb2YgdGhlIGF0dHJpYnV0ZSBwYXRoLiAgU28sIHN0b3JlIHRoZVxuICAgICAgICAgKiBvYmplY3QgYXMgdGhlIGN1cnJlbnQgdmFsdWUgb2YgdGhlIGF0dHJpYnV0ZSBhbmQgZmlyZSBhIGNoYW5nZSBldmVudC5cbiAgICAgICAgICovXG4gICAgICAgIGlmIChfLmlzRW1wdHkoYXR0clBhdGgpIHx8IF8uaXNVbmRlZmluZWQoYW5PYmplY3QpIHx8IF8uaXNOdWxsKGFuT2JqZWN0KSB8fFxuICAgICAgICAgICAgKCEoYW5PYmplY3QgaW5zdGFuY2VvZiBCYWNrYm9uZS5Nb2RlbCkpKSB7XG4gICAgICAgICAgICBpZiAoIV8uaXNFbXB0eShhdHRyUGF0aCkpIHtcbiAgICAgICAgICAgICAgICBhbk9iamVjdCA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHByb3h5QXR0clZhbHVlc1twcm94eUF0dHJdICE9PSBhbk9iamVjdCkge1xuICAgICAgICAgICAgICAgIHByb3h5QXR0clZhbHVlc1twcm94eUF0dHJdID0gYW5PYmplY3Q7XG4gICAgICAgICAgICAgICAgcHJveHkudHJpZ2dlcignY2hhbmdlOicgKyBwcm94eUF0dHIpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24oKSB7IC8qIGRvIG5vdGhpbmcsIGFzIHRoZXJlIGFyZSBubyBsaXN0ZW5lcnMgdG8gcmVtb3ZlICovfTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8qXG4gICAgICAgICAqIEFzIHdlIG5vdyBrbm93IHdlIGhhdmUgYSBiYWNrYm9uZSBtb2RlbCwgcHJlcGFyZSB0byBzdGFydCBsaXN0ZW4gdG8gaXQuIE5vdGUgdGhhdCB3ZSBkbyBzb21lIHNwZWNpYWwtY2FzaW5nXG4gICAgICAgICAqIHNpbmNlIHRoZSBuZXh0IGF0dHJpYnV0ZSBpbiB0aGUgYXR0cmlidXRlIHBhdGggbWlnaHQgYmUgYW4gb3JkaW5hcnkgYmFja2JvbmUgcHJvcGVydHksIG9yIGl0IG1pZ2h0IGJlIG9uZVxuICAgICAgICAgKiBvZiBvdXIgY3VzdG9tIHJlZmVyZW5jZWQtb2JqZWN0IGFjY2Vzc29ycy5cbiAgICAgICAgICovXG4gICAgICAgIHZhciBtb2RlbEF0dHIgPSBhdHRyUGF0aFswXTtcbiAgICAgICAgdmFyIGJhc2ljQXR0ciA9IChtb2RlbEF0dHIuY2hhckF0KDApID09PSAnJCcpID8gbW9kZWxBdHRyLnN1YnN0cmluZygxKSA6IG1vZGVsQXR0cjtcblxuICAgICAgICByZXR1cm4gbGlzdGVuVG9Nb2RlbChwcm94eSwgYW5PYmplY3QsIGJhc2ljQXR0ciwgbW9kZWxBdHRyLCBhdHRyUGF0aC5zbGljZSgxKSwgcHJveHlBdHRyKTtcbiAgICB9XG5cbiAgICAvKlxuICAgICAqIFNldCB1cCBhIGxpc3RlbmVyIG9uIHRoZSBzcGVjaWZpZWQgbW9kZWwsIGFuZCB0aGVuIHN0YXJ0IHRoZSBzYW1lIHByb2Nlc3Mgb24gbW9kZWxzIGZ1cnRoZXIgZG93biB0aGVcbiAgICAgKiBhdHRyaWJ1dGUgY2hhaW4uXG4gICAgICpcbiAgICAgKiBUaGlzIHJldHVybnMgYSBmdW5jdGlvbiB3aGljaCwgd2hlbiBjYWxsZWQsIHdpbGwgcmVtb3ZlIHRoZSBsaXN0ZW5lciB0aGF0IHRoaXMgY3JlYXRlZC5cbiAgICAgKlxuICAgICAqIG1vZGVsOiBUaGUgbW9kZWwgdGhhdCB0aGlzIHdpbGwgYmUgbGlzdGVuaW5nIHRvLiBUaGlzIGlzIGFsd2F5cyBhIEJhY2tib25lIG1vZGVsXG4gICAgICogYmFzZUF0dHI6IFRoZSBhdHRyaWJ1dGUgdGhhdCB0aGlzIHdpbGwgYmUgbGlzdGVuaW5nIHRvXG4gICAgICogZnVsbEF0dHI6IFRoZSBmdWxsIG5hbWUgb2YgdGhlIGF0dHJpYnV0ZSAoc2FtZSBhcyBiYXNlQXR0ciwgdW5sZXNzIHRoaXMgc3RhcnRzIHdpdGggJClcbiAgICAgKiBhdHRyU3ViUGF0aDogQW4gYXJyYXkgb2Ygc3RyaW5ncyB0aGF0IGFyZSB0aGUgcmVtYWluaW5nIGF0dHJpYnV0ZXMgYWxvbmcgdGhlIGF0dHJpYnV0ZSBwYXRoXG4gICAgICogcHJveHlBdHRyOiBUaGUgcHJveHkgYXR0cmlidXRlIHRoYXQgYWxsIG9mIHRoaXMgaXMgcmVsYXRlZCB0by5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBsaXN0ZW5Ub01vZGVsKHByb3h5LCBtb2RlbCwgYmFzZUF0dHIsIGZ1bGxBdHRyLCBhdHRyU3ViUGF0aCwgcHJveHlBdHRyKSB7XG4gICAgICAgIHZhciBzdWJQYXRoUmVtb3ZlcjtcbiAgICAgICAgdmFyIHJlYWR5UmVtb3ZlcjtcblxuICAgICAgICAvKlxuICAgICAgICAgKiBFeGFtaW5lIHRoZSBuZXh0IHBhdGggc2VnbWVudC4gSWYgaXQgcmVzdWx0cyBpbiBhIGNoYW5nZWQgdmFsdWUsIGZpcmUgYSBjaGFuZ2UgZXZlbnRcbiAgICAgICAgICovXG4gICAgICAgIGZ1bmN0aW9uIGV4YW1pbmVOZXh0UGF0aEFuZFRyaWdnZXJJZkNoYW5nZShuZXdNb2RlbCwgYmVmb3JlKSB7XG4gICAgICAgICAgICBzdWJQYXRoUmVtb3ZlciA9IGV4YW1pbmVOZXh0UGF0aFNlZ21lbnQocHJveHksIG5ld01vZGVsLCBhdHRyU3ViUGF0aCwgcHJveHlBdHRyKTtcbiAgICAgICAgICAgIGlmIChiZWZvcmUgIT09IHByb3h5QXR0clZhbHVlc1twcm94eUF0dHJdKSB7XG4gICAgICAgICAgICAgICAgcHJveHkudHJpZ2dlcignY2hhbmdlJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLypcbiAgICAgICAgICogTGlzdGVuZXIgZm9yIHRoaXMgbW9kZWwrbW9kZWxBdHRyaWJ1dGUuIFdoZW4gdGhlIG1vZGVsIGF0dHJpYnV0ZSBjaGFuZ2VzLCB0aGlzIHdpbGwgcmVtb3ZlIGFueSBwcmV2aW91c2x5XG4gICAgICAgICAqIGV4aXN0aW5nIGxpc3RlbmVycywgYW5kIHRoZW4gYnVpbGQgbmV3IGxpc3RlbmVycyBmb3Igc3ViLW1vZGVscyBpbiB0aGUgYXR0cmlidXRlIHBhdGhcbiAgICAgICAgICovXG4gICAgICAgIGZ1bmN0aW9uIGNoYW5nZUxpc3RlbmVyKGNoYW5nZWRNb2RlbCkge1xuICAgICAgICAgICAgc3ViUGF0aFJlbW92ZXIoKTtcblxuICAgICAgICAgICAgdmFyIG5ld01vZGVsID0gY2hhbmdlZE1vZGVsLmdldChmdWxsQXR0cik7XG4gICAgICAgICAgICBpZiAoaXNEZWxwaGl4TW9kZWwobmV3TW9kZWwpKSB7XG4gICAgICAgICAgICAgICAgdmFyIHJlYWR5SGFuZGxlciA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICBleGFtaW5lTmV4dFBhdGhBbmRUcmlnZ2VySWZDaGFuZ2UobmV3TW9kZWwsIHByb3h5QXR0clZhbHVlc1twcm94eUF0dHJdKTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIG5ld01vZGVsLm9uY2UoJ3JlYWR5JywgcmVhZHlIYW5kbGVyKTtcbiAgICAgICAgICAgICAgICByZWFkeVJlbW92ZXIgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgbmV3TW9kZWwub2ZmKCdyZWFkeScsIHJlYWR5SGFuZGxlcik7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgZXhhbWluZU5leHRQYXRoQW5kVHJpZ2dlcklmQ2hhbmdlKG5ld01vZGVsLCBwcm94eUF0dHJWYWx1ZXNbcHJveHlBdHRyXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvKlxuICAgICAgICAgKiBSb3V0aW5lIHVzZWQgdG8gcmVtb3ZlIHRoZSBsaXN0ZW5lciB0aGF0IHdpbGwgaGF2ZSBiZWVuIHNldCB1cCBqdXN0IGJlbG93LCBhcyB3ZWxsIGFzIGFueSBzdWItbGlzdGVuZXJzXG4gICAgICAgICAqL1xuICAgICAgICBmdW5jdGlvbiBjaGFuZ2VMaXN0ZW5lclJlbW92ZXIoKSB7XG4gICAgICAgICAgICBtb2RlbC5vZmYoJ2NoYW5nZTonICsgYmFzZUF0dHIsIGNoYW5nZUxpc3RlbmVyKTtcbiAgICAgICAgICAgIGlmIChzdWJQYXRoUmVtb3Zlcikge1xuICAgICAgICAgICAgICAgIHN1YlBhdGhSZW1vdmVyKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocmVhZHlSZW1vdmVyKSB7XG4gICAgICAgICAgICAgICAgcmVhZHlSZW1vdmVyKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgbmV3TW9kZWwgPSBtb2RlbC5nZXQoZnVsbEF0dHIpO1xuICAgICAgICBpZiAoaXNEZWxwaGl4TW9kZWwobmV3TW9kZWwpKSB7XG4gICAgICAgICAgICB2YXIgcmVhZHlIYW5kbGVyID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgZXhhbWluZU5leHRQYXRoQW5kVHJpZ2dlcklmQ2hhbmdlKG5ld01vZGVsLCBwcm94eUF0dHJWYWx1ZXNbcHJveHlBdHRyXSk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgbmV3TW9kZWwub25jZSgncmVhZHknLCByZWFkeUhhbmRsZXIpO1xuICAgICAgICAgICAgcmVhZHlSZW1vdmVyID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgbmV3TW9kZWwub2ZmKCdyZWFkeScsIHJlYWR5SGFuZGxlcik7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgc3ViUGF0aFJlbW92ZXIgPSBleGFtaW5lTmV4dFBhdGhTZWdtZW50KHByb3h5LCBuZXdNb2RlbCwgYXR0clN1YlBhdGgsIHByb3h5QXR0cik7XG4gICAgICAgIH1cblxuICAgICAgICBtb2RlbC5vbignY2hhbmdlOicgKyBiYXNlQXR0ciwgY2hhbmdlTGlzdGVuZXIpO1xuXG4gICAgICAgIHJldHVybiBjaGFuZ2VMaXN0ZW5lclJlbW92ZXI7XG4gICAgfVxuXG4gICAgLypcbiAgICAgKiBJdGVyYXRlIG92ZXIgZWFjaCBvZiB0aGUgcHJveHkgYXR0cmlidXRlIC0tPiBhdHRyaWJ1dGUgcGF0aHMgbWFwcGluZyB2YWx1ZXMsIGFuZCBidWlsZCBhIGNoYWluIG9mIGxpc3RlbmVyc1xuICAgICAqIGZvciBlYWNoLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGxpc3RlblRvQmFzZU1vZGVsKHByb3h5LCBuZXdNb2RlbCkge1xuICAgICAgICBmdW5jdGlvbiBwcm9jZXNzTW9kZWwoKSB7XG4gICAgICAgICAgICBwcm9jZXNzQmFzZU1vZGVsKHByb3h5LCBiYXNlTW9kZWwpO1xuICAgICAgICB9XG4gICAgICAgIC8vIGNsZWFuIHVwIGFueSByZW1haW5pbmcgbGlzdGVuZXJzXG4gICAgICAgIF8uZWFjaChwcm94eUF0dHJzUmVtb3ZlcnMsIGZ1bmN0aW9uKHJlbW92ZXIpIHtcbiAgICAgICAgICAgIHJlbW92ZXIoKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgaWYgKGlzRGVscGhpeE1vZGVsKGJhc2VNb2RlbCkpIHtcbiAgICAgICAgICAgIGJhc2VNb2RlbC5vZmYoJ3JlYWR5JywgcHJvY2Vzc01vZGVsKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGJhc2VNb2RlbCA9IG5ld01vZGVsO1xuXG4gICAgICAgIGlmIChpc0RlbHBoaXhNb2RlbChiYXNlTW9kZWwpKSB7XG4gICAgICAgICAgICBiYXNlTW9kZWwub25jZSgncmVhZHknLCBwcm9jZXNzTW9kZWwpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcHJvY2Vzc01vZGVsKCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKlxuICAgICAqIEl0ZXJhdGUgb3ZlciBhbGwgdGhlIHByb3h5IGF0dHJpYnV0ZXMsIHNldCB1cCBsaXN0ZW5lcnMgYW5kIGZpcmUgY2hhbmdlIGV2ZW50IGlmIGFwcHJvcHJpYXRlLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHByb2Nlc3NCYXNlTW9kZWwocHJveHksIGJhc2VNb2RlbCkge1xuICAgICAgICB2YXIgY2hhbmdlcyA9IGZhbHNlO1xuXG4gICAgICAgIF8uZWFjaChwcm94eUF0dHJUb0F0dHJQYXRocywgZnVuY3Rpb24oYXR0clBhdGgsIHByb3h5QXR0cikge1xuICAgICAgICAgICAgdmFyIGJlZm9yZSA9IHByb3h5QXR0clZhbHVlc1twcm94eUF0dHJdO1xuICAgICAgICAgICAgcHJveHlBdHRyc1JlbW92ZXJzW3Byb3h5QXR0cl0gPSBleGFtaW5lTmV4dFBhdGhTZWdtZW50KHByb3h5LCBiYXNlTW9kZWwsIGF0dHJQYXRoLnBhdGgsIHByb3h5QXR0cik7XG4gICAgICAgICAgICBpZiAoYmVmb3JlICE9PSBwcm94eUF0dHJWYWx1ZXNbcHJveHlBdHRyXSkge1xuICAgICAgICAgICAgICAgIGNoYW5nZXMgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICBpZiAoY2hhbmdlcykge1xuICAgICAgICAgICAgcHJveHkudHJpZ2dlcignY2hhbmdlJyk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKlxuICAgICAqIFJldHVybiB0cnVlIGlmIHRoZSBvYmplY3QgaXMgYSBkYXRhIG1vZGVsXG4gICAgICovXG4gICAgZnVuY3Rpb24gaXNEZWxwaGl4TW9kZWwodmFsdWUpIHtcbiAgICAgICAgcmV0dXJuICh2YWx1ZSBpbnN0YW5jZW9mIEJhY2tib25lLk1vZGVsKSAmJiB2YWx1ZS5fZHhTY2hlbWE7XG4gICAgfVxuXG4gICAgLypcbiAgICAgKiBUcnkgdG8gYWRkIHRoaXMgdG8gdGhlIHNjcmVlbiBzeXN0ZW0gZm9yIGF1dG9tYXRpYyBjbGVhbnVwLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHJlZ2lzdGVyRm9yRGVzdHJ1Y3Rpb24oKSB7XG4gICAgICAgIGR4U2NyZWVuLnJlZ2lzdGVyQ2xlYW51cENhbGxiYWNrKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgZGVzdHJveSgpO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICAvKlxuICAgICAqIElmIG5vIG9uZSBpcyBsaXN0ZW5pbmcgZm9yIGV2ZW50cyBmcm9tIHRoaXMgcHJveHksIHRoZW4gZGVzdHJveSB0aGUgbGlzdGVycyBpdCBoYXMgb24gaXRzIG1vZGVscywgYW5kXG4gICAgICogcmVzZXQgYWxsIG9mIHRoZSBjYWNoZWQgdmFsdWVzXG4gICAgICovXG4gICAgZnVuY3Rpb24gZGVzdHJveSgpIHtcbiAgICAgICAgdmFyIG5vblplcm9FdmVudENvdW50ID0gMDtcbiAgICAgICAgXy5lYWNoKHByb3h5TW9kZWwuX2V2ZW50cywgZnVuY3Rpb24oZXZlbnRJbmZvKSB7XG4gICAgICAgICAgICBpZiAoZXZlbnRJbmZvLmxlbmd0aCAhPT0gMCkge1xuICAgICAgICAgICAgICAgIG5vblplcm9FdmVudENvdW50Kys7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBpZiAobm9uWmVyb0V2ZW50Q291bnQpIHtcbiAgICAgICAgICAgIHJlZ2lzdGVyRm9yRGVzdHJ1Y3Rpb24oKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIF8uZWFjaChwcm94eUF0dHJzUmVtb3ZlcnMsIGZ1bmN0aW9uKHJlbW92ZXIpIHtcbiAgICAgICAgICAgIHJlbW92ZXIoKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHByb3h5QXR0cnNSZW1vdmVycyA9IHt9O1xuICAgICAgICBwcm94eUF0dHJWYWx1ZXMgPSB7fTtcbiAgICB9XG5cbiAgICAvKlxuICAgICAqIFNldHMgdGhlIHNwZWNpZmllZCBiYWNrYm9uZSBtb2RlbCAob3IgbnVsbCBvciB1bmRlZmluZWQpIHRvIGJlIHRoZSBuZXcgYmFzZSBtb2RlbCBmb3IgdGhpcyBwcm94eS4gVGhpcyB3aWxsXG4gICAgICogcmVjb21wdXRlIGFsbCB2YWx1ZXMgZm9yIGVhY2ggb2YgdGhlIGF0dHJpYnV0ZXMgaW4gdGhlIG1hcHBpbmcsIHNlbmRpbmcgYW55IGFwcHJvcHJpYXRlIGNoYW5nZSBldmVudHMuXG4gICAgICovXG4gICAgZnVuY3Rpb24gc2V0TW9kZWwobW9kZWwpIHtcbiAgICAgICAgaWYgKGR4VXRpbC5pc05vbmUobW9kZWwpIHx8IChtb2RlbCBpbnN0YW5jZW9mIEJhY2tib25lLk1vZGVsKSkge1xuICAgICAgICAgICAgbGlzdGVuVG9CYXNlTW9kZWwodGhpcywgbW9kZWwpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhyb3cgZHhVdGlsLmZhaWwoJ21vZGVscyBtdXN0IGJlIGFuIGV4dGVuc2lvbiBvZiBCYWNrYm9uZS5Nb2RlbCcpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGdldE1vZGVsKCkge1xuICAgICAgICByZXR1cm4gYmFzZU1vZGVsO1xuICAgIH1cblxuICAgIC8qXG4gICAgICogUmV0dXJuIHRoZSBjdXJyZW50IHZhbHVlIG9mIHRoZSBwcm94eSdzIGF0dHJpYnV0ZS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBnZXQoYXR0ck5hbWUpIHtcbiAgICAgICAgcmV0dXJuIHByb3h5QXR0clZhbHVlc1thdHRyTmFtZV07XG4gICAgfVxuXG4gICAgLypcbiAgICAgKiBDYWxscyB0aGUgc2V0dGVyIGZvciB0aGUgYXNzb2NpYXRlZCBhdHRyaWJ1dGUuICBJZiB0aGVyZSBpcyBubyBzZXR0ZXIsIGxvZyBhbiBlcnJvci4gIEZpcmUgYSBjaGFuZ2UgZXZlbnRcbiAgICAgKiBzbyBjbGllbnRzIHdpbGwgYmUgYWJsZSB0byBhdXRvbWF0aWNhbGx5IGNoYW5nZSB0aGVpciBkaXNwbGF5IHRvIHNob3cgdGhlIG9sZCB2YWx1ZS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBzZXQoYXR0ck5hbWUsIHZhbHVlKSB7XG4gICAgICAgIGlmIChfLmlzT2JqZWN0KGF0dHJOYW1lKSkge1xuICAgICAgICAgICAgXy5lYWNoKGF0dHJOYW1lLCBmdW5jdGlvbihpbmRpdmlkdWFsVmFsdWUsIGtleSkgeyB0aGlzLnNldChrZXksIGluZGl2aWR1YWxWYWx1ZSk7IH0sIHRoaXMpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFwcm94eUF0dHJUb0F0dHJQYXRoc1thdHRyTmFtZV0uc2V0dGVyKSB7XG4gICAgICAgICAgICBkeFV0aWwuZmFpbCgnVHJpZWQgdG8gY2FsbCBhIHNldHRlciBvbiAnICsgYXR0ck5hbWUgKyAnIGJ1dCBubyBzZXR0ZXIgZGVmaW5lZCcpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcHJveHlBdHRyVG9BdHRyUGF0aHNbYXR0ck5hbWVdLnNldHRlcihhdHRyTmFtZSwgdmFsdWUpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy50cmlnZ2VyKCdjaGFuZ2U6JyArIGF0dHJOYW1lKTtcbiAgICAgICAgdGhpcy50cmlnZ2VyKCdjaGFuZ2UnKTtcbiAgICB9XG5cbiAgICAvKlxuICAgICAqIEdpdmVuIGEgcHJveHksIHJldHVybiBhbiBvYmplY3Qgd2hlcmUgZWFjaCBtZW1iZXIgaXMgYSByZWFkLW9ubHkgb2JzZXJ2YWJsZSB0aGF0IG1hcHMgdG8gdGhlIGNvcnJlc3BvbmRpbmdcbiAgICAgKiBwcm9wZXJ0eSBpbiB0aGUgcHJveHkuIENoYW5nZXMgdG8gdGhlIG9ic2VydmFibGUgYXJlIG5vdCBwcm9wYWdhdGVkIHRvIHRoZSBwcm94eSBvciB1bmRlcmx5aW5nIG1vZGVsLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHRvT2JzZXJ2YWJsZSgpIHtcbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gICAgICAgIHZhciByZXN1bHQgPSB7fTtcbiAgICAgICAgXy5lYWNoKHByb3h5QXR0clZhbHVlcywgZnVuY3Rpb24ocHJveHlWYWx1ZSwgcHJveHlBdHRyKSB7XG4gICAgICAgICAgICByZXN1bHRbcHJveHlBdHRyXSA9IGtvLm9ic2VydmFibGUocHJveHlWYWx1ZSk7XG4gICAgICAgICAgICBzZWxmLm9uKCdjaGFuZ2U6JyArIHByb3h5QXR0ciwgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0W3Byb3h5QXR0cl0oc2VsZi5nZXQocHJveHlBdHRyKSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvLyBJbml0aWFsaXplIG91ciBjb3B5IG9mIHRoZSBtYXBwaW5nIGFuZCBvdXIgY2FjaGUgb2YgYXR0cmlidXRlIHZhbHVlc1xuICAgIF8uZWFjaChzb3VyY2VNYXBwaW5nLCBmdW5jdGlvbihhdHRyUGF0aCwgcHJveHlBdHRyKSB7XG4gICAgICAgIHZhciBuZXdBdHRyUGF0aDtcblxuICAgICAgICBpZiAoXy5pc09iamVjdChhdHRyUGF0aCkpIHtcbiAgICAgICAgICAgIGlmICghXy5pc1N0cmluZyhhdHRyUGF0aC5wYXRoKSB8fCAoXy5oYXMoYXR0clBhdGgsICdzZXR0ZXInKSAmJiAhXy5pc0Z1bmN0aW9uKGF0dHJQYXRoLnNldHRlcikpKSB7XG4gICAgICAgICAgICAgICAgZHhVdGlsLmZhaWwoJ0F0dHJpYnV0ZSBwYXRoIGZvciAnICsgcHJveHlBdHRyICsgJyBtdXN0IGhhdmUgYSBwYXRoIHByb3BlcnR5IHRoYXQgaXMgYSBzdHJpbmcnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG5ld0F0dHJQYXRoID0ge1xuICAgICAgICAgICAgICAgIHBhdGg6IGF0dHJQYXRoLnBhdGgsXG4gICAgICAgICAgICAgICAgc2V0dGVyOiBhdHRyUGF0aC5zZXR0ZXJcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0gZWxzZSBpZiAoXy5pc1N0cmluZyhhdHRyUGF0aCkpIHtcbiAgICAgICAgICAgIGlmIChhdHRyUGF0aCA9PT0gJycpIHtcbiAgICAgICAgICAgICAgICBkeFV0aWwuZmFpbCgnQXR0cmlidXRlIHBhdGggZm9yICcgKyBwcm94eUF0dHIgKyAnIGlzIGVtcHR5LiBUaGlzIGlzIG5vdCBhbGxvd2VkJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBuZXdBdHRyUGF0aCA9IHsgcGF0aDogYXR0clBhdGggfTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGR4VXRpbC5mYWlsKCdBdHRyaWJ1dGUgcGF0aCBmb3IgJyArIHByb3h5QXR0ciArICcgbXVzdCBiZSBhIHN0cmluZyBvciBhbiBvYmplY3QnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIG5ld0F0dHJQYXRoLnBhdGggPSBuZXdBdHRyUGF0aC5wYXRoLnNwbGl0KCcuJyk7XG4gICAgICAgIHByb3h5QXR0clRvQXR0clBhdGhzW3Byb3h5QXR0cl0gPSBuZXdBdHRyUGF0aDtcbiAgICAgICAgcHJveHlBdHRyVmFsdWVzW3Byb3h5QXR0cl0gPSB1bmRlZmluZWQ7XG4gICAgfSk7XG5cbiAgICB2YXIgcHJveHlNb2RlbCA9IHtcbiAgICAgICAgc2V0TW9kZWw6IHNldE1vZGVsLFxuICAgICAgICBnZXRNb2RlbDogZ2V0TW9kZWwsXG4gICAgICAgIHNldDogc2V0LFxuICAgICAgICBnZXQ6IGdldCxcbiAgICAgICAgZGVzdHJveTogZGVzdHJveSxcbiAgICAgICAgdG9PYnNlcnZhYmxlOiB0b09ic2VydmFibGVcbiAgICB9O1xuICAgIF8uZXh0ZW5kKHByb3h5TW9kZWwsIEJhY2tib25lLkV2ZW50cyk7XG4gICAgcmVnaXN0ZXJGb3JEZXN0cnVjdGlvbigpO1xuXG4gICAgcmV0dXJuIHByb3h5TW9kZWw7XG59O1xuIiwiLypcbiAqIENvcHlyaWdodCAoYykgMjAxMywgMjAxNSBieSBEZWxwaGl4LiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICovXG5cbi8qIGdsb2JhbCAkLCBfLCBCYWNrYm9uZSwgWFJlZ0V4cCAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbi8qXG4gKiBNaXNjIGRhdGEtcmVsYXRlZCB1dGlsaXRpZXMuICBHZW5lcmFsbHkgbm90IG5lZWRlZCB1bmxlc3MgeW91IGFyZSBieXBhc3NpbmcgZGF0YSBpbiBzb21lIGZhc2hpb24uXG4gKi9cbnZhciBNQVhfTkFNRV9MRU5HVEggPSAyNTY7XG5cbmNvbnN0IGR4VXRpbCA9IHJlcXVpcmUoJ2R4Y29yZS9qcy91dGlsLmpzJyksXG4gICAgZHhMb2NhbGUgPSByZXF1aXJlKCdkeGNvcmUvanMvbG9jYWxlLmpzJyk7XG5cbi8qXG4gKiBUYWtlIGFuIEFQSUVycm9yIGFuZCByZXR1cm4gYSBzdHJpbmcgb2YgdmFsaWRhdGlvbiBlcnJvcnMgY29udGFpbmluZyBodG1sIHRoYXQgY2FuIGJlIGRpc3BsYXllZCBpbiBhbiBlcnJvciBhbGVydFxuICovXG5mdW5jdGlvbiBwcm9jZXNzRXJyb3JSZXN1bHREZXRhaWxzKGFwaUVycm9yKSB7XG4gICAgaWYgKCEoYXBpRXJyb3IgaW5zdGFuY2VvZiBCYWNrYm9uZS5Nb2RlbCkgfHwgYXBpRXJyb3IuZ2V0KCd0eXBlJykgIT09ICdBUElFcnJvcicpIHtcbiAgICAgICAgZHhVdGlsLmZhaWwoJ3Byb2Nlc3NFcnJvclJlc3VsdERldGFpbHMgZXhwZWN0cyBhbiBBUElFcnJvciBtb2RlbCBhcyBhbiBhcmd1bWVudC4nKTtcbiAgICB9XG5cbiAgICBhcGlFcnJvciA9IGFwaUVycm9yLnRvSlNPTigpO1xuICAgIGFwaUVycm9yLmRldGFpbHMgPSBhcGlFcnJvci5kZXRhaWxzID8gYXBpRXJyb3IuZGV0YWlscyA6ICcnO1xuXG4gICAgaWYgKHR5cGVvZiBhcGlFcnJvci5kZXRhaWxzID09PSAnc3RyaW5nJykge1xuICAgICAgICByZXR1cm4gYXBpRXJyb3IuZGV0YWlscztcbiAgICB9XG5cbiAgICB2YXIgcmVzdWx0TGlzdCA9IFtdO1xuICAgIF8uZWFjaChhcGlFcnJvci5kZXRhaWxzLCBmdW5jdGlvbihzdWJFcnJvciwgZmllbGQpIHtcbiAgICAgICAgYnVpbGRWYWxpZGF0aW9uRXJyb3JMaXN0KGZpZWxkLCBzdWJFcnJvciwgcmVzdWx0TGlzdCk7XG4gICAgfSk7XG5cbiAgICB2YXIgZWxlbSA9ICQoJzx1bD4nKTtcbiAgICBfLmVhY2gocmVzdWx0TGlzdCwgZnVuY3Rpb24oZXJyb3IpIHtcbiAgICAgICAgJCgnPGxpPicpLnRleHQoZXJyb3IuZmllbGQgKyAnOiAnICsgZXJyb3IuZGV0YWlscylcbiAgICAgICAgLmFwcGVuZFRvKGVsZW0pO1xuICAgIH0pO1xuXG4gICAgLypcbiAgICAgKiAuaHRtbCgpIGdldHMgdGhlIGlubmVyIGh0bWwgb2YgdGhlIGVsZW1lbnQgaW4gcXVlc3Rpb24sIGFuZCB3ZSB3YW50IHRvIGluY2x1ZGUgJ2VsZW0nIGluIHRoZSBvdXRwdXQgc3RyaW5nLFxuICAgICAqIHNvIGFwcGVuZCB0byBhIGR1bW15IGRpdlxuICAgICAqL1xuICAgIHJldHVybiAkKCc8ZGl2PicpLmFwcGVuZChlbGVtKS5odG1sKCk7XG59XG5cbi8qXG4gKiBIZWxwZXIgbWV0aG9kIHRvIGJ1aWxkIGEgbGlzdCBvZiB2YWxpZGF0aW9uIGVycm9ycyBpbiBERlMgb3JkZXIuIFRoaXMgZXhwZWN0cyB0byBlaXRoZXIgZ2V0IGFuIEFQSUVycm9yIG9iamVjdCwgb3JcbiAqIGFuIG9iamVjdCB3aG9zZSBrZXlzIGFyZSBwcm9wZXJ0eSBuYW1lcyBhbmQgdmFsdWVzIGFyZSB0aGVtc2VsdmVzIG1vcmUgb2YgdGhlIHNhbWUgKGVpdGhlciBhbiBBUElFcnJvciBvciBhbiBvYmplY3RcbiAqIHdpdGgga2V5cyBhcyBwcm9wIG5hbWVzKS5cbiAqL1xuZnVuY3Rpb24gYnVpbGRWYWxpZGF0aW9uRXJyb3JMaXN0KGZpZWxkU3RyLCBlcnJvciwgZXJyb3JMaXN0KSB7XG4gICAgdmFyIGFwaUVycm9yS2V5cyA9IF8uaW50ZXJzZWN0aW9uKF8ua2V5cyhlcnJvciksIFsnaWQnLCAnZGV0YWlscycsICdhY3Rpb24nXSk7XG5cbiAgICAvLyBUaGUgJ2lkJyBwcm9wZXJ0eSB0ZWxscyB1cyB0aGlzIGlzIGFuIEFQSUVycm9yLCByYXRoZXIgdGhhbiBhIGhhc2ggb2YgbmVzdGVkIHZhbGlkYXRpb24gZXJyb3JzXG4gICAgLy8gQWxzbywgY2hlY2sgdG8gc2VlIGlmIHRoZSBvYmplY3QgaGFzIHRoZSBwcmltYXJ5IHByb3BlcnRpZXMgb2YgYW4gQVBJRXJyb3IsIGFuZCBpZiBzbyBjb25zaWRlciBpdCBhbiBBUElFcnJvclxuICAgIGlmIChlcnJvci50eXBlID09PSAnQVBJRXJyb3InIHx8IGFwaUVycm9yS2V5cy5sZW5ndGggPT09IDMpIHtcbiAgICAgICAgZXJyb3JMaXN0LnB1c2goe1xuICAgICAgICAgICAgYWN0aW9uOiBlcnJvci5hY3Rpb24sXG4gICAgICAgICAgICBkZXRhaWxzOiBlcnJvci5kZXRhaWxzLFxuICAgICAgICAgICAgZmllbGQ6IGZpZWxkU3RyXG4gICAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIF8uZWFjaChlcnJvciwgZnVuY3Rpb24oc3ViRXJyb3IsIHN1YkZpZWxkKSB7XG4gICAgICAgICAgICBidWlsZFZhbGlkYXRpb25FcnJvckxpc3QoZmllbGRTdHIgKyAnLicgKyBzdWJGaWVsZCwgc3ViRXJyb3IsIGVycm9yTGlzdCk7XG4gICAgICAgIH0pO1xuICAgIH1cbn1cblxuLypcbiAqIEFsbG93IHVuaWNvZGUgd2l0aCB0aGUgZXhjZXB0aW9uIG9mIHRoZSBcIk90aGVyXCIgY2F0ZWdvcnkgd2hpY2ggaW5jbHVkZXMgKGNvbnRyb2wgY2hhcmFjdGVycyxcbiAqIGZvcm1hdCBjaGFyYWN0ZXJzLCBwcml2YXRlIHVzZSBjaGFyYWN0ZXJzLCBzdXJyb2dhdGUgY2hhcmFjdGVycywgYW5kIHVuYXNzaWduZWQgY2hhcmFjdGVycykgYW5kICUnYFxuICovXG52YXIgYmFkQ2hhcnNSZWdleCA9IFhSZWdFeHAoJ1tcXFxccHtDfSVcXCdgXSsnKTtcblxuLypcbiAqIFZhbGlkYXRlcyB0aGF0IGEgbmFtZSBtYXRjaGVzIHRoZSBjb25zdHJhaW50cyBvdXIgc2VydmVyIHB1dHMgb24gb2JqZWN0IG5hbWVzLiAgVGhpcyByZXR1cm5zIGFuIG9iamVjdCB3aXRoIHRoZXNlXG4gKiBwcm9wZXJ0aWVzOlxuICogICAgdmFsaWQ6IHRydWV8ZmFsc2UgICBJZiB0aGUgcHJvdmlkZWQgbmFtZSBpcyB2YWxpZFxuICogICAgdG9vTG9uZzogdHJ1ZXxmYWxzZSBJZiB0aGUgcHJvdmlkZWQgdmFsdWUgZXhjZWVkcyBvdXIgbGVuZ3RoIGxpbWl0c1xuICogICAgYmFkQ2hhcnM6IFN0cmluZyAgICBUaGUgc2V0IG9mIGNoYXJhY3RlcnMgZm91bmQgdGhhdCBhcmUgaW52YWxpZC4gVXNlZnVsIGZvciBzaG93aW5nIGluIGVycm9yIG1lc3NhZ2VzLlxuICpcbiAqIE5vdGUgdGhhdCB0aGlzIGlzIGJlaW5nIGRvbmUgJ2J5IGhhbmQnIGJlY2F1c2UgdGhlIHNjaGVtYXMgZG8gbm90IHByZXNlbnRseSBwcm92aWRlIHRoaXMgaW5mb3JtYXRpb24gdG8gY2xpZW50cy5cbiAqIENvbnN1bHQgdGhlIGZvbGxvd2luZyByZXNvdXJjZXMgdG8gcXVpY2tseSBmaWd1cmUgb3V0IGlmIHRoaXMgaXMgc3RpbGwgdmFsaWQ6XG4gKiAgICAgYXBwbGlhbmNlL3NlcnZlci9jbXMvc3JjL2phdmEvY29tL2RlbHBoaXgvYXBwbGlhbmNlL3NlcnZlci9qc29uL3ZhbGlkYXRpb24vaW1wbC9PYmplY3ROYW1lRm9ybWF0Q29uc3RyYWludC5qYXZhXG4gKiAgICAgaHR0cDovL2RvY3Mub3JhY2xlLmNvbS9qYXZhc2UvNi9kb2NzL2FwaS9qYXZhL3V0aWwvcmVnZXgvUGF0dGVybi5odG1sXG4gKi9cbmZ1bmN0aW9uIHZhbGlkYXRlTmFtZShuYW1lKSB7XG4gICAgdmFyIHRvb0xvbmcgPSBmYWxzZSxcbiAgICAgICAgYmFkQ2hhcnMgPSAnJztcblxuICAgIGlmICghZHhVdGlsLmlzTm9uZShuYW1lKSkge1xuICAgICAgICBpZiAobmFtZS5sZW5ndGggPiBNQVhfTkFNRV9MRU5HVEgpIHtcbiAgICAgICAgICAgIHRvb0xvbmcgPSB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHJlc3VsdCA9IFhSZWdFeHAuZXhlYyhuYW1lLCBiYWRDaGFyc1JlZ2V4KTtcblxuICAgICAgICBfLmVhY2gocmVzdWx0LCBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICAgICAgaWYgKGJhZENoYXJzLmluZGV4T2YodmFsdWUpID09PSAtMSlcbiAgICAgICAgICAgICAgICBiYWRDaGFycyArPSB2YWx1ZTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgICAgdmFsaWQ6ICghdG9vTG9uZyAmJiAoYmFkQ2hhcnMgPT09ICcnKSksXG4gICAgICAgIHRvb0xvbmc6IHRvb0xvbmcsXG4gICAgICAgIGJhZENoYXJzOiBiYWRDaGFyc1xuICAgIH07XG59XG5cbi8qXG4gKiBWYWxpZGF0ZXMgdGhhdCBhIG5hbWUgbWF0Y2hlcyB0aGUgY29uc3RyYWludHMgb3VyIHNlcnZlciBwdXRzIG9uIG9iamVjdCBuYW1lcy4gVGhpcyByZXR1cm5zIHVuZGVmaW5lZCBpZiB0aGUgbmFtZVxuICogaXMgdmFsaWQsIGFuIGxvY2FsaXplZCBlcnJvciBtZXNzYWdlIG90aGVyd2lzZS5cbiAqL1xuZnVuY3Rpb24gZ2V0TmFtZVZhbGlkYXRpb25FcnJvcklmQW55KG5hbWUpIHtcbiAgICBpZiAoXy5pc1VuZGVmaW5lZChuYW1lKSB8fCBuYW1lLnRyaW0oKSA9PT0gJycpIHtcbiAgICAgICAgcmV0dXJuIGR4TG9jYWxlLmdscygnZHguY29yZS5uYW1lX2VtcHR5Lm1zZycpO1xuICAgIH1cblxuICAgIC8vIENoZWNrIHNvbWUgaW52YWxpZCBuYW1lIHByb2JsZW1zICh0b28gbG9uZywgdW5zdXBwb3J0ZWQgY2hhcmFjdGVycylcbiAgICB2YXIgcmVzdWx0ID0gbW9kdWxlLmV4cG9ydHMudmFsaWRhdGVOYW1lKG5hbWUpO1xuICAgIGlmICghcmVzdWx0LnZhbGlkKSB7XG4gICAgICAgIGlmIChyZXN1bHQudG9vTG9uZykge1xuICAgICAgICAgICAgcmV0dXJuIGR4TG9jYWxlLmdscygnZHguY29yZS5uYW1lX3Rvb19sb25nLm1zZycsIE1BWF9OQU1FX0xFTkdUSCk7XG4gICAgICAgIH0gZWxzZSBpZiAocmVzdWx0LmJhZENoYXJzKSB7XG4gICAgICAgICAgICByZXR1cm4gZHhMb2NhbGUuZ2xzKCdkeC5jb3JlLm5hbWVfaW52YWxpZENoYXJzLm1zZycsIHJlc3VsdC5iYWRDaGFycyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBkeFV0aWwuZmFpbCgnTmFtZSB2YWxpZGF0b3IgaGFzIHJldHVybmVkIGEgbmV3IGVycm9yIGNvbmRpdGlvbi4gTXVzdCBjb3BlIHdpdGggdGhhdCBoZXJlLicpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gICAgcHJvY2Vzc0Vycm9yUmVzdWx0RGV0YWlsczogcHJvY2Vzc0Vycm9yUmVzdWx0RGV0YWlscyxcbiAgICB2YWxpZGF0ZU5hbWU6IHZhbGlkYXRlTmFtZSxcbiAgICBnZXROYW1lVmFsaWRhdGlvbkVycm9ySWZBbnk6IGdldE5hbWVWYWxpZGF0aW9uRXJyb3JJZkFueVxufTtcbiIsIi8qXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTUgYnkgRGVscGhpeC4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqL1xuXG4vKiBnbG9iYWwgZGVscGhpeFNjaGVtYSovXG5cbid1c2Ugc3RyaWN0JztcblxuY29uc3Qgc2V0dXBEYXRhID0gcmVxdWlyZSgnZHhjb3JlL2RhdGEvbGF5ZXIzL2pzL2FwaS5qcycpLnNldHVwRGF0YVN5c3RlbSxcbiAgICBzZXR1cERlbHBoaXhGaWx0ZXJzID0gcmVxdWlyZSgnZHhjb3JlL2RhdGEvZGVscGhpeC9qcy9maWx0ZXIuanMnKS5faW5pdERlbHBoaXhGaWx0ZXJzO1xuXG5tb2R1bGUuZXhwb3J0cy5pbml0aWFsaXplID0gZnVuY3Rpb24oKSB7XG4gICAgc2V0dXBEYXRhKGRlbHBoaXhTY2hlbWEsIG1vZHVsZS5leHBvcnRzKTtcbiAgICBzZXR1cERlbHBoaXhGaWx0ZXJzKG1vZHVsZS5leHBvcnRzKTtcbn07XG4iLCIvKlxuICogQ29weXJpZ2h0IChjKSAyMDE0LCAyMDE1IGJ5IERlbHBoaXguIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKi9cblxuLyogZ2xvYmFsIF8gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCBkeFV0aWwgPSByZXF1aXJlKCdkeGNvcmUvanMvdXRpbC5qcycpLFxuICAgIGR4Q29uc3RhbnRzID0gcmVxdWlyZSgnZHhjb3JlL2pzL2NvbnN0YW50cy5qcycpO1xuXG4vKlxuICogRG8gdG9wLWxldmVsIHByb2Nlc3Npbmcgb2YgZWFjaCBzY2hlbWEuIFRoaXMgaW52b2x2ZXM6XG4gKiAgMSkgSWYgdGhlIHNjaGVtYSBoYXMgbm8gbmFtZSwgcmVwbGFjZSBpdCB3aXRoIGEgbmFtZSwgYmFzZWQgb24gdGhlIHNjaGVtYUtleSwgdGhhdCBjYW4gYmUgdXNlZCBhcyBhIEphdmFzY3JpcHRcbiAqICAgICBpZGVudGlmaWVyLlxuICogIDIpIFJlcGxhY2UgdGhlIGV4dGVuZHMgc2NoZW1hS2V5IChpZiBwcmVzZW50KSB3aXRoIHRoZSBuYW1lIG9mIHRoZSBwYXJlbnQgc2NoZW1hLlxuICogIDMpIEFkZCBhIHBhcmVudFNjaGVtYSBwcm9wZXJ0eSB3aXRoIGEgcmVmZXJlbmNlIHRvIHRoZSBwYXJlbnQgc2NoZW1hLCBpZiBhbnkuXG4gKiAgNCkgQWRkIHRoZSBuYW1lIG9mIHRoZSBjbG9zZXN0IGFuY2VzdG9yIHNjaGVtYSB0eXBlIHRoYXQgaGFkIGEgcm9vdCBwcm9wZXJ0eS5cbiAqICA1KSBJbmhlcml0IHRoZSBwYXJlbnQncyByb290IHByb3BlcnR5LCBpZiB0aGlzIGl0c2VsZiBkb2Vzbid0IGhhdmUgb25lLlxuICovXG5mdW5jdGlvbiBwcm9jZXNzU2NoZW1hKHNjaGVtYSwgc2NoZW1hS2V5LCBzb3VyY2VTY2hlbWFzLCBuZXdTY2hlbWFzLCBwcmVzZXJ2ZVVubmVlZGVkKSB7XG4gICAgLypcbiAgICAgKiBNb3N0IHNjaGVtYXMgaGF2ZSBhIG5hbWUuIEhvd2V2ZXIsIG5vdCBhbGwgZG8uICBXZSBtdXN0IG5ldmVydGhlbGVzcyBleHBvc2UgdGhvc2Ugc2NoZW1hcyBhcyB0aGV5IGhhdmUgcm9vdFxuICAgICAqIG9wZXJhdGlvbnMgb24gdGhlbS4gVGh1cywgd2UgY29udmVydCB0aGUga2V5IGludG8gYSBmb3JtIHRoYXQgY2FuIGJlIHVzZWQgdG8gaWRlbnRpZnkgdGhlbS5cbiAgICAgKi9cbiAgICBzY2hlbWEubmFtZSA9IHNjaGVtYUtleVRvVHlwZU5hbWUoc2NoZW1hS2V5LCBzb3VyY2VTY2hlbWFzKTtcblxuICAgIC8vIElmIHRoaXMgc2NoZW1hIGhhcyBhbHJlYWR5IGJlZW4gcHJvY2Vzc2VkIChzZWUgcmVjdXJzaXZlIGNhbGwsIGJlbG93KSwgcmV0dXJuIGl0XG4gICAgaWYgKG5ld1NjaGVtYXNbc2NoZW1hLm5hbWVdKSB7XG4gICAgICAgIHJldHVybiBuZXdTY2hlbWFzW3NjaGVtYS5uYW1lXTtcbiAgICB9XG5cbiAgICBuZXdTY2hlbWFzW3NjaGVtYS5uYW1lXSA9IHNjaGVtYTtcblxuICAgIGlmIChzY2hlbWEucm9vdCkge1xuICAgICAgICBzY2hlbWEucm9vdFR5cGVOYW1lID0gc2NoZW1hLm5hbWU7XG4gICAgfVxuXG4gICAgLy8gUHJvY2VzcyB0aGUgcGFyZW50IHNjaGVtYSwgaWYgYW55LiBUaGlzIGFzc3VtZXMgYWxsIGV4dGVuZHMgc2NoZW1hcyBoYXZlIGp1c3QgYSAkcmVmIHByb3BlcnR5LlxuICAgIHZhciBwYXJlbnRTY2hlbWEgPSBzY2hlbWEuZXh0ZW5kcztcbiAgICBpZiAocGFyZW50U2NoZW1hKSB7XG4gICAgICAgIHNjaGVtYS5wYXJlbnRTY2hlbWEgPSBwcm9jZXNzU2NoZW1hKHNvdXJjZVNjaGVtYXNbcGFyZW50U2NoZW1hLiRyZWZdLCBwYXJlbnRTY2hlbWEuJHJlZixcbiAgICAgICAgICAgIHNvdXJjZVNjaGVtYXMsIG5ld1NjaGVtYXMpO1xuICAgICAgICBwYXJlbnRTY2hlbWEuJHJlZiA9IHNjaGVtYUtleVRvVHlwZU5hbWUocGFyZW50U2NoZW1hLiRyZWYsIHNvdXJjZVNjaGVtYXMpO1xuICAgICAgICBwYXJlbnRTY2hlbWEgPSBzY2hlbWEucGFyZW50U2NoZW1hO1xuXG4gICAgICAgIGlmICghc2NoZW1hLnJvb3RUeXBlTmFtZSkge1xuICAgICAgICAgICAgc2NoZW1hLnJvb3RUeXBlTmFtZSA9IHBhcmVudFNjaGVtYS5yb290VHlwZU5hbWU7XG4gICAgICAgIH1cblxuICAgICAgICBzY2hlbWEucm9vdCA9IHNjaGVtYS5yb290IHx8IHBhcmVudFNjaGVtYS5yb290O1xuICAgIH1cblxuICAgIGlmICghcHJlc2VydmVVbm5lZWRlZCkge1xuICAgICAgICBkZWxldGUgc2NoZW1hLmRlc2NyaXB0aW9uO1xuICAgIH1cblxuICAgIHByb2Nlc3NQcm9wZXJ0aWVzKHNjaGVtYSwgcGFyZW50U2NoZW1hLCBzb3VyY2VTY2hlbWFzLCBwcmVzZXJ2ZVVubmVlZGVkKTtcbiAgICBwcm9jZXNzT3BlcmF0aW9ucyhzY2hlbWEsIHBhcmVudFNjaGVtYSwgc291cmNlU2NoZW1hcyk7XG5cbiAgICByZXR1cm4gc2NoZW1hO1xufVxuXG4vKlxuICogVGhlIHNjaGVtYUtleXMgd2UgZ2V0IGFyZSBvZnRlbiBvZiB0aGUgZm9ybSAvc29tZS1uYW1lLmpzb24uIFNvbWUgb2YgdGhlIGNoYXJhY3RlcnMgdGhhdCBzaG93IHVwIHRoZXJlIGNhbiBub3QgYmVcbiAqIHVzZWQgYXMgYSBKYXZhc2NyaXB0IGlkZW50aWZpZXIsIGFuZCBzbyB3ZSBtb2RpZnkgdGhlIGFib3ZlIGludG8gYSBKYXZhc2NyaXB0IGNvbXBhdGlibGUgZm9ybS4gRm9yIGV4YW1wbGUgdGhlXG4gKiBhYm92ZSB3b3VsZCBiZWNvbWUgc29tZV9uYW1lLlxuICovXG5mdW5jdGlvbiBzY2hlbWFLZXlUb1R5cGVOYW1lKHNjaGVtYUtleSwgc2NoZW1hcykge1xuICAgIGlmICghc2NoZW1hc1tzY2hlbWFLZXldKSB7XG4gICAgICAgIGR4VXRpbC5mYWlsKCdDb3VsZCBub3QgZmluZCBhIHNjaGVtYSBlbnRyeSBmb3IgJyArIHNjaGVtYUtleSk7XG4gICAgfVxuXG4gICAgaWYgKHNjaGVtYXNbc2NoZW1hS2V5XS5uYW1lKSB7XG4gICAgICAgIHJldHVybiBzY2hlbWFzW3NjaGVtYUtleV0ubmFtZTtcbiAgICB9XG5cbiAgICB2YXIgbmV3U3RyaW5nID0gc2NoZW1hS2V5LnJlcGxhY2UoL1xcLmpzb24kLywgJycpXG4gICAgICAgIC5yZXBsYWNlKC8tL2csICdfJylcbiAgICAgICAgLnJlcGxhY2UoL1xcLy9nLCAnJyk7XG5cbiAgICByZXR1cm4gbmV3U3RyaW5nO1xufVxuXG4vKlxuICogUHJvY2VzcyB0aGUgcHJvcGVydGllcy4gQXMgZmFyIGFzIHRoaXMgaXMgY29uY2VybmVkLCBwcm9wZXJ0aWVzIGFyZSBvbmUgb2Y6XG4gKiBBIHNpbXBsZSBwcmltaXRpdmUgdmFsdWVcbiAqICAgICBwcm9wZXJ0eU5hbWU6IHtcbiAqICAgICAgICAgdHlwZTogc3RyaW5nfG51bWJlcnxpbnRlZ2VyfGJvb2xlYW58bnVsbCxcbiAqICAgICAgICAgW2RlZmF1bHQ6IHZhbHVlXVxuICogICAgIH1cbiAqICBvciBhIHNpbXBsZSBvYmplY3RcbiAqICAgICBwcm9wZXJ0eU5hbWU6IHtcbiAqICAgICAgICAgdHlwZTogb2JqZWN0XG4gKiAgICAgfVxuICogIG9yIGFuICdlbWJlZGRlZCBvYmplY3QnXG4gKiAgICAgcHJvcGVydHlOYW1lOiB7XG4gKiAgICAgICAgIHR5cGU6IG9iamVjdCxcbiAqICAgICAgICAgJHJlZjogc2NoZW1hS2V5XG4gKiAgICAgfVxuICogIG9yIGEgJ3JlZmVyZW5jZWQgb2JqZWN0J1xuICogICAgIHByb3BlcnR5TmFtZToge1xuICogICAgICAgICB0eXBlOiBzdHJpbmcsXG4gKiAgICAgICAgIGZvcm1hdDogb2JqZWN0UmVmZXJlbmNlLFxuICogICAgICAgICBbcmVmZXJlbmNlVG86IHNjaGVtYUtleV1cbiAqICAgICB9XG4gKiAgb3IgYW4gYXJyYXlcbiAqICAgICBwcm9wZXJ0eU5hbWU6IHtcbiAqICAgICAgICAgdHlwZTogYXJyYXksXG4gKiAgICAgICAgIFtpdGVtczoge1xuICogICAgICAgICAgICAgdHlwZTogc3RyaW5nfG51bWJlcnxpbnRlZ2VyfGJvb2xlYW58bnVsbHxvYmplY3QsXG4gKiAgICAgICAgICAgICBbJHJlZjogc2NoZW1hS2V5XVxuICogICAgICAgICB9XVxuICogICAgIH1cbiAqICBub3RlOiAkcmVmIG1heSBvbmx5IHByZXNlbnQgaWYgdGhlIHR5cGUgaXMgb2JqZWN0LlxuICogQWxzbyB0aGUgdHlwZSBjYW4gYmUgYW4gYXJyYXkgb2YgYW55IG9mIHRoZSB0aGluZ3MgYWJvdmUuXG4gKlxuICogQW55IG9uZSBvZiB0aGVzZSBtYXkgYWxzbyBoYXZlIHRoZXNlIHZhbHVlczpcbiAqICAgICAgICAgW2NyZWF0ZTogcmVxdWlyZWR8b3B0aW9uYWx8cmVhZG9ubHksXVxuICogICAgICAgICBbdXBkYXRlOiByZXF1aXJlZHxvcHRpb25hbHxyZWFkb25seSxdXG4gKiAgICAgICAgIFtyZXF1aXJlZDogdHJ1ZXxmYWxzZV1cbiAqIE5vdGUgdGhhdCB0aGVyZSBhcmUgbWFueSBvdGhlciB2YWxpZGF0aW9uIHJlbGF0ZWQgcHJvcGVydGllcywgYnV0IHRoZXkgYXJlIG5vdCBhbHRlcmVkIGJ5IHRoaXMgcHJvY2Vzc2luZy5cbiAqXG4gKiBUaGlzIGRvZXMgdHdvIHRoaW5nczpcbiAqICAxKSBwcm92aWRlcyAncHJvcGVydHkgaW5oZXJpdGFuY2UnIGJ5IGNvcHlpbmcgdGhlIHBhcmVudCdzIHByb3BlcnRpZXMgKGlmIGFueSkgYW5kIHJlcGxhY2luZyB0aGVtIGFzIGFwcHJvcHJpYXRlXG4gKiAgICAgd2l0aCB0aGlzIHNjaGVtYSdzIHByb3BlcnRpZXMuXG4gKiAgMikgUmVwbGFjZXMgYW55IHJlZmVyZW5jZXMgdG8gc2NoZW1hIHR5cGVzIHdpdGggdGhlIHR5cGUgbmFtZSBvZiB0aGUgdGFyZ2V0IHR5cGVzLlxuICovXG5mdW5jdGlvbiBwcm9jZXNzUHJvcGVydGllcyhzY2hlbWEsIHBhcmVudFNjaGVtYSwgc291cmNlU2NoZW1hcywgcHJlc2VydmVVbm5lZWRlZCkge1xuICAgIGlmICghc2NoZW1hLnByb3BlcnRpZXMgJiYgIShwYXJlbnRTY2hlbWEgJiYgcGFyZW50U2NoZW1hLnByb3BlcnRpZXMpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgcGFyZW50UHJvcHMgPSAocGFyZW50U2NoZW1hICYmIHBhcmVudFNjaGVtYS5wcm9wZXJ0aWVzKSA/IF8uY2xvbmUocGFyZW50U2NoZW1hLnByb3BlcnRpZXMpIDoge307XG4gICAgdmFyIHByb3BLZXlzID0gXy5rZXlzKHNjaGVtYS5wcm9wZXJ0aWVzIHx8IHt9KTtcbiAgICBzY2hlbWEucHJvcGVydGllcyA9IF8uZXh0ZW5kKHNjaGVtYS5wcm9wZXJ0aWVzIHx8IHt9LCBfLm9taXQocGFyZW50UHJvcHMsIHByb3BLZXlzKSk7XG5cbiAgICAvLyBNb2RpZnkgYW55IG9mIHRoZSBzY2hlbWFzIG93biBwcm9wZXJ0aWVzXG4gICAgXy5lYWNoKHByb3BLZXlzLCBmdW5jdGlvbihwcm9wTmFtZSkge1xuICAgICAgICB2YXIgcHJvcERhdGEgPSBzY2hlbWEucHJvcGVydGllc1twcm9wTmFtZV07XG5cbiAgICAgICAgY29udmVydFR5cGVSZWZlcmVuY2UocHJvcERhdGEsIHNvdXJjZVNjaGVtYXMpO1xuXG4gICAgICAgIGlmICghcHJlc2VydmVVbm5lZWRlZCkge1xuICAgICAgICAgICAgZGVsZXRlIHByb3BEYXRhLmRlc2NyaXB0aW9uO1xuICAgICAgICB9XG4gICAgfSk7XG59XG5cbi8qXG4gKiBQcm9jZXNzIGFsbCBvcGVyYXRpb25zLiB0aGVzZSBsb29rIGxpa2UgdGhlIGZvbGxvd2luZzpcbiAqICAgICBvcGVyYXRpb25zOiB7XG4gKiAgICAgICAgIG9wZXJhdGlvbk5hbWU6IHsgLi4uIGRldGFpbHMgLi4uIH0sXG4gKiAgICAgICAgIC4uLlxuICogICAgIH1cbiAqIG9yXG4gKiAgICAgcm9vdE9wZXJhdGlvbnM6IHtcbiAqICAgICAgICAgb3BlcmF0aW9uTmFtZTogeyAuLi4gZGV0YWlscyAuLi4gfSxcbiAqICAgICAgICAgLi4uXG4gKiAgICAgfVxuICogb3Igb25lIG9mIHRoZSBmb2xsb3dpbmdcbiAqICAgICBjcmVhdGU6IHsgLi4uIGRldGFpbHMgLi4uIH1cbiAqICAgICByZWFkOiB7IC4uLiBkZXRhaWxzIC4uLiB9XG4gKiAgICAgbGlzdDogeyAuLi4gZGV0YWlscyAuLi4gfVxuICogICAgIHVwZGF0ZTogeyAuLi4gZGV0YWlscyAuLi4gfVxuICogICAgIGRlbGV0ZTogeyAuLi4gZGV0YWlscyAuLi4gfVxuICpcbiAqIFRoaXMgbWFrZXMgdGhlIGZvbGxvd2luZyBjaGFuZ2VzIHRvIHRoZXNlIHNjaGVtYXM6XG4gKiAgMSkgU2NoZW1hcyB0aGF0IGFyZSBleHRlbnNpb25zIG9mIGEgcm9vdCBzY2hlbWEgd2lsbCBpbmhlcml0IHRoZWlyIHBhcmVudHMnIG9wZXJhdGlvbnNcbiAqICAyKSBTdGFuZGFyZCBvcGVyYXRpb25zIHVwZGF0ZSwgZGVsZXRlIGFuZCByZWFkIGFyZSBwcm9wb2dhdGVkIGRvd24gdG8gY2hpbGQgb2JqZWN0cy4gTGlzdCBhbmQgY3JlYXRlIGFyZSBub3RcbiAqL1xuZnVuY3Rpb24gcHJvY2Vzc09wZXJhdGlvbnMoc2NoZW1hLCBwYXJlbnRTY2hlbWEsIHNvdXJjZVNjaGVtYXMpIHtcbiAgICAvLyBEbyBzb21lIHNjaGVtYSB2YWxpZGF0aW9uXG4gICAgdmFyIHNjaGVtYU9wcyA9IF8ucGljayhzY2hlbWEsIFsnb3BlcmF0aW9ucycsICdyb290T3BlcmF0aW9ucycsICdjcmVhdGUnLCAncmVhZCcsICdsaXN0JywgJ3VwZGF0ZScsICdkZWxldGUnXSk7XG4gICAgaWYgKCFzY2hlbWEucm9vdCAmJiAhXy5pc0VtcHR5KHNjaGVtYU9wcykpIHtcbiAgICAgICAgZHhVdGlsLmZhaWwoJ0ZvdW5kICcgKyBfLmtleXMoc2NoZW1hT3BzKSArICcgb24gYSBub24tcm9vdCBzY2hlbWEuJyk7XG4gICAgfVxuXG4gICAgaWYgKHNjaGVtYS5vcGVyYXRpb25zICYmIHBhcmVudFNjaGVtYSAmJiBwYXJlbnRTY2hlbWEub3BlcmF0aW9ucykge1xuICAgICAgICBkeFV0aWwuZmFpbCgnQm90aCAnICsgcGFyZW50U2NoZW1hLm5hbWUgKyAnIGFuZCAnICsgc2NoZW1hLm5hbWUgKyAnIGhhdmUgb3BlcmF0aW9ucy4gVGhpcyBpc25cXCd0IHN1cHBvcnRlZC4nKTtcbiAgICB9XG5cbiAgICB2YXIgcGFyZW50T3BzID0gKHBhcmVudFNjaGVtYSAmJiBwYXJlbnRTY2hlbWEub3BlcmF0aW9ucykgPyBwYXJlbnRTY2hlbWEub3BlcmF0aW9ucyA6IHt9O1xuICAgIHZhciBvcEtleXMgPSBzY2hlbWEub3BlcmF0aW9ucyA/IF8ua2V5cyhzY2hlbWEub3BlcmF0aW9ucykgOiBbXTtcbiAgICB2YXIgbXlPcGVyYXRpb25zID0gXy5leHRlbmQoc2NoZW1hLm9wZXJhdGlvbnMgfHwge30sIF8ub21pdChwYXJlbnRPcHMsIG9wS2V5cykpO1xuXG4gICAgaWYgKCFfLmlzRW1wdHkobXlPcGVyYXRpb25zKSkge1xuICAgICAgICBzY2hlbWEub3BlcmF0aW9ucyA9IG15T3BlcmF0aW9ucztcblxuICAgICAgICBfLmVhY2gob3BLZXlzLCBmdW5jdGlvbihvcE5hbWUpIHtcbiAgICAgICAgICAgIHByb2Nlc3NPcGVyYXRpb24oc2NoZW1hLm9wZXJhdGlvbnNbb3BOYW1lXSwgb3BOYW1lLCBzb3VyY2VTY2hlbWFzKTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgXy5lYWNoKHNjaGVtYS5yb290T3BlcmF0aW9ucywgZnVuY3Rpb24ob3BJbmZvLCBvcE5hbWUpIHtcbiAgICAgICAgcHJvY2Vzc09wZXJhdGlvbihvcEluZm8sIG9wTmFtZSwgc291cmNlU2NoZW1hcyk7XG4gICAgfSk7XG5cbiAgICB2YXIgcFNjaGVtYSA9IHBhcmVudFNjaGVtYSB8fCB7fTtcbiAgICBfLmVhY2goWydjcmVhdGUnLCAndXBkYXRlJywgJ3JlYWQnLCAnbGlzdCcsICdkZWxldGUnXSwgZnVuY3Rpb24ob3BOYW1lKSB7XG4gICAgICAgIHZhciBvcERlZiA9IHNjaGVtYVtvcE5hbWVdO1xuICAgICAgICBpZiAoIWR4VXRpbC5pc05vbmUob3BEZWYpKSB7XG4gICAgICAgICAgICBpZiAob3BOYW1lID09PSAnY3JlYXRlJyB8fCBvcE5hbWUgPT09ICd1cGRhdGUnKSB7XG4gICAgICAgICAgICAgICAgb3BEZWYudmFsaWRhdGVBcyA9IG9wRGVmLnZhbGlkYXRlQXMgfHwgb3BOYW1lO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBwcm9jZXNzT3BlcmF0aW9uKG9wRGVmLCBvcE5hbWUsIHNvdXJjZVNjaGVtYXMpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG9wTmFtZSAhPT0gJ2NyZWF0ZScgJiYgb3BOYW1lICE9PSAnbGlzdCcpIHtcbiAgICAgICAgICAgIHNjaGVtYVtvcE5hbWVdID0gb3BEZWYgfHwgcFNjaGVtYVtvcE5hbWVdO1xuICAgICAgICB9XG4gICAgfSk7XG59XG5cbi8qXG4gKiBQcm9jZXNzIGVhY2ggb3BlcmF0aW9uLiBUaGlzIGdlbmVyYWxpemVzIGFjcm9zcyBzdGFuZGFyZCwgb2JqZWN0IGFuZCByb290IG9wZXJhdGlvbnMuIFRoZXNlIGFyZSBleHBlY3RlZCB0byBiZSBvZlxuICogdGhlIGZvcm06XG4gKiAgICAgb3BlcmF0aW9uTmFtZToge1xuICogICAgICAgICBwYXlsb2FkOiB7XG4gKiAgICAgICAgICAgICBbdHlwZTogJ29iamVjdCcsXG4gKiAgICAgICAgICAgICAkcmVmOiB1cmwtdG8tdHlwZV1cbiAqICAgICAgICAgfVxuICogICAgICAgICBbdmFsaWRhdGVBczogY3JlYXRlfHVwZGF0ZV1cbiAqICAgICAgICAgW3JlcXVpcmVkOiB0cnVlfGZhbHNlXVxuICogICAgICAgICBbcmV0dXJuOiAuLi5dXG4gKiAgICAgfVxuICogb3JcbiAqICAgICBvcGVyYXRpb25OYW1lOiB7XG4gKiAgICAgICAgIHBhcmFtZXRlcnM6IHtcbiAqICAgICAgICAgICAgIC4uLlxuICogICAgICAgICB9XG4gKiAgICAgICAgIFtyZXR1cm46IC4uLl1cbiAqICAgICB9XG4gKiBvciB0aGUgZm9sbG93aW5nLCB3aGljaCBtZWFucyBhIEdFVCB3aXRoIG5vIHBhcmFtZXRlcnNcbiAqICAgICBvcGVyYXRpb25OYW1lOiB7XG4gKiAgICAgfVxuICogQW55IG9uZSBvZiB0aG9zZSBtYXkgaGF2ZSBhICdzdWItb3BlcmF0aW9uJyBvZiB0aGUgc2FtZSBmb3JtICh0aG91Z2gsIHRoZSBsYXN0LCB3aXRoIG5laXRoZXIgcGF5bG9hZCBub3JcbiAqIHBhcmFtZXRlcnMgZGVmaW5lZCB3aWxsIGJlIHJlY29nbml6ZWQsIHNpbXBseSBiZWNhdXNlIGl0IGlzIGFtYmlndW91cyB3aXRoIG90aGVyIGVudHJpZXMpLlxuICogICAgICAgICBzdWJPcE5hbWU6IHtcbiAqICAgICAgICAgICAgIHBheWxvYWQ6IHsuLi59LFxuICogICAgICAgICAgICAgW3ZhbGlkYXRlQXM6IGNyZWF0ZXx1cGRhdGVdXG4gKiAgICAgICAgICAgICBbcmV0dXJuOiAuLi5dXG4gKiAgICAgICAgICB9XG4gKiBvclxuICogICAgICAgICBzdWJPcE5hbWU6IHtcbiAqICAgICAgICAgICAgIHBhcmFtZXRlcnM6IHsuLi59LFxuICogICAgICAgICAgICAgW3JldHVybjogLi4uXVxuICogICAgICAgICAgfVxuICogVGhlIHBhcmFtZXRlcnMgYXJlIGV4cGVjdGVkIHRvIGJlIG9uZSBvZiB0aGUgZm9sbG93aW5nIGZvcm1zOlxuICogICAgIHBhcmFtTmFtZToge1xuICogICAgICAgICB0eXBlOiB0eXBlTmFtZSxcbiAqICAgICAgICAgW2Zvcm1hdDogZm9ybWF0VmFsdWVdLFxuICogICAgICAgICBbZW51bTogW3ZhbHVlcy4uLl1dLFxuICogICAgICAgICBbZGVmYXVsdDogZGVmYXVsdFZhbHVlXVxuICogICAgICAgICBbcmVxdWlyZWQ6IHRydWV8ZmFsc2VdXG4gKiAgICAgfVxuICogb3JcbiAqICAgICBwYXJhbU5hbWU6IHtcbiAqICAgICAgICAgdHlwZTogJ3N0cmluZycsXG4gKiAgICAgICAgIGZvcm1hdDogJ29iamVjdFJlZmVyZW5jZScsXG4gKiAgICAgICAgIHJlZmVyZW5jZVRvOiBzY2hlbWFLZXlcbiAqICAgICAgICAgW3JlcXVpcmVkOiB0cnVlfGZhbHNlXVxuICogICAgIH1cbiAqIFdoaWxlLCB0aGUgcmV0dXJuIHZhbHVlIGlzIGV4cGVjdGVkIHRvIGJlIG9uZSBvZiB0aGUgZm9sbG93aW5nOlxuICogICAgIHJldHVybiA6IHtcbiAqICAgICAgICB0eXBlOiB0eXBlTmFtZSxcbiAqICAgICAgICAgW2Zvcm1hdDogZm9ybWF0VmFsdWVdXG4gKiAgICAgfVxuICogb3JcbiAqICAgICByZXR1cm4gOiB7XG4gKiAgICAgICAgdHlwZTogdHlwZU5hbWUsXG4gKiAgICAgICAgIFskcmVmOiBzY2hlbWFLZXldXG4gKiAgICAgfVxuICogb3JcbiAqICAgICByZXR1cm4gOiB7XG4gKiAgICAgICAgdHlwZTogJ2FycmF5JyxcbiAqICAgICAgICAgW2l0ZW1zOiB7XG4gKiAgICAgICAgICAgICAkcmVmOiBzY2hlbWFLZXlcbiAqICAgICAgICAgfV1cbiAqICAgICB9XG4gKiBvclxuICogICAgIHJldHVybiA6IHtcbiAqICAgICAgICB0eXBlOiAnYXJyYXknLFxuICogICAgICAgICBbaXRlbXM6IHtcbiAqICAgICAgICAgICAgIHJlZmVyZW5jZVRvOiBzY2hlbWFLZXlcbiAqICAgICAgICAgfV1cbiAqICAgICB9XG4gKiBUaGVzZSB3aWxsIGJlIG1vZGlmaWVkIGluIHRoZXNlIHdheXM6XG4gKiAgMSkgJHJlZiBhbmQgcmVmZXJlbmNlVG8ncyB3aWxsIGJlIHNldCB0byB0eXBlIG5hbWUgb2YgdGhlIHJlbGV2YW50IHNjaGVtYXNcbiAqICAyKSBBbnkgc3ViLW9wZXJhdGlvbiBpcyBleHRyYWN0ZWQgZnJvbSBpdHMgZGVmYXVsdCBsb2NhdGlvbiwgYW5kIHB1dCBpbnRvIGEgc3ViLW9iamVjdCBjYWxsZWQgZHhPcGVyYXRpb25zXG4gKiAgMykgaW4gdGhlIGNhc2Ugb2YgYSAnbWlzc2luZycgcGFyYW1ldGVycywgYW4gZW1wdHkgb25lIHdpbGwgYmUgaW5zZXJ0ZWQuXG4gKiAgNCkgQW55ICRyZWYgaW4gdGhlIHJldHVybiB2YWx1ZSBvciB0aGUgcmV0dXJuLml0ZW1zIHZhbHVlIHdpbGwgYmUgcmVwbGFjZWQgd2l0aCB0aGUgdHlwZSBuYW1lIG9mIHRoZSBzY2hlbWEuXG4gKiBUaHVzLCB3ZSBnZXQ6XG4gKiB7XG4gKiAgICAgcGF5bG9hZDoge1xuICogICAgICAgICAuLi5wYXlsb2FkIHByb3BlcnRpZXMuLi5cbiAqICAgICAgICAgJHJlZjogPHJlbGF0ZWQgc2NoZW1hPlxuICogICAgIH1cbiAqICAgICB2YWxpZGF0ZUFzOiBjcmVhdGV8dXBkYXRlLFxuICogICAgIFtkeE9wZXJhdGlvbnM6IHtcbiAqICAgICAgICAgLy8gc3ViLW9wZXJhdGlvbnNcbiAqICAgICB9XVxuICogfVxuICogb3JcbiAqIHtcbiAqICAgICBwYXJhbWV0ZXJzOiB7XG4gKiAgICAgICAgIC4uLiBwYXJhbWV0ZXJzIGluZm8sIHdpdGggYW55IHJlZmVyZW5jZVRvJ3Mgc2V0IHRvIHRoZSBhY3R1YWwgcmVsYXRlZCBzY2hlbWEgLi4uXG4gKiAgICAgfSxcbiAqICAgICBbZHhPcGVyYXRpb25zOiB7XG4gKiAgICAgICAgIC8vIHN1Yi1vcGVyYXRpb25zXG4gKiAgICAgfV1cbiAqIH1cbiAqL1xuZnVuY3Rpb24gcHJvY2Vzc09wZXJhdGlvbihvcERlZiwgb3BOYW1lLCBzb3VyY2VTY2hlbWFzKSB7XG4gICAgaWYgKG9wRGVmLnBheWxvYWQpIHtcbiAgICAgICAgaWYgKG9wRGVmLnBhcmFtZXRlcnMpIHtcbiAgICAgICAgICAgIGR4VXRpbC5mYWlsKCdGb3VuZCBib3RoIGEgcGF5bG9hZCBhbmQgYSBwYXJhbWV0ZXJzIGZvciB0aGUgb3BlcmF0aW9uICcgKyBvcE5hbWUgKyAnLicpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvcERlZi5wYXlsb2FkLiRyZWYpIHtcbiAgICAgICAgICAgIG9wRGVmLnBheWxvYWQuJHJlZiA9IHNjaGVtYUtleVRvVHlwZU5hbWUob3BEZWYucGF5bG9hZC4kcmVmLCBzb3VyY2VTY2hlbWFzKTtcbiAgICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAgIG9wRGVmLnBhcmFtZXRlcnMgPSBvcERlZi5wYXJhbWV0ZXJzIHx8IHt9O1xuXG4gICAgICAgIF8uZWFjaChvcERlZi5wYXJhbWV0ZXJzLCBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICAgICAgaWYgKHZhbHVlLnJlZmVyZW5jZVRvKSB7XG4gICAgICAgICAgICAgICAgdmFsdWUucmVmZXJlbmNlVG8gPSBzY2hlbWFLZXlUb1R5cGVOYW1lKHZhbHVlLnJlZmVyZW5jZVRvLCBzb3VyY2VTY2hlbWFzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgaWYgKG9wRGVmLnJldHVybikge1xuICAgICAgICBjb252ZXJ0VHlwZVJlZmVyZW5jZShvcERlZi5yZXR1cm4sIHNvdXJjZVNjaGVtYXMpO1xuICAgIH1cblxuICAgIC8vIE1vdmUgYW55IHN1Yi1vcGVyYXRpb25zIGludG8gYSBzdWItb2JqZWN0XG4gICAgXy5lYWNoKG9wRGVmLCBmdW5jdGlvbih2YWx1ZSwga2V5KSB7XG4gICAgICAgIGlmIChrZXkgPT09ICdwYXlsb2FkJyB8fCBrZXkgPT09ICdwYXJhbWV0ZXJzJykge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmICh2YWx1ZS5wYXlsb2FkIHx8IHZhbHVlLnBhcmFtZXRlcnMpIHtcbiAgICAgICAgICAgIG9wRGVmLmR4T3BlcmF0aW9ucyA9IG9wRGVmLmR4T3BlcmF0aW9ucyB8fCB7fTtcbiAgICAgICAgICAgIG9wRGVmLmR4T3BlcmF0aW9uc1trZXldID0gcHJvY2Vzc09wZXJhdGlvbih2YWx1ZSwgb3BOYW1lICsgJy4nICsga2V5LCBzb3VyY2VTY2hlbWFzKTtcbiAgICAgICAgICAgIGRlbGV0ZSBvcERlZltrZXldO1xuICAgICAgICB9XG4gICAgfSk7XG5cbiAgICByZXR1cm4gb3BEZWY7XG59XG5cbi8qXG4gKiBHaXZlbiBhIHR5cGUgcmVmZXJlbmNlIChhIHByb3BlcnR5IHR5cGUgZGVmaW5pdGlvbiwgb3IgYSByZXR1cm4gdmFsdWUgZGVmaW5pdGlvbiksIGNvbnZlcnQgYW55IHJlZmVyZW5jZXMgdG9cbiAqIHNjaGVtYSB0eXBlcyBmcm9tIHNjaGVtYUtleSBmb3JtYXQgdG8gdGhlIGFjdHVhbCB0eXBlIG5hbWUuXG4gKi9cbmZ1bmN0aW9uIGNvbnZlcnRUeXBlUmVmZXJlbmNlKHByb3BEYXRhLCBzb3VyY2VTY2hlbWFzKSB7XG4gICAgZnVuY3Rpb24gY29udmVydFJlZmVyZW5jZXModHlwZSwgcHJvcERhdGEpIHtcbiAgICAgICAgaWYgKHR5cGUgPT09ICdhcnJheScgJiYgXy5oYXMocHJvcERhdGEsICdpdGVtcycpKSB7XG4gICAgICAgICAgICBpZiAoXy5oYXMocHJvcERhdGEuaXRlbXMsICckcmVmJykpIHtcbiAgICAgICAgICAgICAgICBwcm9wRGF0YS5pdGVtcy4kcmVmID0gc2NoZW1hS2V5VG9UeXBlTmFtZShwcm9wRGF0YS5pdGVtcy4kcmVmLCBzb3VyY2VTY2hlbWFzKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoXy5oYXMocHJvcERhdGEuaXRlbXMsICdyZWZlcmVuY2VUbycpKSB7XG4gICAgICAgICAgICAgICAgcHJvcERhdGEuaXRlbXMucmVmZXJlbmNlVG8gPSBzY2hlbWFLZXlUb1R5cGVOYW1lKHByb3BEYXRhLml0ZW1zLnJlZmVyZW5jZVRvLCBzb3VyY2VTY2hlbWFzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlID09PSAnc3RyaW5nJyAmJiBwcm9wRGF0YS5mb3JtYXQgPT09ICdvYmplY3RSZWZlcmVuY2UnICYmIHByb3BEYXRhLnJlZmVyZW5jZVRvKSB7XG4gICAgICAgICAgICBwcm9wRGF0YS5yZWZlcmVuY2VUbyA9IHNjaGVtYUtleVRvVHlwZU5hbWUocHJvcERhdGEucmVmZXJlbmNlVG8sIHNvdXJjZVNjaGVtYXMpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGUgPT09ICdvYmplY3QnICYmIHByb3BEYXRhLiRyZWYpIHtcbiAgICAgICAgICAgIHByb3BEYXRhLiRyZWYgPSBzY2hlbWFLZXlUb1R5cGVOYW1lKHByb3BEYXRhLiRyZWYsIHNvdXJjZVNjaGVtYXMpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgaWYgKF8uaXNBcnJheShwcm9wRGF0YS50eXBlKSkge1xuICAgICAgICBfLmVhY2gocHJvcERhdGEudHlwZSwgZnVuY3Rpb24odHlwZUl0ZW0pIHtcbiAgICAgICAgICAgIGNvbnZlcnRSZWZlcmVuY2VzKHR5cGVJdGVtLCBwcm9wRGF0YSk7XG4gICAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnZlcnRSZWZlcmVuY2VzKHByb3BEYXRhLnR5cGUsIHByb3BEYXRhKTtcbiAgICB9XG59XG5cbi8qXG4gKiBXYWxrIHRocm91Z2ggZWFjaCBsaXN0IG9wZXJhdGlvbiwgYW5kIGFkZCBhIGR4RmlsdGVyTW9kZSBwcm9wZXJ0eSB0byBlYWNoLiBUaGUgdmFsdWVzIGFyZTpcbiAqICAgIG5vbmU6IFRoZXJlIGFyZSBubyBxdWVyeSBwYXJhbWV0ZXJzLCBubyBmaWx0ZXIgaXMgbmVlZGVkXG4gKiAgICB1YmVyOiBFdmVyeSBwYXJhbWV0ZXIgaGFzIGEgbWFwc1RvIHByb3BlcnR5LCBzbyB0aGUgdWJlckZpbHRlciBjYW4gYmUgdXNlZFxuICogICAgY3VzdG9tOiBOb3QgZW5vdWdoIGluZm9ybWF0aW9uLiBBIGN1c3RvbSBmaWx0ZXIgd2lsbCBiZSBuZWVkZWQuXG4gKi9cbmZ1bmN0aW9uIG1hcmtMaXN0T3BlcmF0aW9ucyhzY2hlbWFzKSB7XG4gICAgXy5lYWNoKHNjaGVtYXMsIGZ1bmN0aW9uKHNjaGVtYSkge1xuICAgICAgICBpZiAoc2NoZW1hLmxpc3QpIHtcbiAgICAgICAgICAgIGlmIChfLmlzRW1wdHkoc2NoZW1hLmxpc3QucGFyYW1ldGVycykpIHtcbiAgICAgICAgICAgICAgICBzY2hlbWEubGlzdC5keEZpbHRlck1vZGUgPSBkeENvbnN0YW50cy5MSVNUX1RZUEVTLk5PTkU7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHZhciBtaXNzaW5nTWFwc1RvID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgXy5hbnkoc2NoZW1hLmxpc3QucGFyYW1ldGVycywgZnVuY3Rpb24ocGFyYW0pIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFwYXJhbS5tYXBzVG8pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1pc3NpbmdNYXBzVG8gPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBzY2hlbWEubGlzdC5keEZpbHRlck1vZGUgPSBtaXNzaW5nTWFwc1RvID8gZHhDb25zdGFudHMuTElTVF9UWVBFUy5DVVNUT00gOlxuICAgICAgICAgICAgICAgICAgICBkeENvbnN0YW50cy5MSVNUX1RZUEVTLlVCRVI7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9KTtcbn1cblxuLypcbiAqIEdpdmVuIGEgc2V0IG9mIHNjaGVtYXMsIG1vZGlmeSB0aGVtIHNvIHRoYXQgdGhleSBhcmUgbW9yZSBlYXNpbHkgY29uc3VtYWJsZSBieSBvdGhlciBsYXllcnMgb2YgdGhlIGRhdGEgc3lzdGVtLlxuICpcbiAqIFNwZWNpZmljYWxseSwgdGhpcyBleHBlY3RzIHRoZSBzY2hlbWFzIHRvIGNvbWUgaW4gdGhlIGZvcm06XG4gKiB7XG4gKiAgICAgJ3NjaGVtYUtleSc6IHtcbiAqICAgICAgICBbbmFtZTogdHlwZU5hbWUsXVxuICogICAgICAgIFtzaW5nbGV0b246IHRydWV8ZmFsc2UsXVxuICogICAgICAgIFtleHRlbmRzOiB7ICRyZWY6ICdzY2hlbWFLZXknIH0sXVxuICogICAgICAgIFtyb290OiAndXJsLWZyYWdtZW50JyxdXG4gKiAgICAgICAgW3Byb3BlcnRpZXM6IHsuLi59LF1cbiAqICAgICAgICBbY3JlYXRlOiB7Li4ufSxdXG4gKiAgICAgICAgW3JlYWQ6IHsuLi59LF1cbiAqICAgICAgICBbbGlzdDogey4uLn0sXVxuICogICAgICAgIFt1cGRhdGU6IHsuLi59LF1cbiAqICAgICAgICBbZGVsZXRlOiB7Li4ufSxdXG4gKiAgICAgICAgW29wZXJhdGlvbnM6IHsuLi59LF1cbiAqICAgICAgICBbcm9vdE9wZXJhdGlvbnM6IHsuLi59XVxuICogICAgIH0sXG4gKiAgICAgLi4uXG4gKiB9XG4gKiBFYWNoIHNjaGVtYSBtYXkgaW5jbHVkZSBvdGhlciBwcm9wZXJ0aWVzLCBidXQgdGhpcyB3aWxsIGlnbm9yZSB0aGVtLlxuICpcbiAqIFRoZSByZXR1cm4gdmFsdWUgZnJvbSB0aGlzIHJvdXRpbmUgaXMgYSBuZXcgdmVyc2lvbiBvZiB0aGUgc2NoZW1hcywgd2l0aCBtb2RpZmljYXRpb25zIGFzIGRpc2N1c3NlZCBpbiBlYWNoIHNlY3Rpb25cbiAqIGJlbG93LlxuICpcbiAqIHNjaGVtYXM6ICAgICAgICAgICAgICAgVGhlIHNldCBvZiBzY2hlbWFzIHRvIGJlIHByZXBhcmVkLiAgVGhpcyBpcyB0aGUgb25seSBwYXJhbWV0ZXIgdGhhdCBtdXN0IGJlIHByb3ZpZGVkLlxuICogY29weVNjaGVtYXM6ICAgICAgICAgICBJZiB0cnV0aHksIHRoaXMgd2lsbCBtYWtlIGEgY29weSBvZiB0aGUgcHJvdmlkZWQgc2NoZW1hcyBiZWZvcmUgbWFraW5nIGNoYW5nZXMgdG8gdGhlbS5cbiAqICAgICAgICAgICAgICAgICAgICAgICAgT3RoZXJ3aXNlIHRoZSBvcmlnaW5hbCBzY2hlbWEgb2JqZWN0cyB3aWxsIGJlIGFsdGVyZWQuXG4gKiBwcmVzZXJ2ZVVubmVlZGVkOiAgICAgIElmIHRydXRoeSwgcHJvcGVydGllcyBsaWtlICdkZXNjcmlwdGlvbicgdGhhdCBhcmVuJ3QgbmVlZGVkIHdpbGwgbm90IGJlIGRlbGV0ZWQuXG4gKi9cbmZ1bmN0aW9uIHByZXBhcmVTY2hlbWFzKHNjaGVtYXMsIGNvcHlTY2hlbWFzLCBwcmVzZXJ2ZVVubmVlZGVkKSB7XG4gICAgdmFyIG5ld1NjaGVtYXMgPSB7fTtcblxuICAgIGlmICghXy5pc09iamVjdChzY2hlbWFzKSkge1xuICAgICAgICBkeFV0aWwuZmFpbCgnTXVzdCBwcm92aWRlIGEgc2NoZW1hcyBvYmplY3QuJyk7XG4gICAgfVxuXG4gICAgLy8gQWx3YXlzIGNvcHkgdGhlIHNjaGVtYXMgYXQgdGhpcyB0aW1lLCBhcyBpdCBjYXVzZWQgbW9kZWwtZ2VuZXJhdG9yIHRvIGJlIHVuaGFwcHkuXG4gICAgaWYgKGNvcHlTY2hlbWFzIHx8IHRydWUpIHtcbiAgICAgICAgc2NoZW1hcyA9IGR4VXRpbC5kZWVwQ2xvbmUoc2NoZW1hcyk7XG4gICAgfVxuXG4gICAgXy5lYWNoKHNjaGVtYXMsIGZ1bmN0aW9uKHZhbHVlLCBrZXkpIHtcbiAgICAgICAgcHJvY2Vzc1NjaGVtYSh2YWx1ZSwga2V5LCBzY2hlbWFzLCBuZXdTY2hlbWFzLCBwcmVzZXJ2ZVVubmVlZGVkKTtcbiAgICB9KTtcblxuICAgIC8qXG4gICAgICogRmluYWxseSwgYWRkIGEgZmxhZyB0byBlYWNoIGxpc3Qgb3BlcmF0aW9uIHRvIGRldGVybWluZSB3aGV0aGVyIGl0IGNhbiBiZSBnZW5lcmljYWxseSBmaWx0ZXJlZCwgb3Igd2hldGhlclxuICAgICAqIGl0IG5lZWRzIGhlbHBcbiAgICAgKi9cbiAgICBtYXJrTGlzdE9wZXJhdGlvbnMobmV3U2NoZW1hcyk7XG5cbiAgICByZXR1cm4gbmV3U2NoZW1hcztcbn1cblxuLypcbiAqIEdpdmVuIGEgc2V0IG9mIHByZXBhcmVkIHNjaGVtYXMsIHRoaXMgd2lsbCBmaW5kIGVudW1zIHRoYXQgYXJlIHByb3BlcnRpZXMgb2YgYSB0eXBlIGFuZCBlbnVtcyB0aGF0IGFyZSBkZWZpbmVkIGFzXG4gKiBwYXJhbWV0ZXJzIG9mIGxpc3QsIG9iamVjdCwgYW5kIHJvb3Qgb3BlcmF0aW9ucy4gIFRoZSBleHBlY3RlZCBpbnB1dCBmb3JtYXQgb2YgdGhlIHByZXBhcmVkIHNjaGVtYXMgaXMgYXMgZm9sbG93czpcbiAqXG4gKiAge1xuICogICAgICB0eXBlTmFtZToge1xuICogICAgICAgICAgW3Byb3BlcnRpZXM6IHtcbiAqICAgICAgICAgICAgICBwcm9wZXJ0eU5hbWU6IHtcbiAqICAgICAgICAgICAgICAgICAgZW51bTogW3ZhbHVlLCAuLi5dXG4gKiAgICAgICAgICAgICAgfSxcbiAqICAgICAgICAgICAgICBhcnJheVByb3BlcnR5TmFtZToge1xuICogICAgICAgICAgICAgICAgICBpdGVtczoge1xuICogICAgICAgICAgICAgICAgICAgICAgZW51bTogW3ZhbHVlLCAuLi5dXG4gKiAgICAgICAgICAgICAgICAgIH1cbiAqICAgICAgICAgICAgICB9XG4gKiAgICAgICAgICB9LF1cbiAqICAgICAgICAgIFtsaXN0OiB7XG4gKiAgICAgICAgICAgICAgcGFyYW1ldGVyczoge1xuICogICAgICAgICAgICAgICAgICBwYXJhbWV0ZXJOYW1lOiB7XG4gKiAgICAgICAgICAgICAgICAgICAgICBlbnVtOiBbdmFsdWUsIC4uLl1cbiAqICAgICAgICAgICAgICAgICAgfVxuICogICAgICAgICAgICAgIH1cbiAqICAgICAgICAgIH0sXVxuICogICAgICAgICAgW3Jvb3RPcGVyYXRpb25zfG9wZXJhdGlvbnM6IHtcbiAqICAgICAgICAgICAgICBvcGVyYXRpb25OYW1lOiB7XG4gKiAgICAgICAgICAgICAgICAgIHBhcmFtZXRlcnM6IHsuLi59XG4gKiAgICAgICAgICAgICAgfVxuICogICAgICAgICAgfV1cbiAqICAgICAgfVxuICogIH1cbiAqXG4gKiBObyBzcGVjaWZpYyB0eXBlcywgcHJvcGVydGllcyBvciBwYXJhbWV0ZXJzIGFyZSByZXF1aXJlZCwgYW5kIGV4Y2VzcyBwcm9wZXJ0aWVzIHdpbGwgYmUgaWdub3JlZC4gIFRoZSBvdXRwdXQgaXMgYW5cbiAqIG9iamVjdCB3aGVyZSBlYWNoIHR5cGUgYW5kIGl0cyBlbnVtcyBjYW4gYmUgYWNjZXNzZWQgYXMgcHJvcGVydGllczpcbiAqXG4gKiAge1xuICogICAgICB0eXBlTmFtZToge1xuICogICAgICAgICAgKHByb3BlcnR5fG9wZXJhdGlvbilOYW1lOiB7XG4gKiAgICAgICAgICAgICAgdmFsdWU6IHZhbHVlXG4gKiAgICAgICAgICAgICAgLi4uXG4gKiAgICAgICAgICB9XG4gKiAgICAgIH1cbiAqICB9XG4gKlxuICovXG5mdW5jdGlvbiBwcmVwYXJlRW51bXMoc2NoZW1hcykge1xuICAgIHZhciBlbnVtcyA9IHt9O1xuXG4gICAgaWYgKCFfLmlzT2JqZWN0KHNjaGVtYXMpKSB7XG4gICAgICAgIGR4VXRpbC5mYWlsKCdNdXN0IHByb3ZpZGUgYSBzZXQgb2YgcHJlcGFyZWQgc2NoZW1hcy4nKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBwcm9jZXNzRW51bSh0eXBlLCBuYW1lLCBkZWZpbml0aW9uKSB7XG4gICAgICAgIHZhciBlbnVtVHlwZSA9IGVudW1zW3R5cGVdID0gZW51bXNbdHlwZV0gfHwge307XG4gICAgICAgIHZhciBlbnVtUHJvcCA9IGVudW1UeXBlW25hbWVdID0gZW51bVR5cGVbbmFtZV0gfHwge307XG4gICAgICAgIF8uZWFjaChkZWZpbml0aW9uLmVudW0sIGZ1bmN0aW9uKGVudW1WYWwpIHtcbiAgICAgICAgICAgIGVudW1Qcm9wW2VudW1WYWxdID0gZW51bVZhbDtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcHJvY2Vzc1BhcmFtZXRlcnModHlwZSwgb3BEZWYpIHtcbiAgICAgICAgXy5lYWNoKG9wRGVmLnBhcmFtZXRlcnMsIGZ1bmN0aW9uKHBhcmFtRGVmLCBwYXJhbU5hbWUpIHtcbiAgICAgICAgICAgIGlmIChwYXJhbURlZi5lbnVtKSB7XG4gICAgICAgICAgICAgICAgcHJvY2Vzc0VudW0odHlwZSwgcGFyYW1OYW1lLCBwYXJhbURlZik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIF8uZWFjaChzY2hlbWFzLCBmdW5jdGlvbihzY2hlbWEsIHR5cGUpIHtcbiAgICAgICAgXy5lYWNoKHNjaGVtYS5wcm9wZXJ0aWVzLCBmdW5jdGlvbihwcm9wRGVmLCBwcm9wTmFtZSkge1xuICAgICAgICAgICAgaWYgKHByb3BEZWYuZW51bSkge1xuICAgICAgICAgICAgICAgIHByb2Nlc3NFbnVtKHR5cGUsIHByb3BOYW1lLCBwcm9wRGVmKTtcbiAgICAgICAgICAgIC8vIEFycmF5IG9mIGVudW1zXG4gICAgICAgICAgICB9IGVsc2UgaWYgKHByb3BEZWYuaXRlbXMgJiYgcHJvcERlZi5pdGVtcy5lbnVtKSB7XG4gICAgICAgICAgICAgICAgcHJvY2Vzc0VudW0odHlwZSwgcHJvcE5hbWUsIHByb3BEZWYuaXRlbXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICAvLyBDb2xsZWN0IGVudW1zIGZyb20gbGlzdCwgcm9vdCBvcGVyYXRpb24sIGFuZCBvYmplY3Qgb3BlcmF0aW9uIHBhcmFtZXRlcnNcbiAgICAgICAgaWYgKHNjaGVtYS5saXN0KSB7XG4gICAgICAgICAgICBwcm9jZXNzUGFyYW1ldGVycyh0eXBlLCBzY2hlbWEubGlzdCk7XG4gICAgICAgIH1cbiAgICAgICAgXy5lYWNoKHNjaGVtYS5yb290T3BlcmF0aW9ucywgZnVuY3Rpb24ocm9vdE9wRGVmKSB7XG4gICAgICAgICAgICBwcm9jZXNzUGFyYW1ldGVycyh0eXBlLCByb290T3BEZWYpO1xuICAgICAgICB9KTtcbiAgICAgICAgXy5lYWNoKHNjaGVtYS5vcGVyYXRpb25zLCBmdW5jdGlvbihvcERlZikge1xuICAgICAgICAgICAgcHJvY2Vzc1BhcmFtZXRlcnModHlwZSwgb3BEZWYpO1xuICAgICAgICB9KTtcbiAgICB9KTtcblxuICAgIHJldHVybiBlbnVtcztcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gICAgX3ByZXBhcmVTY2hlbWFzOiBwcmVwYXJlU2NoZW1hcyxcbiAgICBfcHJlcGFyZUVudW1zOiBwcmVwYXJlRW51bXNcbn07XG4iLCIvKlxuICogQ29weXJpZ2h0IChjKSAyMDE0LCAyMDE1IGJ5IERlbHBoaXguIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKi9cblxuLyogZ2xvYmFsIF8sIEJhY2tib25lICovXG5cbid1c2Ugc3RyaWN0JztcblxuY29uc3QgZHhVdGlsID0gcmVxdWlyZSgnZHhjb3JlL2pzL3V0aWwuanMnKTtcblxuZnVuY3Rpb24gZHVtcEV2ZW50TGlzdG5lcnMoZXZlbnRMYWRlbk9iamVjdCkge1xuICAgIHZhciBmdW5jdGlvbk5hbWVSZWdFeCA9IC8uKmZ1bmN0aW9uICooW14gXFwoXSopICpcXCgvO1xuICAgIF8uZWFjaChldmVudExhZGVuT2JqZWN0Ll9ldmVudHMsIGZ1bmN0aW9uKGxpc3RlbmVyQXJyYXksIGV2ZW50TmFtZSkge1xuICAgICAgICB2YXIgYW5vbnltb3VzQ291bnQgPSAwO1xuICAgICAgICB2YXIgY2FsbGJhY2tOYW1lcyA9IF8ucmVkdWNlKGxpc3RlbmVyQXJyYXksIGZ1bmN0aW9uKG1lbW8sIGl0ZW0pIHtcbiAgICAgICAgICAgIGlmIChpdGVtLmNhbGxiYWNrKSB7XG4gICAgICAgICAgICAgICAgdmFyIGZ1bmN0aW9uU3RyaW5nID0gaXRlbS5jYWxsYmFjay50b1N0cmluZygpO1xuICAgICAgICAgICAgICAgIHZhciBmdW5jdGlvbk5hbWUgPSBmdW5jdGlvblN0cmluZy5tYXRjaChmdW5jdGlvbk5hbWVSZWdFeCk7XG4gICAgICAgICAgICAgICAgaWYgKGZ1bmN0aW9uTmFtZSAmJiBmdW5jdGlvbk5hbWVbMV0gIT09ICcnKSB7XG4gICAgICAgICAgICAgICAgICAgIG1lbW8ucHVzaChmdW5jdGlvbk5hbWVbMV0pO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGFub255bW91c0NvdW50Kys7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG1lbW87XG4gICAgICAgIH0sIFtdKTtcblxuICAgICAgICAvLyBEb24ndCBzaG93IHRoZSBpbnRlcm5hbCBjYWxsYmFja3MgdXNlZCBieSB0aGlzIGNhY2hlIHRvIG1hbmdlIHRoZSBtb2RlbHMuIFRoZXNlIG5ldmVyIGFmZmVjdCBwcnVuZSgpLlxuICAgICAgICBpZiAoY2FsbGJhY2tOYW1lcy5sZW5ndGggPT09IDEgJiZcbiAgICAgICAgICAgIChldmVudE5hbWUgPT09ICdiYWRSZWZlcmVuY2UnICYmIGNhbGxiYWNrTmFtZXNbMF0gPT09ICdoYW5kbGU0MDQnIHx8XG4gICAgICAgICAgICBldmVudE5hbWUgPT09ICdjaGFuZ2UnICYmIGNhbGxiYWNrTmFtZXNbMF0gPT09ICd1cGRhdGVDb2xsZWN0aW9ucycpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHN1ZmZpeCA9IGNhbGxiYWNrTmFtZXMubGVuZ3RoID09PSAwID8gJycgOiAnLiAnICsgY2FsbGJhY2tOYW1lcy5qb2luKCcsJyk7XG4gICAgICAgIGlmIChhbm9ueW1vdXNDb3VudCA+IDApIHtcbiAgICAgICAgICAgIHN1ZmZpeCArPSAnICgnICsgYW5vbnltb3VzQ291bnQgKyAnIGFub255bW91cyknO1xuICAgICAgICB9XG4gICAgICAgIGR4VXRpbC5pbmZvKCcgICAnICsgZXZlbnROYW1lICsgJyA6ICcgKyBsaXN0ZW5lckFycmF5Lmxlbmd0aCArICcgY2FsbGJhY2tzJyArIHN1ZmZpeCk7XG4gICAgfSk7XG59XG5cbi8qXG4gKiBBIHNpbXBsZSBjYWNoZSBvZiBzdWJzY3JpYmVycyAoY29sbGVjdGlvbnMgb3Igbm90aWZpY2F0aW9uIGxpc3RlbmVycykuICBOb3RlIHRoYXQgdGhlc2UgYXJlIHN0b3JlZCBieSB0aGUgdHlwZSB0aGF0XG4gKiB0aGUgbGlzdCBvcGVyYXRpb24gZm9yIHRoZSBzcGVjaWZpZWQgdHlwZSByZXR1cm5zLCB3aGljaCBpbiBzb21lIGNhc2VzIGlzIGRpZmZlcmVudCB0aGFuIHRoZSBzcGVjaWZpZWQgdHlwZS5cbiAqIFRoaXMgaXMgYSBwcml2YXRlIHR5cGUsIHNvIGl0IGRvZXMgbm8gY2hlY2tpbmcgb2YgYXJndW1lbnRzLlxuICovXG5mdW5jdGlvbiBNb2RlbFN1YnNjcmliZXJTdG9yZSgpIHtcbiAgICB2YXIgbW9kZWxTdWJzY3JpYmVyc0J5VHlwZSA9IHt9O1xuXG4gICAgZnVuY3Rpb24gZm9yRWFjaFN1YnNjcmlwdGlvbihmdW5jdGlvblRvQXBwbHkpIHtcbiAgICAgICAgXy5lYWNoKG1vZGVsU3Vic2NyaWJlcnNCeVR5cGUsIGZ1bmN0aW9uKHN1YnNjcmliZXIpIHtcbiAgICAgICAgICAgIF8uZWFjaChzdWJzY3JpYmVyLCBmdW5jdGlvblRvQXBwbHkpO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBhZGQoc3Vic2NyaWJlcikge1xuICAgICAgICB2YXIgYmFzZVR5cGUgPSBzdWJzY3JpYmVyLl9keEluZm8uYmFzZVR5cGU7XG4gICAgICAgIG1vZGVsU3Vic2NyaWJlcnNCeVR5cGVbYmFzZVR5cGVdID0gbW9kZWxTdWJzY3JpYmVyc0J5VHlwZVtiYXNlVHlwZV0gfHwgW107XG5cbiAgICAgICAgaWYgKG1vZGVsU3Vic2NyaWJlcnNCeVR5cGVbYmFzZVR5cGVdLmluZGV4T2Yoc3Vic2NyaWJlcikgPT09IC0xKSB7XG4gICAgICAgICAgICBtb2RlbFN1YnNjcmliZXJzQnlUeXBlW2Jhc2VUeXBlXS5wdXNoKHN1YnNjcmliZXIpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcmVtb3ZlKHN1YnNjcmliZXIpIHtcbiAgICAgICAgdmFyIGJhc2VUeXBlID0gc3Vic2NyaWJlci5fZHhJbmZvLmJhc2VUeXBlO1xuICAgICAgICB2YXIgaW5kZXggPSBtb2RlbFN1YnNjcmliZXJzQnlUeXBlW2Jhc2VUeXBlXS5pbmRleE9mKHN1YnNjcmliZXIpO1xuICAgICAgICBpZiAoaW5kZXggIT09IC0xKSB7XG4gICAgICAgICAgICBpZiAoc3Vic2NyaWJlciBpbnN0YW5jZW9mIEJhY2tib25lLkNvbGxlY3Rpb24pIHtcbiAgICAgICAgICAgICAgICBzdWJzY3JpYmVyLmNsZWFyKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBtb2RlbFN1YnNjcmliZXJzQnlUeXBlW2Jhc2VUeXBlXS5zcGxpY2UoaW5kZXgsIDEpO1xuXG4gICAgICAgICAgICBpZiAoXy5pc0VtcHR5KG1vZGVsU3Vic2NyaWJlcnNCeVR5cGVbYmFzZVR5cGVdKSkge1xuICAgICAgICAgICAgICAgIGRlbGV0ZSBtb2RlbFN1YnNjcmliZXJzQnlUeXBlW2Jhc2VUeXBlXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGhhc1R5cGUodHlwZU5hbWUpIHtcbiAgICAgICAgcmV0dXJuICEhbW9kZWxTdWJzY3JpYmVyc0J5VHlwZVt0eXBlTmFtZV07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ2V0QWxsT2ZUeXBlKHR5cGVOYW1lKSB7XG4gICAgICAgIHJldHVybiBtb2RlbFN1YnNjcmliZXJzQnlUeXBlW3R5cGVOYW1lXSB8fCBbXTtcbiAgICB9XG5cbiAgICAvKlxuICAgICAqIEZvcmNpYmx5IGVtcHR5IGFsbCBjb2xsZWN0aW9ucyBpbiB0aGUgc3RvcmUsIGFuZCB0aGVuIHJlbW92ZSBhbGwgc3Vic2NyaWJlcnNcbiAgICAgKi9cbiAgICBmdW5jdGlvbiByZXNldCgpIHtcbiAgICAgICAgdmFyIHRvUmVtb3ZlID0gW107XG5cbiAgICAgICAgLy8gYWNjdW11bGF0ZSB0aGUgaXRlbXMgdG8gcmVtb3ZlXG4gICAgICAgIGZvckVhY2hTdWJzY3JpcHRpb24oZnVuY3Rpb24oc3Vic2NyaWJlcikge1xuICAgICAgICAgICAgdG9SZW1vdmUucHVzaChzdWJzY3JpYmVyKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgLy8gbm93IHJlbW92ZSB0aGVtIChyZW1vdmluZyB3aGlsZSBhY2N1bXVsYXRpbmcgY2FuIG1lc3MgdXAgdGhlIGxvb3BzKVxuICAgICAgICBfLmVhY2godG9SZW1vdmUsIHJlbW92ZSk7XG4gICAgfVxuXG4gICAgLypcbiAgICAgKiBSZW1vdmUgYWxsIHN1YnNjcmliZXJzIHRoYXQgaGF2ZSBubyBtb3JlIGxpc3RlbmVyc1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIHBydW5lKCkge1xuICAgICAgICB2YXIgdG9SZW1vdmUgPSBbXTtcblxuICAgICAgICBmb3JFYWNoU3Vic2NyaXB0aW9uKGZ1bmN0aW9uKHN1YnNjcmliZXIpIHtcbiAgICAgICAgICAgIGlmIChzdWJzY3JpYmVyIGluc3RhbmNlb2YgQmFja2JvbmUuQ29sbGVjdGlvbikge1xuICAgICAgICAgICAgICAgIGlmIChfLmlzRW1wdHkoc3Vic2NyaWJlci5fZXZlbnRzKSkge1xuICAgICAgICAgICAgICAgICAgICB0b1JlbW92ZS5wdXNoKHN1YnNjcmliZXIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSBpZiAoIXN1YnNjcmliZXIuaW5Vc2UpIHtcbiAgICAgICAgICAgICAgICAvLyBpdCBpcyBhIGNyZWF0aW9uIExpc3RlbmVyXG4gICAgICAgICAgICAgICAgdG9SZW1vdmUucHVzaChzdWJzY3JpYmVyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgXy5lYWNoKHRvUmVtb3ZlLCByZW1vdmUpO1xuICAgIH1cblxuICAgIC8qXG4gICAgICogUmV0dXJuczpcbiAgICAgKiAgICB0cnVlOiBJZiB0aGUgc3RvcmUgaGFzIG5vIHN1YnNjcmliZXJzXG4gICAgICogICAgZmFsc2U6IGlmIHRoZSBzdG9yZSBoYXMgb25lIG9yIG1vcmUgc3Vic2NyaWJlcnNcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpc0VtcHR5KCkge1xuICAgICAgICByZXR1cm4gXy5pc0VtcHR5KG1vZGVsU3Vic2NyaWJlcnNCeVR5cGUpO1xuICAgIH1cblxuICAgIC8qXG4gICAgICogV3JpdGUgb3V0IHRoZSBzdWJzY3JpYmVycy5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBkdW1wKCkge1xuICAgICAgICBkeFV0aWwuaW5mbygnU1VCU0NSSUJFUlMnKTtcbiAgICAgICAgZHhVdGlsLmluZm8oJz09PT09PT09PT09Jyk7XG4gICAgICAgIGR4VXRpbC5pbmZvKG1vZGVsU3Vic2NyaWJlcnNCeVR5cGUpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGR1bXBUZXh0KCkge1xuICAgICAgICBkeFV0aWwuaW5mbygnU1VCU0NSSUJFUlMnKTtcbiAgICAgICAgZHhVdGlsLmluZm8oJz09PT09PT09PT09Jyk7XG4gICAgICAgIGlmIChfLmlzRW1wdHkobW9kZWxTdWJzY3JpYmVyc0J5VHlwZSkpIHtcbiAgICAgICAgICAgIGR4VXRpbC5pbmZvKCdOb25lLicpO1xuICAgICAgICB9XG4gICAgICAgIHZhciB0eXBlcyA9IF8ua2V5cyhtb2RlbFN1YnNjcmliZXJzQnlUeXBlKTtcbiAgICAgICAgXy5lYWNoKHR5cGVzLnNvcnQoKSwgZnVuY3Rpb24odHlwZU5hbWUpIHtcbiAgICAgICAgICAgIGR4VXRpbC5pbmZvKHR5cGVOYW1lKTtcbiAgICAgICAgICAgIGR4VXRpbC5pbmZvKCctLS0tLS0tLS0tLS0tJyk7XG4gICAgICAgICAgICBfLmVhY2gobW9kZWxTdWJzY3JpYmVyc0J5VHlwZVt0eXBlTmFtZV0sIGZ1bmN0aW9uKHN1YnNjcmliZXIpIHtcbiAgICAgICAgICAgICAgICBpZiAoc3Vic2NyaWJlciBpbnN0YW5jZW9mIEJhY2tib25lLkNvbGxlY3Rpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGNvbGxlY3Rpb24gPSBzdWJzY3JpYmVyO1xuICAgICAgICAgICAgICAgICAgICB2YXIgcmVmZXJlbmNlcyA9IGNvbGxlY3Rpb24ucmVkdWNlKGZ1bmN0aW9uKG1lbW8sIGl0ZW0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpdGVtLmlkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWVtby5wdXNoKGl0ZW0uaWQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG1lbW87XG4gICAgICAgICAgICAgICAgICAgIH0sIFtdKTtcblxuICAgICAgICAgICAgICAgICAgICB2YXIgc3VmZml4ID0gcmVmZXJlbmNlcy5sZW5ndGggPT09IDAgPyAnJyA6ICAnLiBJRHM6ICcgKyByZWZlcmVuY2VzLmpvaW4oJywgJyk7XG4gICAgICAgICAgICAgICAgICAgIGR4VXRpbC5pbmZvKCcgICAnICsgY29sbGVjdGlvbi5sZW5ndGggKyAnIG1vZGVsIGNvbGxlY3Rpb24nICsgc3VmZml4KTtcbiAgICAgICAgICAgICAgICAgICAgZHVtcEV2ZW50TGlzdG5lcnMoY29sbGVjdGlvbik7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHFwID0gc3Vic2NyaWJlci5nZXRRdWVyeVBhcmFtZXRlcnMoKTtcbiAgICAgICAgICAgICAgICAgICAgZHhVdGlsLmluZm8oJ05vdGlmaWNhdGlvbiBMaXN0ZW5lciB3aXRoIHF1ZXJ5IHBhcmFtczogJyArIChxcCA/IEpTT04uc3RyaW5naWZ5KHFwKSA6ICdOb25lJykpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgICBfbW9kZWxTdWJzY3JpYmVyczogbW9kZWxTdWJzY3JpYmVyc0J5VHlwZSxcbiAgICAgICAgYWRkOiBhZGQsXG4gICAgICAgIHJlbW92ZTogcmVtb3ZlLFxuICAgICAgICBoYXNUeXBlOiBoYXNUeXBlLFxuICAgICAgICBnZXRBbGxPZlR5cGU6IGdldEFsbE9mVHlwZSxcbiAgICAgICAgcmVzZXQ6IHJlc2V0LFxuICAgICAgICBkdW1wOiBkdW1wLFxuICAgICAgICBwcnVuZTogcHJ1bmUsXG4gICAgICAgIGlzRW1wdHk6IGlzRW1wdHksXG4gICAgICAgIGR1bXBUZXh0OiBkdW1wVGV4dFxuICAgIH07XG59XG5cbi8qXG4gKiBBIHNpbXBsZSBjYWNoZSBvZiBzaW5nbGV0b25zLiAgVGhpcyBpcyBhIHByaXZhdGUgdHlwZSwgc28gaXQgZG9lcyBubyBjaGVja2luZyBvZiBhcmd1bWVudHMuXG4gKi9cbmZ1bmN0aW9uIFNpbmdsZXRvblN0b3JlKCkge1xuICAgIHZhciBzaW5nbGV0b25zID0ge307XG5cbiAgICBmdW5jdGlvbiBhZGQoc2luZ2xldG9uKSB7XG4gICAgICAgIHNpbmdsZXRvbnNbc2luZ2xldG9uLmdldCgndHlwZScpXSA9IHNpbmdsZXRvbjtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZXQodHlwZU5hbWUpIHtcbiAgICAgICAgcmV0dXJuIHNpbmdsZXRvbnNbdHlwZU5hbWVdO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHJlbW92ZShzaW5nbGV0b24pIHtcbiAgICAgICAgaWYgKCFfLmlzVW5kZWZpbmVkKHNpbmdsZXRvbnNbc2luZ2xldG9uLmdldCgndHlwZScpXSkpIHtcbiAgICAgICAgICAgIGRlbGV0ZSBzaW5nbGV0b25zW3NpbmdsZXRvbi5nZXQoJ3R5cGUnKV07XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBoYXNUeXBlKHR5cGVOYW1lKSB7XG4gICAgICAgIHJldHVybiAhIXNpbmdsZXRvbnNbdHlwZU5hbWVdO1xuICAgIH1cblxuICAgIC8qXG4gICAgICogRm9yY2libHkgcmVtb3ZlIGFsbCBzaW5nbGV0b25zXG4gICAgICovXG4gICAgZnVuY3Rpb24gcmVzZXQoKSB7XG4gICAgICAgIF8uZWFjaChfLmtleXMoc2luZ2xldG9ucyksIGZ1bmN0aW9uKHR5cGVOYW1lKSB7XG4gICAgICAgICAgICBkZWxldGUgc2luZ2xldG9uc1t0eXBlTmFtZV07XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIC8qXG4gICAgICogUmVtb3ZlIGFsbCBzaW5nbGV0b25zIHRoYXQgaGF2ZSBubyBtb3JlIGxpc3RlbmVyc1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIHBydW5lKCkge1xuICAgICAgICB2YXIgdG9SZW1vdmUgPSBfLmZpbHRlcihzaW5nbGV0b25zLCBmdW5jdGlvbihzaW5nbGV0b24pIHtcbiAgICAgICAgICAgIHJldHVybiBfLmlzRW1wdHkoc2luZ2xldG9uLl9ldmVudHMpO1xuICAgICAgICB9KTtcblxuICAgICAgICBfLmVhY2godG9SZW1vdmUsIGZ1bmN0aW9uKG1vZGVsKSB7XG4gICAgICAgICAgICBkZWxldGUgc2luZ2xldG9uc1ttb2RlbC5nZXQoJ3R5cGUnKV07XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIC8qXG4gICAgICogUmV0dXJuczpcbiAgICAgKiAgICB0cnVlOiBJZiB0aGUgc3RvcmUgaGFzIG5vIHNpbmdsZXRvbnNcbiAgICAgKiAgICBmYWxzZTogaWYgdGhlIHN0b3JlIGhhcyBvbmUgb3IgbW9yZSBzaW5nbGV0b25zXG4gICAgICovXG4gICAgZnVuY3Rpb24gaXNFbXB0eSgpIHtcbiAgICAgICAgcmV0dXJuIF8uaXNFbXB0eShzaW5nbGV0b25zKTtcbiAgICB9XG5cbiAgICAvKlxuICAgICAqIFdyaXRlIG91dCB0aGUgc2luZ2xldG9ucy5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBkdW1wKCkge1xuICAgICAgICBkeFV0aWwuaW5mbygnU0lOR0xFVE9OUycpO1xuICAgICAgICBkeFV0aWwuaW5mbygnPT09PT09PT09PScpO1xuICAgICAgICBkeFV0aWwuaW5mbyhzaW5nbGV0b25zKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBkdW1wVGV4dCgpIHtcbiAgICAgICAgZHhVdGlsLmluZm8oJ1NJTkdMRVRPTlMnKTtcbiAgICAgICAgZHhVdGlsLmluZm8oJz09PT09PT09PT0nKTtcbiAgICAgICAgaWYgKF8uaXNFbXB0eShzaW5nbGV0b25zKSkge1xuICAgICAgICAgICAgZHhVdGlsLmluZm8oJ05vbmUuJyk7XG4gICAgICAgIH1cbiAgICAgICAgXy5lYWNoKHNpbmdsZXRvbnMsIGZ1bmN0aW9uKHNpbmdsZXRvbiwgdHlwZU5hbWUpIHtcbiAgICAgICAgICAgIGR4VXRpbC5pbmZvKHR5cGVOYW1lKTtcbiAgICAgICAgICAgIGR1bXBFdmVudExpc3RuZXJzKHNpbmdsZXRvbik7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICAgIF9zaW5nbGV0b25zOiBzaW5nbGV0b25zLFxuICAgICAgICBhZGQ6IGFkZCxcbiAgICAgICAgZ2V0OiBnZXQsXG4gICAgICAgIHJlbW92ZTogcmVtb3ZlLFxuICAgICAgICBoYXNUeXBlOiBoYXNUeXBlLFxuICAgICAgICByZXNldDogcmVzZXQsXG4gICAgICAgIGR1bXA6IGR1bXAsXG4gICAgICAgIHBydW5lOiBwcnVuZSxcbiAgICAgICAgaXNFbXB0eTogaXNFbXB0eSxcbiAgICAgICAgZHVtcFRleHQ6IGR1bXBUZXh0XG4gICAgfTtcbn1cblxuLypcbiAqIEEgc2ltcGxlIGNhY2hlIG9mIG1vZGVscy4gIFRoZXNlIGFyZSBvcmdhbml6ZWQgYnkgcm9vdCB0eXBlLCB0aGVuIHJlZmVyZW5jZS4gVGhpcyBpcyBhIHByaXZhdGUgdHlwZSwgc28gaXQgZG9lcyBub1xuICogc2lnbmlmaWFuY3QgY2hlY2tpbmcgb2YgYXJndW1lbnRzLlxuICovXG5mdW5jdGlvbiBNb2RlbFN0b3JlKGNvbnRleHQpIHtcbiAgICB2YXIgbW9kZWxzQnlUeXBlVGhlblJlZiA9IHt9O1xuXG4gICAgZnVuY3Rpb24gZm9yRWFjaE1vZGVsKGZ1bmN0aW9uVG9BcHBseSkge1xuICAgICAgICBfLmVhY2gobW9kZWxzQnlUeXBlVGhlblJlZiwgZnVuY3Rpb24obW9kZWxzKSB7XG4gICAgICAgICAgICBfLmVhY2gobW9kZWxzLCBmdW5jdGlvblRvQXBwbHkpO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBhZGQobW9kZWwpIHtcbiAgICAgICAgdmFyIHJvb3RUeXBlID0gY29udGV4dC5fZ2V0Um9vdFR5cGUobW9kZWwuZ2V0KCd0eXBlJykpO1xuICAgICAgICB2YXIgcmVmZXJlbmNlID0gbW9kZWwuZ2V0KCdyZWZlcmVuY2UnKTtcbiAgICAgICAgbW9kZWxzQnlUeXBlVGhlblJlZltyb290VHlwZV0gPSBtb2RlbHNCeVR5cGVUaGVuUmVmW3Jvb3RUeXBlXSB8fCB7fTtcblxuICAgICAgICBpZiAoZHhVdGlsLmlzTm9uZShyZWZlcmVuY2UpKSB7XG4gICAgICAgICAgICBkeFV0aWwuZmFpbCgnQ2FuIG5vdCBjYWNoZSBhIG1vZGVsIHdpdGggbm8gcmVmZXJlbmNlICh0eXBlIGlzOiAnICsgbW9kZWwuZ2V0KCd0eXBlJykgKyAnKS4nKTtcbiAgICAgICAgfVxuXG4gICAgICAgIG1vZGVsc0J5VHlwZVRoZW5SZWZbcm9vdFR5cGVdW3JlZmVyZW5jZV0gPSBtb2RlbDtcbiAgICB9XG5cbiAgICAvLyB0eXBlTmFtZSBpcyBvcHRpb25hbFxuICAgIGZ1bmN0aW9uIGdldChyZWZlcmVuY2UsIHR5cGVOYW1lKSB7XG4gICAgICAgIGlmIChfLmlzVW5kZWZpbmVkKHR5cGVOYW1lKSkge1xuICAgICAgICAgICAgdmFyIHJlc3VsdDtcbiAgICAgICAgICAgIF8uZmluZChtb2RlbHNCeVR5cGVUaGVuUmVmLCBmdW5jdGlvbihtb2RlbHMpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gXy5maW5kKG1vZGVscywgZnVuY3Rpb24obW9kZWwsIG1vZGVsUmVmZXJlbmNlKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChtb2RlbFJlZmVyZW5jZSA9PT0gcmVmZXJlbmNlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSBtb2RlbDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gbW9kZWxzQnlUeXBlVGhlblJlZlt0eXBlTmFtZV0gPyBtb2RlbHNCeVR5cGVUaGVuUmVmW3R5cGVOYW1lXVtyZWZlcmVuY2VdIDogdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcmVtb3ZlKG1vZGVsKSB7XG4gICAgICAgIHZhciByb290VHlwZSA9IGNvbnRleHQuX2dldFJvb3RUeXBlKG1vZGVsLmdldCgndHlwZScpKTtcbiAgICAgICAgdmFyIHJlZmVyZW5jZSA9IG1vZGVsLmdldCgncmVmZXJlbmNlJyk7XG4gICAgICAgIG1vZGVsc0J5VHlwZVRoZW5SZWZbcm9vdFR5cGVdID0gbW9kZWxzQnlUeXBlVGhlblJlZltyb290VHlwZV0gfHwgW107XG4gICAgICAgIG1vZGVsLm9mZih1bmRlZmluZWQsIHVuZGVmaW5lZCwgY29udGV4dCk7XG5cbiAgICAgICAgZGVsZXRlIG1vZGVsc0J5VHlwZVRoZW5SZWZbcm9vdFR5cGVdW3JlZmVyZW5jZV07XG5cbiAgICAgICAgaWYgKF8uaXNFbXB0eShtb2RlbHNCeVR5cGVUaGVuUmVmW3Jvb3RUeXBlXSkpIHtcbiAgICAgICAgICAgIGRlbGV0ZSBtb2RlbHNCeVR5cGVUaGVuUmVmW3Jvb3RUeXBlXTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGhhc01vZGVsKHJlZmVyZW5jZSkge1xuICAgICAgICByZXR1cm4gISFnZXQocmVmZXJlbmNlKTtcbiAgICB9XG5cbiAgICAvKlxuICAgICAqIEZvcmNpYmx5IHJlbW92ZSBhbGwgbW9kZWxzXG4gICAgICovXG4gICAgZnVuY3Rpb24gcmVzZXQoKSB7XG4gICAgICAgIHZhciB0b1JlbW92ZSA9IFtdO1xuXG4gICAgICAgIGZvckVhY2hNb2RlbChmdW5jdGlvbihtb2RlbCkge1xuICAgICAgICAgICAgdG9SZW1vdmUucHVzaChtb2RlbCk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIF8uZWFjaCh0b1JlbW92ZSwgcmVtb3ZlKTtcbiAgICB9XG5cbiAgICAvKlxuICAgICAqIFJlbW92ZSBhbGwgbW9kZWxzIHRoYXQgaGF2ZSBubyBtb3JlIGxpc3RlbmVyc1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIHBydW5lKCkge1xuICAgICAgICB2YXIgdG9SZW1vdmUgPSB7fTtcblxuICAgICAgICBmb3JFYWNoTW9kZWwoZnVuY3Rpb24obW9kZWwsIHJlZmVyZW5jZSkge1xuICAgICAgICAgICAgdmFyIGV2ZW50cyA9IG1vZGVsLl9ldmVudHMgfHwge307XG4gICAgICAgICAgICAvKlxuICAgICAgICAgICAgICogT3VyIG1vZGVsIGNyZWF0aW9uIHN5c3RlbSBjdXJyZW50bHkgc2V0cyB1cCBsaXN0ZW5lcnMgb24gYmFkUmVmZXJlbmNlLiAgSWYgYSBtb2RlbCBoYXNcbiAgICAgICAgICAgICAqIG9ubHkgb25lIGxpc3RlbmVyIGZvciB0aGF0IGV2ZW50LCB3ZSB3YW50IHRvIGlnbm9yZSBpdCB3aGVuIHdlIGNvbnNpZGVyIHdoZXRoZXIgdGhlIG1vZGVsIGhhcyBhbnlcbiAgICAgICAgICAgICAqIGxpc3RlbmVycyB0aGF0IHNob3VsZCBwcmV2ZW50IGl0IGZyb20gYmVpbmcgcHJ1bmVkLiAod2UgZG9uJ3QgbWluZCBwcnVuaW5nIHNvbWV0aGluZyB0aGF0IG9ubHkgaGFzXG4gICAgICAgICAgICAgKiBsaXN0ZW5lcnMgc2V0IHVwIGJ5IHRoZSBtb2RlbCBjcmVhdGlvbiBzeXN0ZW0pXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIHZhciBoYXNDYWNoaW5nTGlzdGVuZXJzID0gZXZlbnRzLmJhZFJlZmVyZW5jZSAmJiBldmVudHMuYmFkUmVmZXJlbmNlLmxlbmd0aCA9PT0gMTtcbiAgICAgICAgICAgIHZhciBsaXN0ZW5lcnMgPSBoYXNDYWNoaW5nTGlzdGVuZXJzID8gXy5vbWl0KGV2ZW50cywgWydiYWRSZWZlcmVuY2UnXSkgOiBldmVudHM7XG5cbiAgICAgICAgICAgIGlmIChfLmlzRW1wdHkobGlzdGVuZXJzKSkge1xuICAgICAgICAgICAgICAgIHRvUmVtb3ZlW3JlZmVyZW5jZV0gPSBtb2RlbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgXy5lYWNoKHRvUmVtb3ZlLCByZW1vdmUpO1xuICAgIH1cblxuICAgIC8qXG4gICAgICogUmV0dXJuczpcbiAgICAgKiAgICB0cnVlOiBJZiB0aGUgc3RvcmUgaGFzIG5vIG1vZGVsc1xuICAgICAqICAgIGZhbHNlOiBpZiB0aGUgc3RvcmUgaGFzIG9uZSBvciBtb3JlIG1vZGVsc1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzRW1wdHkoKSB7XG4gICAgICAgIHJldHVybiBfLmlzRW1wdHkobW9kZWxzQnlUeXBlVGhlblJlZik7XG4gICAgfVxuXG4gICAgLypcbiAgICAgKiBXcml0ZSBvdXQgdGhlIG1vZGVscy5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBkdW1wKCkge1xuICAgICAgICBkeFV0aWwuaW5mbygnU0VSVkVSIE1PREVMUycpO1xuICAgICAgICBkeFV0aWwuaW5mbygnPT09PT09PT09PT09PScpO1xuICAgICAgICBkeFV0aWwuaW5mbyhtb2RlbHNCeVR5cGVUaGVuUmVmKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBkdW1wVGV4dCgpIHtcbiAgICAgICAgZHhVdGlsLmluZm8oJ1NFUlZFUiBNT0RFTFMnKTtcbiAgICAgICAgZHhVdGlsLmluZm8oJz09PT09PT09PT09PT0nKTtcbiAgICAgICAgaWYgKF8uaXNFbXB0eShtb2RlbHNCeVR5cGVUaGVuUmVmKSkge1xuICAgICAgICAgICAgZHhVdGlsLmluZm8oJ05vbmUuJyk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHR5cGVzID0gXy5rZXlzKG1vZGVsc0J5VHlwZVRoZW5SZWYpO1xuICAgICAgICBfLmVhY2godHlwZXMuc29ydCgpLCBmdW5jdGlvbih0eXBlTmFtZSkge1xuICAgICAgICAgICAgZHhVdGlsLmluZm8odHlwZU5hbWUpO1xuICAgICAgICAgICAgZHhVdGlsLmluZm8oJy0tLS0tLS0tLS0tLS0nKTtcbiAgICAgICAgICAgIHZhciByZWZlcmVuY2VzID0gXy5rZXlzKG1vZGVsc0J5VHlwZVRoZW5SZWZbdHlwZU5hbWVdKTtcbiAgICAgICAgICAgIF8uZWFjaChyZWZlcmVuY2VzLnNvcnQoKSwgZnVuY3Rpb24ocmVmZXJlbmNlKSB7XG4gICAgICAgICAgICAgICAgdmFyIG1vZGVsID0gbW9kZWxzQnlUeXBlVGhlblJlZlt0eXBlTmFtZV1bcmVmZXJlbmNlXTtcbiAgICAgICAgICAgICAgICBkeFV0aWwuaW5mbyhyZWZlcmVuY2UpO1xuICAgICAgICAgICAgICAgIGR1bXBFdmVudExpc3RuZXJzKG1vZGVsKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgICBfbW9kZWxzOiBtb2RlbHNCeVR5cGVUaGVuUmVmLFxuICAgICAgICBhZGQ6IGFkZCxcbiAgICAgICAgZ2V0OiBnZXQsXG4gICAgICAgIHJlbW92ZTogcmVtb3ZlLFxuICAgICAgICBoYXNNb2RlbDogaGFzTW9kZWwsXG4gICAgICAgIHJlc2V0OiByZXNldCxcbiAgICAgICAgZHVtcDogZHVtcCxcbiAgICAgICAgcHJ1bmU6IHBydW5lLFxuICAgICAgICBpc0VtcHR5OiBpc0VtcHR5LFxuICAgICAgICBkdW1wVGV4dDogZHVtcFRleHRcbiAgICB9O1xufVxuXG4vKlxuICogVGhpcyBwb3J0aW9uIG9mIHRoZSBkYXRhIHN5c3RlbSBwcm92aWRlcyBhIGNhY2hlIG9mIG1vZGVscyBhbmQgc3Vic2NyaWJlcnMsIGNvbGxlY3Rpb25zIGFuZCBub3RpZmljYXRpb24gbGlzdGVuZXJzLlxuICogSXQgZW5zdXJlcyB0aGF0IG1vZGVscyBhcmUgdW5pcXVlICh0aGF0IGlzLCB0aGVyZSBpcyBvbmx5IG9uZSBpbnN0YW5jZSBmb3IgYSBwYXJ0aWN1bGFyIHJlZmVyZW5jZSksIGl0IG1ha2VzIHN1cmVcbiAqIGFsbCBjb2xsZWN0aW9ucyBjb250YWluIHRoZSBtb2RlbHMgdGhhdCB0aGV5IGxlZ2l0aW1hdGVseSBjb3VsZCBjb250YWluLCBhbmQgc3Vic2NyaWJlcnMgYXJlIG5vdGlmaWVkIG9mIG5ld1xuICogbW9kZWxzLlxuICpcbiAqIFRoZXJlIGFyZSBmb3VyIHByaW1hcnkgdXNlczpcbiAqICAgLSBTb21lb25lIHJldHJpZXZlcyBkYXRhIGZyb20gdGhlIHNlcnZlci4gSXQgd291bGQgY2FsbCBnZXRDYWNoZWRNb2RlbEZyb21Qcm9wZXJ0aWVzKCkgd2hpY2ggd2lsbCBjcmVhdGUgb3IgdXBkYXRlXG4gKiAgICAgYSBtb2RlbCB1c2luZyB0aG9zZSBwcm9wZXJ0aWVzLCBhbmQgcmV0dXJuIHRoZSBtb2RlbCB0byB0aGUgY2FsbGVyLlxuICogICAtIFNvbWVvbmUgd2FudHMgdG8gcmV0cmlldmUgYSBwYXJ0aWN1bGFyIG1vZGVsLiBJdCBjYWxscyBnZXRDYWNoZWRNb2RlbCgpLCB3aGljaCByZXR1cm5zIHRoZSByZXF1ZXN0ZWQgbW9kZWwgKGFuZFxuICogICAgIGRvZXMgYSBmZXRjaCBvbiBpdCwgaWYgbmVjZXNzYXJ5KVxuICogICAtIFNvbWVvbmUgd2FudHMgdG8gZ2V0IGEgc2luZ2xldG9uOiBzbyBpdCBjYWxscyBnZXRDYWNoZWRTaW5nbGV0b24oKSB3aGljaCByZXR1cm5zIHRoZSB1bmlxdWUgc2luZ2xldG9uIGluc3RhbmNlLlxuICogICAtIFNvbWVvbmUgd2FudHMgYSBjb2xsZWN0aW9uIG9yIG5vdGlmaWNhdGlvbiBzdWJzY3JpYmVycyBvZiBhIHBhcnRpY3VsYXIgdHlwZS4gVGhleSBjcmVhdGUgdGhlIGRhdGEgc3RydWN0dXJlXG4gKiAgICAgYW5kIGNhbGwgX21vZGVsU3Vic2NyaWJlcnNTdG9yZS5hZGQgdG8gbWFrZSBzdXJlIHRoZSBzdWJzY3JpYmVycyBnZXRzIG5vdGlmaWVkIG9mIGNoYW5nZXMgYW5kIGNvbGxlY3Rpb25zXG4gKiAgICAgdXBkYXRlZC5cbiAqXG4gKiBUaGlzIGVudGlyZSBjYWNoZSBzeXN0ZW0gaXMgJ3ByaXZhdGUnIHRvIHRoZSBkYXRhIHN5c3RlbSwgYW5kIHNob3VsZCBub3QgYmUgY2FsbGVkIGZyb20gb3V0c2lkZS5cbiAqXG4gKiBVbmxlc3MgcmVzZXQoKSBpcyBjYWxsZWQsIGF0IHRoaXMgdGltZSBtb2RlbHMgYW5kIGNvbGxlY3Rpb25zIGFyZSBuZXZlciBkaXNjYXJkZWQuXG4gKlxuICogQXMgd2l0aCBvdGhlciBwYXJ0cyBvZiB0aGUgZGF0YSBzeXN0ZW0sIHRoaXMgdGFrZXMgYSAnY29udGV4dCcgb2JqZWN0LCBhbmQgYXR0YWNoZXMgYSBfY2FjaGUgb2JqZWN0IHRvIHRoYXQgb25lLFxuICogd2hlcmUgcHJpdmF0ZSAodG8gdGhlIGRhdGEgc3lzdGVtKSBjYWNoaW5nIHJvdXRpbmVzIHJlc2lkZS4gVGhlIGludGVudCBoZXJlIGlzIHRvIG1ha2Ugc3VyZSB0aGF0IGlmIG5lZWRlZCBtdWx0aXBsZVxuICogZGF0YSBzeXN0ZW1zIGNhbiBjby1leGlzdC5cbiAqL1xubW9kdWxlLmV4cG9ydHMuX2luaXRDYWNoZSA9IGZ1bmN0aW9uIF9pbml0Q2FjaGUoY29udGV4dCkge1xuICAgIC8qXG4gICAgICogUmV0dXJuIGEgc2luZ2xldG9uIG9mIHRoZSBzcGVjaWZpZWQgdHlwZS4gSWYgaXQgZG9lc24ndCBhbHJlYWR5IGV4aXN0LCBhIG5ldyBtb2RlbCBpcyBjcmVhdGVkLCBjYWNoZWQsIGFuZFxuICAgICAqIHJldHVybmVkLiAgSWYgJ3VwZGF0ZScgaXMgdHJ1ZSwgdGhlbiB0aGlzIHdpbGwgZmV0Y2ggbmV3IGRhdGEgZm9yIHRoZSBtb2RlbC5cbiAgICAgKiB0eXBlTmFtZTogICBUaGUgdHlwZSBvZiB0aGUgc2luZ2xldG9uXG4gICAgICogb3B0aW9uczogICAgSlNPTiBvYmplY3Qgd2l0aCB0aGVzZSBvcHRpb25hbCBwcm9wZXJ0aWVzOlxuICAgICAqICAgICAgICAgICAgICAgdXBkYXRlOiB7dHJ1ZXxmYWxzZX0gIFdpbGwgY2F1c2UgYW4gdXBkYXRlIChmZXRjaCkgb24gdGhlIG1vZGVsXG4gICAgICogICAgICAgICAgICAgICBzdWNjZXNzOiBBIGZ1bmN0aW9uIHRvIGNhbGwgd2hlbiB0aGUgbW9kZWwgaXMgcmVhZHlcbiAgICAgKiAgICAgICAgICAgICAgIGVycm9yOiBBIGZ1bmN0aW9uIHRvIGNhbGwgd2hlbiBhbiBlcnJvciBvY2N1cnJlZCBkdXJpbmcgYSBmZXRjaFxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGdldENhY2hlZFNpbmdsZXRvbih0eXBlTmFtZSwgb3B0aW9ucykge1xuICAgICAgICBpZiAoIV8uaXNTdHJpbmcodHlwZU5hbWUpKSB7XG4gICAgICAgICAgICBkeFV0aWwuZmFpbCgnQSB0eXBlIG5hbWUgbXVzdCBiZSBwYXNzZWQgdG8gZ2V0IHRoZSBzaW5nbGV0b24uJyk7XG4gICAgICAgIH1cbiAgICAgICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gICAgICAgIHZhciBtb2RlbDtcbiAgICAgICAgdmFyIGlzTmV3O1xuICAgICAgICBpZiAoY29udGV4dC5fc2luZ2xldG9uU3RvcmUuaGFzVHlwZSh0eXBlTmFtZSkpIHtcbiAgICAgICAgICAgIG1vZGVsID0gY29udGV4dC5fc2luZ2xldG9uU3RvcmUuZ2V0KHR5cGVOYW1lKTtcbiAgICAgICAgICAgIGlmIChvcHRpb25zLnN1Y2Nlc3MpIHtcbiAgICAgICAgICAgICAgICBvcHRpb25zLnN1Y2Nlc3MobW9kZWwpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdmFyIHNjaGVtYSA9IGFzc2VydFR5cGVBbmRHZXRNb2RlbFNjaGVtYSh0eXBlTmFtZSk7XG5cbiAgICAgICAgICAgIGlmICghc2NoZW1hLnNpbmdsZXRvbikge1xuICAgICAgICAgICAgICAgIGR4VXRpbC5mYWlsKHR5cGVOYW1lICsgJyBpcyBub3QgYSBzaW5nbGV0b24uJyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIG1vZGVsID0gY29udGV4dC5fbmV3U2VydmVyTW9kZWwodHlwZU5hbWUpO1xuICAgICAgICAgICAgY29udGV4dC5fc2luZ2xldG9uU3RvcmUuYWRkKG1vZGVsKTtcbiAgICAgICAgICAgIGlzTmV3ID0gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChvcHRpb25zLnVwZGF0ZSB8fCBpc05ldykge1xuICAgICAgICAgICAgdmFyIGZldGNoT3B0cyA9IG9wdGlvbnM7XG4gICAgICAgICAgICBpZiAoaXNOZXcpIHtcbiAgICAgICAgICAgICAgICBmZXRjaE9wdHMgPSB7XG4gICAgICAgICAgICAgICAgICAgIHN1Y2Nlc3M6IG9wdGlvbnMuc3VjY2VzcyxcbiAgICAgICAgICAgICAgICAgICAgZXJyb3I6IGZ1bmN0aW9uKHJlc3VsdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29udGV4dC5fc2luZ2xldG9uU3RvcmUucmVtb3ZlKG1vZGVsKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChvcHRpb25zLmVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb3B0aW9ucy5lcnJvcihyZXN1bHQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmICghb3B0aW9ucy5zdXBwcmVzc0RlZmF1bHRFcnJvckhhbmRsZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250ZXh0LnJlcG9ydEVycm9yUmVzdWx0KHJlc3VsdCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbW9kZWwuX2R4RmV0Y2goZmV0Y2hPcHRzKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBtb2RlbDtcbiAgICB9XG5cbiAgICAvKlxuICAgICAqIEdpdmVuIGEgc2V0IG9mIHByb3BlcnRpZXMsIGVpdGhlciB1cGRhdGUgYW4gZXhpc3RpbmcgbW9kZWwgd2l0aCB0aGUgc2FtZSByZWZlcmVuY2UgYXMgaW4gdGhlIHByb3BlcnRpZXNcbiAgICAgKiBvYmplY3QsIG9yIGNyZWF0ZSBhIG5ldyBzZXJ2ZXIgbW9kZWwsIHBvcHVsYXRlIGl0IHdpdGggdGhlc2UgcHJvcGVydGllcywgY2FjaGUgaXQgYW5kIHJldHVybiBpdC5cbiAgICAgKlxuICAgICAqIHByb3BlcnRpZXM6IEEgSlNPTiBvYmplY3QgY29udGFpbmluZyBwcm9wZXJ0aWVzIHRoYXQgY2FuIGJlIHNldCgpIG9uIGEgRFNCIG1vZGVsXG4gICAgICogb3B0aW9uczogICAgQmFja2JvbmUgb3B0aW9uc1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIGdldENhY2hlZE1vZGVsRnJvbVByb3BlcnRpZXMocHJvcGVydGllcywgb3B0aW9ucykge1xuICAgICAgICB2YXIgbW9kZWw7XG5cbiAgICAgICAgaWYgKCFfLmlzT2JqZWN0KHByb3BlcnRpZXMpIHx8ICFfLmlzU3RyaW5nKHByb3BlcnRpZXMudHlwZSkpIHtcbiAgICAgICAgICAgIGR4VXRpbC5mYWlsKCdNdXN0IGJlIGNhbGxlZCB3aXRoIGFuIG9iamVjdCB0aGF0IGhhcyBhIHR5cGUgcHJvcGVydHkgdGhhdCBpcyBhIHN0cmluZyB2YWx1ZS4nKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghY29udGV4dC5fbW9kZWxDb25zdHJ1Y3RvcnNbcHJvcGVydGllcy50eXBlXSkge1xuICAgICAgICAgICAgZHhVdGlsLmZhaWwoJ0RvblxcJ3Qga25vdyBob3cgdG8gY3JlYXRlIGEgbW9kZWwgb2YgdHlwZSAnICsgcHJvcGVydGllcy50eXBlICsgJy4nKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIE5vdCBhbGwgdHlwZXMgaGF2ZSBhIHJlZmVyZW5jZSBwcm9wZXJ0eS4gVGhvc2UgdGhhdCBkbyBub3QgYXJlIG5vdCBjYWNoYWJsZS4gQXNzdW1lIHRoaXMgaXMgYSBjbGllbnQgbW9kZWxcbiAgICAgICAgaWYgKCFpc1R5cGVDYWNoYWJsZShwcm9wZXJ0aWVzLnR5cGUpIHx8IGR4VXRpbC5pc05vbmUocHJvcGVydGllcy5yZWZlcmVuY2UpKSB7XG4gICAgICAgICAgICBtb2RlbCA9IGNvbnRleHQuX25ld0NsaWVudE1vZGVsKHByb3BlcnRpZXMudHlwZSk7XG4gICAgICAgICAgICBtb2RlbC5fZHhTZXQocHJvcGVydGllcyk7XG4gICAgICAgICAgICByZXR1cm4gbW9kZWw7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgcm9vdFR5cGUgPSBjb250ZXh0Ll9nZXRSb290VHlwZShwcm9wZXJ0aWVzLnR5cGUpO1xuICAgICAgICBtb2RlbCA9IGNvbnRleHQuX21vZGVsU3RvcmUuZ2V0KHByb3BlcnRpZXMucmVmZXJlbmNlLCByb290VHlwZSk7XG4gICAgICAgIGlmIChfLmlzVW5kZWZpbmVkKG1vZGVsKSkge1xuICAgICAgICAgICAgbW9kZWwgPSBtYWtlTW9kZWwocHJvcGVydGllcywgcHJvcGVydGllcy50eXBlLCByb290VHlwZSk7XG4gICAgICAgICAgICBtb2RlbC5fZHhNYWtlUmVhZHkoKTtcbiAgICAgICAgICAgIGFkZE1vZGVsKG1vZGVsLCByb290VHlwZSwgb3B0aW9ucyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBtb2RlbC5fZHhTZXQocHJvcGVydGllcyk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbW9kZWw7XG4gICAgfVxuXG4gICAgLypcbiAgICAgKiBSZXR1cm5zIGEgY2FjaGVkIG1vZGVsIHdpdGggdGhlIHNwZWNpZmllZCByZWZlcmVuY2UuICBJZiB0aGUgbW9kZWwgaXNuJ3QgaW4gdGhlIGNhY2hlLCB0aGlzIHdpbGwgcmV0dXJuXG4gICAgICogYSBuZXcgbW9kZWwsIHdoaWNoIGl0IHdpbGwgYWxzbyBmZXRjaC4gSWYgdGhlIHVwZGF0ZSBhcmd1bWVudCBpcyB0cnVlLCBpdCB3aWxsIGJlXG4gICAgICogZmV0Y2hlZCByZWdhcmRsZXNzIG9mIHdoZXRoZXIgaXQgaXMgbmV3IG9yIG9sZC5cbiAgICAgKlxuICAgICAqIHJlZmVyZW5jZTogIFRoZSByZWZlcmVuY2Ugb2YgdGhlIG1vZGVsIHRvIHJldHJpZXZlXG4gICAgICogdHlwZU5hbWU6ICAgVGhlIHR5cGUgb2YgdGhlIG1vZGVsIEBAQEAgd2h5IGlzbid0IHRoaXMgdGhlIHJvb3QgdHlwZT9cbiAgICAgKiBvcHRpb25zOiAgICBKU09OIG9iamVjdCB3aXRoIHRoZXNlIG9wdGlvbmFsIHByb3BlcnRpZXM6XG4gICAgICogICAgICAgICAgICAgICB1cGRhdGU6IHt0cnVlfGZhbHNlfSAgV2lsbCBjYXVzZSBhbiB1cGRhdGUgKGZldGNoKSBvbiB0aGUgbW9kZWxcbiAgICAgKiAgICAgICAgICAgICAgIGNhY2hlT25seUlmTmVlZGVkOiB7dHJ1ZXxmYWxzZX0gQWRkIHRvIHRoZSBjYWNoZSAoYW5kIHJldHVybikgb25seSBpZiB0aGVyZSBhcmUgYWxyZWFkeVxuICAgICAqICAgICAgICAgICAgICAgICAgY29sbGVjdGlvbnMgdGhhdCB3b3VsZCB1c2UgaXQuXG4gICAgICogICAgICAgICAgICAgICBzdXBwcmVzc0RlZmF1bHRFcnJvckhhbmRsZXI6IHt0cnVlfGZhbHNlfSBEbyBub3QgdHJpZ2dlciB0aGUgZGVmYXVsdCBlcnJvciBoYW5kbGVyIG9uIGR4RmV0Y2hcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBnZXRDYWNoZWRNb2RlbChyZWZlcmVuY2UsIHR5cGVOYW1lLCBvcHRpb25zKSB7XG4gICAgICAgIGlmICghXy5pc1N0cmluZyhyZWZlcmVuY2UpIHx8ICFfLmlzU3RyaW5nKHR5cGVOYW1lKSkge1xuICAgICAgICAgICAgZHhVdGlsLmZhaWwoJ0EgcmVmZXJlbmNlIGFuZCBhIHR5cGUgbXVzdCBiZSBwYXNzZWQgdG8gZ2V0IHRoZSBtb2RlbC4nKTtcbiAgICAgICAgfVxuICAgICAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuICAgICAgICB2YXIgaXNOZXcgPSBmYWxzZTtcbiAgICAgICAgdmFyIHJvb3RUeXBlID0gY29udGV4dC5fZ2V0Um9vdFR5cGUodHlwZU5hbWUpO1xuICAgICAgICB2YXIgbXVzdENhY2hlID0gIW9wdGlvbnMuY2FjaGVPbmx5SWZOZWVkZWQ7XG4gICAgICAgIHZhciBoYXZlU3Vic2NyaXB0aW9uV2hpY2hOZWVkc01vZGVsID0gKGNvbnRleHQuX21vZGVsU3Vic2NyaWJlcnNTdG9yZS5nZXRBbGxPZlR5cGUocm9vdFR5cGUpLmxlbmd0aCAhPT0gMCk7XG4gICAgICAgIHZhciBhZGRUb0NhY2hlID0gbXVzdENhY2hlIHx8IGhhdmVTdWJzY3JpcHRpb25XaGljaE5lZWRzTW9kZWw7XG5cbiAgICAgICAgdmFyIG1vZGVsID0gY29udGV4dC5fbW9kZWxTdG9yZS5nZXQocmVmZXJlbmNlLCByb290VHlwZSk7XG4gICAgICAgIGlmIChfLmlzVW5kZWZpbmVkKG1vZGVsKSAmJiBhZGRUb0NhY2hlKSB7XG4gICAgICAgICAgICBtb2RlbCA9IG1ha2VNb2RlbCh7IHJlZmVyZW5jZTogcmVmZXJlbmNlIH0sIHR5cGVOYW1lLCByb290VHlwZSk7XG4gICAgICAgICAgICBpc05ldyA9IHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAobW9kZWwgJiYgKG9wdGlvbnMudXBkYXRlIHx8IGlzTmV3KSkge1xuICAgICAgICAgICAgbW9kZWwuX2R4RmV0Y2goe1xuICAgICAgICAgICAgICAgIHN1Y2Nlc3M6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoaXNOZXcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFkZE1vZGVsKG1vZGVsLCByb290VHlwZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIGVycm9yOiBmdW5jdGlvbihyZXN1bHQpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlzTmV3KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb250ZXh0Ll9tb2RlbFN0b3JlLnJlbW92ZShtb2RlbCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKCFvcHRpb25zIHx8ICFvcHRpb25zLnN1cHByZXNzRGVmYXVsdEVycm9ySGFuZGxlcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29udGV4dC5yZXBvcnRFcnJvclJlc3VsdChyZXN1bHQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbW9kZWw7XG4gICAgfVxuXG4gICAgLypcbiAgICAgKiBSZXR1cm5zIHRydWUgaWYgdGhlIGNhY2hlIGNvbnRhaW5zIGEgbW9kZWwgd2l0aCB0aGUgc3BlY2lmaWVkIHJlZmVyZW5jZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNvbnRhaW5zQ2FjaGVkTW9kZWwocmVmZXJlbmNlLCB0eXBlTmFtZSkge1xuICAgICAgICBpZiAoIV8uaXNTdHJpbmcocmVmZXJlbmNlKSB8fCAhXy5pc1N0cmluZyh0eXBlTmFtZSkpIHtcbiAgICAgICAgICAgIGR4VXRpbC5mYWlsKCdBIHJlZmVyZW5jZSBhbmQgYSB0eXBlIG11c3QgYmUgcGFzc2VkIHRvIGNoZWNrIG9uIHRoZSBtb2RlbC4nKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiAhXy5pc1VuZGVmaW5lZChjb250ZXh0Ll9tb2RlbFN0b3JlLmdldChyZWZlcmVuY2UsIGNvbnRleHQuX2dldFJvb3RUeXBlKHR5cGVOYW1lKSkpO1xuICAgIH1cblxuICAgIC8qXG4gICAgICogRGVsZXRlcyB0aGUgbW9kZWwuIFRoaXMgbWVhbnMgcmVtb3ZpbmcgaXQgZnJvbSB0aGUgY2FjaGUsIGFzIHdlbGwgYXMgZnJvbSBhbnlcbiAgICAgKiBjb2xsZWN0aW9ucyB0aGF0IGNvbnRhaW4gaXQsIGFuZCBjbGVhcnMgdGhlIG1vZGVsJ3MgcHJvcGVydGllcy5cbiAgICAgKiBJZiB0aGUgZG9udFRyaWdnZXJEZWxldGUgZmxhZyBpcyBub3Qgc2V0LCB0aGlzIHdpbGwgYWxzbyB0cmlnZ2VyIGEgJ2RlbGV0ZScgZXZlbnQgb24gdGhlIG1vZGVsLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGRlbGV0ZUNhY2hlZE1vZGVsKHJlZmVyZW5jZSwgdHlwZU5hbWUsIGRvbnRUcmlnZ2VyRGVsZXRlKSB7XG4gICAgICAgIGlmICghXy5pc1N0cmluZyhyZWZlcmVuY2UpIHx8ICFfLmlzU3RyaW5nKHR5cGVOYW1lKSkge1xuICAgICAgICAgICAgZHhVdGlsLmZhaWwoJ0EgcmVmZXJlbmNlIGFuZCBhIHR5cGUgbXVzdCBiZSBwYXNzZWQgdG8gZGVsZXRlIGEgbW9kZWwuJyk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgcm9vdFR5cGUgPSBjb250ZXh0Ll9nZXRSb290VHlwZSh0eXBlTmFtZSk7XG4gICAgICAgIHZhciBkb29tZWQgPSBjb250ZXh0Ll9tb2RlbFN0b3JlLmdldChyZWZlcmVuY2UsIHJvb3RUeXBlKTtcbiAgICAgICAgaWYgKCFkb29tZWQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIF8uZWFjaChjb250ZXh0Ll9tb2RlbFN1YnNjcmliZXJzU3RvcmUuZ2V0QWxsT2ZUeXBlKHJvb3RUeXBlKSwgZnVuY3Rpb24oc3Vic2NyaWJlcikge1xuICAgICAgICAgICAgaWYgKHN1YnNjcmliZXIgaW5zdGFuY2VvZiBCYWNrYm9uZS5Db2xsZWN0aW9uKSB7XG4gICAgICAgICAgICAgICAgc3Vic2NyaWJlci5fZHhSZW1vdmVNb2RlbChkb29tZWQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICBpZiAoIWRvbnRUcmlnZ2VyRGVsZXRlKSB7XG4gICAgICAgICAgICBkb29tZWQudHJpZ2dlcignZGVsZXRlJywgZG9vbWVkKTtcbiAgICAgICAgfVxuICAgICAgICBkb29tZWQub2ZmKG51bGwsIG51bGwsIGNvbnRleHQpO1xuICAgICAgICBjb250ZXh0Ll9tb2RlbFN0b3JlLnJlbW92ZShkb29tZWQpO1xuICAgICAgICBkb29tZWQuX2R4Q2xlYXIoKTtcbiAgICAgICAgZG9vbWVkLl9keERlbGV0ZWQgPSB0cnVlO1xuICAgIH1cblxuICAgIC8qXG4gICAgICogUmVtb3ZlIGFsbCByZWZlcmVuY2VzIHdlIGhhdmUgdG8gYm90aCBzaW5nbGV0b25zIGFuZCBzZXJ2ZXIgbW9kZWxzLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHJlc2V0Q2FjaGUoKSB7XG4gICAgICAgIGNvbnRleHQuX21vZGVsU3Vic2NyaWJlcnNTdG9yZS5yZXNldCgpO1xuICAgICAgICBjb250ZXh0Ll9zaW5nbGV0b25TdG9yZS5yZXNldCgpO1xuICAgICAgICBjb250ZXh0Ll9tb2RlbFN0b3JlLnJlc2V0KCk7XG4gICAgfVxuXG4gICAgLypcbiAgICAgKiBEdW1wIHRoZSB0eXBlcyAoZm9yIHNpbmdsZXRvbnMpIGFuZCByZWZlcmVuY2VzIChmb3Igc2VydmVyIG1vZGVscykgYXMgdGV4dCBmb3IgYWxsIG9iamVjdHMgaW4gdGhlIGNhY2hlLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGR1bXBDYWNoZUFzVGV4dCgpIHtcbiAgICAgICAgY29udGV4dC5fbW9kZWxTdWJzY3JpYmVyc1N0b3JlLmR1bXBUZXh0KCk7XG4gICAgICAgIGR4VXRpbC5pbmZvKCcnKTtcblxuICAgICAgICBjb250ZXh0Ll9zaW5nbGV0b25TdG9yZS5kdW1wVGV4dCgpO1xuICAgICAgICBkeFV0aWwuaW5mbygnJyk7XG5cbiAgICAgICAgY29udGV4dC5fbW9kZWxTdG9yZS5kdW1wVGV4dCgpO1xuICAgIH1cblxuICAgIC8qXG4gICAgICogRHVtcCB0aGUgaW50ZXJuYWwgc2luZ2xldG9ucyBhbmQgbW9kZWwgZGF0YSBzdHJ1Y3R1cmVzLiAgVGhpcyBpcyB1c2FibGUgb24gbW9zdCBicm93c2Vycy5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBkdW1wQ2FjaGUoKSB7XG4gICAgICAgIGNvbnRleHQuX21vZGVsU3Vic2NyaWJlcnNTdG9yZS5kdW1wKCk7XG4gICAgICAgIGR4VXRpbC5pbmZvKCcnKTtcblxuICAgICAgICBjb250ZXh0Ll9zaW5nbGV0b25TdG9yZS5kdW1wKCk7XG4gICAgICAgIGR4VXRpbC5pbmZvKCcnKTtcblxuICAgICAgICBjb250ZXh0Ll9tb2RlbFN0b3JlLmR1bXAoKTtcbiAgICAgICAgZHhVdGlsLmluZm8oJycpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHBydW5lKCkge1xuICAgICAgICBjb250ZXh0Ll9tb2RlbFN1YnNjcmliZXJzU3RvcmUucHJ1bmUoKTtcbiAgICAgICAgY29udGV4dC5fc2luZ2xldG9uU3RvcmUucHJ1bmUoKTtcbiAgICAgICAgY29udGV4dC5fbW9kZWxTdG9yZS5wcnVuZSgpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGlzRW1wdHkoKSB7XG4gICAgICAgIHJldHVybiBjb250ZXh0Ll9tb2RlbFN1YnNjcmliZXJzU3RvcmUuaXNFbXB0eSgpICYmXG4gICAgICAgICAgICBjb250ZXh0Ll9zaW5nbGV0b25TdG9yZS5pc0VtcHR5KCkgJiZcbiAgICAgICAgICAgIGNvbnRleHQuX21vZGVsU3RvcmUuaXNFbXB0eSgpO1xuICAgIH1cblxuICAgIC8qXG4gICAgICogQ3JlYXRlcyBhIG1vZGVsLCBzdGlja3MgaXQgaW4gdGhlIGNhY2hlLCBhbmQgc2V0cyB1cCB0byBjb3BlIHdpdGggYmFkUmVmZXJlbmNlc1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIG1ha2VNb2RlbChwcm9wZXJ0aWVzLCB0eXBlTmFtZSwgcm9vdFR5cGUpIHtcbiAgICAgICAgdmFyIG1vZGVsID0gY29udGV4dC5fbmV3U2VydmVyTW9kZWwodHlwZU5hbWUpO1xuICAgICAgICBtb2RlbC5fZHhTZXQocHJvcGVydGllcyk7XG4gICAgICAgIGNvbnRleHQuX21vZGVsU3RvcmUuYWRkKG1vZGVsKTtcbiAgICAgICAgbW9kZWwub24oJ2JhZFJlZmVyZW5jZScsIGZ1bmN0aW9uIGhhbmRsZTQwNCgpIHtcbiAgICAgICAgICAgIGRlbGV0ZUNhY2hlZE1vZGVsKHByb3BlcnRpZXMucmVmZXJlbmNlLCByb290VHlwZSwgdHJ1ZSk7XG4gICAgICAgIH0sIGNvbnRleHQpO1xuXG4gICAgICAgIHJldHVybiBtb2RlbDtcbiAgICB9XG5cbiAgICAvKlxuICAgICAqIEFkZHMgdGhlIHNwZWNpZmllZCBtb2RlbCB0byB0aGUgY29sbGVjdGlvbnNcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBhZGRNb2RlbChtb2RlbCwgcm9vdFR5cGUsIG9wdGlvbnMpIHtcbiAgICAgICAgbm90aWZ5U3Vic2NyaXB0aW9uc09mTW9kZWwobW9kZWwsIHJvb3RUeXBlLCBvcHRpb25zKTtcbiAgICB9XG5cbiAgICAvKlxuICAgICAqIEluZGljYXRlcyB0aGF0IGEgbW9kZWwgbWF5IGhhdmUgY2hhbmdlZCwgYW5kIHRoZSBjYWNoZSBzaG91bGQgcmVjaGVjayB3aGV0aGVyIHRoZSBtb2RlbCBzaG91bGQgYmUgYWRkZWQgb3JcbiAgICAgKiByZW1vdmVkIGZyb20gYW55IGNvbGxlY3Rpb25zLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIG1vZGVsTWF5SGF2ZUNoYW5nZWQobW9kZWwsIHJvb3RUeXBlKSB7XG4gICAgICAgIGlmICghKG1vZGVsIGluc3RhbmNlb2YgQmFja2JvbmUuTW9kZWwpKSB7XG4gICAgICAgICAgICBkeFV0aWwuZmFpbCgnTXVzdCBwYXNzIGEgQmFja2JvbmUgTW9kZWwuJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFfLmlzU3RyaW5nKHJvb3RUeXBlKSkge1xuICAgICAgICAgICAgZHhVdGlsLmZhaWwoJ3Jvb3RUeXBlIG11c3QgYmUgYSBzdHJpbmcuJyk7XG4gICAgICAgIH1cblxuICAgICAgICBub3RpZnlTdWJzY3JpcHRpb25zT2ZNb2RlbENoYW5nZWQobW9kZWwsIHJvb3RUeXBlKTtcbiAgICB9XG5cbiAgICAvKlxuICAgICAqIEFkZHMgdGhlIHNwZWNpZmllZCBtb2RlbCB0byBhbGwgcmVsZXZhbnQgc3Vic2NyaWJlcnMgKGNvbGxlY3Rpb25zIG9yIG5vdGlmaWNhdGlvbiBsaXN0ZW5lcnMpLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIG5vdGlmeVN1YnNjcmlwdGlvbnNPZk1vZGVsKG1vZGVsLCByb290VHlwZSwgb3B0aW9ucykge1xuICAgICAgICBfLmVhY2goY29udGV4dC5fbW9kZWxTdWJzY3JpYmVyc1N0b3JlLmdldEFsbE9mVHlwZShyb290VHlwZSksIGZ1bmN0aW9uKHN1YnNjcmliZXIpIHtcbiAgICAgICAgICAgIHN1YnNjcmliZXIuX2R4QWRkT3JSZW1vdmUobW9kZWwsIG9wdGlvbnMpO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICAvKlxuICAgICAqIE5vdGlmaWVzIGNvbGxlY3Rpb25zIHRoYXQgdGhlIG1vZGVsIGhhcyBjaGFuZ2VkLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIG5vdGlmeVN1YnNjcmlwdGlvbnNPZk1vZGVsQ2hhbmdlZChtb2RlbCwgcm9vdFR5cGUsIG9wdGlvbnMpIHtcbiAgICAgICAgXy5lYWNoKGNvbnRleHQuX21vZGVsU3Vic2NyaWJlcnNTdG9yZS5nZXRBbGxPZlR5cGUocm9vdFR5cGUpLCBmdW5jdGlvbihzdWJzY3JpYmVyKSB7XG4gICAgICAgICAgICBpZiAoc3Vic2NyaWJlciBpbnN0YW5jZW9mIEJhY2tib25lLkNvbGxlY3Rpb24pIHtcbiAgICAgICAgICAgICAgICBzdWJzY3JpYmVyLl9keEFkZE9yUmVtb3ZlKG1vZGVsLCBvcHRpb25zKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgLypcbiAgICAgKiBBc3NlcnRzIHRoYXQgdGhlIHR5cGUgaXMgYSB2YWxpZCBtb2RlbCB0eXBlLCBhbmQgcmV0dXJucyBpdHMgc2NoZW1hLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGFzc2VydFR5cGVBbmRHZXRNb2RlbFNjaGVtYSh0eXBlTmFtZSkge1xuICAgICAgICB2YXIgTW9kZWxDb25zdHJ1Y3RvciA9IGNvbnRleHQuX21vZGVsQ29uc3RydWN0b3JzW3R5cGVOYW1lXTtcblxuICAgICAgICBpZiAoIU1vZGVsQ29uc3RydWN0b3IpIHtcbiAgICAgICAgICAgIGR4VXRpbC5mYWlsKHR5cGVOYW1lICsgJyBpcyBub3QgYSBrbm93biB0eXBlIG5hbWUuJyk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gTW9kZWxDb25zdHJ1Y3Rvci5wcm90b3R5cGUuX2R4U2NoZW1hO1xuICAgIH1cblxuICAgIC8qXG4gICAgICogRXhhbWluZXMgdGhlIHR5cGUsIGFuZCByZXR1cm5zIGEgdHJ1dGh5IHZhbHVlIGlmIGl0IGlzIGNhY2hhYmxlXG4gICAgICovXG4gICAgZnVuY3Rpb24gaXNUeXBlQ2FjaGFibGUodHlwZSkge1xuICAgICAgICB2YXIgQ29uc3RydWN0b3IgPSBjb250ZXh0Ll9tb2RlbENvbnN0cnVjdG9yc1t0eXBlXTtcbiAgICAgICAgaWYgKCFDb25zdHJ1Y3Rvcikge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHZhciB0eXBlRGVmID0gQ29uc3RydWN0b3IucHJvdG90eXBlLl9keFNjaGVtYTtcbiAgICAgICAgdmFyIHByb3BEZWZzID0gdHlwZURlZi5wcm9wZXJ0aWVzIHx8IHt9O1xuXG4gICAgICAgIHJldHVybiAhIXByb3BEZWZzLnJlZmVyZW5jZTtcbiAgICB9XG5cbiAgICBjb250ZXh0ID0gY29udGV4dCB8fCB0aGlzO1xuICAgIGNvbnRleHQuX21vZGVsU3Vic2NyaWJlcnNTdG9yZSA9IG5ldyBNb2RlbFN1YnNjcmliZXJTdG9yZSgpO1xuICAgIGNvbnRleHQuX3NpbmdsZXRvblN0b3JlID0gbmV3IFNpbmdsZXRvblN0b3JlKCk7XG4gICAgY29udGV4dC5fbW9kZWxTdG9yZSA9IG5ldyBNb2RlbFN0b3JlKGNvbnRleHQpO1xuXG4gICAgLypcbiAgICAgKiBNYWtlIGFsbCBvZiBvdXIgcHVibGljIHJvdXRpbmVzIGF2YWlsYWJsZS5cbiAgICAgKi9cbiAgICBjb250ZXh0Ll9jYWNoZSA9IHtcbiAgICAgICAgX01vZGVsU3Vic2NyaWJlclN0b3JlOiBNb2RlbFN1YnNjcmliZXJTdG9yZSxcbiAgICAgICAgX1NpbmdsZXRvblN0b3JlOiBTaW5nbGV0b25TdG9yZSxcbiAgICAgICAgX01vZGVsU3RvcmU6IE1vZGVsU3RvcmUsXG4gICAgICAgIGdldENhY2hlZFNpbmdsZXRvbjogZ2V0Q2FjaGVkU2luZ2xldG9uLFxuICAgICAgICBnZXRDYWNoZWRNb2RlbEZyb21Qcm9wZXJ0aWVzOiBnZXRDYWNoZWRNb2RlbEZyb21Qcm9wZXJ0aWVzLFxuICAgICAgICBnZXRDYWNoZWRNb2RlbDogZ2V0Q2FjaGVkTW9kZWwsXG4gICAgICAgIG1vZGVsTWF5SGF2ZUNoYW5nZWQ6IG1vZGVsTWF5SGF2ZUNoYW5nZWQsXG4gICAgICAgIGRlbGV0ZUNhY2hlZE1vZGVsOiBkZWxldGVDYWNoZWRNb2RlbCxcbiAgICAgICAgY29udGFpbnNDYWNoZWRNb2RlbDogY29udGFpbnNDYWNoZWRNb2RlbCxcbiAgICAgICAgcmVzZXQ6IHJlc2V0Q2FjaGUsXG4gICAgICAgIGR1bXBUZXh0OiBkdW1wQ2FjaGVBc1RleHQsXG4gICAgICAgIGR1bXA6IGR1bXBDYWNoZSxcbiAgICAgICAgcHJ1bmU6IHBydW5lLFxuICAgICAgICBpc0VtcHR5OiBpc0VtcHR5LFxuICAgICAgICBpc1R5cGVDYWNoYWJsZTogaXNUeXBlQ2FjaGFibGVcbiAgICB9O1xufTtcbiIsIi8qXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTQsIDIwMTUgYnkgRGVscGhpeC4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqL1xuXG4vKiBnbG9iYWwgJCwgXywgQmFja2JvbmUgKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCBkeFV0aWwgPSByZXF1aXJlKCdkeGNvcmUvanMvdXRpbC5qcycpLFxuICAgIGR4Q29uc3RhbnRzID0gcmVxdWlyZSgnZHhjb3JlL2pzL2NvbnN0YW50cy5qcycpO1xuXG4vKlxuICogVGhpcyB0YWtlcyBhIHNldCBvZiBzY2hlbWFzIChtb2RpZmllZCBieSBfcHJlcGFyZVNjaGVtYXMpLCBhbmQgY3JlYXRlcyBhIHNldCBvZiBCYWNrYm9uZSBDb2xsZWN0aW9uIGNvbnN0cnVjdG9yXG4gKiBmdW5jdGlvbnMgKGFuZCwgYnkgaW1wbGljYXRpb24sIGZ1bmN0aW9uYWxpdHkgdXBvbiB0aGUgY29sbGVjdGlvbnMgZ2VuZXJhdGVkIGJ5IHRob3NlIGZ1bmN0aW9ucykuIFRoZXNlIHdpbGwgYmVcbiAqIHVzZWQgYnkgdGhlICdsZXZlbDMnIEFQSSdzIHRvIHByb3ZpZGUgZmluYWwgY29sbGVjdGlvbnMgdG8gY29uc3VtZXJzIG9mIHRoZSBkYXRhIGxheWVyLlxuICpcbiAqIFNlZSB0aGUgY29tbWVudCBmb3IgbGV2ZWwyLW1vZGVscyBmb3IgYSBsaXN0IG9mIHRoZSBzcGVjaWFsaXplZCB0ZXJtaW5vbG9neSB1c2VkIGhlcmUgKGUuZy4gRFNCKS5cbiAqXG4gKiBDT05TVFJVQ1RPUiBGVU5DVElPTlNcbiAqIFRoZSBjb2xsZWN0aW9ucyBjcmVhdGVkIGJ5IHRoZXNlIGNvbnN0cnVjdG9yIGZ1bmN0aW9ucyBjb250YWluIGdyb3VwcyBvZiBEU0IgTW9kZWxzIHRoYXQgYWxsIHNoYXJlIGEgY29tbW9uIHBhcmVudFxuICogdHlwZS4gIFRoZXNlIGNvbGxlY3Rpb25zIGNhbiBvbmx5IGhhdmUgdGhlaXIgY29udGVudHMgY2hhbmdlZCBieSB3YXkgb2YgJCRsaXN0KCkgb3BlcmF0aW9ucyBhbmQgdGhlIG5vdGlmaWNhdGlvblxuICogc3lzdGVtLiBVbmxpa2UgRFNCIG1vZGVscywgdGhlcmUgYXJlIG5vICdDbGllbnQnIGNvbGxlY3Rpb25zLiAgVG8gaGF2ZSBhIGZ1bGx5LWFsdGVyYWJsZSBjb2xsZWN0aW9uIG9mIG1vZGVscyxcbiAqIHVzZSBhbiBvcmRpbmFyeSBCYWNrYm9uZSBDb2xsZWN0aW9uLlxuICpcbiAqIEVWRU5UU1xuICogcmVhZHkgOiByZWFkeUhhbmRsZXIoY29sbGVjdGlvbilcbiAqIElmIHlvdSB3YW50IHRvIGtub3cgaWYgYSBjb2xsZWN0aW9uIGlzIHJlYWR5IHRvIGJlIHVzZWQgKGhhcyByZXRyaWV2ZWQgYXQgbGVhc3Qgb25lIHNldCBvZiByZXN1bHRzIHZpYSAkJGxpc3QoKSksXG4gKiB1c2UgdGhlICdyZWFkeScgZXZlbnQsIHdoaWNoIGlzIHVuaXF1ZSB0byBEU0IgY29sbGVjdGlvbnMuXG4gKiBSZWFkeSBpbmRpY2F0ZXMgdGhhdCB0aGUgY29sbGVjdGlvbiBoYXMgcmV0cmlldmVkIGFuIGluaXRpYWwgc2V0IG9mIG1vZGVscy4gIFVubGlrZSBvcmRpbmFyeSBldmVudHMsIGlmIGEgcmVhZHlcbiAqIGhhbmRsZXIgaXMgYXNzaWduZWQgdG8gYSBjb2xsZWN0aW9uIHRoYXQgaXMgYWxyZWFkeSByZWFkeSwgdGhhdCBoYW5kbGVyIChhbmQgbm8gb3RoZXJzKSB3aWxsIGJlIHRyaWdnZXJlZFxuICogaW1tZWRpYXRlbHkuIFJlYWR5IGhhbmRsZXJzIHJlY2VpdmUgdGhlIGNvbGxlY3Rpb24gYXMgdGhlaXIgZmlyc3QgKGFuZCBvbmx5KSBhcmd1bWVudC5cbiAqXG4gKiBkaXJ0eSA6IGRpcnR5SGFuZGxlcihjb2xsZWN0aW9uKVxuICogSW5kaWNhdGVzIHRoYXQgdGhlIGNvbGxlY3Rpb24gbWF5IGJlIG91dCBvZiBzeW5jIHdpdGggdGhlIHNlcnZlciBhbmQgc2hvdWxkIGJlIHJlLSQkbGlzdCgpJ2VkXG4gKlxuICogUE9QVUxBVElPTlxuICogU2VydmVyIGNvbGxlY3Rpb25zIGFyZSBwb3B1bGF0ZWQgaW4gdHdvIHdheXM6XG4gKiAgIDEpIEEgY2FsbCB0byAkJGxpc3QoKSB3aWxsIGZpbGwgdGhlIGNvbGxlY3Rpb24gd2l0aCB0aGUgY3VycmVudCBzZXQgb2YgbW9kZWxzIGZyb20gdGhlIHNlcnZlclxuICogICAyKSBUaGUgbm90aWZpY2F0aW9uIHN5c3RlbSwgaWYgZW5hYmxlZCwgbWF5IGNhdXNlIG1vZGVscyB0byBiZSBhZGRlZCBhbmQgcmVtb3ZlZCBmcm9tIHRoZSBjb2xsZWN0aW9uIGF0IGFueSB0aW1lLlxuICogVGhlIG9wZXJhdGlvbiBvZiAkJGxpc3QoKSBpcyBzdHJhaWdodGZvcndhcmQuICBOb3RpZmljYXRpb25zIGFyZSBhIGxpdHRsZSBsZXNzIGNsZWFyLiAgQXMgdGhlIG5vdGlmaWNhdGlvbiBzeXN0ZW1cbiAqIGxlYXJucyBvZiBvYmplY3QgY2hhbmdlcywgaXQgd2lsbCBpbmZvcm0gdGhlIGNhY2hpbmcgc3lzdGVtIGFib3V0IHRoZSBjaGFuZ2VzLiAgVGhhdCwgaW4gdHVybiB3aWxsIGNhdXNlIHRoZVxuICogY2FjaGluZyBzeXN0ZW0gdG8gdHJ5IHRvIHVwZGF0ZSBhbnkgY29sbGVjdGlvbnMsIGFkZGluZyBhbmQgcmVtb3ZpbmcgdGhvc2UgbW9kZWxzIHRvIGNvbGxlY3Rpb25zIGFzIG5lZWRlZC5cbiAqIFRoZSBkZWNpc2lvbiBvZiB3aGV0aGVyIGEgbW9kZWwgc2hvdWxkIGJlIGFkZGVkIHdpbGwgZGVwZW5kIG9uIHRoZSBxdWVyeSBwYXJhbWV0ZXJzIHRoYXQgY3VycmVudGx5IGdvdmVybiB0aGVcbiAqIGNvbGxlY3Rpb24gKHRoZSBvbmVzIGxhc3QgcGFzc2VkIHRvICQkbGlzdCgpLCBpZiBhbnkpLiAgSW4gc29tZSBjYXNlcywgYSBjb2xsZWN0aW9uIG1heSBoYXZlIGEgcGFnZWQgc2V0IG9mIHJlc3VsdHMsXG4gKiBhbmQgYXQgdGhhdCBwb2ludCBpdCBjYW4gYmUgZGlmZmljdWx0IHRvIGRldGVybWluZSB3aGV0aGVyIHRoZSBtb2RlbCBzaG91bGQgYmUgYWRkZWQgdG8gdGhlIGNvbGxlY3Rpb24uXG4gKiBUaGUgZmlsdGVyIHN5c3RlbSAobGV2ZWwyLWZpbHRlcikgcHJvdmlkZXMgcGVyLXR5cGUgZmlsdGVycy4gSXQgaXMgdGhlaXIgcmVzcG9uc2liaWxpdHkgdG8gZGV0ZXJtaW5lIGhvdyB0aGUgbW9kZWxcbiAqIHNob3VsZCBiZSBkZWFsdCB3aXRoLiBJZiBpdCBjYW4ndCBkZXRlcm1pbmUgKGFzIGluIHRoZSBjYXNlIHdpdGggcGFnaW5nKSwgdGhlIGNvbGxlY3Rpb24gd2lsbCB0cmlnZ2VyIGEgJ2RpcnR5J1xuICogZXZlbnQsIHdoaWNoIHRoZSBjbGllbnQgb2YgdGhlIGNvbGxlY3Rpb24gY2FuIHVzZSB0byBkZWNpZGUgaG93IHRvIGhhbmRsZSB0aGlzIGNhc2UuIElmIHNldEF1dG9QYWdlUmVmcmVzaCh0cnVlKSBoYXNcbiAqIGJlZW4gY2FsbGVkIG9uIHRoZSBjb2xsZWN0aW9uLCB0aGVuIGluIHRoZXNlIGNpcmN1bXN0YW5jZXMsIGluIGFkZGl0aW9uIHRvIGZpcmluZyB0aGUgJ2RpcnR5JyBldmVudCwgdGhlIGNvbGxlY3Rpb25cbiAqIHdpbGwgYXV0b21hdGljYWxseSByZS1jYWxsICQkbGlzdCgpIHdpdGggdGhlIG9yaWdpbmFsIHF1ZXJ5IHBhcmFtZXRlcnMuIEluIHRoaXMgY2FzZSwgdGhlIG9yaWdpbmFsIHN1Y2Nlc3MgYW5kIGVycm9yXG4gKiBoYW5kbGVycyB3aWxsIGJlIGNhbGxlZCBhZ2FpbiBhZnRlciB0aGUgbGlzdCBvcGVyYXRpb24gcmV0dXJucy5cbiAqXG4gKiBPUEVSQVRJT05TXG4gKiBUaGUgY29sbGVjdGlvbnMgY3JlYXRlZCBieSB0aGVzZSBjb25zdHJ1Y3RvciBmdW5jdGlvbnMgaGF2ZSB0aGVzZSBzaW1pbGFyaXRpZXMgYW5kIGRpZmZlcmVuY2VzIGNvbXBhcmVkIHRvIHRoZVxuICogc3RhbmRhcmQgQmFja2JvbmUgY29sbGVjdGlvbnMuXG4gKlxuICogU3RhbmRhcmQgQmFja2JvbmUgcHJvcGVydGllcyAobm9uZSBvZiB0aGVzZSBzaG91bGQgYmUgY2hhbmdlZClcbiAqICAgICBtb2RlbHMgICAgIDogLS0gOiBUaGUgc2V0IG9mIG1vZGVscyBpbiB0aGUgY29sbGVjdGlvbi4gRG9uJ3QgYWNjZXNzIGRpcmVjdGx5LiBVc2UgYXQoKSBpbnN0ZWFkLlxuICogICAgIGxlbmd0aCAgICAgOiAgICA6IFN0YW5kYXJkIGJlaGF2aW9yLlxuICpcbiAqIFN0YW5kYXJkIEJhY2tib25lIGZ1bmN0aW9uc1xuICogICAgIG1vZGVsICAgICAgOiAtLSA6IE11c3Qgbm90IHVzZS4gQ29sbGVjdGlvbnMgY2FuIG5vdCBjcmVhdGUgdGhlaXIgb3duIG1vZGVscy5cbiAqICAgICB0b0pTT04gICAgIDogICAgOiBTdGFuZGFyZCBiZWhhdmlvci5cbiAqICAgICBVbmRlcnNjb3JlIDogICAgOiBTdGFuZGFyZCBiZWhhdmlvci4gVGhlc2UgYXJlIHRoZSAndW5kZXJzY29yZScgZnVuY3Rpb25zIGNhbiBhbGwgYmUgYXBwbGllZCB0byBjb2xsZWN0aW9ucy5cbiAqICAgICBhZGQgICAgICAgIDogLS0gOiBEbyBub3QgdXNlLiBVc2UgJCRsaXN0KCkgaW5zdGVhZC5cbiAqICAgICByZW1vdmUgICAgIDogLS0gOiBEbyBub3QgdXNlLiBVc2UgJCRsaXN0KCkgaW5zdGVhZC5cbiAqICAgICByZXNldCAgICAgIDogLS0gOiBEbyBub3QgdXNlLiBVc2UgJCRsaXN0KCkgaW5zdGVhZC5cbiAqICAgICBzZXQgICAgICAgIDogLS0gOiBEbyBub3QgdXNlLiBVc2UgJCRsaXN0KCkgaW5zdGVhZC5cbiAqICAgICBnZXQgICAgICAgIDogICAgOiBTdGFuZGFyZCBiZWhhdmlvci5cbiAqICAgICBhdCAgICAgICAgIDogICAgOiBTdGFuZGFyZCBiZWhhdmlvci5cbiAqICAgICBwdXNoICAgICAgIDogLS0gOiBEbyBub3QgdXNlLiBVc2UgJCRsaXN0KCkgaW5zdGVhZC5cbiAqICAgICBwb3AgICAgICAgIDogLS0gOiBEbyBub3QgdXNlLiBVc2UgJCRsaXN0KCkgaW5zdGVhZC5cbiAqICAgICB1bnNoaWZ0ICAgIDogLS0gOiBEbyBub3QgdXNlLiBVc2UgJCRsaXN0KCkgaW5zdGVhZC5cbiAqICAgICBzaGlmdCAgICAgIDogLS0gOiBEbyBub3QgdXNlLiBVc2UgJCRsaXN0KCkgaW5zdGVhZC5cbiAqICAgICBzbGljZSAgICAgIDogICAgOiBTdGFuZGFyZCBiZWhhdmlvci5cbiAqICAgICBjb21wYXJhdG9yIDogICAgOiBTdGFuZGFyZCBiZWhhdmlvci5cbiAqICAgICBzb3J0ICAgICAgIDogICAgOiBTdGFuZGFyZCBiZWhhdmlvci5cbiAqICAgICBwbHVjayAgICAgIDogICAgOiBTdGFuZGFyZCBiZWhhdmlvci5cbiAqICAgICB3aGVyZSAgICAgIDogICAgOiBTdGFuZGFyZCBiZWhhdmlvci5cbiAqICAgICBmaW5kV2hlcmUgIDogICAgOiBTdGFuZGFyZCBiZWhhdmlvci5cbiAqICAgICB1cmwgICAgICAgIDogLS0gOiBJbnRlcm5hbCB1c2UuIERvbid0IHVzZS5cbiAqICAgICBwYXJzZSAgICAgIDogLS0gOiBJbnRlcm5hbCB1c2UuIERvbid0IHVzZS4gSGFuZGxlcyByZXR1cm4gdmFsdWVzIGZyb20gdGhlIERlbHBoaXggRW5naW5lXG4gKiAgICAgY2xvbmUgICAgICA6ICAgIDogU3RhbmRhcmQgYmVoYXZpb3IuIEhvd2V2ZXIsIHRoZSByZXR1cm5lZCBjb2xsZWN0aW9uIGlzIGFuIG9yZGluYXJ5IEJhY2tib25lIENvbGxlY3Rpb24uXG4gKiAgICAgZmV0Y2ggICAgICA6IC0tIDogRG8gbm90IHVzZS4gVXNlICQkbGlzdCgpIGluc3RlYWQuXG4gKiAgICAgY3JlYXRlICAgICA6IC0tIDogRG8gbm90IHVzZS4gRFNCIE1vZGVscyBoYXZlIG1vcmUgY29tcGxleCBjcmVhdGlvbiBzZW1hbnRpY3MuIHVzZSByb290T3BzLi4kJGNyZWF0ZSgpLlxuICpcbiAqIERTQiBDb2xsZWN0aW9uIGZ1bmN0aW9uc1xuICogICAgICQkbGlzdCAgICAgICAgICAgICA6ICAgIDogUG9wdWxhdGVzIHRoZSBjb2xsZWN0aW9uIHdpdGggYSBzZWxlY3Rpb24gb2YgbW9kZWxzIGZyb20gdGhlIHNlcnZlci5cbiAqICAgICBnZXRRdWVyeVBhcmFtZXRlcnMgOiAgICA6IFJldHVybnMgdGhlIHF1ZXJ5IHBhcmFtZXRlcnMgdXNlZCB0byBwb3B1bGF0ZSB0aGlzIGNvbGxlY3Rpb24gdmlhICQkbGlzdFxuICogICAgIGNsZWFyICAgICAgICAgICAgICA6ICAgIDogUmVtb3ZlcyBhbGwgbW9kZWxzIGZyb20gdGhlIGNvbGxlY3Rpb24sIGVtcHRpZXMgYW55IHF1ZXJ5IHBhcmFtZXRlcnMsIGFuZCBibG9ja3MgYW55XG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtb2RlbHMgZnJvbSBiZWluZyBhdXRvLWFkZGVkIHVudGlsIGFub3RoZXIgJCRsaXN0IGlzIGlzc3VlZFxuICpcbiAqIFByaXZhdGUgdG8gZHhDb3JlIERhdGFcbiAqICAgICBjb250ZXh0Ll9jb2xsZWN0aW9uQ29uc3RydWN0b3JzIDogVGhlIHNldCBvZiBjb2xsZWN0aW9uIGNvbnN0cnVjdG9yIGZ1bmN0aW9uc1xuICogICAgIGNvbnRleHQuX25ld1NlcnZlckNvbGxlY3Rpb24gICAgOiBDcmVhdGVzIGEgbmV3IFNlcnZlciBDb2xsZWN0aW9uXG4gKlxuICogUGFyYW1ldGVyczpcbiAqICAgICBzY2hlbWFzOiBUaGUgc2V0IG9mIHNjaGVtYXMgdGhpcyBzaG91bGQgZ2VuZXJhdGUgY29uc3RydWN0b3JzIGZyb20uXG4gKiAgICAgY29udGV4dDogVGhlIG9iamVjdCB0byBwdXQgdGhlIHJlc3VsdGluZyBjb25zdHJ1Y3RvcnMgKF9jb2xsZWN0aW9uQ29uc3RydWN0b3JzKSBvbi4gSWYgbm90IHNwZWNpZmllZCwgcHV0cyB0aGVtXG4gKiAgICAgICAgICAgICAgb24gJ3RoaXMnLlxuICovXG5tb2R1bGUuZXhwb3J0cy5fZ2VuZXJhdGVDb2xsZWN0aW9uQ29uc3RydWN0b3JzID0gZnVuY3Rpb24gX2dlbmVyYXRlQ29sbGVjdGlvbkNvbnN0cnVjdG9ycyhzY2hlbWFzLCBjb250ZXh0KSB7XG4gICAgdmFyIExJU1RJTkdNT0RFX0lETEUgPSAwO1xuICAgIHZhciBMSVNUSU5HTU9ERV9MSVNUSU5HID0gMTtcblxuICAgIC8qXG4gICAgICogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICAgICAqIENvbGxlY3Rpb24gZnVuY3Rpb25zXG4gICAgICogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICAgICAqL1xuXG4gICAgLypcbiAgICAgKiBCYWNrYm9uZSBkZWZpbmVzIHRoaXMgYXM6IEJpbmQgYSBjYWxsYmFjayBmdW5jdGlvbiB0byBhbiBvYmplY3QuIFRoZSBjYWxsYmFjayB3aWxsIGJlIGludm9rZWQgd2hlbmV2ZXIgdGhlIGV2ZW50XG4gICAgICogaXMgZmlyZWQuXG4gICAgICpcbiAgICAgKiBGb3IgRFNCIGNvbGxlY3Rpb25zLCB3ZSBwcm92aWRlIHN0YW5kYXJkIGJlaGF2aW9yIGZvciB0aGlzLCBidXQgZG8gc29tZSBzcGVjaWFsIHByb2Nlc3NpbmcgaWYgc29tZW9uZSBpc1xuICAgICAqIGxpc3RlbmluZyBmb3IgdGhlICdyZWFkeScgZXZlbnQuIEluIHRoYXQgY2FzZSwgaWYgd2UgaGF2ZSBkb25lIGEgJCRsaXN0KCkgc3VjY2Vzc2Z1bGx5LCB0aGVuIHdlIHRyaWdnZXIgdGhlXG4gICAgICogcmVhZHkgZXZlbnQgaW1tZWRpYXRlbHkuXG4gICAgICovXG4gICAgZnVuY3Rpb24gZHhPbihuYW1lLCBjYWxsYmFjaywgY29udGV4dCkge1xuICAgICAgICBCYWNrYm9uZS5FdmVudHMub24uY2FsbCh0aGlzLCBuYW1lLCBjYWxsYmFjaywgY29udGV4dCk7XG4gICAgICAgIGlmIChuYW1lID09PSAncmVhZHknICYmIHRoaXMuX2R4SXNSZWFkeSkge1xuICAgICAgICAgICAgdGhpcy50cmlnZ2VyKCdyZWFkeScsIHRoaXMpO1xuICAgICAgICB9IGVsc2UgaWYgKG5hbWUgPT09ICdlcnJvcicgJiYgdGhpcy5fZHhJc0Vycm9yZWQpIHtcbiAgICAgICAgICAgIHRoaXMudHJpZ2dlcignZXJyb3InLCB0aGlzKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qXG4gICAgICogQmFja2JvbmUgZGVmaW5lcyB0aGlzIGFzOiBbVGhpc10gcGVyZm9ybXMgYSAnc21hcnQnIHVwZGF0ZSBvZiB0aGUgY29sbGVjdGlvbiB3aXRoIHRoZSBwYXNzZWQgbGlzdCBvZiBtb2RlbHMuXG4gICAgICpcbiAgICAgKiBJbiBnZW5lcmFsLCB3ZSBkbyBub3QgYWxsb3cgdGhpcyB0byBiZSBjYWxsZWQsIHNpbmNlIHNlcnZlciBtb2RlbHMgYXJlIHN1cHBvc2VkIHRvIGJlIHJlYWQgb25seS4gSG93ZXZlcixcbiAgICAgKiBpbiBzb21lIGNhc2VzLCBpbnRlcm5hbGx5LCB3ZSBuZWVkIHRvIGFkZCBtb2RlbHMgdG8gdGhlIGNvbGxlY3Rpb24sIGFuZCB3aXNoIHRvIHBhcnRha2Ugb2YgdGhlIGZ1bmN0aW9uYWxpdHlcbiAgICAgKiBhbHJlYWR5IGRlZmluZWQgYnkgQmFja2JvbmUuIFNvLCBpZiB0aGlzIGlzIGNhbGxlZCB3aXRoIHsgX2R4QWxsb3dTZXRQYXNzdGhyb3VnaDp0cnVlIH0sIGl0IHdpbGwgY2FsbFxuICAgICAqIEJhY2tib25lLkNvbGxlY3Rpb24uc2V0KCkgbm9ybWFsbHkuXG4gICAgICpcbiAgICAgKiBUaGlzIGlzIG5vdCBzaW1wbHkgYSBkeEFkZCBmdW5jdGlvbiwgc2luY2Ugd2UgbmVlZCB0byBzdXBwb3J0IGNhbGxzIGZyb20gd2l0aGluIGJhY2tib25lIGJhY2sgdG8gbW9kZWwuc2V0KClcbiAgICAgKiB0aGF0IG1heSBoYXZlIGJlZW4gdHJpZ2dlcmVkIGJ5IG90aGVyIGFjdGlvbnMgd2UgaGF2ZSB0YWtlbi5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBkeFNldChtb2RlbHMsIG9wdGlvbnMpIHtcbiAgICAgICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gICAgICAgIGlmICghb3B0aW9ucy5fZHhBbGxvd1NldFBhc3N0aHJvdWdoKSB7XG4gICAgICAgICAgICBvcGVyYXRpb25Ob3RBbGxvd2VkKCk7XG4gICAgICAgIH1cblxuICAgICAgICBhc3NlcnRNb2RlbHNDb21wYXRpYmxlKG1vZGVscywgdGhpcyk7XG4gICAgICAgIHJldHVybiBCYWNrYm9uZS5Db2xsZWN0aW9uLnByb3RvdHlwZS5zZXQuY2FsbCh0aGlzLCBtb2RlbHMsIF8uZXh0ZW5kKG9wdGlvbnMsIHtcbiAgICAgICAgICAgIG1lcmdlOiBmYWxzZSxcbiAgICAgICAgICAgIHJlbW92ZTogZmFsc2VcbiAgICAgICAgfSkpO1xuICAgIH1cblxuICAgIC8qXG4gICAgICogQmFja2JvbmUgZGVmaW5lcyB0aGlzIGFzOiBwYXJzZSBpcyBjYWxsZWQgYnkgQmFja2JvbmUgd2hlbmV2ZXIgYSBjb2xsZWN0aW9uJ3MgbW9kZWxzIGFyZSByZXR1cm5lZCBieSB0aGUgc2VydmVyLFxuICAgICAqIGluIGZldGNoLiBUaGUgZnVuY3Rpb24gaXMgcGFzc2VkIHRoZSByYXcgcmVzcG9uc2Ugb2JqZWN0LCBhbmQgc2hvdWxkIHJldHVybiB0aGUgYXJyYXkgb2YgbW9kZWwgYXR0cmlidXRlcyB0byBiZVxuICAgICAqIGFkZGVkIHRvIHRoZSBjb2xsZWN0aW9uLiBUaGUgZGVmYXVsdCBpbXBsZW1lbnRhdGlvbiBpcyBhIG5vLW9wLCBzaW1wbHkgcGFzc2luZyB0aHJvdWdoIHRoZSBKU09OIHJlc3BvbnNlLlxuICAgICAqIE92ZXJyaWRlIHRoaXMgaWYgeW91IG5lZWQgdG8gd29yayB3aXRoIGEgcHJlZXhpc3RpbmcgQVBJLCBvciBiZXR0ZXIgbmFtZXNwYWNlIHlvdXIgcmVzcG9uc2VzLlxuICAgICAqXG4gICAgICogVGhpcyBleHBlY3RzIHRoZSByZXNwb25zZSB0byBhbHdheXMgaGF2ZSBhIHR5cGUgYXR0cmlidXRlLiBJZiBpdCBpcyBhbiBFcnJvclJlc3VsdCwgaXQgZ2V0cyByZXBvcnRlZCB0aHJvdWdoIHRoZVxuICAgICAqIHN0YW5kYXJkIGVycm9yIGhhbmRsZXIuIElmIGl0IGlzIGEgTGlzdFJlc3VsdCwgd2UgcmV0dXJuIGp1c3QgdGhlIHJlc3VsdCBhcnJheS4gT3RoZXJ3aXNlIHdlIHRocm93IGFuIGVycm9yLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGR4UGFyc2UocmVzcG9uc2UpIHtcbiAgICAgICAgaWYgKCFyZXNwb25zZSB8fCAhcmVzcG9uc2UudHlwZSkge1xuICAgICAgICAgICAgZHhVdGlsLmZhaWwoJ0dvdCBhIHJlc3BvbnNlIHdpdGhvdXQgYSB0eXBlLicpO1xuICAgICAgICB9IGVsc2UgaWYgKHJlc3BvbnNlLnR5cGUgIT09ICdMaXN0UmVzdWx0Jykge1xuICAgICAgICAgICAgZHhVdGlsLmZhaWwoJ0dvdCBhbiB1bmV4cGVjdGVkIHR5cGUgb2YgcmVzcG9uc2UgKCcgKyByZXNwb25zZS50eXBlICsgJykgaW4gcGFyc2UoKS4nKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiByZXNwb25zZS5yZXN1bHQ7XG4gICAgfVxuXG4gICAgLypcbiAgICAgKiBFbnRpcmVseSBibG9jayB0aGUgc3RhbmRhcmQgQmFja2JvbmUgZmV0Y2goKSByb3V0aW5lLiBXZSB3YW50IHVzZXJzIHRvIGNhbGwgJCRsaXN0KCksIGFzIHRoYXQgaGFzIGEgbW9yZVxuICAgICAqIGNvbnN0cmFpbmVkIEFQSSwgYmV0dGVyIG1hdGNoZXMgdGhlIGFwaSB3ZSdyZSBwcm92aWRpbmcgZm9yIG9wZXJhdGlvbnMgYW5kIHJvb3RPcGVyYXRpb25zLCBhbmQsIG1vcmUgZGlyZWN0bHlcbiAgICAgKiBtYXBzIHRvIG91ciBzY2hlbWFzLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGR4RmV0Y2goKSB7XG4gICAgICAgIGR4VXRpbC5mYWlsKCdEbyBub3QgY2FsbCBmZXRjaCgpIGRpcmVjdGx5LiBJbnN0ZWFkLCBjYWxsICQkbGlzdCgpLicpO1xuICAgIH1cblxuICAgIC8qXG4gICAgICogRW50aXJlbHkgYmxvY2sgdGhlIHN0YW5kYXJkIEJhY2tib25lIGNyZWF0ZSgpIHJvdXRpbmUuIENyZWF0aW9uIGlzIG1vcmUgY29tcGxleCBmb3IgRFNCIG1vZGVscywgYW5kIHNvIHNob3VsZCBiZVxuICAgICAqIGRvbmUgdGhyb3VnaCB0aGUgJCRjcmVhdGUgb3BlcmF0aW9ucy5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBkeENyZWF0ZSgpIHtcbiAgICAgICAgZHhVdGlsLmZhaWwoJ0RvIG5vdCBjYWxsIGNyZWF0ZSgpIGRpcmVjdGx5LiBJbnN0ZWFkLCBjYWxsIHJvb3RPcHMuJyArIHRoaXMuX2R4SW5mby5iYXNlVHlwZSArICcuJCRjcmVhdGUoKS4nKTtcbiAgICB9XG5cbiAgICAvKlxuICAgICAqIFJlbW92ZXMgYWxsIG1vZGVscyBmcm9tIHRoZSBjb2xsZWN0aW9uLCBidXQgbGVhdmVzIGl0ICdsaXZlJy4gIFRoaXMgaXMgdXNlZCBmb3IgdGVzdGluZyBwdXJwb3Nlcy5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBkeEVtcHR5KCkge1xuICAgICAgICBCYWNrYm9uZS5Db2xsZWN0aW9uLnByb3RvdHlwZS5yZW1vdmUuY2FsbCh0aGlzLCB0aGlzLm1vZGVscywge3NpbGVudDogdHJ1ZX0pO1xuICAgIH1cblxuICAgIC8qXG4gICAgICogUmVtb3ZlcyBhbGwgbW9kZWxzIGZyb20gdGhlIGNvbGxlY3Rpb24gKG5vdCBzaWxlbnRseSksIHJlbW92ZXMgdGhlIHF1ZXJ5IHBhcmFtZXRlcnMsXG4gICAgICogaWYgYW55LCBhbmQgbWFya3MgdGhlIGNvbGxlY3Rpb24gYXMgbm90IHJlYWR5LCB3aGljaCBtZWFucyBpdCBtdXN0IGhhdmUgYW5vdGhlciAkJGxpc3QoKSBjYWxsIGluIG9yZGVyIHRvIGdldFxuICAgICAqIG5ldyBtb2RlbHNcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBkeENsZWFyKCkge1xuICAgICAgICB0aGlzLl9keElzUmVhZHkgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5fcXVlcnlQYXJhbWV0ZXJzID0gdW5kZWZpbmVkO1xuICAgICAgICBCYWNrYm9uZS5Db2xsZWN0aW9uLnByb3RvdHlwZS5yZW1vdmUuY2FsbCh0aGlzLCB0aGlzLm1vZGVscywge3NpbGVudDogdHJ1ZX0pO1xuICAgICAgICB0aGlzLnRyaWdnZXIoJ3Jlc2V0JywgdGhpcyk7XG4gICAgfVxuXG4gICAgLypcbiAgICAgKiBHaXZlbiBhIG1vZGVsLCB0aGlzIHdpbGwgZWl0aGVyIGFkZCBpdCB0byB0aGUgY29sbGVjdGlvbiwgaWYgaXQgc2hvdWxkIGJlIGluIHRoZSBjb2xsZWN0aW9uLCBpZ25vcmUgaXQgaWYgaXRcbiAgICAgKiBzaG91bGRuJ3QgYmUgaW4gdGhlIGNvbGxlY3Rpb24gKGFuZCBpc24ndCB0aGVyZSBhbHJlYWR5KSwgb3IgcmVtb3ZlIGl0IGlmIGl0IHNob3VsZG4ndCBiZSBpbiB0aGUgY29sbGVjdGlvbiBhbmRcbiAgICAgKiBpcy4gIFRoaXMgdGFrZXMgaW50byBhY2NvdW50IGFueSBxdWVyeSBwYXJhbWV0ZXJzIGFzc29jaWF0ZWQgd2l0aCB0aGUgY29sbGVjdGlvbiwgYW5kIHVzZXMgY29sbGVjdGlvbiBmaWx0ZXJzXG4gICAgICogaWYgZGVmaW5lZC5cbiAgICAgKlxuICAgICAqIE5vdGUgdGhhdCBtb2RlbHMgY2FuIGJlIG5laXRoZXIgYWRkZWQgbm9yIHJlbW92ZWQgaWYgdGhpcyBpcyBub3QgcmVhZHkuXG4gICAgICovXG4gICAgZnVuY3Rpb24gZHhBZGRPclJlbW92ZShtb2RlbCwgb3B0aW9ucykge1xuICAgICAgICBhc3NlcnRNb2RlbHNDb21wYXRpYmxlKG1vZGVsLCB0aGlzKTtcbiAgICAgICAgaWYgKCF0aGlzLl9keElzUmVhZHkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBvcHRpb25zID0gXy5leHRlbmQoe1xuICAgICAgICAgICAgX2R4QWxsb3dTZXRQYXNzdGhyb3VnaDogdHJ1ZVxuICAgICAgICB9LCBvcHRpb25zKTtcbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgICB2YXIgcm9vdFR5cGUgPSB0aGlzLl9keEluZm8uYmFzZVR5cGU7XG5cbiAgICAgICAgaWYgKHNlbGYuX2xpc3RpbmdNb2RlID09PSBMSVNUSU5HTU9ERV9MSVNUSU5HKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgZmlsdGVyID0gY29udGV4dC5fZmlsdGVyc1tyb290VHlwZV07XG4gICAgICAgIGlmICghZmlsdGVyKSB7XG4gICAgICAgICAgICBpZiAoc2VsZi5fZHhJbmZvLnBhcmFtRGVmcy5keEZpbHRlck1vZGUgPT09IGR4Q29uc3RhbnRzLkxJU1RfVFlQRVMuTk9ORSkge1xuICAgICAgICAgICAgICAgIGR4U2V0LmNhbGwoc2VsZiwgbW9kZWwsIG9wdGlvbnMpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZmlsdGVyID0gY29udGV4dC5fZmlsdGVycy5fdWJlckZpbHRlcjtcbiAgICAgICAgfVxuXG4gICAgICAgIGZpbHRlcih0aGlzLCBtb2RlbCwgZnVuY3Rpb24ocGxhY2VtZW50KSB7XG4gICAgICAgICAgICBpZiAobW9kZWwuX2R4RGVsZXRlZCkge1xuICAgICAgICAgICAgICAgIC8qXG4gICAgICAgICAgICAgICAgICogU2luY2Ugc29tZSBmaWx0ZXJzIHVzZSBhc3luY2hyb25vdXMgcmVxdWVzdHMgdG8gZGV0ZXJtaW5lIHRoZSBpbmNsdXNpb24gb2YgYW4gb2JqZWN0LFxuICAgICAgICAgICAgICAgICAqIGl0IGlzIHBvc3NpYmxlIGZvciBhbiBvYmplY3QgdG8gYmUgZGVsZXRlZCB3aGlsZSBhIGZpbHRlciBpcyBleGVjdXRlZC5cbiAgICAgICAgICAgICAgICAgKiBXZSBuZWVkIHRvIG1ha2Ugc3VyZSB0aGF0IGV2ZW4gaWYgdGhlIGZpbHRlciBkZXRlcm1pbmVzIHRoYXQgdGhlIG9iamVjdCBzaG91bGQgYmVcbiAgICAgICAgICAgICAgICAgKiBpbmNsdWRlZCBpbiB0aGUgbGlzdCwgdGhlIGNvbGxlY3Rpb24gZGlzY2FyZHMgZGVsZXRlZCBvYmplY3RzLlxuICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHN3aXRjaCAocGxhY2VtZW50KSB7XG4gICAgICAgICAgICAgICAgY2FzZSBjb250ZXh0Ll9maWx0ZXJzLklOQ0xVREU6XG4gICAgICAgICAgICAgICAgICAgIGR4U2V0LmNhbGwoc2VsZiwgbW9kZWwsIG9wdGlvbnMpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIGNvbnRleHQuX2ZpbHRlcnMuRVhDTFVERTpcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5fZHhSZW1vdmVNb2RlbChtb2RlbCwgb3B0aW9ucyk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgY29udGV4dC5fZmlsdGVycy5VTktOT1dOOlxuICAgICAgICAgICAgICAgICAgICBpZiAoc2VsZi5fbGlzdGluZ01vZGUgPT09IExJU1RJTkdNT0RFX0lETEUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRyaWdnZXJEaXJ0eShzZWxmKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICBkeFV0aWwuZmFpbCgnRmlsdGVyIHJldHVybmVkIGFuIGludmFsaWQgdmFsdWUuJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIC8qXG4gICAgICogU2V0cyB0aGUgYXV0b1BhZ2VSZWZyZXNoIHByb3BlcnR5LlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHNldEF1dG9QYWdlUmVmcmVzaCh2YWx1ZSkge1xuICAgICAgICB0aGlzLl9hdXRvUGFnZVJlZnJlc2ggPSB2YWx1ZTtcbiAgICB9XG5cbiAgICAvKlxuICAgICAqIFJldHVybiB0aGUgYXV0b1BhZ2VSZWZyZXNoIHByb3BlcnR5LlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGdldEF1dG9QYWdlUmVmcmVzaCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2F1dG9QYWdlUmVmcmVzaDtcbiAgICB9XG5cbiAgICAvKlxuICAgICAqIFJlbW92ZSB0aGUgbW9kZWxzIGZyb20gdGhpcyBjb2xsZWN0aW9uIHRoYXQgYXJlIGJlaW5nIG9ic29sZXRlZCBieSB0aGUgY29udGVudHMgb2YgdGhlIHJhd1Byb3BzQXJyYXkuIEluXG4gICAgICogZ2VuZXJhbCwgd2UgcmVtb3ZlIHRoZSBtb2RlbHMgdGhhdCB0aGUgY29sbGVjdGlvbiBjdXJyZW50bHkgY29udGFpbnMgdGhhdCBhcmUgbm90IHBhcnQgb2YgdGhlIHJhd1Byb3BzQXJyYXksXG4gICAgICogYnV0IGlmIHRoZSByYXdQcm9wc0FycmF5IGRvbid0IGhhdmUgYSByZWZlcmVuY2UgYXR0cmlidXRlLCB0aGVuIHdlIGNhbid0IHRlbGwgaWYgdGhlIG1vZGVscyBhcmUgdGhlIHNhbWUgb3Igbm90XG4gICAgICogc28gd2UgcmVzZXQuXG4gICAgICpcbiAgICAgKiBSZXR1cm4gd2hldGhlciB3ZSBhcmUgcmVzZXR0aW5nIHRoZSBjb2xsZWN0aW9uLiBUaGlzIGlzIHRydWUgaWYgd2UncmUgcmVtb3ZpbmcgYWxsIGVsZW1lbnRzLCBvciBpZlxuICAgICAqIGNvbGxlY3Rpb24uX3Jlc2V0T25MaXN0IGlzIHRydWUuXG4gICAgICovXG4gICAgZnVuY3Rpb24gcmVtb3ZlVW5uZWVkZWRNb2RlbHMoY29sbGVjdGlvbiwgcmF3UHJvcHNBcnJheSkge1xuICAgICAgICB2YXIgcmVzZXR0aW5nID0gZmFsc2U7XG5cbiAgICAgICAgaWYgKHJhd1Byb3BzQXJyYXkubGVuZ3RoICE9PSAwICYmIF8uaXNVbmRlZmluZWQocmF3UHJvcHNBcnJheVswXS5yZWZlcmVuY2UpKSB7XG4gICAgICAgICAgICBCYWNrYm9uZS5Db2xsZWN0aW9uLnByb3RvdHlwZS5yZW1vdmUuY2FsbChjb2xsZWN0aW9uLCBjb2xsZWN0aW9uLm1vZGVscywge3NpbGVudDogdHJ1ZX0pO1xuICAgICAgICAgICAgcmVzZXR0aW5nID0gdHJ1ZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHZhciBuZXdSZWZlcmVuY2VzID0gXy5tYXAocmF3UHJvcHNBcnJheSwgZnVuY3Rpb24oYXR0cmlidXRlcykge1xuICAgICAgICAgICAgICAgIHJldHVybiBhdHRyaWJ1dGVzLnJlZmVyZW5jZTtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAvLyBGaWd1cmUgb3V0IHdoaWNoIG1vZGVscyB0byByZW1vdmUgKGJ5IHJlZmVyZW5jZSkuIHJlc2V0IGlmIHJlbW92aW5nIGFsbFxuICAgICAgICAgICAgdmFyIG1vZGVsc1RvUmVtb3ZlID0gW107XG4gICAgICAgICAgICBjb2xsZWN0aW9uLmVhY2goZnVuY3Rpb24obW9kZWwpIHtcbiAgICAgICAgICAgICAgICBpZiAoIV8uY29udGFpbnMobmV3UmVmZXJlbmNlcywgbW9kZWwuaWQpKSB7XG4gICAgICAgICAgICAgICAgICAgIG1vZGVsc1RvUmVtb3ZlLnB1c2gobW9kZWwpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBpZiAoY29sbGVjdGlvbi5fcmVzZXRPbkxpc3QgfHwgbW9kZWxzVG9SZW1vdmUubGVuZ3RoID09PSBjb2xsZWN0aW9uLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHJlc2V0dGluZyA9IHRydWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIF8uZWFjaChtb2RlbHNUb1JlbW92ZSwgZnVuY3Rpb24obW9kZWwpIHtcbiAgICAgICAgICAgICAgICBCYWNrYm9uZS5Db2xsZWN0aW9uLnByb3RvdHlwZS5yZW1vdmUuY2FsbChjb2xsZWN0aW9uLCBtb2RlbCwge3NpbGVudDogcmVzZXR0aW5nfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzZXR0aW5nO1xuICAgIH1cblxuICAgIC8qXG4gICAgICogUmV0cmlldmUgYSBzZXQgb2YgbW9kZWxzIGZyb20gdGhlIHNlcnZlciwgZW50aXJlbHkgcmVwbGFjaW5nIHRoZSBjb250ZW50cyBvZiB0aGlzIGNvbGxlY3Rpb24gd2l0aCB0aG9zZSBtb2RlbHMuXG4gICAgICogVGhpcyBpcyBhIHJlZmxlY3Rpb24gb2YgdGhlIGxpc3Qgc3RhbmRhcmQgb3BlcmF0aW9uIGZvdW5kIGluIERlbHBoaXggc2NoZW1hcy4gIFRoaXMgdGFrZXMgYSBzZXQgb2YgcXVlcnlcbiAgICAgKiBwYXJhbWV0ZXJzIGFzIGFuIGFyZ3VtZW50LCBhbmQgd2lsbCBwb3B1bGF0ZSB0aGUgY29sbGVjdGlvbiB3aXRoIHRoZSByZXN1bHRzIG9mIHRoYXQgcXVlcnkuXG4gICAgICpcbiAgICAgKiBOb3RlIHRoYXQgaWYgbXVsdGlwbGUgcmVxdWVzdHMgYXJlIGlzc3VlZCwgdGhpcyB3aWxsIG9ubHkgaG9ub3IgdGhlIGxhc3QgcmVxdWVzdCBzZW50LiBNb2RlbHMgYXJlIGFkZGVkL3JlbW92ZWRcbiAgICAgKiBvbmx5IHdoZW4gdGhlIGxhc3QgaXNzdWVkIHJlcXVlc3QgcmV0dXJucy4gVGhpcyBhbHNvIG1lYW5zIHRoYXQgcmVhZHkvZXJyb3IgZXZlbnRzIGFyZSB0cmlnZ2VyZWQgYW5kIHByb21pc2VzXG4gICAgICogcmVzb2x2ZWQvcmVqZWN0ZWQgb25seSBvbmNlIHRoZSBsYXN0IHJlcXVlc3QgaXNzdWVkIHJldHVybnMuXG4gICAgICpcbiAgICAgKiBQYXJhbWV0ZXJzOlxuICAgICAqICAgICBwYXJhbWV0ZXJzOiBBbiBvYmplY3QgaGFzaCBjb250YWluaW5nIHRoZSBwYXJhbWV0ZXJzIHRvIHRoaXMgbGlzdCBvcGVyYXRpb24uIEZvciBleGFtcGxlLCBpZiB0aGlzIGlzIGFcbiAgICAgKiAgICAgICAgIENvbnRhaW5lciBjb2xsZWN0aW9uLCB5b3UgbWlnaHQgY2FsbFxuICAgICAqICAgICAgICAgICAgIG15Q29sbGVjdGlvbi4kJGxpc3Qoe1xuICAgICAqICAgICAgICAgICAgICAgICBncm91cDogJ0dST1VQLTEnLFxuICAgICAqICAgICAgICAgICAgICAgICBwYXJlbnQ6ICdDT05UQUlORVItMjMnXG4gICAgICogICAgICAgICAgICAgfSk7XG4gICAgICogICAgIHN1Y2Nlc3NFcnJvcjogQSBzdGFuZGFyZCBvYmplY3QgdGhhdCBjb250YWlucyBhIHN1Y2Nlc3MgYW5kL29yIGVycm9yIGNhbGxiYWNrIHJvdXRpbmUuXG4gICAgICogRXZlbnRzOlxuICAgICAqICAgICByZWFkeTogIFRyaWdnZXJlZCBmb3IgdGhlIGNvbGxlY3Rpb24gb25jZSBhbGwgdGhlIG1vZGVscyBoYXZlIGJlZW4gYWRkZWQgYW5kIHJlbW92ZWQuIEhhbmRsZXIgYXJndW1lbnQgaXNcbiAgICAgKiAgICAgICAgICAgICB0aGUgY29sbGVjdGlvbi5cbiAgICAgKiAgICAgICAgICAgICBBbHNvIHRyaWdnZXJlZCBmb3IgZWFjaCBtb2RlbCBtYXJrZWQgYXMgcmVhZHkuIEhhbmRsZXIgYXJndW1lbnQgaXMgYSBtb2RlbC5cbiAgICAgKiAgICAgcmVzZXQ6ICBUcmlnZ2VyZWQgaWYgdGhpcyByZXN1bHRzIGluIGFsbCB0aGUgZXhpc3RpbmcgbW9kZWxzIGJlaW5nIHJlbW92ZWQsIG9yIHRoZSBfcmVzZXRPbkxpc3QgZmxhZyBoYXNcbiAgICAgKiAgICAgICAgICAgICBiZWVuIHNldCB0byB0cnVlLiBBcmd1bWVudCBpcyB0aGUgY29sbGVjdGlvbi5cbiAgICAgKiAgICAgcmVtb3ZlOiBUcmlnZ2VyZWQgZm9yIGVhY2ggbW9kZWwgcmVtb3ZlZCwgaWZmIG9ubHkgc29tZSBvZiB0aGUgbW9kZWxzIGFyZSByZW1vdmVkLiBBcmd1bWVudCBpcyB0aGUgbW9kZWwuXG4gICAgICogICAgIGFkZDogICAgVHJpZ2dlcmVkIGZvciBlYWNoIGFkZGVkIG1vZGVsLCBpZmYgb25seSBzb21lIG9mIHRoZSBtb2RlbHMgd2VyZSByZW1vdmVkLiBBcmd1bWVudCBpcyB0aGUgbW9kZWwuXG4gICAgICovXG4gICAgZnVuY3Rpb24gZHhMaXN0KHBhcmFtZXRlcnMsIHN1Y2Nlc3NFcnJvcikge1xuICAgICAgICB2YXIgc2VuZGFibGVQYXJhbXMgPSBjb250ZXh0Ll9jaGVja0FuZENvbnZlcnRQYXJhbWV0ZXJzKHBhcmFtZXRlcnMsIHRoaXMuX2R4SW5mby5wYXJhbURlZnMucGFyYW1ldGVycyk7XG4gICAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgICAgdmFyIHJvb3RUeXBlID0gdGhpcy5fZHhJbmZvLmJhc2VUeXBlO1xuXG4gICAgICAgIC8vIE5vIGZpbHRlciBmdW5jdGlvbi4gQ29tcGxhaW4gc28gc29tZW9uZSB3cml0ZXMgb25lLCBhbmQgYmxpbmRseSBhZGQgdGhlIG1vZGVsXG4gICAgICAgIGlmIChkeFV0aWwuaXNOb25lKGNvbnRleHQuX2ZpbHRlcnNbcm9vdFR5cGVdKSAmJlxuICAgICAgICAgICAgc2VsZi5fZHhJbmZvLnBhcmFtRGVmcy5keEZpbHRlck1vZGUgPT09IGR4Q29uc3RhbnRzLkxJU1RfVFlQRVMuQ1VTVE9NKSB7XG4gICAgICAgICAgICBkeFV0aWwuZmFpbCgnTm8gZmlsdGVyIGZ1bmN0aW9uIGZvdW5kIGZvciBjb2xsZWN0aW9ucyBvZiB0eXBlICcgKyByb290VHlwZSArICcuIEFkZCBvbmUgdG8gJyArXG4gICAgICAgICAgICAgICAgICcgY29yZSBkYXRhIF9maWx0ZXJzLiBJbiB0aGUgbWVhbiB0aW1lLCBhbGwgbW9kZWxzIHdpbGwgYmUgYWRkZWQgdG8gdGhlIGNvbGxlY3Rpb24uJyk7XG4gICAgICAgIH1cblxuICAgICAgICBzZWxmLl9keElzUmVhZHkgPSBmYWxzZTtcbiAgICAgICAgc2VsZi5fZHhJc0Vycm9yZWQgPSBmYWxzZTtcbiAgICAgICAgLy8gS2VlcCB0cmFjayBvZiBsYXRlc3Qgb3V0c3RhbmRpbmcgcmVxdWVzdC4gV2Ugb25seSBob25vciBhIHJlc3BvbnNlIGlmIGl0IGNhbWUgZnJvbSB0aGUgbGF0ZXN0IGlzc3VlZCByZXF1ZXN0LlxuICAgICAgICBzZWxmLl9sYXRlc3RMaXN0VG9rZW4rKztcbiAgICAgICAgdmFyIGN1cnJMaXN0VG9rZW4gPSBzZWxmLl9sYXRlc3RMaXN0VG9rZW47XG5cbiAgICAgICAgc2VsZi5zeW5jKCdyZWFkJywgc2VsZiwge1xuICAgICAgICAgICAgcGFyc2U6IHRydWUsXG4gICAgICAgICAgICBkYXRhOiBzZW5kYWJsZVBhcmFtcyxcbiAgICAgICAgICAgIHN1Y2Nlc3M6IGZ1bmN0aW9uKHJlc3ApIHtcbiAgICAgICAgICAgICAgICBpZiAoc2VsZi5fbGF0ZXN0TGlzdFRva2VuICE9PSBjdXJyTGlzdFRva2VuKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjsgLy8gQW5vdGhlciBsaXN0IHJlcXVlc3QgaGFzIGJlZW4gaXNzdWVkXG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKHJlc3AgJiYgcmVzcC50eXBlID09PSAnRXJyb3JSZXN1bHQnKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBwcm9jZXNzZWRSZXN1bHQgPSBjb250ZXh0Ll9uZXdDbGllbnRNb2RlbChyZXNwLnR5cGUpO1xuICAgICAgICAgICAgICAgICAgICBwcm9jZXNzZWRSZXN1bHQuc2V0KHJlc3ApO1xuICAgICAgICAgICAgICAgICAgICBpZiAoc3VjY2Vzc0Vycm9yICYmIHN1Y2Nlc3NFcnJvci5lcnJvcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgc3VjY2Vzc0Vycm9yLmVycm9yKHByb2Nlc3NlZFJlc3VsdCk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb250ZXh0LnJlcG9ydEVycm9yUmVzdWx0KHByb2Nlc3NlZFJlc3VsdCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgc2VsZi50cmlnZ2VyKCdlcnJvcicsIHNlbGYpO1xuICAgICAgICAgICAgICAgICAgICBzZWxmLl9keElzRXJyb3JlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB2YXIgcmVzZXR0aW5nID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgc2VsZi5fcXVlcnlQYXJhbWV0ZXJzID0gZHhVdGlsLmRlZXBDbG9uZShwYXJhbWV0ZXJzKTtcbiAgICAgICAgICAgICAgICBzZWxmLl9saXN0U3VjY2Vzc0Vycm9yID0gc3VjY2Vzc0Vycm9yOyAvLyBzYXZlIGZvciBhdXRvLXJlbGlzdGluZ1xuICAgICAgICAgICAgICAgIHNlbGYuX2R4SXNSZWFkeSA9IHRydWU7XG4gICAgICAgICAgICAgICAgc2VsZi5fbGlzdGluZ01vZGUgPSBMSVNUSU5HTU9ERV9MSVNUSU5HO1xuXG4gICAgICAgICAgICAgICAgcmVzcCA9IHNlbGYucGFyc2UocmVzcCk7XG5cbiAgICAgICAgICAgICAgICByZXNldHRpbmcgPSByZW1vdmVVbm5lZWRlZE1vZGVscyhzZWxmLCByZXNwKSB8fCBzZWxmLl9yZXNldE9uTGlzdDtcblxuICAgICAgICAgICAgICAgIC8qXG4gICAgICAgICAgICAgICAgICogQWRkIHRoZSBuZXcgbW9kZWxzLlxuICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgIF8uZWFjaChyZXNwLCBmdW5jdGlvbihhdHRyaWJ1dGVzKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBtb2RlbCA9IGNvbnRleHQuX2NhY2hlLmdldENhY2hlZE1vZGVsRnJvbVByb3BlcnRpZXMoYXR0cmlidXRlcywge3NpbGVudDogcmVzZXR0aW5nfSk7XG4gICAgICAgICAgICAgICAgICAgIGR4U2V0LmNhbGwoc2VsZiwgbW9kZWwsIHtzaWxlbnQ6IHJlc2V0dGluZywgX2R4QWxsb3dTZXRQYXNzdGhyb3VnaDogdHJ1ZX0pO1xuICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgc2VsZi5fbGlzdGluZ01vZGUgPSBMSVNUSU5HTU9ERV9JRExFO1xuXG4gICAgICAgICAgICAgICAgLy8gUmVwb3J0IGZpbmlzaGluZyBldmVudHNcbiAgICAgICAgICAgICAgICBpZiAocmVzZXR0aW5nKSB7XG4gICAgICAgICAgICAgICAgICAgIHNlbGYudHJpZ2dlcigncmVzZXQnLCBzZWxmKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBzZWxmLnRyaWdnZXIoJ3JlYWR5Jywgc2VsZik7XG5cbiAgICAgICAgICAgICAgICBpZiAoc3VjY2Vzc0Vycm9yICYmIHN1Y2Nlc3NFcnJvci5zdWNjZXNzKSB7XG4gICAgICAgICAgICAgICAgICAgIHN1Y2Nlc3NFcnJvci5zdWNjZXNzKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGVycm9yOiBmdW5jdGlvbih4aHIpIHtcbiAgICAgICAgICAgICAgICBpZiAoc2VsZi5fbGF0ZXN0TGlzdFRva2VuICE9PSBjdXJyTGlzdFRva2VuKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjsgLy8gQW5vdGhlciBsaXN0IHJlcXVlc3QgaGFzIGJlZW4gaXNzdWVkXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHZhciBlcnJvclJlc3VsdCA9IGNvbnRleHQuX2NvbnZlcnRYaHJUb0Vycm9yUmVzdWx0KHhocik7XG4gICAgICAgICAgICAgICAgY29udGV4dC5faGFuZGxlRXJyb3JSZXN1bHQoZXJyb3JSZXN1bHQsIHN1Y2Nlc3NFcnJvcik7XG4gICAgICAgICAgICAgICAgc2VsZi50cmlnZ2VyKCdlcnJvcicsIHNlbGYpO1xuICAgICAgICAgICAgICAgIHNlbGYuX2R4SXNFcnJvcmVkID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgLy8gUmV0dXJuIGEgcHJvbWlzZSB0aGF0IGlzIHJlc29sdmVkIG9uY2UgdGhlIG1vZGVsIGlzIHJlYWR5LCBhbmQgcmVqZWN0ZWQgaWYgdGhlIG1vZGVsIHJlcG9ydHMgYW4gZXJyb3JcbiAgICAgICAgdmFyIGRlZmVycmVkID0gbmV3ICQuRGVmZXJyZWQoKTtcbiAgICAgICAgdmFyIGxpc3RlbmVyQ29udGV4dCA9IHt9O1xuXG4gICAgICAgIHNlbGYub25jZSgncmVhZHknLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIGRlZmVycmVkLnJlc29sdmUoc2VsZik7XG4gICAgICAgICAgICBzZWxmLm9mZih1bmRlZmluZWQsIHVuZGVmaW5lZCwgbGlzdGVuZXJDb250ZXh0KTtcbiAgICAgICAgfSwgbGlzdGVuZXJDb250ZXh0KTtcblxuICAgICAgICAvLyBkb24ndCBzZXQgdXAgdGhlIGVycm9yIGhhbmRsZXIgaWYgcmVhZHkgd2FzIGFscmVhZHkgdHJpZ2dlcmVkXG4gICAgICAgIGlmIChkZWZlcnJlZC5zdGF0ZSgpID09PSAncGVuZGluZycpIHtcbiAgICAgICAgICAgIHNlbGYub25jZSgnZXJyb3InLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICBkZWZlcnJlZC5yZWplY3Qoc2VsZik7XG4gICAgICAgICAgICAgICAgc2VsZi5vZmYodW5kZWZpbmVkLCB1bmRlZmluZWQsIGxpc3RlbmVyQ29udGV4dCk7XG4gICAgICAgICAgICB9LCBsaXN0ZW5lckNvbnRleHQpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGRlZmVycmVkLnByb21pc2UoKTtcbiAgICB9XG5cbiAgICAvKlxuICAgICAqIFJldHJpZXZlIHRoZSBsYXN0IHNldCBvZiBxdWVyeSBwYXJhbWV0ZXJzIHBhc3NlZCB0byAkJGxpc3QoKS4gIFRoaXMgaXMgdXNlZnVsIGlmIHlvdSB3YW50IHRvIHNlZSB3aGF0IHRoaXNcbiAgICAgKiBjb2xsZWN0aW9uIGN1cnJlbnRseSBjb250YWlucy5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBnZXRRdWVyeVBhcmFtZXRlcnMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9xdWVyeVBhcmFtZXRlcnM7XG4gICAgfVxuXG4gICAgLypcbiAgICAgKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gICAgICogQ29sbGVjdGlvbiBjcmVhdGlvblxuICAgICAqID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAgICAgKi9cblxuICAgIC8qXG4gICAgICogUmV0dXJucyBhIG5ldyBEU0IgY29sbGVjdGlvbiB3aGljaCBpcyBzZXQgdG8gYmUgYSBzZXJ2ZXIgY29sbGVjdGlvbi5cbiAgICAgKlxuICAgICAqIHJlc2V0T25MaXN0OiBJZiB0cnVlLCAkJGxpc3QoKSdzIHdpbGwgb25seSB0cmlnZ2VyIGEgc2luZ2xlICdyZXNldCcgZXZlbnQgcmF0aGVyIHRoYW4gaW5kaXZpZHVhbCAnYWRkJyBhbmRcbiAgICAgKiAgICAgICAgICAgICAgJ3JlbW92ZScgZXZlbnRzLiBPdGhlcndpc2UgdGhpcyBoYXBwZW5zIG9ubHkgd2hlbiB0aGUgJCRsaXN0KCkgZnVsbHkgcmVwbGFjZXMgdGhlIGNvbnRlbnRzIG9mIHRoZVxuICAgICAqICAgICAgICAgICAgICBjb2xsZWN0aW9uLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIG5ld1NlcnZlckNvbGxlY3Rpb24odHlwZU5hbWUsIHJlc2V0T25MaXN0KSB7XG4gICAgICAgIGlmIChkeFV0aWwuaXNOb25lKHR5cGVOYW1lKSkge1xuICAgICAgICAgICAgZHhVdGlsLmZhaWwoJ1RvIGNyZWF0ZSBhIG5ldyBjb2xsZWN0aW9uLCBhIHR5cGUgbmFtZSBtdXN0IGJlIHByb3ZpZGVkLicpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFpc1NjaGVtYVR5cGUodHlwZU5hbWUpKSB7XG4gICAgICAgICAgICBkeFV0aWwuZmFpbCh0eXBlTmFtZSArICcgaXMgbm90IGEga25vd24gdHlwZSB3aXRoIGEgbGlzdCBvcGVyYXRpb24uIENhbiBub3QgY3JlYXRlIHRoaXMgY29sbGVjdGlvbi4nKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBjb2xsZWN0aW9uID0gbmV3IGNvbnRleHQuX2NvbGxlY3Rpb25Db25zdHJ1Y3RvcnNbdHlwZU5hbWVdKCk7XG4gICAgICAgIGNvbGxlY3Rpb24uY29uc3RydWN0b3IgPSBCYWNrYm9uZS5Db2xsZWN0aW9uLmV4dGVuZCgpOyAvLyBtYWtlIGNsb25lKCkgcmV0dXJuIGFuIG9yZGluYXJ5IGJhY2tib25lIGNvbGxlY3Rpb24uXG4gICAgICAgIGNvbGxlY3Rpb24uX3Jlc2V0T25MaXN0ID0gISFyZXNldE9uTGlzdDtcblxuICAgICAgICByZXR1cm4gY29sbGVjdGlvbjtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBvcGVyYXRpb25Ob3RBbGxvd2VkKCkge1xuICAgICAgICBkeFV0aWwuZmFpbCgnQ2FuIG5vdCBjYWxsIHRoaXMgb3BlcmF0aW9uIG9uIGEgU2VydmVyIENvbGxlY3Rpb24uJyk7XG4gICAgfVxuXG4gICAgLypcbiAgICAgKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gICAgICogVXRpbGl0eSBmdW5jdGlvbnNcbiAgICAgKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gICAgICovXG5cbiAgICBmdW5jdGlvbiBpc1NjaGVtYVR5cGUodHlwZU5hbWUpIHtcbiAgICAgICAgcmV0dXJuICEhY29udGV4dC5fY29sbGVjdGlvbkNvbnN0cnVjdG9yc1t0eXBlTmFtZV07XG4gICAgfVxuXG4gICAgLypcbiAgICAgKiBSZXR1cm4gdHJ1ZSBpZiB0aGUgdHlwZSBpcyB0aGUgc2FtZSBhcyBiYXNlVHlwZSBvciBpcyBhIHN1YnR5cGUuXG4gICAgICovXG4gICAgZnVuY3Rpb24gaXNBQ29tcGF0aWJsZVR5cGUodHlwZSwgYmFzZVR5cGUpIHtcbiAgICAgICAgaWYgKCFjb250ZXh0Ll9tb2RlbENvbnN0cnVjdG9yc1t0eXBlXSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHR5cGVEZWYgPSBjb250ZXh0Ll9tb2RlbENvbnN0cnVjdG9yc1t0eXBlXS5wcm90b3R5cGUuX2R4U2NoZW1hO1xuICAgICAgICB3aGlsZSAodHlwZURlZikge1xuICAgICAgICAgICAgaWYgKHR5cGVEZWYubmFtZSA9PT0gYmFzZVR5cGUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHR5cGVEZWYgPSB0eXBlRGVmLnBhcmVudFNjaGVtYTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICAvKlxuICAgICAqIFRocm93cyBlcnJvciBpZiBtb2RlbCAoQmFja2JvbmUuTW9kZWwgb3IgYXR0cmlidXRlcykgaXMgbm90IGNvbXBhdGlibGUgd2l0aCB0aGUgc3BlY2lmaWVkIHR5cGUuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYXNzZXJ0TW9kZWxDb21wYXRpYmxlKGFNb2RlbCwgYmFzZVR5cGUpIHtcbiAgICAgICAgdmFyIHR5cGU7XG4gICAgICAgIGlmIChhTW9kZWwgaW5zdGFuY2VvZiBCYWNrYm9uZS5Nb2RlbCkge1xuICAgICAgICAgICAgdHlwZSA9IGFNb2RlbC5nZXQoJ3R5cGUnKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGR4VXRpbC5mYWlsKCdDYW4gbm90IGFkZCBhbiBhcmJpdHJhcnkgc2V0IG9mIGF0dHJpYnV0ZXMuIE11c3QgcGFzcyBhIEJhY2tib25lIE1vZGVsLicpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFpc0FDb21wYXRpYmxlVHlwZSh0eXBlLCBiYXNlVHlwZSkpIHtcbiAgICAgICAgICAgIGR4VXRpbC5mYWlsKCdDYW4gbm90IGFkZCBhIG1vZGVsIG9mIHR5cGUgJyArIHR5cGUgKyAnIHRvIGEgY29sbGVjdGlvbiB3aXRoIGEgYmFzZSB0eXBlIG9mICcgKyBiYXNlVHlwZSArXG4gICAgICAgICAgICAgICAgJy4nKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qXG4gICAgICogVmFsaWRhdGVzIHRoYXQgYWxsIG1vZGVscyBhcmUgY29tcGF0aWJsZSB3aXRoIHRoaXMgY29sbGVjdGlvbidzIHR5cGUuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYXNzZXJ0TW9kZWxzQ29tcGF0aWJsZShtb2RlbHMsIHJlZmVyZW5jZU1vZGVsKSB7XG4gICAgICAgIGlmIChkeFV0aWwuaXNOb25lKG1vZGVscykpIHtcbiAgICAgICAgICAgIGR4VXRpbC5mYWlsKCdDYW4gbm90IGNhbGwgd2l0aG91dCBhIG1vZGVsLicpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKF8uaXNBcnJheShtb2RlbHMpKSB7XG4gICAgICAgICAgICBfLmVhY2gobW9kZWxzLCBmdW5jdGlvbihtb2RlbCkge1xuICAgICAgICAgICAgICAgIGFzc2VydE1vZGVsQ29tcGF0aWJsZShtb2RlbCwgcmVmZXJlbmNlTW9kZWwuX2R4SW5mby5iYXNlVHlwZSk7XG4gICAgICAgICAgICB9LCB0aGlzKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGFzc2VydE1vZGVsQ29tcGF0aWJsZShtb2RlbHMsIHJlZmVyZW5jZU1vZGVsLl9keEluZm8uYmFzZVR5cGUpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLypcbiAgICAgKiBUcmlnZ2VyIGEgJ2RpcnR5JyBldmVudCwgYW5kIGlmIGFwcHJvcHJpYXRlLCBzZXQgdXAgYW5vdGhlciBjYWxsIHRvIGRvIGEgbmV3IGxpc3Qgb3BlcmF0aW9uLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHRyaWdnZXJEaXJ0eShjb2xsZWN0aW9uKSB7XG4gICAgICAgIGNvbGxlY3Rpb24udHJpZ2dlcignZGlydHknKTtcbiAgICAgICAgaWYgKGNvbGxlY3Rpb24uZ2V0QXV0b1BhZ2VSZWZyZXNoKCkpIHtcbiAgICAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgZHhMaXN0LmNhbGwoY29sbGVjdGlvbiwgY29sbGVjdGlvbi5nZXRRdWVyeVBhcmFtZXRlcnMoKSwgY29sbGVjdGlvbi5fbGlzdFN1Y2Nlc3NFcnJvcik7XG4gICAgICAgICAgICB9LCAwKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qXG4gICAgICogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICAgICAqIEFjdHVhbGx5IGRvIHRoZSB3b3JrIG9mIHRoaXMgZnVuY3Rpb25cbiAgICAgKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gICAgICovXG5cbiAgICBjb250ZXh0ID0gY29udGV4dCB8fCB0aGlzO1xuICAgIGNvbnRleHQuX2NvbGxlY3Rpb25Db25zdHJ1Y3RvcnMgPSBjb250ZXh0Ll9jb2xsZWN0aW9uQ29uc3RydWN0b3JzIHx8IHt9O1xuXG4gICAgXy5lYWNoKHNjaGVtYXMsIGZ1bmN0aW9uKHNjaGVtYSwgdHlwZU5hbWUpIHtcbiAgICAgICAgaWYgKHNjaGVtYS5saXN0KSB7XG4gICAgICAgICAgICAvLyBleGFtaW5lIHJldHVybiB2YWx1ZXMsIGluIGNhc2UgdGhlIHJldHVybiB0eXBlIGlzIG5vdCB0aGUgc2FtZSBhcyB0aGUgc2NoZW1hIHR5cGVcbiAgICAgICAgICAgIHZhciByZXRPYmogPSBzY2hlbWEubGlzdC5yZXR1cm47XG4gICAgICAgICAgICB2YXIgcmV0SXRlbXNPYmogPSByZXRPYmogPyByZXRPYmouaXRlbXMgOiB1bmRlZmluZWQ7XG4gICAgICAgICAgICB2YXIgY29sbGVjdGlvblR5cGUgPSByZXRJdGVtc09iaiAgPyByZXRJdGVtc09iai4kcmVmIDogKHJldE9iaiB8fCB7fSkuJHJlZjtcbiAgICAgICAgICAgIGNvbGxlY3Rpb25UeXBlID0gY29sbGVjdGlvblR5cGUgfHwgc2NoZW1hLm5hbWU7XG5cbiAgICAgICAgICAgIGNvbnRleHQuX2NvbGxlY3Rpb25Db25zdHJ1Y3RvcnNbdHlwZU5hbWVdID0gQmFja2JvbmUuQ29sbGVjdGlvbi5leHRlbmQoe1xuICAgICAgICAgICAgICAgIF9keEluZm86IHtcbiAgICAgICAgICAgICAgICAgICAgYmFzZVR5cGU6IGNvbGxlY3Rpb25UeXBlLFxuICAgICAgICAgICAgICAgICAgICBwYXJhbURlZnM6IHNjaGVtYS5saXN0XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBfZHhJc1JlYWR5OiBmYWxzZSxcbiAgICAgICAgICAgICAgICBfZHhJc0Vycm9yZWQ6IGZhbHNlLFxuICAgICAgICAgICAgICAgIF9xdWVyeVBhcmFtZXRlcnM6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICAgICBfYXV0b1BhZ2VSZWZyZXNoOiBmYWxzZSxcbiAgICAgICAgICAgICAgICBfbGlzdFN1Y2Nlc3NFcnJvcjogdW5kZWZpbmVkLFxuICAgICAgICAgICAgICAgIF9saXN0aW5nTW9kZTogTElTVElOR01PREVfSURMRSxcbiAgICAgICAgICAgICAgICB1cmw6IHNjaGVtYS5yb290LFxuICAgICAgICAgICAgICAgIF9keEVtcHR5OiBkeEVtcHR5LFxuICAgICAgICAgICAgICAgIF9keFJlbW92ZU1vZGVsOiBCYWNrYm9uZS5Db2xsZWN0aW9uLnByb3RvdHlwZS5yZW1vdmUsXG4gICAgICAgICAgICAgICAgX2R4QWRkT3JSZW1vdmU6IGR4QWRkT3JSZW1vdmUsXG4gICAgICAgICAgICAgICAgbW9kZWw6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICBkeFV0aWwuZmFpbCgnQ2FuIG5vdCBjcmVhdGUgYSBuZXcgbW9kZWwgb24gYSBjb2xsZWN0aW9uLiBNdXN0IHVzZSB0aGUgY2FjaGUuJyk7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBvbjogZHhPbixcbiAgICAgICAgICAgICAgICBhZGQ6IG9wZXJhdGlvbk5vdEFsbG93ZWQsXG4gICAgICAgICAgICAgICAgcmVtb3ZlOiBvcGVyYXRpb25Ob3RBbGxvd2VkLFxuICAgICAgICAgICAgICAgIHNldDogZHhTZXQsXG4gICAgICAgICAgICAgICAgcmVzZXQ6IG9wZXJhdGlvbk5vdEFsbG93ZWQsXG4gICAgICAgICAgICAgICAgcHVzaDogb3BlcmF0aW9uTm90QWxsb3dlZCxcbiAgICAgICAgICAgICAgICBwb3A6IG9wZXJhdGlvbk5vdEFsbG93ZWQsXG4gICAgICAgICAgICAgICAgdW5zaGlmdDogb3BlcmF0aW9uTm90QWxsb3dlZCxcbiAgICAgICAgICAgICAgICBzaGlmdDogb3BlcmF0aW9uTm90QWxsb3dlZCxcbiAgICAgICAgICAgICAgICBwYXJzZTogZHhQYXJzZSxcbiAgICAgICAgICAgICAgICBmZXRjaDogZHhGZXRjaCxcbiAgICAgICAgICAgICAgICBjcmVhdGU6IGR4Q3JlYXRlLFxuICAgICAgICAgICAgICAgICQkbGlzdDogZHhMaXN0LFxuICAgICAgICAgICAgICAgIF9sYXRlc3RMaXN0VG9rZW46IDAsXG4gICAgICAgICAgICAgICAgX3Jlc2V0T25MaXN0OiBmYWxzZSxcbiAgICAgICAgICAgICAgICBjbGVhcjogZHhDbGVhcixcbiAgICAgICAgICAgICAgICBnZXRRdWVyeVBhcmFtZXRlcnM6IGdldFF1ZXJ5UGFyYW1ldGVycyxcbiAgICAgICAgICAgICAgICBzZXRBdXRvUGFnZVJlZnJlc2g6IHNldEF1dG9QYWdlUmVmcmVzaCxcbiAgICAgICAgICAgICAgICBnZXRBdXRvUGFnZVJlZnJlc2g6IGdldEF1dG9QYWdlUmVmcmVzaFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9KTtcblxuICAgIGNvbnRleHQuX25ld1NlcnZlckNvbGxlY3Rpb24gPSBuZXdTZXJ2ZXJDb2xsZWN0aW9uO1xufTtcbiIsIi8qXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTQsIDIwMTUgYnkgRGVscGhpeC4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqL1xuXG4vKiBnbG9iYWwgXyAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbmNvbnN0IGR4VXRpbCA9IHJlcXVpcmUoJ2R4Y29yZS9qcy91dGlsLmpzJyk7XG5cbi8qXG4gKiBDcmVhdGlvbiBsaXN0ZW5lcnMgcHJvdmlkZSBhY2Nlc3MgdG8gbm90aWZpY2F0aW9uIHVwZGF0ZXMgZm9yIEFQSSBzZXJ2ZXIgb2JqZWN0cyBjcmVhdGlvbiBpbiB0aGUgZm9ybVxuICogb2YgbGV2ZWwyIG1vZGVscy5cbiAqXG4gKiAgIHR5cGVOYW1lICAgICAgICAgVGhlIHNjaGVtYSB0eXBlIGZvciB3aGljaCBvbmUgcmVjZWl2ZXMgbm90aWZpY2F0aW9ucy5cbiAqXG4gKiAgIGNhbGxiYWNrICAgICAgICAgQSBmdW5jdGlvbiB0byBiZSBpbnZva2VkIHdpdGggYSBsZXZlbDIgbW9kZWwgYXMgYXJndW1lbnQgZm9yIGVhY2ggY3JlYXRlIG5vdGlmaWNhdGlvbi5cbiAqXG4gKiAgIHF1ZXJ5UGFyYW1zICAgICAgT3B0aW9uYWwgcXVlcnkgcGFyYW1ldGVycyB1c2VkIHRvIGZpbHRlciBub3RpZmljYXRpb25zLlxuICpcbiAqICAgY29udGV4dCAgICAgICAgICBUaGUgY29udGV4dCB0byBhY2Nlc3Mgb3RoZXIgZHhEYXRhIGNvbnRlbnQgKGNhY2hlLCBmaWx0ZXJzKS5cbiAqL1xubW9kdWxlLmV4cG9ydHMuQ3JlYXRpb25MaXN0ZW5lciA9IGZ1bmN0aW9uIENyZWF0aW9uTGlzdGVuZXIoc2V0dGluZ3MpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgICBpZiAoZHhVdGlsLmlzTm9uZShzZXR0aW5ncy50eXBlTmFtZSkpIHtcbiAgICAgICAgZHhVdGlsLmZhaWwoJ1RvIGNyZWF0ZSBhIG5ldyBjcmVhdGlvbiBsaXN0ZW5lciwgYSB0eXBlIG5hbWUgbXVzdCBiZSBwcm92aWRlZC4nKTtcbiAgICB9XG4gICAgdmFyIHR5cGVOYW1lID0gc2V0dGluZ3MudHlwZU5hbWU7XG4gICAgdmFyIGNvbnRleHQgPSBzZXR0aW5ncy5jb250ZXh0O1xuICAgIGlmICghaXNMaXN0YWJsZVR5cGUodHlwZU5hbWUsIGNvbnRleHQpKSB7XG4gICAgICAgIGR4VXRpbC5mYWlsKHR5cGVOYW1lICsgJyBpcyBub3QgYSBrbm93biB0eXBlIHdpdGggYSBsaXN0IG9wZXJhdGlvbi4gQ2FuIG5vdCBjcmVhdGUgdGhpcyBjcmVhdGlvbiBsaXN0ZW5lci4nKTtcbiAgICB9XG4gICAgaWYgKCFfLmlzRnVuY3Rpb24oc2V0dGluZ3MuY2FsbGJhY2spKSB7XG4gICAgICAgIGR4VXRpbC5mYWlsKCdDYWxsYmFjayBtdXN0IGJlIHByb3ZpZGVkIGFzIGEgZnVuY3Rpb24uJyk7XG4gICAgfVxuXG4gICAgc2VsZi5fZHhJbmZvID0ge1xuICAgICAgICBiYXNlVHlwZTogc2V0dGluZ3MudHlwZU5hbWVcbiAgICB9O1xuXG4gICAgc2VsZi5pblVzZSA9IHRydWU7XG5cbiAgICBzZWxmLmdldFF1ZXJ5UGFyYW1ldGVycyA9IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gc2V0dGluZ3MucXVlcnlQYXJhbXM7XG4gICAgfTtcblxuICAgIC8vIFRoZSBmb3JtYXQgbXVzdCByZW1haW4gY29tcGF0aWJsZSB3aXRoIGxldmVsMi1jb2xsZWN0aW9ucyBhbmQgbGV2ZWwyLWNhY2hlLlxuICAgIHNlbGYuX2R4QWRkT3JSZW1vdmUgPSBmdW5jdGlvbihtb2RlbCkge1xuICAgICAgICBpZiAoIXNlbGYuaW5Vc2UpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnRleHQuX2ZpbHRlcnNbdHlwZU5hbWVdKHNlbGYsIG1vZGVsLCBmdW5jdGlvbihwbGFjZW1lbnQpIHtcbiAgICAgICAgICAgIHN3aXRjaCAocGxhY2VtZW50KSB7XG4gICAgICAgICAgICAgICAgY2FzZSBjb250ZXh0Ll9maWx0ZXJzLklOQ0xVREU6XG4gICAgICAgICAgICAgICAgICAgIHNldHRpbmdzLmNhbGxiYWNrKG1vZGVsKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBjb250ZXh0Ll9maWx0ZXJzLkVYQ0xVREU6XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgY29udGV4dC5fZmlsdGVycy5VTktOT1dOOlxuICAgICAgICAgICAgICAgICAgICBkeFV0aWwuZmFpbCgnVU5LTk9XTiBmaWx0ZXIgcmVzdWx0IG5vdCBzdXBwb3J0ZWQgYnkgY3JlYXRpb24gbGlzdGVuZXJzJyk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrOyAgLy8gdG8ga2VlcCBhbnQgY2hlY2sgaGFwcHkuXG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgZHhVdGlsLmZhaWwoJ0ZpbHRlciByZXR1cm5lZCBhbiBpbnZhbGlkIHZhbHVlLicpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9O1xuXG4gICAgc2VsZi5kaXNwb3NlID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHNlbGYuaW5Vc2UgPSBmYWxzZTtcbiAgICB9O1xufTtcblxuZnVuY3Rpb24gaXNMaXN0YWJsZVR5cGUodHlwZU5hbWUsIGNvbnRleHQpIHtcbiAgICByZXR1cm4gISFjb250ZXh0Ll9jb2xsZWN0aW9uQ29uc3RydWN0b3JzW3R5cGVOYW1lXTtcbn1cbiIsIi8qXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTQsIDIwMTUgYnkgRGVscGhpeC4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqL1xuXG4vKiBnbG9iYWwgXywgJCwgQmFja2JvbmUgKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCBkeFV0aWwgPSByZXF1aXJlKCdkeGNvcmUvanMvdXRpbC5qcycpLFxuICAgIGR4Q29uc3RhbnRzID0gcmVxdWlyZSgnZHhjb3JlL2pzL2NvbnN0YW50cy5qcycpO1xuXG4vKlxuICogRGVmaW5lcyBnZW5lcmFsIHB1cnBvc2UgZmlsdGVyIHJvdXRpbmVzLiBUaGVzZSBjYW4gYmUgdXNlZCB0byBidWlsZCB0eXBlLXNwZWNpZmljIGZpbHRlcnMuXG4gKlxuICogQSBmaWx0ZXIgaXMgc2ltcGx5IGEgZnVuY3Rpb24gdGhhdCByZXByb2R1Y2VzIHRoZSBzZXJ2ZXIncyB0cmVhdG1lbnQgb2YgdGhlIHF1ZXJ5IHBhcmFtZXRlcnMgb24gdGhlIGxpc3Qgb3BlcmF0aW9uXG4gKiBmb3IgYW55IHR5cGUuICBFYWNoIGZpbHRlciBmdW5jdGlvbiBoYXMgdGhlIHNpZ25hdHVyZVxuICogICAgZmlsdGVyRnVuY3Rpb24oY29sbGVjdGlvbiwgbW9kZWwsIHJlc3VsdEhhbmRsZXIpXG4gKiBUaGUgZmlsdGVyIGZ1bmN0aW9uIHNob3VsZCBleGFtaW5lIHRoZSBxdWVyeSBwYXJhbWV0ZXJzIG9uIHRoZSBjb2xsZWN0aW9uLCB0aGVuIGV4YW1pbmUgdGhlIHByb3BlcnRpZXMgb2YgdGhlIG1vZGVsXG4gKiBhbmQgY2FsbCByZXN1bHRIYW5kbGVyIHdpdGggYSB2YWx1ZSBpbmRpY2F0aW5nIGhvdyB0aGUgbW9kZWwgc2hvdWxkIGJlIHBsYWNlZCB3aXRoIHJlc3BlY3QgdG8gdGhlIGNvbGxlY3Rpb246XG4gKiAgICBJTkNMVURFOiBUaGUgbW9kZWwgY2FuIGJlIHB1dCBpbiB0aGUgY29sbGVjdGlvblxuICogICAgRVhDTFVERTogVGhlIG1vZGVsIHNob3VsZCBub3QgYmUgcHV0IGluIHRoZSBjb2xsZWN0aW9uIChhbmQgcmVtb3ZlZCBpZiBpdCBpcyB0aGVyZSBhbHJlYWR5KVxuICogICAgVU5LTk9XTjogVGhlIGZpbHRlciBjYW4ndCBkZXRlcm1pbmUgd2hhdCB0byBkbyB3aXRoIHRoZSBtb2RlbC4gTW9zdCBsaWtlbHkgdGhlIGNvbGxlY3Rpb24gc2hvdWxkIGJlIHJlLWZldGNoZWRcbiAqIFRoZSBwb3RlbnRpYWxseSBhc3luY2hyb25vdXMgY2FsbCB0byByZXN1bHRIYW5kbGVyIGlzIG5lY2Vzc2FyeSBzaW5jZSBzb21lIHF1ZXJ5IHBhcmFtZXRlcnMgd2lsbCByZXF1aXJlIHJldHJpZXZhbFxuICogb2YgbW9kZWxzIHRvIG1ha2UgdGhlaXIgZGV0ZXJtaW5hdGlvbi5cbiAqL1xubW9kdWxlLmV4cG9ydHMuX2luaXRGaWx0ZXJzID0gZnVuY3Rpb24gX2luaXRGaWx0ZXJzKGNvbnRleHQpIHtcbiAgICB2YXIgRVhDTFVERSA9ICdFWENMVURFJztcbiAgICB2YXIgSU5DTFVERSA9ICdJTkNMVURFJztcbiAgICB2YXIgVU5LTk9XTiA9ICdVTktOT1dOJztcblxuICAgIHZhciBEQVRFX1BST1BTID0gWydmcm9tRGF0ZScsICdzdGFydERhdGUnLCAndG9EYXRlJywgJ2VuZERhdGUnXTtcblxuICAgIC8qXG4gICAgICogSGVscGVyIGZvciBub24tZ2VuZXJhdGVkIGZpbHRlcnMuIEluIG1hbnkgY2FzZXMsIHRoZSBwcm9wZXJ0eSBpbiB0aGUgcXVlcnkgcGFyYW1ldGVyIGlzIHRoZSBzYW1lIGFzIHRoYXQgb2YgdGhlXG4gICAgICogYXR0cmlidXRlIGluIHRoZSBtb2RlbC4gVGhpcyBtZWFucyB3ZSBjYW4gbWFrZSBhIGRlY2lzaW9uIHN5bmNocm9ub3VzbHksIHdoaWNoIGtlZXBzIHRoZSBsb2dpYyBpbiB0aGUgZmlsdGVyc1xuICAgICAqIHNpbXBsZXIgKGNvbXBhcmUgdG8gY2hlY2tRdWVyeVBhcmFtKCksIHdoaWNoIHJldHVybnMgYSBwcm9taXNlKS5cbiAgICAgKiBUaGlzIGNvbXBhcmVzIHRoZSB2YWx1ZSBpbiB0aGUgcXVlcnkgcGFyYW1ldGVyIHdpdGggdGhhdCBvZiB0aGUgbW9kZWwuXG4gICAgICpcbiAgICAgKiBwcm9wZXJ0aWVzOiBBbiBhcnJheSBvZiBwcm9wZXJ0eSBuYW1lcyB0byBjb21wYXJlXG4gICAgICogcVBhcmFtczogICAgVGhlIHF1ZXJ5IHBhcmFtZXRlcnMgdG8gY29tcGFyZVxuICAgICAqIG1vZGVsOiAgICAgIFRoZSBtb2RlbCB0byBjb21wYXJlXG4gICAgICovXG4gICAgZnVuY3Rpb24gY2hlY2tTYW1lUHJvcHMocHJvcGVydGllcywgcVBhcmFtcywgbW9kZWwpIHtcbiAgICAgICAgdmFyIHJlc3VsdCA9IElOQ0xVREU7XG5cbiAgICAgICAgXy5lYWNoKHByb3BlcnRpZXMsIGZ1bmN0aW9uKHByb3BlcnR5KSB7XG4gICAgICAgICAgICBpZiAoXy5oYXMocVBhcmFtcywgcHJvcGVydHkpICYmIHFQYXJhbXNbcHJvcGVydHldICE9PSBtb2RlbC5nZXQocHJvcGVydHkpKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gRVhDTFVERTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKlxuICAgICAqIFdoZW4gYSBtb2RlbCBpcyBiZWluZyBjb21wYXJlZCBhZ2FpbnN0IGEgY29sbGVjdGlvbiB0aGF0IGhhcyBiZWVuIHJldHJpZXZlZCB3aXRoIHBhZ2luZywgdGhlbiB3ZSBjYW4ndCByZWxpYWJseVxuICAgICAqIHRlbGwgd2hldGhlciB0aGUgbW9kZWwgYmVsb25ncyBpbiB0aGUgY29sbGVjdGlvbi4gTm90ZSB0aGF0IHRoaXMgYXNzdW1lcyBub3Qgc3BlY2lmeWluZyBhIHBhZ2Ugc2l6ZSBpbXBsaWNpdGx5XG4gICAgICogc2V0cyBpdCB0byBhIHBhcnRpY3VsYXIgc2l6ZSAoZ2VuZXJhbGx5IDI1KSwgd2hpbGUgc3BlY2lmeWluZyAwIG1lYW5zICdhbGwnXG4gICAgICovXG4gICAgZnVuY3Rpb24gY2hlY2tQYWdlU2l6ZShxUGFyYW1zKSB7XG4gICAgICAgIGlmICghXy5oYXMocVBhcmFtcywgJ3BhZ2VTaXplJykgfHwgcVBhcmFtcy5wYWdlU2l6ZSAhPT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIFVOS05PV047XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIElOQ0xVREU7XG4gICAgfVxuXG4gICAgLypcbiAgICAgKiBIZWxwZXIgZnVuY3Rpb24gdG8gY2hlY2sgZGF0ZS1yZWxhdGVkIHF1ZXJ5IHBhcmFtZXRlcnMuIFRoaXMgYXNzdW1lcyBxUGFyYW1OYW1lIGlzIGEgdmFsaWQgZGF0ZSBwcm9wZXJ0eS5cbiAgICAgKiBUaGUgY2FsbGVyIGlzIHJlc3BvbnNpYmxlIGZvciBtYWtpbmcgc3VyZSB0aGF0IHFQYXJhbU5hbWUgaXMgb25lIG9mIERBVEVfUFJPUFNcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjaGVja0RhdGVQcm9wKHFQYXJhbVZhbCwgcVBhcmFtTmFtZSwgcXBTY2hlbWEsIG1vZGVsLCBhdHRyTmFtZSkge1xuICAgICAgICBpZiAoIV8uaGFzKHFwU2NoZW1hLCAnaW5lcXVhbGl0eVR5cGUnKSkge1xuICAgICAgICAgICAgZHhVdGlsLmZhaWwoJ0RhdGUgcHJvcGVydHkgXCInICsgcVBhcmFtTmFtZSArICdcIiBtaXNzaW5nIFwiaW5lcXVhbGl0eVR5cGVcIiBzY2hlbWEgcHJvcGVydHknKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZHhVdGlsLmlzTm9uZShtb2RlbC5nZXQoYXR0ck5hbWUpKSkge1xuICAgICAgICAgICAgcmV0dXJuIEVYQ0xVREU7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoXy5jb250YWlucyhbJ2Zyb21EYXRlJywgJ3N0YXJ0RGF0ZSddLCBxUGFyYW1OYW1lKSkge1xuICAgICAgICAgICAgaWYgKG1vZGVsLmdldChhdHRyTmFtZSkuZ2V0VGltZSgpIDwgcVBhcmFtVmFsLmdldFRpbWUoKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBFWENMVURFO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKG1vZGVsLmdldChhdHRyTmFtZSkuZ2V0VGltZSgpID4gcVBhcmFtVmFsLmdldFRpbWUoKSkgeyAvLyB0b0RhdGUgb3IgZW5kRGF0ZVxuICAgICAgICAgICAgcmV0dXJuIEVYQ0xVREU7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAocXBTY2hlbWEuaW5lcXVhbGl0eVR5cGUgPT09IGR4Q29uc3RhbnRzLklORVFVQUxJVFlfVFlQRVMuU1RSSUNUICYmXG4gICAgICAgICAgICAgICAgbW9kZWwuZ2V0KGF0dHJOYW1lKS5nZXRUaW1lKCkgPT09IHFQYXJhbVZhbC5nZXRUaW1lKCkpIHtcbiAgICAgICAgICAgIHJldHVybiBFWENMVURFO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIElOQ0xVREU7XG4gICAgfVxuXG4gICAgLypcbiAgICAgKiBIZWxwZXIgZm9yIHRoZSB1YmVyRmlsdGVyIHRvIGNoZWNrIGFuIGluZGl2aWR1YWwgcXVlcnkgcGFyYW1ldGVyIGFnYWluc3QgdGhlIG1vZGVsLiBUaGlzIG1heSBpbnZvbHZlXG4gICAgICogYXN5bmNocm9ub3VzIFNlcnZlck1vZGVsIGZldGNoZXMgdG8gcmVzb2x2ZSAnbWFwc1RvJyBkYXRhIG1hcHBpbmcgY2hhaW5zLiBBcyBhIHJlc3VsdCB0aGlzIHJldHVybnMgYSBwcm9taXNlIHRvXG4gICAgICogdGhlIGNhbGxlci4gQXQgdGhlIG1vbWVudCB0aGlzIG9ubHkgZGVhbHMgd2l0aCBxdWVyeSBwYXJhbXMgdGhhdCBtYXkgcmVzdWx0IGluIElOQ0xVREUgb3IgRVhDTFVERSAtIG5ldmVyXG4gICAgICogVU5LTk9XTi5cbiAgICAgKiBUaGUgcmV0dXJuZWQgcHJvbWlzZSBpcyBlaXRoZXIgcmVzb2x2ZWQgd2l0aCBJTkNMVURFIG9yIHJlamVjdGVkIHdpdGggRVhDTFVERS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjaGVja1F1ZXJ5UGFyYW0ocVBhcmFtVmFsLCBxUGFyYW1OYW1lLCBtb2RlbCwgcm9vdFNjaGVtYURlZikge1xuICAgICAgICB2YXIgcXBTY2hlbWEgPSByb290U2NoZW1hRGVmLmxpc3QucGFyYW1ldGVyc1txUGFyYW1OYW1lXSxcbiAgICAgICAgICAgIGRlZmVycmVkID0gJC5EZWZlcnJlZCgpLFxuICAgICAgICAgICAgbWFwc1RvID0gcXBTY2hlbWEubWFwc1RvO1xuXG4gICAgICAgIGlmICghbWFwc1RvKSB7XG4gICAgICAgICAgICBkeFV0aWwuZmFpbCgnTm8gbWFwc1RvIHByb3BlcnR5IGZvdW5kIGZvciBxdWVyeSBwYXJhbWV0ZXIgJyArIHFQYXJhbU5hbWUgKyAnLicpO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHBhdGhTZWdzID0gbWFwc1RvLnNwbGl0KCcuJyk7XG5cbiAgICAgICAgLy8gV2Uga25vdyB0aGUgbGFzdCBzZWcgd2lsbCBiZSBwcm9wZXJ0eSB0byBjb21wYXJlLiBBbnl0aGluZyBiZWZvcmUgd2lsbCBiZSBhIGNoYWluIG9mIG9iamVjdCByZWZlcmVuY2VzLlxuICAgICAgICB2YXIgZmluYWxBdHRyTmFtZSA9IHBhdGhTZWdzLnBvcCgpO1xuXG4gICAgICAgIC8vIFJlY3Vyc2l2ZWx5IHdhbGsgdGhlIGRhdGEgbWFwcGluZyBzZWdtZW50c1xuICAgICAgICBmdW5jdGlvbiBmb2xsb3dOZXh0U2VnKGN1cnJNb2RlbCkge1xuICAgICAgICAgICAgY3Vyck1vZGVsLm9uY2UoJ2Vycm9yJywgZGVmZXJyZWQucmVqZWN0KTtcbiAgICAgICAgICAgIGN1cnJNb2RlbC5vbmNlKCdyZWFkeScsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIGlmIChfLmlzRW1wdHkocGF0aFNlZ3MpKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFdlJ3ZlIHJlYWNoZWQgdGhlIGVuZCBvZiB0aGUgcGF0aC4gRG8gdGhlIGFjdHVhbCBjaGVjay5cbiAgICAgICAgICAgICAgICAgICAgdmFyIHJlc3VsdDtcblxuICAgICAgICAgICAgICAgICAgICBpZiAoXy5jb250YWlucyhEQVRFX1BST1BTLCBxUGFyYW1OYW1lKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gY2hlY2tEYXRlUHJvcChxUGFyYW1WYWwsIHFQYXJhbU5hbWUsIHFwU2NoZW1hLCBjdXJyTW9kZWwsIGZpbmFsQXR0ck5hbWUpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgeyAvLyBzaW1wbGUgcHJvcGVydHkgY2hlY2tcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IGN1cnJNb2RlbC5nZXQoZmluYWxBdHRyTmFtZSkgPT09IHFQYXJhbVZhbCA/IElOQ0xVREUgOiBFWENMVURFO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKHJlc3VsdCA9PT0gSU5DTFVERSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZGVmZXJyZWQucmVzb2x2ZShyZXN1bHQpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgZGVmZXJyZWQucmVqZWN0KHJlc3VsdCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAvLyByZWN1cnNpdmUgY2FzZSAtIGNvbnRpbnVlIGZvbGxvd2luZyBwYXRoIHNlZ21lbnRzLlxuICAgICAgICAgICAgICAgICAgICB2YXIgY3VyclBhcnQgPSAnJCcgKyBwYXRoU2Vncy5zaGlmdCgpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgbmV3TW9kZWwgPSBjdXJyTW9kZWwuZ2V0KGN1cnJQYXJ0KTtcbiAgICAgICAgICAgICAgICAgICAgZm9sbG93TmV4dFNlZyhuZXdNb2RlbCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICBmb2xsb3dOZXh0U2VnKG1vZGVsKTtcblxuICAgICAgICByZXR1cm4gZGVmZXJyZWQucHJvbWlzZSgpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGdldFJvb3RlZFNjaGVtYShtb2RlbCkge1xuICAgICAgICBmdW5jdGlvbiB1cHdhcmRGaW5kKHNjaGVtYSwgc2NoZW1hTmFtZSkge1xuICAgICAgICAgICAgaWYgKGR4VXRpbC5pc05vbmUoc2NoZW1hKSkge1xuICAgICAgICAgICAgICAgIGR4VXRpbC5mYWlsKCdNYWxmb3JtZWQgdHlwZS4gUm9vdCBzY2hlbWEgdHlwZSBub3QgZm91bmQuJyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChzY2hlbWEubmFtZSA9PT0gc2NoZW1hTmFtZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBzY2hlbWE7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiB1cHdhcmRGaW5kKHNjaGVtYS5wYXJlbnRTY2hlbWEsIHNjaGVtYU5hbWUpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFtb2RlbC5fZHhTY2hlbWEucm9vdFR5cGVOYW1lKSB7XG4gICAgICAgICAgICBkeFV0aWwuZmFpbCgnVHJ5aW5nIHRvIGZpbHRlciBhIHR5cGUgdGhhdCBoYXMgbm8gcm9vdCB0eXBlLicpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHVwd2FyZEZpbmQobW9kZWwuX2R4U2NoZW1hLCBtb2RlbC5fZHhTY2hlbWEucm9vdFR5cGVOYW1lKTtcbiAgICB9XG5cbiAgICAvKlxuICAgICAqIFRoaXMgaXMgdGhlIGZpbHRlciB0byBydWxlIGFsbCBmaWx0ZXJzLiBJdCB3aWxsIGZpbHRlciBtb2RlbHMgZm9yIGEgZ2l2ZW4gY29sbGVjdGlvbiBiYXNlZCBvbiB0aGUgc2NoZW1hXG4gICAgICogZGVmaW5pdGlvbiBhbmQgYW5ub3RhdGlvbnMuIFRoaXMgbWF5IGJlIHVzZWQgYXMgYSBzdGFuZGFsb25lIGZpbHRlciBvciBhcyBhIGhlbHBlciBmb3IgYW5vdGhlciBmaWx0ZXIsIHVzdWFsbHlcbiAgICAgKiBpbiBjb25qdW5jdGlvbiB3aXRoIHRoZSAnc2tpcFBhcmFtcycgYXJndW1lbnQgKHNlZSBhbGVydEZpbHRlcikuXG4gICAgICogVGhlIHViZXJGaWx0ZXIgY2FuIG9ubHkgaGFuZGxlICdzdGFuZGFyZCcgcXVlcnkgcGFyYW1ldGVyczogc2ltcGxlIGVxdWFsaXR5IGNoZWNrcywgZGF0ZSBjb21wYXJpc29ucywgYW5kXG4gICAgICogcGFnaW5nLiBTaW1pbGFybHkgdGhlcmUgYXJlIGluc3RhbmNlcyBvZiBxdWVyeSBwYXJhbWV0ZXJzIHRoYXQgdGhlIHViZXJGaWx0ZXIgc2hvdWxkIG5vdCBhdHRlbXB0IHRvIGhhbmRsZS5cbiAgICAgKiBUaGVzZSBjb21lIGluIHR3byBmbGF2b3JzOlxuICAgICAqIDEpIFBhcmFtcyB0aGF0IGRvIG5vdCBhZmZlY3Qgd2hhdCBjb21lcyBiYWNrIGZyb20gdGhlIG5vdGlmaWNhdGlvbiBzeXN0ZW0gYXJlIG1hcmtlZCBhcyAnZXhjbHVkZUZyb21GaWx0ZXInIGluXG4gICAgICogICAgdGhlIHNjaGVtYXMuXG4gICAgICogMikgUGFyYW1zIHRoYXQgcmVxdWlyZSBzcGVjaWFsIGhhbmRsaW5nIGNhbiBiZSBwYXNzZWQgdG8gdGhlIHViZXJGaWx0ZXIgdXNpbmcgdGhlICdza2lwUGFyYW1zJyBhcnJheS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiB1YmVyRmlsdGVyKGNvbGxlY3Rpb24sIG1vZGVsLCByZXN1bHRIYW5kbGVyLCBza2lwUGFyYW1zKSB7XG4gICAgICAgIHZhciBxUGFyYW1zID0gY29sbGVjdGlvbi5nZXRRdWVyeVBhcmFtZXRlcnMoKSB8fCB7fTtcbiAgICAgICAgdmFyIHNjaGVtYURlZiA9IGdldFJvb3RlZFNjaGVtYShtb2RlbCk7XG4gICAgICAgIHZhciBsaXN0UGFyYW1zID0gc2NoZW1hRGVmLmxpc3QucGFyYW1ldGVycztcblxuICAgICAgICAvLyBJZiB0aGUgc2NoZW1hIGRlZmluaXRpb24gZm9yIGxpc3Qgc2F5cyB0aGVyZSBhcmUgbm8gcGFyYW1ldGVycywgdGhlbiB0aGUgbW9kZWwgY2FuIGFsd2F5cyBiZSBpbmNsdWRlZFxuICAgICAgICBpZiAoXy5pc0VtcHR5KHNjaGVtYURlZi5saXN0LnBhcmFtZXRlcnMpKSB7XG4gICAgICAgICAgICByZXN1bHRIYW5kbGVyKElOQ0xVREUpO1xuICAgICAgICB9XG5cbiAgICAgICAgcVBhcmFtcyA9IF8ub21pdChxUGFyYW1zLCBza2lwUGFyYW1zKTtcblxuICAgICAgICAvKlxuICAgICAgICAgKiBJZiBhIHR5cGUgY291bGQgaGF2ZSBwYWdlU2l6ZSwgd2UgbWF5IG5lZWQgdG8gcmV0dXJuIFVOS05PV04uIE90aGVyd2lzZSB3ZSBjYW4ga2VlcCBnb2luZyBpbiB0aGUgZmlsdGVyLlxuICAgICAgICAgKiBOb3RlIHRoYXQgd2UgZG9uJ3QgY2FyZSBhYm91dCBwYWdpbmcgcGFyYW1zIHdoZW4gZGVhbGluZyB3aXRoIGNyZWF0aW9uIGxpc3RlbmVycy5cbiAgICAgICAgICovXG4gICAgICAgIGlmIChfLmhhcyhsaXN0UGFyYW1zLCAncGFnZVNpemUnKSAmJiBjb2xsZWN0aW9uIGluc3RhbmNlb2YgQmFja2JvbmUuQ29sbGVjdGlvbikge1xuICAgICAgICAgICAgdmFyIHBhZ2VTaXplUmVzdWx0ID0gY2hlY2tQYWdlU2l6ZShxUGFyYW1zKTtcbiAgICAgICAgICAgIGlmIChwYWdlU2l6ZVJlc3VsdCA9PT0gVU5LTk9XTikge1xuICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHRIYW5kbGVyKHBhZ2VTaXplUmVzdWx0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBxUGFyYW1zID0gXy5vbWl0KHFQYXJhbXMsIFsncGFnZVNpemUnLCAncGFnZU9mZnNldCddKTtcblxuICAgICAgICBpZiAoXy5pc0VtcHR5KHFQYXJhbXMpKSB7XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0SGFuZGxlcihJTkNMVURFKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgcHJvbWlzZXMgPSBfLm1hcChxUGFyYW1zLCBmdW5jdGlvbihxUGFyYW1WYWwsIHFQYXJhbU5hbWUpIHtcbiAgICAgICAgICAgIHJldHVybiBjaGVja1F1ZXJ5UGFyYW0ocVBhcmFtVmFsLCBxUGFyYW1OYW1lLCBtb2RlbCwgc2NoZW1hRGVmKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgLypcbiAgICAgICAgICogV2FpdCB1bnRpbCBhbGwgcXVlcnkgcGFyYW0gY2hlY2tzIGhhdmUgcmVzb2x2ZWQgdG8gbWFrZSBhIGZpbmFsIGRlY2lzaW9uLiBQYXJhbXMgdGhhdCBtaWdodCByZXN1bHQgaW5cbiAgICAgICAgICogVU5LTk9XTiAocGFnaW5nIGFuZCBwYXJhbXMgd2UgY2FuJ3QgaGFuZGxlKSBhcmUgZGVhbHQgd2l0aCBlYXJsaWVyLiBUaGVyZWZvcmUgd2Uga25vdyBlYWNoIG9mIHRoZXNlIHByb21pc2VzXG4gICAgICAgICAqIGlzIGVpdGhlciByZXNvbHZlZCB3aXRoIElOQ0xVREUgb3IgcmVqZWN0ZWQgd2l0aCBFWENMVURFLlxuICAgICAgICAgKi9cbiAgICAgICAgJC53aGVuLmFwcGx5KHVuZGVmaW5lZCwgcHJvbWlzZXMpXG4gICAgICAgICAgICAudGhlbihmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICByZXN1bHRIYW5kbGVyKElOQ0xVREUpO1xuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIC5mYWlsKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHJlc3VsdEhhbmRsZXIoRVhDTFVERSk7XG4gICAgICAgICAgICB9KTtcbiAgICB9XG5cbiAgICAvKlxuICAgICAqIFNpbXBsZSBmaWx0ZXIgZm9yIGFueSB0eXBlIHRoYXQgZG9lc24ndCBhY3R1YWxseSBoYXZlIHF1ZXJ5IHBhcmFtZXRlcnMgb24gaXRzIGxpc3Qgb3BlcmF0aW9uIChlLmcuIEdyb3VwKS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBnZW5lcmljRmlsdGVyKGNvbGxlY3Rpb24sIG1vZGVsLCByZXN1bHRIYW5kbGVyKSB7XG4gICAgICAgIHJlc3VsdEhhbmRsZXIoSU5DTFVERSk7XG4gICAgfVxuXG4gICAgLypcbiAgICAgKiBEbyB0aGUgcmVhbCB3b3JrLlxuICAgICAqL1xuICAgIGNvbnRleHQgPSBjb250ZXh0IHx8IHRoaXM7XG4gICAgY29udGV4dC5fZmlsdGVycyA9IGNvbnRleHQuX2ZpbHRlcnMgfHwge307XG5cbiAgICBfLmV4dGVuZChjb250ZXh0Ll9maWx0ZXJzLCB7XG4gICAgICAgIEVYQ0xVREU6IEVYQ0xVREUsXG4gICAgICAgIElOQ0xVREU6IElOQ0xVREUsXG4gICAgICAgIFVOS05PV046IFVOS05PV04sXG4gICAgICAgIE5vdGlmaWNhdGlvbjogdWJlckZpbHRlcixcbiAgICAgICAgX2NoZWNrU2FtZVByb3BzOiBjaGVja1NhbWVQcm9wcyxcbiAgICAgICAgX2dlbmVyaWNGaWx0ZXI6IGdlbmVyaWNGaWx0ZXIsXG4gICAgICAgIF91YmVyRmlsdGVyOiB1YmVyRmlsdGVyXG4gICAgfSk7XG59O1xuIiwiLypcbiAqIENvcHlyaWdodCAoYykgMjAxMywgMjAxNSBieSBEZWxwaGl4LiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICovXG5cbi8qIGdsb2JhbCAkLCBfLCBCYWNrYm9uZSAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbmNvbnN0IGR4VXRpbCA9IHJlcXVpcmUoJ2R4Y29yZS9qcy91dGlsLmpzJyksXG4gICAgZHhBamF4ID0gcmVxdWlyZSgnZHhjb3JlL2pzL2FqYXguanMnKTtcblxuLypcbiAqIFRoaXMgdGFrZXMgYSBzZXQgb2Ygc2NoZW1hcyAobW9kaWZpZWQgYnkgX3ByZXBhcmVTY2hlbWFzKSwgYW5kIGNyZWF0ZXMgYSBzZXQgb2YgQmFja2JvbmUgTW9kZWwgY29uc3RydWN0b3IgZnVuY3Rpb25zXG4gKiAoYW5kLCBieSBpbXBsaWNhdGlvbiwgZnVuY3Rpb25hbGl0eSB1cG9uIHRoZSBtb2RlbHMpLiBUaGlzIGFsc28gY3JlYXRlcyBhIHNldCBvZiAncm9vdCBvcGVyYXRpb24nIGZ1bmN0aW9ucy5cbiAqIFRoZSBjb25zdHJ1Y3RvciBmdW5jdGlvbnMgd2lsbCBiZSB1c2VkIGJ5IHRoZSBsZXZlbCAzIEFQSSdzIHRvIHByb3ZpZGUgZmluYWwgY29sbGVjdGlvbnMgdG8gY29uc3VtZXJzIG9mIGR4Q29yZSBEYXRhLlxuICpcbiAqIENPTlNUUlVDVE9SIEZVTkNUSU9OU1xuICogVGhlIG1vZGVscyBjcmVhdGVkIGJ5IHRoZXNlIGNvbnN0cnVjdG9yIGZ1bmN0aW9ucyBwcm92aWRlIGFjY2VzcyB0byB0aGUgZGF0YSB0eXBlcyB0aGF0IHRoZSBEZWxwaGl4IFNlcnZlciB3b3JrcyB3aXRoXG4gKiBhbmQgaW1wbGljaXRseSBtYW5hZ2UgdGhlIG5ldHdvcmsgY29ubmVjdGlvbnMgdG8gdGhlIHNlcnZlciB0byBnZXQgdGhlaXIgZGF0YSBhbmQgcGVyZm9ybSBvcGVyYXRpb25zIG9uIHRoZW0uIFRoYXRcbiAqIGlzLCB3aGVuIHVzaW5nIHRoZSBtb2RlbHMgY3JlYXRlZCBieSB0aGVzZSBjb25zdHJ1Y3RvciBmdW5jdGlvbnMsIHRoZSBjYWxsZXIgY2FuIHdvcmsgd2l0aCB0aGUgZGF0YSBpbiB0aGUgc2VydmVyJ3NcbiAqIHRlcm1zLCBhbmQgY2FuIHJlbWFpbiBpbnN1bGF0ZWQgZnJvbSBtYW5hZ2luZyBuZXR3b3JrIGNvbW11bmljYXRpb24uXG4gKlxuICogVGVybWlub2xvZ3kgbm90ZXM6XG4gKiAgICAgQXR0cmlidXRlczogICAgICAgQmFja2JvbmUgY2FsbHMgdGhlIG5hbWUvdmFsdWUgcGFpcnMgb24gYSBNb2RlbCAnYXR0cmlidXRlcycuXG4gKiAgICAgQ2xpZW50IE1vZGVsOiAgICAgQSBtb2RlbCB3aGljaCBpcyBjcmVhdGVkIG9uIHRoZSBjbGllbnQsIGFuZCBnZW5lcmFsbHkgZG9lc24ndCByZWZsZWN0IGRhdGEgdGhhdCBleGlzdHMgb24gdGhlXG4gKiAgICAgICAgICAgICAgICAgICAgICAgc2VydmVyLiBNb3N0IGNvbW1vbmx5LCB0aGVzZSBhcmUgZWl0aGVyIHBhcmFtZXRlcnMgdG8gb3BlcmF0aW9ucyBvbiBTZXJ2ZXIgTW9kZWxzLCBvciByZXR1cm5cbiAqICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZXMgZnJvbSBvcGVyYXRpb25zLiBDbGllbnQgTW9kZWxzIGFyZSBub3QgbWFpbnRhaW5lZCBieSB0aGUgbm90aWZpY2F0aW9uIHN5c3RlbS5cbiAqICAgICBEU0IgTW9kZWw6ICAgICAgICBEZWxwaGl4LVNjaGVtYS1CYXNlZCBNb2RlbC4gIFRoZSBtb2RlbHMgcHJvZHVjZWQgYnkgdGhlIGNvbnN0cnVjdG9yIGZ1bmN0aW9ucyB0aGlzIGNyZWF0ZXMuXG4gKiAgICAgICAgICAgICAgICAgICAgICAgVGhlc2UgYXJlIEJhY2tib25lIG1vZGVscyB0aGF0IGFyZSBjb25zdHJhaW5lZCBhbmQgZW5oYW5jZWQgdG8gZml0IG91ciBEZWxwaGl4IFNjaGVtYVxuICogICAgICAgICAgICAgICAgICAgICAgIHJlcXVpcmVtZW50cy5cbiAqICAgICBFbWJlZGRlZCBNb2RlbDogICBBIG1vZGVsIHRoYXQgaXMgcGxhY2VkICd3aXRoaW4nIGFub3RoZXIgbW9kZWwgdmlhIGEgb2JqZWN0L3JlZmVyZW5jZVRvIHByb3BlcnR5IGluIHRoZSBzY2hlbWEuXG4gKiAgICAgUHJvcGVydGllczogICAgICAgVGhlIG5hbWUvdmFsdWUgcGFpcnMgb24gYW4gb3JkaW5hcnkgSmF2YXNjcmlwdC9KU09OL0pTT04tU2NoZW1hIG9iamVjdCBhcmUgY2FsbGVkICdwcm9wZXJ0aWVzJy5cbiAqICAgICBSZWZlcmVuY2VkIE1vZGVsOiBBIG1vZGVsIHRoYXQgaXMgcmVmZXJlbmNlZCB2aWEgYSBzdHJpbmcvb2JqZWN0UmVmZXJlbmNlIHByb3BlcnR5IGluIGFub3RoZXIuXG4gKiAgICAgU2VydmVyIE1vZGVsOiAgICAgQSBtb2RlbCB3aGljaCByZXByZXNlbnRzIGEgY29ycmVzcG9uZGluZyBvYmplY3Qgb24gdGhlIHNlcnZlci4gIFRoZXNlIG1vZGVscyBtYXkgbm90IGJlXG4gKiAgICAgICAgICAgICAgICAgICAgICAgbW9kaWZpZWQgZnJvbSBvdXRzaWRlIG9mIHRoZSBkeENvcmUgRGF0YSwgc2luY2UgdGhleSBhcmUgZ3VhcmFudGVlZCB0byByZW1haW4gYWNjdXJhdGUgYW5kIHVwXG4gKiAgICAgICAgICAgICAgICAgICAgICAgdG8gZGF0ZSB3aXRoIHRoZSBzZXJ2ZXIncyBvYmplY3RzIChhcyBsb25nIGFzIHRoZXkgYXJlIGxlZnQgaW5zaWRlIG9mIGEgY29sbGVjdGlvbilcbiAqXG4gKiBUaGlzIHJvdXRpbmUgKHdoaWNoIHNob3VsZCBvbmx5IGJlIGNhbGxlZCBmcm9tIHdpdGhpbiB0aGUgZGF0YSBzeXN0ZW0pIGNvbnN1bWVzIHRoZSBzY2hlbWFzIGFuZCBjcmVhdGVzIGEgc2V0IG9mXG4gKiBCYWNrYm9uZSBNb2RlbCBjb25zdHJ1Y3RvciBmdW5jdGlvbnMsIG9uZSBmb3IgZWFjaCB0eXBlIGluIHRoZSBzY2hlbWFzLlxuICpcbiAqIFRoZSBtb2RlbHMgY29uc3RydWN0ZWQgYnkgdGhlc2UgZnVuY3Rpb25zIGFyZSB2ZXJ5IHNpbWlsYXIgdG8gb3JkaW5hcnkgQmFja2JvbmUgTW9kZWxzLCBidXQgYWxzbyBoYXZlIGEgbnVtYmVyIG9mXG4gKiBzaWduaWZpY2FudCBkaWZmZXJlbmNlcy4gVGhlc2UgZGlmZmVyZW5jZXMgaW5jbHVkZSAqaW5jb21wYXRpYmxlKiBjaGFuZ2VzIHRvIHRoZSBiZWhhdmlvciBvZiBzb21lIEJhY2tib25lIE1vZGVsXG4gKiBmdW5jdGlvbnMsIGFzIHdlbGwgYXMgdGhlIGFkZGl0aW9uIG9mIG5ldyBvbmVzLlxuICpcbiAqIEVWRU5UU1xuICogcmVhZHk6ICAgICAgICBJZiB5b3Ugd2FudCB0byBrbm93IGlmIGEgbW9kZWwgaXMgcmVhZHkgdG8gYmUgdXNlZCAoaGFzIGFuIGluaXRpYWwgc2V0IG9mIGRhdGEgcmV0cmlldmVkIGZyb20gdGhlXG4gKiAgICAgICAgICAgICAgIHNlcnZlciksIHRoZW4gbWFrZSB1c2Ugb2YgdGhlICdyZWFkeScgZXZlbnQsIHdoaWNoIGlzIHVuaXF1ZSB0byBEU0IgbW9kZWxzLiBSZWFkeSBpbmRpY2F0ZXMgdGhhdCB0aGVcbiAqICAgICAgICAgICAgICAgbW9kZWwgaGFzIHJldHJpZXZlZCBhbiBpbml0aWFsIHNldCBvZiBkYXRhIGZyb20gdGhlIHNlcnZlci4gVW5saWtlIG9yZGluYXJ5IGV2ZW50cywgaWYgYSByZWFkeSBoYW5kbGVyXG4gKiAgICAgICAgICAgICAgIGlzIGFzc2lnbmVkIHRvIGEgbW9kZWwgdGhhdCBpcyBhbHJlYWR5IHJlYWR5LCB0aGF0IGhhbmRsZXIgKGFuZCBubyBvdGhlcnMpIHdpbGwgYmUgdHJpZ2dlcmVkXG4gKiAgICAgICAgICAgICAgIGltbWVkaWF0ZWx5LiBSZWFkeSBoYW5kbGVycyBhcmUgIGFsd2F5cyBwYXNzZWQgdGhlIG1vZGVsIGFzIHRoZSBmaXJzdCwgYW5kIG9ubHksIGFyZ3VtZW50LiBUaGUgaGFuZGxlclxuICogICAgICAgICAgICAgICBzaG91bGQgaGF2ZSB0aGUgc2lnbmF0dXJlIChtb2RlbClcbiAqIHN5bmM6ICAgICAgICAgVGhpcyBpcyB0cmlnZ2VyZWQgYWZ0ZXIgZmV0Y2hpbmcgdGhlIG1vZGVsIGZyb20gdGhlIHNlcnZlciBzdWNjZXNzZnVsbHkgYW5kIGFmdGVyIGFueSBwcm9wZXJ0aWVzIGhhdmVcbiAqICAgICAgICAgICAgICAgYmVlbiB1cGRhdGVkLlxuICogYmFkUmVmZXJlbmNlOiBUaGlzIGlzIHRyaWdnZXJlZCB3aGVuIGEgbW9kZWwgaXMgZmV0Y2hlZCwgYW5kIGEgNDA0IGlzIHJldHVybmVkLiBUaGUgaGFuZGxlciBzaG91bGQgaGF2ZSB0aGUgc2lnbmF0dXJlXG4gKiAgICAgICAgICAgICAgIChtb2RlbCwgZXJyb3JSZXN1bHQpXG4gKiBlcnJvcjogICAgICAgIFRoaXMgaXMgcmVwb3J0ZWQgd2hlbiBhbiBlcnJvciBpcyByZXR1cm5lZCBmcm9tIGEgZmV0Y2guIExpa2UgcmVhZHksIGl0IHdpbGwgYmUgYWxzbyBpbW1lZGlhdGVseVxuICogICAgICAgICAgICAgICB0cmlnZ2VyIGlmIHRoZSBvYmplY3QgaXMgaW4gYSBlcnJvciBzdGF0ZS4gVW5saWtlIHJlYWR5LCBhIG1vZGVsIG1heSBnbyBpbnRvIGFuZCBvdXQgb2YgYmVpbmcgaW5cbiAqICAgICAgICAgICAgICAgYW4gZXJyb3Igc3RhdGUsIGRlcGVuZGluZyBvbiB0aGUgcmVzdWx0cyBvZiB0aGUgbGFzdCB0aW1lIGl0IHdhcyBmZXRjaGVkLiBUaGUgaGFuZGxlciBzaG91bGQgaGF2ZSB0aGVcbiAqICAgICAgICAgICAgICAgc2lnbmF0dXJlIChtb2RlbCwgZXJyb3JSZXN1bHQpXG4gKiBOb3RlOiBUaGUgb3JkZXIgb2YgdGhlIHRyaWdnZXJpbmcgb2YgYmFkUmVmZXJlbmNlLCBlcnJvciBhbmQgdGhlIGNhbGxpbmcgb2YgdGhlIGVycm9yIGhhbmRsZXIgcGFzc2VkIHRvIGZldGNoIGFyZSBub3RcbiAqIGd1YXJhbnRlZWQuXG4gKlxuICogU3RhbmRhcmQgQmFja2JvbmUgcHJvcGVydGllcyAobm9uZSBvZiB0aGVzZSBzaG91bGQgYmUgY2hhbmdlZClcbiAqICAgICBpZCAgICAgICAgICAgICAgOiAtLSA6IFN0YW5kYXJkXG4gKiAgICAgaWRBdHRyaWJ1dGUgICAgIDogLS0gOiBTZXQgdG8gJ3JlZmVyZW5jZScsIGFzIHRoaXMgaXMgdGhlIHVuaXF1ZSBJRCBwcm9wZXJ0eSBuYW1lIGZvciBEZWxwaGl4IFNjaGVtYXMuXG4gKiAgICAgY2lkICAgICAgICAgICAgIDogLS0gOiBTdGFuZGFyZFxuICogICAgIGF0dHJpYnV0ZXMgICAgICA6IC0tIDogU3RhbmRhcmQsIGJ1dCBlc3NlbnRpYWxseSBwcml2YXRlLlxuICogICAgIGNoYW5nZWQgICAgICAgICA6IC0tIDogU3RhbmRhcmQsIGJ1dCBlc3NlbnRpYWxseSBwcml2YXRlLiBVc2UgaGFzQ2hhbmdlZCgpIGV0Yy5cbiAqICAgICBkZWZhdWx0cyAgICAgICAgOiAtLSA6IFRoaXMgaXMgbm90IHVzZWQgYnkgRFNCIE1vZGVsc1xuICogICAgIHZhbGlkYXRpb25FcnJvciA6IC0tIDogQXQgdGhpcyB0aW1lIG5vdCB1c2VkLlxuICogICAgIHVybFJvb3RcbiAqXG4gKiBTdGFuZGFyZCBCYWNrYm9uZSBmdW5jdGlvbnNcbiAqICAgICBVbmxlc3Mgb3RoZXJ3aXNlIG5vdGVkLCBhbGwgZnVuY3Rpb25zIGFjY2VwdCBvbmx5IGF0dHJpYnV0ZSBuYW1lcyBzcGVjaWZpZWQgaW4gdGhlIERlbHBoaXggc2NoZW1hICh0aGV5IHdpbGxcbiAqICAgICB0aHJvdyBhbiBlcnJvciBpZiBnaXZlbiBzb21ldGhpbmcgZWxzZSkuIElmIGFuIGF0dHJpYnV0ZSBpcyBvZiB0eXBlIHN0cmluZy9vYmplY3RSZWZlcmVuY2UsIHRoZW4gJyRhdHRyaWJ1dGUnIGNhblxuICogICAgIGJlIHVzZWQgdG8gcmV0cmlldmUgdGhlIHJlZmVyZW5jZWQgbW9kZWwuIEluIHRoZSBkZXNjcmlwdGlvbnMgYmVsb3csIGZ1bmN0aW9ucyBtYXJrZWQgYXMgUyBjYW4gYmUgY2FsbGVkIG9uXG4gKiAgICAgc2VydmVyIG1vZGVscywgd2hpbGUgdGhvc2UgbWFya2VkIGFzIEMgY2FuIGJlIGNhbGxlZCBvbiBjbGllbnQgbW9kZWxzLlxuICpcbiAqICAgICBnZXQgICAgICA6IFNDIDogU3RhbmRhcmQsIGFzIGFib3ZlLlxuICogICAgIHNldCAgICAgIDogIEMgOiBTdGFuZGFyZCwgYnV0IGFjY2VwdHMgdmFsdWVzIGZvciBlbWJlZGRlZCBtb2RlbHMuIERvZXMgbm90IGFjY2VwdCAnJGF0dHJpYnV0ZScgbmFtZXMuXG4gKiAgICAgZXNjYXBlICAgOiBTQyA6IFN0YW5kYXJkLCBhcyBhYm92ZS4gTm90ZSB0aGF0IEJhY2tib25lJ3MgZXNjYXBlIGRvZXNuJ3QgZGVhbCB3ZWxsIHdpdGggb2JqZWN0cyBvciBhcnJheXMuXG4gKiAgICAgaGFzICAgICAgOiBTQyA6IFN0YW5kYXJkLCBhcyBhYm92ZS5cbiAqICAgICB1bnNldCAgICA6ICBDIDogU3RhbmRhcmQsIGFzIGFib3ZlLiBTZXRzIGF0dHJpYnV0ZSB0byBkZWZhdWx0IHZhbHVlLiBFbWJlZGRlZCBtb2RlbHMgY2xlYXIoKSdlZC5cbiAqICAgICBjbGVhciAgICA6ICBDIDogU3RhbmRhcmQsIGFzIGFib3ZlLiBTZXRzIGF0dHJpYnV0ZXMgdG8gZGVmYXVsdCB2YWx1ZS4gRW1iZWRkZWQgbW9kZWxzIGNsZWFyKCknZWQuXG4gKiAgICAgdG9KU09OICAgOiBTQyA6IFN0YW5kYXJkLCBhcyBhYm92ZS4gUmVjdXJzaXZlbHkgaW5jbHVkZXMgZW1iZWRkZWQgbW9kZWxzLlxuICogICAgIHN5bmMgICAgIDogLS0gOiBEbyBub3QgdXNlIHRoaXMuXG4gKiAgICAgZmV0Y2ggICAgOiAtLSA6IERvIG5vdCB1c2UgdGhpcy4gVXNlIG5ld0NsaWVudE1vZGVsKCkgb3IgZ2V0U2VydmVyTW9kZWwoKSBpbnN0ZWFkLlxuICogICAgIHNhdmUgICAgIDogLS0gOiBEbyBub3QgdXNlIHRoaXMuIFVzZSAkJHVwZGF0ZSgpIGluc3RlYWQuXG4gKiAgICAgZGVzdHJveSAgOiAtLSA6IERvIG5vdCB1c2UgdGhpcy4gVXNlICQkZGVsZXRlKCkgaW5zdGVhZC5cbiAqICAgICBrZXlzICAgICA6IFNDIDogU3RhbmRhcmQuIERvZXMgbm90IHJldHVybiB0aGUgJyRhdHRyaWJ1dGUnIGtleXMuXG4gKiAgICAgdmFsdWVzICAgOiBTQyA6IFN0YW5kYXJkLiBSZXR1cm5zIEVtYmVkZGVkIE1vZGVscywgYnV0IG5vdCBSZWZlcmVuY2VkIE1vZGVscy5cbiAqICAgICBwYWlycyAgICA6IFNDIDogU3RhbmRhcmQuIFJldHVybnMgRW1iZWRkZWQgTW9kZWxzLCBidXQgbm90IFJlZmVyZW5jZWQgTW9kZWxzLlxuICogICAgIGludmVydCAgIDogU0MgOiBTdGFuZGFyZC4gUmV0dXJucyBFbWJlZGRlZCBNb2RlbHMsIGJ1dCBub3QgUmVmZXJlbmNlZCBNb2RlbHMuXG4gKiAgICAgcGljayAgICAgOiBTQyA6IFN0YW5kYXJkLiBSZXR1cm5zIEVtYmVkZGVkIE1vZGVscywgYnV0IG5vdCBSZWZlcmVuY2VkIE1vZGVscy5cbiAqICAgICBvbWl0ICAgICA6IFNDIDogU3RhbmRhcmQuIFJldHVybnMgRW1iZWRkZWQgTW9kZWxzLCBidXQgbm90IFJlZmVyZW5jZWQgTW9kZWxzLlxuICogICAgIHZhbGlkYXRlIDogLS0gOiBEbyBub3QgdXNlIHRoaXMuIERTQiBNb2RlbHMgZG8gdGhlaXIgb3duIHZhbGlkYXRpb24uIFNldHRpbmcgdGhpcyBtYXkgaGF2ZSBiYWQgZWZmZWN0cy5cbiAqICAgICBpc1ZhbGlkICA6IC0tIDogRG8gbm90IHVzZSB0aGlzLiBEU0IgTW9kZWxzIGFsd2F5cyB2YWxpZC5cbiAqICAgICB1cmwgICAgICA6IC0tIDogSW50ZXJuYWwuIFJldHVybnMgVVJMIHZhbHVlIHVzZWQgYnkgc29tZSBhamF4IHJvdXRpbmVzXG4gKiAgICAgcGFyc2UgICAgOiAtLSA6IEludGVybmFsLiBQcm9jZXNzZXMgdmFsdWVzIHJldHVybmVkIGZyb20gdGhlIHNlcnZlci5cbiAqICAgICBjbG9uZSAgICA6IFNDIDogUmV0dXJucyBhIENsaWVudCBNb2RlbCB3aGljaCBpcyBhIGRlZXAtY29weSBvZiB0aGlzIG1vZGVsLlxuICogICAgIGlzTmV3ICAgIDogU0MgOiBTdGFuZGFyZC4gKGJ1dCBwcmV0dHkgdXNlbGVzcylcbiAqICAgICBoYXNDaGFuZ2VkICAgICAgICAgOiBTQyA6IFN0YW5kYXJkLiBEb2VzIG5vdCByZWZsZWN0ICRhdHRyaWJ1dGUgbmFtZXMuXG4gKiAgICAgY2hhbmdlZEF0dHJpYnV0ZXMgIDogU0MgOiBTdGFuZGFyZC4gRG9lcyBub3QgcmVmbGVjdCAkYXR0cmlidXRlIG5hbWVzLlxuICogICAgIHByZXZpb3VzICAgICAgICAgICA6IFNDIDogU3RhbmRhcmQuIERvZXMgbm90IHJlZmxlY3QgJGF0dHJpYnV0ZSBuYW1lcy5cbiAqICAgICBwcmV2aW91c0F0dHJpYnV0ZXMgOiBTQyA6IFN0YW5kYXJkLiBEb2VzIG5vdCByZWZsZWN0ICRhdHRyaWJ1dGUgbmFtZXMuXG4gKlxuICogRFNCIE1vZGVsIGZ1bmN0aW9uc1xuICogICAgIGluc3RhbmNlT2YgICAgOiBTQyA6IFJldHVybnMgd2hldGhlciB0aGUgbW9kZWwgaXMgYW4gaW5zdGFuY2Ugb2YgYW5vdGhlciB0eXBlLlxuICogICAgIGlzU2VydmVyTW9kZWwgOiBTQyA6IFJldHVybnMgdHJ1ZSBpZiB0aGlzIGlzIGEgc2VydmVyIG1vZGVsXG4gKiAgICAgJCR1cGRhdGUgICAgICA6IFMgIDogVXBkYXRlcyB0aGUgdmVyc2lvbiBvZiB0aGUgbW9kZWwgb24gdGhlIHNlcnZlclxuICogICAgICQkZGVsZXRlICAgICAgOiBTICA6IERlbGV0ZXMgdGhlIHNlcnZlciBvYmplY3RcbiAqICAgICAkb3BlcmF0aW9uICAgIDogU0MgOiBDYWxscyB0aGUgcmVsZXZhbnQgb3BlcmF0aW9uLiBNb2RlbCBtdXN0IGhhdmUgYSByZWZlcmVuY2UgdmFsdWUgdG8gdXNlIHRoZXNlLlxuICpcbiAqIFByaXZhdGUgdG8gZHhDb3JlIERhdGFcbiAqICAgICBjb250ZXh0Ll9hc3NlcnRQYXJhbWV0ZXJzR29vZCAgICA6IFZhbGlkYXRlIHRoYXQgYSBzZXQgb2YgcGFyYW1ldGVycyBhcmUgdmFsaWQuXG4gKiAgICAgY29udGV4dC5fbmV3Q2xpZW50TW9kZWwgICAgICAgICAgOiBNYWtlcyBhIGNsaWVudCBtb2RlbFxuICogICAgIGNvbnRleHQuX25ld1NlcnZlck1vZGVsICAgICAgICAgIDogTWFrZXMgYSBzZXJ2ZXIgbW9kZWxcbiAqICAgICBjb250ZXh0Ll9nZXRSb290VHlwZSAgICAgICAgICAgICA6IFJldHVybnMgdGhlIG1vc3QgZGlzdGFudCBzdXBlciB0eXBlIHRoYXQgaGFzIHRoZSBzYW1lIHJvb3QgcHJvcGVydHkuXG4gKiAgICAgY29udGV4dC5fY29udmVydFhoclRvRXJyb3JSZXN1bHQgOiBDb252ZXJ0cyBhbiB4aHIgaW50byBhbiBFcnJvclJlc3VsdCBvYmplY3QuXG4gKlxuICogUk9PVCBPUEVSQVRJT05TXG4gKiBBbGwgcm9vdCBvcGVyYXRpb25zIG9uIHNjaGVtYXMsIGFuZCBhbGwgY3JlYXRlIG9wZXJhdGlvbnMgYXJlIHN0b3JlZCBpblxuICogICAgIGNvbnRleHQucm9vdE9wcy5UeXBlLiRyb290T3BlcmF0aW9uXG4gKiAgICAgY29udGV4dC5yb290T3BzLlR5cGUuJCRjcmVhdGVcbiAqXG4gKiBOb3RlOiBUaGlzIGRvZXMgbm90IGFsdGVyIHRoZSBiYXNpYyBCYWNrYm9uZSBsaWJyYXJ5IGluIGFueSB3YXkuIFRoaXMgbWVhbnMgdGhpcyBjYW4gY28tZXhpc3Qgd2l0aCBvcmRpbmFyeVxuICogICAgIEJhY2tib25lIHVzYWdlLCBvciBldmVuIG90aGVyIEJhY2tib25lLWJhc2VkIGxpYnJhcmllcyAoaWYgdGhleSBkb24ndCBtb2RpZnkgQmFja2JvbmUsIG9mIGNvdXJzZSkuXG4gKlxuICogUGFyYW1ldGVyczpcbiAqICAgICBzY2hlbWFzOiBUaGUgc2V0IG9mIHNjaGVtYXMgdGhpcyBzaG91bGQgZ2VuZXJhdGUgY29uc3RydWN0b3JzIGZyb20uXG4gKiAgICAgY29udGV4dDogVGhlIG9iamVjdCB0byBwdXQgdGhlIHJlc3VsdGluZyBjb25zdHJ1Y3RvcnMgKF9tb2RlbENvbnN0cnVjdG9ycykgb24uIElmIG5vdCBzcGVjaWZpZWQsIHB1dHMgdGhlbSBvblxuICogICAgICAgICAgICAgICd0aGlzJy5cbiAqL1xubW9kdWxlLmV4cG9ydHMuX2dlbmVyYXRlTW9kZWxDb25zdHJ1Y3RvcnMgPSBmdW5jdGlvbiBfZ2VuZXJhdGVNb2RlbENvbnN0cnVjdG9ycyhzY2hlbWFzLCBjb250ZXh0KSB7XG4gICAgLy8gTm90ZTogJ2NvbnRleHQnIGlzIHRoZSBvbmx5IHRydWUgJ2dsb2JhbCcgd2l0aGluIHRoaXMgY2xvc3VyZS4gUGxlYXNlIGRvbid0IGFkZCBvdGhlcnMuXG5cbiAgICAvKlxuICAgICAqID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAgICAgKiBNb2RlbCBmdW5jdGlvbnMuXG4gICAgICogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICAgICAqL1xuXG4gICAgLypcbiAgICAgKiBCYWNrYm9uZSBkZWZpbmVzIHRoaXMgYXM6IEJpbmQgYSBjYWxsYmFjayBmdW5jdGlvbiB0byBhbiBvYmplY3QuIFRoZSBjYWxsYmFjayB3aWxsIGJlIGludm9rZWQgd2hlbmV2ZXIgdGhlIGV2ZW50XG4gICAgICogaXMgZmlyZWQuXG4gICAgICpcbiAgICAgKiBGb3IgRFNCIG1vZGVscywgd2UgcHJvdmlkZSBzdGFuZGFyZCBiZWhhdmlvciBmb3IgdGhpcywgYnV0IGRvIHNvbWUgc3BlY2lhbCBwcm9jZXNzaW5nIGlmIHNvbWVvbmUgaXMgbGlzdGVuaW5nXG4gICAgICogZm9yIHRoZSAncmVhZHknIG9yICdlcnJvcicgZXZlbnQuIEluIHRoYXQgY2FzZSwgaWYgd2UgaGF2ZSBhbHJlYWR5IGZldGNoZWQgdGhlIG1vZGVsIChvciBpZiB0aGlzIGlzIGEgY2xpZW50XG4gICAgICogbW9kZWwpLCB0aGVuIHRyaWdnZXIgdGhlIHJlYWR5IGV2ZW50IGltbWVkaWF0ZWx5LiAgTm90ZSB0aGF0IGlmIHRoZSBtb2RlbCBpcyBhbHJlYWR5IHJlYWR5IG9yIGluIGVycm9yLFxuICAgICAqIHRoZW4gd2Ugd2lsbCByZWFjdCB0byAncmVhZHknIG9yICdlcnJvcicgaW1tZWRpYXRlbHkgd2l0aG91dCBzdG9yaW5nIHRoZSBsaXN0ZW5lciwgc2luY2UgdGhpcyBpcyBhIG9uZVxuICAgICAqIHRpbWUgcHNldWRvLWV2ZW50LlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGR4T24obmFtZSwgY2FsbGJhY2ssIGNvbnRleHQpIHtcbiAgICAgICAgdmFyIHRyYW5zaWVudFRyaWdnZXI7XG5cbiAgICAgICAgLypcbiAgICAgICAgICogSWYgdGhlIHVzZXIgaXMgYXNraW5nIGZvciByZWFkeSwgYW5kIHdlIGFyZSBhbHJlYWR5IHJlYWR5IG9yIGluIGVycm9yLCB0aGVuIHRyaWdnZXIgdGhlIHJlYWR5IG9yXG4gICAgICAgICAqIGRvIG5vdGhpbmcuIFRoZXJlIGlzIG5vIHJlYXNvbiB0byBrZWVwIHRoZSBldmVudCBsaXN0ZW5lciBhcm91bmQgZm9yIG1vcmUgdGhhbiB0aGlzIGNhbGwuXG4gICAgICAgICAqIFNpbWlsYXJseSBpZiB0aGUgdXNlciBpcyBhc2tpbmcgZm9yIHRoZSBlcnJvciBwc2V1ZG8gZXZlbnQuXG4gICAgICAgICAqL1xuICAgICAgICBpZiAobmFtZSA9PT0gJ3JlYWR5Jykge1xuICAgICAgICAgICAgaWYgKHRoaXMuX2R4SXNSZWFkeSkge1xuICAgICAgICAgICAgICAgIHRyYW5zaWVudFRyaWdnZXIgPSB0cmlnZ2VyUmVhZHk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHRoaXMuX2R4RXJyb3JSZXN1bHQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAobmFtZSA9PT0gJ2Vycm9yJykge1xuICAgICAgICAgICAgaWYgKHRoaXMuX2R4RXJyb3JSZXN1bHQpIHtcbiAgICAgICAgICAgICAgICB0cmFuc2llbnRUcmlnZ2VyID0gdHJpZ2dlckVycm9yO1xuICAgICAgICAgICAgfSBlbHNlIGlmICh0aGlzLl9keElzUmVhZHkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHJhbnNpZW50VHJpZ2dlcikge1xuICAgICAgICAgICAgdmFyIHRlbXBDb250ZXh0ID0ge307XG4gICAgICAgICAgICBCYWNrYm9uZS5FdmVudHMub24uY2FsbCh0aGlzLCBuYW1lLCBjYWxsYmFjaywgdGVtcENvbnRleHQpO1xuICAgICAgICAgICAgdHJhbnNpZW50VHJpZ2dlcih0aGlzKTtcbiAgICAgICAgICAgIEJhY2tib25lLkV2ZW50cy5vZmYuY2FsbCh0aGlzLCBuYW1lLCBjYWxsYmFjaywgdGVtcENvbnRleHQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgQmFja2JvbmUuRXZlbnRzLm9uLmNhbGwodGhpcywgbmFtZSwgY2FsbGJhY2ssIGNvbnRleHQpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLypcbiAgICAgKiBFaXRoZXIgJ3JlYWR5JyBvciAnZXJyb3InIGV2ZW50cyBpcyB0cmlnZ2VyZWQgb25jZSBpbiB0aGUgbGlmZWN5Y2xlIG9mIGEgbW9kZWwuIENsZWFudXAgbGlzdGVuZXJzIGFzIHNvb24gYXNcbiAgICAgKiBwb3NzaWJsZS5cbiAgICAgKlxuICAgICAqIFdpdGhvdXQgdGhpcyBhdXRvbWF0aWMgY2xlYW51cCwgY2FsbGVycyB3b3VsZCBoYXZlIHRvIHNldHVwIDIgbGlzdGVuZXJzIGFuZCBjYW5jZWwgZWFjaCBvdGhlciB3aGVuIHRyaWdnZXJlZC5cbiAgICAgKiBOb3RlIHRoYXQgd2UgbG9vayBhdCB0aGUgbGlzdCBvZiBldmVudHMgYmVmb3JlIHRyaWdnZXJpbmcgZXZlbnRzIHNvIGFzIHRvIGFsbG93IGV2ZW50IGhhbmRsZXJzIHRvIGF0dGFjaCBuZXdcbiAgICAgKiBoYW5kbGVycy5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiByZW1vdmVFdmVudEhhbmRsZXJzKG1vZGVsLCBldmVudHMpIHtcbiAgICAgICAgXy5lYWNoKGV2ZW50cywgZnVuY3Rpb24odmFsdWUsIG5hbWUpIHtcbiAgICAgICAgICAgIF8uZWFjaCh2YWx1ZSwgZnVuY3Rpb24oZXZlbnQpIHtcbiAgICAgICAgICAgICAgICBpZiAoZXZlbnQuY2FsbGJhY2spIHtcbiAgICAgICAgICAgICAgICAgICAgbW9kZWwub2ZmKG5hbWUsIGV2ZW50LmNhbGxiYWNrKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgLypcbiAgICAgKiBHZXQgYSBjb3B5IG9mIHRoZSBjdXJyZW50IGV2ZW50IGhhbmRsZXJzLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGdldEV2ZW50SGFuZGxlcnMobW9kZWwpIHtcbiAgICAgICAgaWYgKCFtb2RlbC5fZXZlbnRzKSB7XG4gICAgICAgICAgICByZXR1cm4ge307XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGVycm9yOiAobW9kZWwuX2V2ZW50cy5lcnJvciB8fCBbXSkuc2xpY2UoMCksXG4gICAgICAgICAgICByZWFkeTogKG1vZGVsLl9ldmVudHMucmVhZHkgfHwgW10pLnNsaWNlKDApXG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgLypcbiAgICAgKiBUcmlnZ2VyIHRoZSAncmVhZHknIGV2ZW50IGFuZCBjbGVhbiB1cCBlcnJvciBsaXN0ZW5lcnNcbiAgICAgKi9cbiAgICBmdW5jdGlvbiB0cmlnZ2VyUmVhZHkobW9kZWwpIHtcbiAgICAgICAgdmFyIGhhbmRsZXJzID0gZ2V0RXZlbnRIYW5kbGVycyhtb2RlbCk7XG4gICAgICAgIG1vZGVsLnRyaWdnZXIoJ3JlYWR5JywgbW9kZWwpO1xuICAgICAgICByZW1vdmVFdmVudEhhbmRsZXJzKG1vZGVsLCBoYW5kbGVycyk7XG4gICAgfVxuXG4gICAgLypcbiAgICAgKiBUcmlnZ2VyIHRoZSAnZXJyb3InIGV2ZW50IGFuZCBjbGVhbiB1cCByZWFkeSBsaXN0ZW5lcnNcbiAgICAgKi9cbiAgICBmdW5jdGlvbiB0cmlnZ2VyRXJyb3IobW9kZWwpIHtcbiAgICAgICAgdmFyIGhhbmRsZXJzID0gZ2V0RXZlbnRIYW5kbGVycyhtb2RlbCk7XG4gICAgICAgIG1vZGVsLnRyaWdnZXIoJ2Vycm9yJywgbW9kZWwsIG1vZGVsLl9keEVycm9yUmVzdWx0KTtcbiAgICAgICAgcmVtb3ZlRXZlbnRIYW5kbGVycyhtb2RlbCwgaGFuZGxlcnMpO1xuICAgIH1cblxuICAgIC8qXG4gICAgICogQmFja2JvbmUgZGVmaW5lcyB0aGlzIGFzOiBHZXQgdGhlIGN1cnJlbnQgdmFsdWUgb2YgYW4gYXR0cmlidXRlIGZyb20gdGhlIG1vZGVsLlxuICAgICAqXG4gICAgICogRm9yIERTQiBtb2RlbHMsIHRoaXMgZG9lcyB0aGUgc2FtZSB0aGluZywgd2l0aCB0d28gYWRkaXRpb25hbCBmZWF0dXJlcy4gRmlyc3QsIGFza2luZyBmb3IgYW4gYXR0cmlidXRlIHRoYXQgaXNuJ3RcbiAgICAgKiBpbiB0aGUgc2NoZW1hIGRlZmluaXRpb24gd2lsbCBjYXVzZSBhbiBlcnJvciB0byBiZSB0aHJvd24uICBTZWNvbmQsIGlmIHRoZXJlIGlzIGFuIGF0dHJpYnV0ZSBuYW1lZCAnYXR0cicgd2hvc2VcbiAgICAgKiBzY2hlbWEgcHJvcGVydHkgaXMgb2YgdHlwZSBzdHJpbmcvb2JqZWN0UmVmZXJlbmNlLCB0aGVuIG9uZSBjYW4gYWxzbyBnZXQoJyRhdHRyJyksIGFuZCB0aGlzIHdpbGwgcmV0dXJuIHRoZVxuICAgICAqIGNvcnJlc3BvbmRpbmcgRFNCIG1vZGVsLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGR4R2V0KGF0dHJOYW1lKSB7XG4gICAgICAgIHZhciBpbmZvID0gYXNzZXJ0QW5kR2V0QXR0ckluZm8odGhpcywgYXR0ck5hbWUpO1xuXG4gICAgICAgIGlmIChpc09iamVjdFJlZlByb3AoaW5mby5wcm9wRGVmKSAmJiBpbmZvLndhbnRzTW9kZWwpIHtcbiAgICAgICAgICAgIHZhciByZWZlcmVuY2VWYWx1ZSA9IHRoaXMuYXR0cmlidXRlc1tpbmZvLmJhc2VOYW1lXTtcbiAgICAgICAgICAgIGlmIChkeFV0aWwuaXNOb25lKHJlZmVyZW5jZVZhbHVlKSkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChfLmlzU3RyaW5nKHJlZmVyZW5jZVZhbHVlKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBjb250ZXh0Ll9jYWNoZS5nZXRDYWNoZWRNb2RlbChyZWZlcmVuY2VWYWx1ZSwgZ2V0Um9vdFR5cGUoaW5mby5wcm9wRGVmLnJlZmVyZW5jZVRvKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBkeFV0aWwuZmFpbCgnVHJpZWQgdG8gcmV0cmlldmUgYSByZWxhdGVkIG9iamVjdCB3aXRoICcgKyBhdHRyTmFtZSArICcgYnV0IHZhbHVlIHdhcyAnICsgcmVmZXJlbmNlVmFsdWUgK1xuICAgICAgICAgICAgICAgICcuJyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gQmFja2JvbmUuTW9kZWwucHJvdG90eXBlLmdldC5jYWxsKHRoaXMsIGluZm8uYmFzZU5hbWUpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLypcbiAgICAgKiBCYWNrYm9uZSBkZWZpbmVzIHRoaXMgYXM6IFNldCBhIGhhc2ggb2YgYXR0cmlidXRlcyAob25lIG9yIG1hbnkpIG9uIHRoZSBtb2RlbC4gSWYgYW55IG9mIHRoZSBhdHRyaWJ1dGVzIGNoYW5nZVxuICAgICAqIHRoZSBtb2RlbCdzIHN0YXRlLCBhICdjaGFuZ2UnIGV2ZW50IHdpbGwgYmUgdHJpZ2dlcmVkIG9uIHRoZSBtb2RlbC5cbiAgICAgKlxuICAgICAqIEZvciBEU0IgTW9kZWxzLCB0aGVyZSBhcmUgYSBudW1iZXIgb2YgZGlmZmVyZW5jZXMuXG4gICAgICogICAgIDEpIE9ubHkgYXR0cmlidXRlcyBkZWZpbmVkIGluIHRoZSBzY2hlbWFzIGNhbiBiZSBzZXQuXG4gICAgICogICAgIDIpIEF0dHJpYnV0ZXMgbWF5IG9ubHkgYmUgc2V0IHRvIHZhbHVlcyB3aXRoIHRoZSBkYXRhIHR5cGUgc3BlY2lmaWVkIGluIHRoZSBzY2hlbWFzLlxuICAgICAqICAgICAzKSBEU0IgbW9kZWxzIG1heSBjb250YWluICdlbWJlZGRlZCcgRFNCIG1vZGVscyAob2JqZWN0LyRyZWYpXG4gICAgICpcbiAgICAgKiBUbyBzZXQgYW4gYXR0cmlidXRlIG9uIGFuIGVtYmVkZGVkIERTQiBtb2RlbCwgb25lIG11c3Qgc3RpbGwgc3BlY2lmeSB2YWx1ZXMgaW4gSlNPTiBmb3JtYXQuIFRodXM6XG4gICAgICogICAgIG15TW9kZWwuc2V0KHtcbiAgICAgKiAgICAgICAgIGF0dHI6IDEsXG4gICAgICogICAgICAgICBteUVtYmVkZGVkTW9kZWw6IHtcbiAgICAgKiAgICAgICAgICAgICBlbWJlZGRlZEF0dHI6IDM0XG4gICAgICogICAgICAgICB9XG4gICAgICogICAgIH0pXG4gICAgICogTm90ZSB0aGF0IGl0IGlzIGxlZ2FsLCBpbiBzb21lIGNpcmN1bXN0YW5jZXMsIHRvIGNoYW5nZSB0aGUgdHlwZSBvZiBhbiBlbWJlZGRlZCBtb2RlbCB3aXRoIGEgc2V0LiBOYXR1cmFsbHksXG4gICAgICogb24gYSBTZXJ2ZXJNb2RlbCwgb25seSB0aGUgc2VydmVyIG1heSBkbyB0aGlzLCBob3dldmVyIG9uIGEgQ2xpZW50TW9kZWwgdGhpcyBjYW4gaGFwcGVuIHF1aXRlIGZyZWVseS4gVGhlXG4gICAgICogaW1wb3J0YW50IHRoaW5ncyB0byBrZWVwIGluIG1pbmQgYXJlIHRoZSBmb2xsb3dpbmc6XG4gICAgICogICAgIGEpIFdoZW4gdGhlIHR5cGUgY2hhbmdlcywgdGhlIG5ldyB0eXBlIG11c3QgYmUgY29tcGF0aWJsZSB3aXRoIHRoZSB0eXBlIGRlY2xhcmVkIGluIHRoZSBzY2hlbWEgKHdoaWNoIGlzIHRvXG4gICAgICogICAgICAgIHNheSB5b3UgbWF5IGNoYW5nZSBpdCB0byB0aGF0IHR5cGUgb3IgYW55IHN1YnR5cGUsIGJ1dCBtYXkgbm90IGNoYW5nZSBpdCB0byBhbiB1bnJlbGF0ZWQgdHlwZSkuXG4gICAgICogICAgIGIpIENoYW5naW5nIGEgdHlwZSBpcyBlcXVpdmFsZW50IHRvIHNldHRpbmcgdGhhdCBlbWJlZGRlZCBtb2RlbCB0byBhIG5ldyBpbnN0YW5jZS4gVGhhdCBpcywgYW55IHZhbHVlcyB0aGF0XG4gICAgICogICAgICAgIHdlcmUgaW4gdGhlIGVtYmVkZGVkIG1vZGVsIGJlZm9yZSB0aGUgc2V0IGFyZSByZXBsYWNlZCB3aXRoIGRlZmF1bHQgdmFsdWVzLCBhbmQgdGhlbiB0aGUgdmFsdWVzIHNwZWNpZmllZFxuICAgICAqICAgICAgICB0byB0aGlzIHNldCgpIHJvdXRpbmUgYXJlIGFwcGxpZWQuXG4gICAgICogICAgIGMpIEhvd2V2ZXIsIGxpc3RlbmVycyBvbiB0aGlzIGVtYmVkZGVkIG1vZGVsIGFyZSBub3QgYWZmZWN0ZWQsIGFuZCBhcHByb3ByaWF0ZSBjaGFuZ2Ugbm90aWZpY2F0aW9ucyB3aWxsIGJlXG4gICAgICogICAgICAgIHNlbnQgb24gc2V0dGluZy5cbiAgICAgKlxuICAgICAqIEEgRFNCIG1vZGVsIG1heSwgbGVnaXRpbWF0ZWx5LCBoYXZlIGFuIGFycmF5IG9yIG9iamVjdCB0aGF0LCBpdHNlbGYsIGNvbnRhaW5zIGEgRFNCIG1vZGVsIChmb3IgZXhhbXBsZSwgYW5cbiAgICAgKiBBUElFcnJvciBtYXkgY29udGFpbiBhIHBsYWluIEpTT04gb2JqZWN0IHdob3NlIHZhbHVlcyBhcmUgb3RoZXIgQVBJRXJyb3JzKS4gIFRvIGRlYWwgd2l0aCB0aGlzIHByb3Blcmx5LCBzZXQoKVxuICAgICAqIHdpbGwgZGV0ZWN0IGFueSBvYmplY3QgdGhhdCBoYXMgYSAndHlwZScgcHJvcGVydHksIHdob3NlIHZhbHVlIGlzIGEgRGVscGhpeC1zY2hlbWEgdHlwZSBuYW1lLCBhbmQgY3JlYXRlIGFcbiAgICAgKiBEU0IgbW9kZWwgYXV0b21hdGljYWxseS4gV2l0aG91dCB0aGF0IHR5cGUgcHJvcGVydHksIGhvd2V2ZXIsIHNldCgpIHdpbGwgdHJlYXQgdGhlIG9iamVjdCBhcyBhbiBvcmRpbmFyeVxuICAgICAqIEpTT04gb2JqZWN0LlxuICAgICAqXG4gICAgICogQXJyYXlzIGluIGEgRGVscGhpeCBzY2hlbWEgbWF5IG9yIG1heSBub3QgaGF2ZSBhIHR5cGUgc3BlY2lmaWVkIGZvciBpdGVtcy4gSWYgdGhleSBkbywgc2V0KCkgd2lsbCBlbmZvcmNlIHRoYXRcbiAgICAgKiB0eXBlLiBJZiBub3QsIHRoZW4gdGhlIGl0ZW1zIGluIHRoZSBhcnJheSBwYXNzZWQgaW4gd2lsbCBiZSBleGFtaW5lZCBhbmQgcmVjdXJzaXZlbHkgcHJvY2Vzc2VzZWQgYXMgYXBwcm9wcmlhdGUuXG4gICAgICogU2ltaWxhcmx5LCBpZiBhIHBsYWluIG9iamVjdCBpcyBlbmNvdW50ZXJlZCwgc2V0KCkgd2lsbCBwcm9jZXNzIGl0cyB2YWx1ZXMgcmVjdXJzaXZlbHkgKGluY2x1ZGluZyB0dXJuaW5nIHRoZW0sXG4gICAgICogb3IgdGhlaXIgb3duIHByb3BlcnRpZXMsIGludG8gRFNCIG1vZGVscyBhcyBhcHByb3ByaWF0ZSlcbiAgICAgKlxuICAgICAqIEEgc2NoZW1hIHByb3BlcnR5IGRlZmluZWQgd2l0aCB0eXBlPXN0cmluZyBhbmQgZm9ybWF0PWRhdGUgZ2V0cyBzb21lIHNwZWNpYWwgdHJlYXRtZW50LiAgSW4gdGhhdCBjYXNlLCB5b3UgY2FuXG4gICAgICogcGFzcyBhIHN0cmluZyBpbiBZWVlZLU1NLUREVEhIOk1NOlNTLk1NTVogZm9ybWF0LCBvciBhIEphdmFzY3JpcHQgRGF0ZSBvYmplY3QgKHRoZSBmb3JtZXIgd2lsbCBiZSBjb252ZXJ0ZWQgdG9cbiAgICAgKiBhIERhdGUgb2JqZWN0IGludGVybmFsbHksIHNvIGltbWVkaWF0ZWx5IGNhbGxpbmcgZ2V0KCkgd2lsbCBub3QgcmV0dXJuIHRoZSBvcmlnaW5hbCBzdHJpbmcpLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGR4U2V0KGtleSwgdmFsdWUsIG9wdGlvbnMpIHtcbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgICB2YXIgbmV3QXR0cnMgPSB7fTtcbiAgICAgICAgdmFyIHByZUNvbnZlcnRBdHRycztcbiAgICAgICAgdmFyIHBvc3RDb252ZXJ0QXR0cnM7XG5cbiAgICAgICAgaWYgKF8uaXNVbmRlZmluZWQoa2V5KSkge1xuICAgICAgICAgICAgcmV0dXJuIHNlbGY7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoXy5pc09iamVjdChrZXkpKSB7XG4gICAgICAgICAgICBuZXdBdHRycyA9IGtleTtcbiAgICAgICAgICAgIG9wdGlvbnMgPSB2YWx1ZTtcblxuICAgICAgICAgICAgaWYgKG5ld0F0dHJzIGluc3RhbmNlb2YgQmFja2JvbmUuTW9kZWwpIHtcbiAgICAgICAgICAgICAgICBuZXdBdHRycyA9IG5ld0F0dHJzLnRvSlNPTigpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbmV3QXR0cnNba2V5XSA9IHZhbHVlO1xuICAgICAgICB9XG5cbiAgICAgICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cbiAgICAgICAgLypcbiAgICAgICAgICogQ2hlY2sgd2hldGhlciB0aGlzIHNldCB3b3VsZCBjaGFuZ2UgdGhlIHR5cGUgb2YgdGhlIG1vZGVsLiBUaGlzIG9ubHkgYWxsb3dzIGNoYW5naW5nIHRvIGEgc3VidHlwZS5cbiAgICAgICAgICovXG4gICAgICAgIGlmIChuZXdBdHRycy50eXBlICYmIG5ld0F0dHJzLnR5cGUgIT09IHNlbGYuX2R4U2NoZW1hLm5hbWUpIHtcbiAgICAgICAgICAgIGlmIChmaXJzdElzU3VidHlwZU9mU2Vjb25kKG5ld0F0dHJzLnR5cGUsIHNlbGYuX2R4U2NoZW1hLm5hbWUpIHx8IG9wdGlvbnMuX2FsbG93VHlwZUNvbnZlcnNpb24pIHtcbiAgICAgICAgICAgICAgICBwcmVDb252ZXJ0QXR0cnMgPSBfLmNsb25lKHNlbGYuYXR0cmlidXRlcyk7XG4gICAgICAgICAgICAgICAgY29udmVydFRvVHlwZShzZWxmLCBuZXdBdHRycy50eXBlKTtcbiAgICAgICAgICAgICAgICBwb3N0Q29udmVydEF0dHJzID0gXy5jbG9uZShzZWxmLmF0dHJpYnV0ZXMpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBkeFV0aWwuZmFpbCgnVHJpZWQgdG8gY2hhbmdlIHRoaXMgZnJvbSAnICsgc2VsZi5fZHhTY2hlbWEubmFtZSArICcgdG8gJyArIG5ld0F0dHJzLnR5cGUgKyAnLicpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLypcbiAgICAgICAgICogUmVqZWN0IHRoZSBzZXQgaWYgYW55IG9mIHRoZSBhdHRyaWJ1dGVzIGFyZW4ndCBvZiB0aGUgcmlnaHQgdHlwZVxuICAgICAgICAgKi9cbiAgICAgICAgdmFyIGludmFsaWRBdHRycyA9IF8ub21pdChuZXdBdHRycywgXy5rZXlzKHNlbGYuX2R4U2NoZW1hLnByb3BlcnRpZXMgfHwge30pKTtcbiAgICAgICAgaWYgKCFfLmlzRW1wdHkoaW52YWxpZEF0dHJzKSkge1xuICAgICAgICAgICAgZHhVdGlsLmZhaWwoXy5rZXlzKGludmFsaWRBdHRycykgKyAnIGFyZSBub3QgYXR0cmlidXRlcyBvZiBhIG1vZGVsIG9mIHR5cGUgJyArIHNlbGYuX2R4U2NoZW1hLm5hbWUgKyAnLicpO1xuICAgICAgICB9XG5cbiAgICAgICAgLypcbiAgICAgICAgICogVmFsaWRhdGUgdHlwZXMgbWF0Y2gsIGFuZCBwcmVwYXJlIHZhbHVlcyB0byBiZSBzZXRcbiAgICAgICAgICovXG4gICAgICAgIHZhciBmaW5hbEF0dHJzID0ge307XG4gICAgICAgIHZhciBzdWJNb2RlbHNUb1NldCA9IHt9O1xuICAgICAgICB2YXIgc3ViTW9kZWxzVG9DbGVhciA9IFtdO1xuICAgICAgICB2YXIgc3ViTW9kZWxzVG9Db252ZXJ0ID0ge307XG5cbiAgICAgICAgXy5lYWNoKG5ld0F0dHJzLCBmdW5jdGlvbihuZXdWYWx1ZSwgbmV3TmFtZSkge1xuICAgICAgICAgICAgdmFyIHByb3BEZWYgPSBzZWxmLl9keFNjaGVtYS5wcm9wZXJ0aWVzW25ld05hbWVdO1xuICAgICAgICAgICAgdmFyIG5ld1R5cGUgPSBhc3NlcnRWYWx1ZU1hdGNoZXNEZWZpbml0aW9uKG5ld05hbWUsIG5ld1ZhbHVlLCBwcm9wRGVmKTtcblxuICAgICAgICAgICAgc3dpdGNoIChuZXdUeXBlKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAndW5kZWZpbmVkJzpcbiAgICAgICAgICAgICAgICBjYXNlICdib29sZWFuJzpcbiAgICAgICAgICAgICAgICBjYXNlICdzdHJpbmcnOlxuICAgICAgICAgICAgICAgIGNhc2UgJ251bWJlcic6XG4gICAgICAgICAgICAgICAgY2FzZSAnaW50ZWdlcic6XG4gICAgICAgICAgICAgICAgICAgIGZpbmFsQXR0cnNbbmV3TmFtZV0gPSBuZXdWYWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAnbnVsbCc6XG4gICAgICAgICAgICAgICAgICAgIHZhciBudWxsYWJsZSA9IF8uYW55KHByb3BEZWYudHlwZSwgZnVuY3Rpb24odHlwZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHR5cGUgPT09ICdudWxsJztcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzZWxmLmdldChuZXdOYW1lKSBpbnN0YW5jZW9mIEJhY2tib25lLk1vZGVsICYmICFudWxsYWJsZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgc3ViTW9kZWxzVG9DbGVhci5wdXNoKG5ld05hbWUpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgZmluYWxBdHRyc1tuZXdOYW1lXSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlICdkYXRlJzpcbiAgICAgICAgICAgICAgICAgICAgaWYgKG5ld1ZhbHVlIGluc3RhbmNlb2YgRGF0ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZmluYWxBdHRyc1tuZXdOYW1lXSA9IG5ldyBEYXRlKG5ld1ZhbHVlLmdldFRpbWUoKSk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBmaW5hbEF0dHJzW25ld05hbWVdID0gbmV3IERhdGUobmV3VmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgJ2FycmF5JzpcbiAgICAgICAgICAgICAgICAgICAgZmluYWxBdHRyc1tuZXdOYW1lXSA9IHNldHVwQXJyYXkobmV3VmFsdWUsIHByb3BEZWYuaXRlbXMpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlICdvYmplY3QnOlxuICAgICAgICAgICAgICAgICAgICBpZiAoc2VsZi5nZXQobmV3TmFtZSkgaW5zdGFuY2VvZiBCYWNrYm9uZS5Nb2RlbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG5ld1ZhbHVlLnR5cGUgJiYgc2VsZi5nZXQobmV3TmFtZSkuZ2V0KCd0eXBlJykgIT09IG5ld1ZhbHVlLnR5cGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdWJNb2RlbHNUb0NvbnZlcnRbbmV3TmFtZV0gPSBuZXdWYWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3ViTW9kZWxzVG9TZXRbbmV3TmFtZV0gPSBuZXdWYWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChwcm9wRGVmLiRyZWYgPT09ICdKc29uJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgLypcbiAgICAgICAgICAgICAgICAgICAgICAgICAqIERlYWwgd2l0aCBzcGVjaWFsIEpzb24gdHlwZSwgd2hpY2ggaXMgb2JqZWN0LCBidXQgZG9lc24ndCBuZWVkIGFueSBzZXQgdXAuIEl0IGhhcyBhXG4gICAgICAgICAgICAgICAgICAgICAgICAgKiByZWZlcmVuY2UgYmVjYXVzZSB0aGUgYmFja2VuZCBuZWVkcyB0aGlzIHRvIGRvIGl0cyB2YWxpZGF0aW9uLiBUaGUgVUkgc2hvdWxkIGNvbnNpZGVyXG4gICAgICAgICAgICAgICAgICAgICAgICAgKiBpbnN0YW5jZXMgb2YgdGhpcyB0eXBlIGFzIGEgYmxhY2sgYm94IChlLmcuIGRvbid0IHZhbGlkYXRlIGl0cyBwcm9wZXJ0aWVzKS5cbiAgICAgICAgICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgICAgICAgICAgZmluYWxBdHRyc1tuZXdOYW1lXSA9IGpzb25JemUobmV3VmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgZmluYWxBdHRyc1tuZXdOYW1lXSA9IHNldHVwT2JqZWN0KG5ld1ZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgLypcbiAgICAgICAgICogRmluYWxseSwgc2V0IGFsbCB0aGUgdmFsdWVzXG4gICAgICAgICAqL1xuICAgICAgICBfLmVhY2goc3ViTW9kZWxzVG9DbGVhciwgZnVuY3Rpb24oYXR0ck5hbWUpIHtcbiAgICAgICAgICAgIHNlbGYuZ2V0KGF0dHJOYW1lKS5fZHhDbGVhcihvcHRpb25zKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgdmFyIHJldmlzZWRPcHRpb25zID0gXy5leHRlbmQoXy5jbG9uZShvcHRpb25zKSwgeyBfYWxsb3dUeXBlQ29udmVyc2lvbjogdHJ1ZSB9KTtcbiAgICAgICAgXy5lYWNoKHN1Yk1vZGVsc1RvQ29udmVydCwgZnVuY3Rpb24odmFsdWUsIGtleSkge1xuICAgICAgICAgICAgdmFyIHN1Yk1vZGVsID0gc2VsZi5nZXQoa2V5KTtcbiAgICAgICAgICAgIHN1Yk1vZGVsLl9keFNldCh2YWx1ZSwgcmV2aXNlZE9wdGlvbnMpO1xuICAgICAgICB9KTtcblxuICAgICAgICBfLmVhY2goc3ViTW9kZWxzVG9TZXQsIGZ1bmN0aW9uKHZhbHVlLCBrZXkpIHtcbiAgICAgICAgICAgIHNlbGYuZ2V0KGtleSkuX2R4U2V0KHZhbHVlLCBvcHRpb25zKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgLypcbiAgICAgICAgICogSWYgd2UgZGlkIGEgdHlwZSBjb252ZXJzaW9uLCB3ZSBuZWVkIHRvIG1ha2Ugc3VyZSB0byBzZW5kIGFsbCB0aGUgY2hhbmdlOkF0dHJOYW1lIGV2ZW50cyBiZWZvcmUgd2Ugc2VuZFxuICAgICAgICAgKiB0aGUgZmluYWwgY2hhbmdlIGV2ZW50LiAgQmVjYXVzZSB3ZSdyZSByZWx5aW5nIG9uIHRoZSBCYWNrYm9uZSBzZXQgcm91dGluZSwgaXQgbWF5IHRoaW5rIGl0IG5lZWRzIHRvIHNlbmRcbiAgICAgICAgICogdGhlIGNoYW5nZSBldmVudCB3aGVuIGl0IGlzIGRvbmUsIGJ1dCB3ZSBoYXZlIHRoZSBwb3RlbnRpYWwgdG8gc2VuZCBhIHZhcmlldHkgb2Ygb3RoZXIgZXZlbnRzIGFmdGVyd2FyZHMuXG4gICAgICAgICAqIFRvIHdvcmsgYXJvdW5kIHRoaXMsIHdlIHN0b3JlIGFsbCBjYWxscyB0byB0cmlnZ2VyKCkgdW50aWwgd2UgYXJlIGRvbmUuXG4gICAgICAgICAqL1xuICAgICAgICBpZiAocHJlQ29udmVydEF0dHJzKSB7XG4gICAgICAgICAgICBpbnRlcmNlcHRUcmlnZ2VyKHNlbGYpO1xuICAgICAgICB9XG5cbiAgICAgICAgLypcbiAgICAgICAgICogVGhpcyB3aWxsIHNldCBhbGwgdGhlIHZhbHVlcywgYW5kIHRyaWdnZXIgY2hhbmdlOmF0dHIgZXZlbnRzIGZvciBhbGwgdGhlIGF0dHJpYnV0ZXMgdGhhdCBjaGFuZ2VkXG4gICAgICAgICAqIE5vdGUgdGhhdCBpZiB0aGlzIGlzIGRvaW5nIGEgdHlwZSBjb252ZXJzaW9uLCB0aGlzIHdpbGwgdHJpZ2dlciBjaGFuZ2VzIGZvcjpcbiAgICAgICAgICogICAtIGF0dHJpYnV0ZXMgdGhhdCB3ZXJlIGFkZGVkICh0aG91Z2ggY29udmVyc2lvbikgYW5kIHRoZW4gY2hhbmdlZFxuICAgICAgICAgKiAgIC0gYXR0cmlidXRlcyB0aGF0IGV4aXN0ZWQgYmVmb3JlIGFuZCBhZnRlciBjb252ZXJzaW9uLCBhbmQgY2hhbmdlZCBmcm9tIHRoZWlyIGNvbnZlcnRlZCB2YWx1ZVxuICAgICAgICAgKi9cbiAgICAgICAgdmFyIHJlc3VsdCA9IEJhY2tib25lLk1vZGVsLnByb3RvdHlwZS5zZXQuY2FsbChzZWxmLCBmaW5hbEF0dHJzLCBvcHRpb25zKTtcblxuICAgICAgICBpZiAocHJlQ29udmVydEF0dHJzKSB7XG4gICAgICAgICAgICB2YXIgcmVtb3ZlZEF0dHJzID0gXy5vbWl0KHByZUNvbnZlcnRBdHRycywgXy5rZXlzKHBvc3RDb252ZXJ0QXR0cnMpKTtcbiAgICAgICAgICAgIHZhciBhZGRlZEF0dHJzID0gXy5vbWl0KHBvc3RDb252ZXJ0QXR0cnMsIF8ua2V5cyhwcmVDb252ZXJ0QXR0cnMpKTtcbiAgICAgICAgICAgIHZhciBjb250aW51ZWRBdHRycyA9IF8ucGljayhwcmVDb252ZXJ0QXR0cnMsIF8ua2V5cyhwb3N0Q29udmVydEF0dHJzKSk7XG5cbiAgICAgICAgICAgIC8vIHRyaWdnZXIgY2hhbmdlIGV2ZW50cyBmb3IgdGhlIGF0dHJpYnV0ZXMgd2VyZSByZW1vdmVkXG4gICAgICAgICAgICBfLmVhY2gocmVtb3ZlZEF0dHJzLCBmdW5jdGlvbih2YWx1ZSwga2V5KSB7XG4gICAgICAgICAgICAgICAgc2VsZi50cmlnZ2VyKCdjaGFuZ2U6JyArIGtleSwgc2VsZiwgdW5kZWZpbmVkKTtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAvLyB0cmlnZ2VyIGNoYW5nZSBldmVudHMgZm9yIHRoZSBhdHRyaWJ1dGVzIHRoYXQgd2VyZSBhZGRlZCwgYnkgY29udmVyc2lvbiwgYnV0IG5vdCBjaGFuZ2VkXG4gICAgICAgICAgICBfLmVhY2goYWRkZWRBdHRycywgZnVuY3Rpb24odmFsdWUsIGtleSkge1xuICAgICAgICAgICAgICAgIGlmIChhZGRlZEF0dHJzW2tleV0gPT09IHNlbGYuYXR0cmlidXRlc1trZXldKSB7XG4gICAgICAgICAgICAgICAgICAgIHNlbGYudHJpZ2dlcignY2hhbmdlOicgKyBrZXksIHNlbGYsIHNlbGYuYXR0cmlidXRlc1trZXldKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgXy5lYWNoKGNvbnRpbnVlZEF0dHJzLCBmdW5jdGlvbih2YWx1ZSwga2V5KSB7XG4gICAgICAgICAgICAgICAgLypcbiAgICAgICAgICAgICAgICAgKiBTdXBwcmVzcyBhIGNoYW5nZTphdHRyTmFtZSBldmVudCBpZiBpZiB0aGUgYXR0ciBjaGFuZ2VkIGR1cmluZyB0aGUgc2V0KCkgdG8gdGhlIHNhbWUgdmFsdWUgYXMgYmVmb3JlXG4gICAgICAgICAgICAgICAgICogdGhlIGNvbnZlcnNpb24gc3VwcHJlc3MgZXZlbnQvXG4gICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgaWYgKGNvbnRpbnVlZEF0dHJzW2tleV0gPT09IHNlbGYuYXR0cmlidXRlc1trZXldICYmIHBvc3RDb252ZXJ0QXR0cnNba2V5XSAhPT0gc2VsZi5hdHRyaWJ1dGVzW2tleV0pIHtcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5fc3VwcHJlc3NFdmVudHMucHVzaCgnY2hhbmdlOicgKyBrZXkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvKlxuICAgICAgICAgICAgICAgICAqIFRyaWdnZXIgYSBjaGFuZ2U6YXR0ck5hbWUgaWYgdGhlIHZhbHVlIGNoYW5nZWQgZHVyaW5nIGNvbnZlcnNhdGlvbiwgYnV0IHRoZW4gd2Fzbid0IGNoYW5nZWQgYnkgc2V0LlxuICAgICAgICAgICAgICAgICAqIEZvciBleGFtcGxlOiBUaGUgb3JpZ2luYWwgdmFsdWUgd2FzIDEsIHRoZW4gd2hlbiB3ZSBjaGFuZ2VkIHRoZSB0eXBlIHdlIHB1dCB0aGUgZGVmYXVsdCB2YWx1ZSBvZiAyXG4gICAgICAgICAgICAgICAgICogaW4sIGFuZCB0aGVuIEJhY2tib25lJ3Mgc2V0IGNoYW5nZWQgaXQgdG8gMi4gIFNvLCBzZXQoKSBkaWRuJ3Qgc2VuZCBhbiBldmVudCwgYnV0IHdlIGtub3cgdGhhdFxuICAgICAgICAgICAgICAgICAqIHRoZXJlIGFjdHVhbGx5IHdhcyBhIGNoYW5nZSBmcm9tIHRoZSBjbGllbnQncyBwb2ludCBvZiB2aWV3LlxuICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgIGlmIChjb250aW51ZWRBdHRyc1trZXldICE9PSBwb3N0Q29udmVydEF0dHJzW2tleV0gJiYgcG9zdENvbnZlcnRBdHRyc1trZXldID09PSBzZWxmLmF0dHJpYnV0ZXNba2V5XSkge1xuICAgICAgICAgICAgICAgICAgICBzZWxmLnRyaWdnZXIoJ2NoYW5nZTonICsga2V5LCBzZWxmLCBzZWxmLmF0dHJpYnV0ZXNba2V5XSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIHJlcGxheVRyaWdnZXJzKHNlbGYpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKlxuICAgICAqIEludGVyY2VwdCBhbmQgcXVldWUgZm9yIGxhdGVyIHJlc3RvcmF0aW9uLCBhbGwgY2FsbHMgdG8gdHJpZ2dlcigpLlxuICAgICAqIFRoaXMgYWxzbyBzZXRzIHVwIGEgdGVtcG9yYXJ5IHByb3BlcnR5IG9uIHRoZSBtb2RlbCwgX3N1cHByZXNzRXZlbnRzLCB3aGljaCBpcyBhIGxpc3Qgb2YgZXZlbnRzIHRvIG5vdFxuICAgICAqIHNlbmQgd2hlbiByZXBsYXlUcmlnZ2VycyBpcyBjYWxsZWQuXG4gICAgICovXG4gICAgZnVuY3Rpb24gaW50ZXJjZXB0VHJpZ2dlcihtb2RlbCkge1xuICAgICAgICBtb2RlbC5fcXVldWVkRXZlbnRzID0gW107XG4gICAgICAgIG1vZGVsLl9zdG9yZWRUcmlnZ2VyRnVuY3Rpb24gPSBtb2RlbC50cmlnZ2VyO1xuICAgICAgICBtb2RlbC5fc3VwcHJlc3NFdmVudHMgPSBbXTtcbiAgICAgICAgbW9kZWwudHJpZ2dlciA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgbW9kZWwuX3F1ZXVlZEV2ZW50cy5wdXNoKGFyZ3VtZW50cyk7XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgLypcbiAgICAgKiBTZW5kIGFsbCBwYXVzZWQgZXZlbnRzIG9uIHRoZWlyIHdheSwgd2l0aCBzb21lIG1vZGlmaWNhdGlvbnMgaW5jbHVkaW5nOiBzdXBwcmVzc2luZyBjZXJ0YWluIG5hbWVkIGV2ZW50cywgYW5kXG4gICAgICogYXNzdXJpbmcgYSBjaGFuZ2UgZXZlbnQgaXMgc2VudCBhZnRlciBhbGwgY2hhbmdlOmF0dHJOYW1lIGV2ZW50cyAoYnV0IG5vdCBpZiB0aGVyZSBhcmUgbm9uZSlcbiAgICAgKi9cbiAgICBmdW5jdGlvbiByZXBsYXlUcmlnZ2Vycyhtb2RlbCkge1xuICAgICAgICB2YXIgY2hhbmdlRXZlbnQ7XG4gICAgICAgIHZhciBzZWVuQXR0ckNoYW5nZSA9IGZhbHNlO1xuICAgICAgICBtb2RlbC50cmlnZ2VyID0gbW9kZWwuX3N0b3JlZFRyaWdnZXJGdW5jdGlvbjtcbiAgICAgICAgZGVsZXRlIG1vZGVsLl9zdG9yZWRUcmlnZ2VyRnVuY3Rpb247XG5cbiAgICAgICAgXy5lYWNoKG1vZGVsLl9xdWV1ZWRFdmVudHMsIGZ1bmN0aW9uKGFyZ3MpIHtcbiAgICAgICAgICAgIC8vIGRvbid0IHNlbmQgdGhlIGNoYW5nZSBldmVudCB5ZXRcbiAgICAgICAgICAgIGlmIChhcmdzWzBdID09PSAnY2hhbmdlJykge1xuICAgICAgICAgICAgICAgIGNoYW5nZUV2ZW50ID0gYXJncztcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIGRvbid0IHNlbmQgZXZlbnRzIHdlIGFyZSB0byBzdXBwcmVzc1xuICAgICAgICAgICAgaWYgKF8uY29udGFpbnMobW9kZWwuX3N1cHByZXNzRXZlbnRzLCBhcmdzWzBdKSkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGFyZ3NbMF0uaW5kZXhPZignY2hhbmdlOicpID09PSAwKSB7XG4gICAgICAgICAgICAgICAgc2VlbkF0dHJDaGFuZ2UgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbW9kZWwudHJpZ2dlci5hcHBseShtb2RlbCwgYXJncyk7XG4gICAgICAgIH0pO1xuICAgICAgICBkZWxldGUgbW9kZWwuX3F1ZXVlZEV2ZW50cztcbiAgICAgICAgZGVsZXRlIG1vZGVsLl9zdXBwcmVzc0V2ZW50cztcblxuICAgICAgICBpZiAoY2hhbmdlRXZlbnQpIHtcbiAgICAgICAgICAgIG1vZGVsLnRyaWdnZXIoY2hhbmdlRXZlbnQpO1xuICAgICAgICB9IGVsc2UgaWYgKHNlZW5BdHRyQ2hhbmdlKSB7XG4gICAgICAgICAgICBtb2RlbC50cmlnZ2VyKCdjaGFuZ2UnLCBtb2RlbCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKlxuICAgICAqIEJhY2tib25lIGRlZmluZXMgdGhpcyBhczogUmV0dXJucyB0cnVlIGlmIHRoZSBhdHRyaWJ1dGUgaXMgc2V0IHRvIGEgbm9uLW51bGwgb3Igbm9uLXVuZGVmaW5lZCB2YWx1ZS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBkeEhhcyhhdHRyTmFtZSkge1xuICAgICAgICBpZiAoIV8uaXNTdHJpbmcoYXR0ck5hbWUpKSB7XG4gICAgICAgICAgICBkeFV0aWwuZmFpbCgnTXVzdCBwcm92aWRlIGFuIGF0dHJpYnV0ZSBuYW1lLicpO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGluZm8gPSBnZXRBdHRySW5mbyh0aGlzLCBhdHRyTmFtZSk7XG5cbiAgICAgICAgLy8gZHhHZXQgd2lsbCB0aHJvdyBhbiBleGNlcHRpb24gZm9yIHVua25vd24gYXR0cmlidXRlcywgc28gcmVhY2ggZGlyZWN0bHkgaW50byB0aGUgYXR0cmlidXRlcyB0byBhdm9pZCB0aGlzXG4gICAgICAgIHJldHVybiBpbmZvLmJhc2VOYW1lICYmICFkeFV0aWwuaXNOb25lKHRoaXMuYXR0cmlidXRlc1tpbmZvLmJhc2VOYW1lXSk7XG4gICAgfVxuXG4gICAgLypcbiAgICAgKiBCYWNrYm9uZSBkZWZpbmVzIHRoaXMgYXM6IFJlbW92ZSBhbiBhdHRyaWJ1dGUgYnkgZGVsZXRpbmcgaXQgZnJvbSB0aGUgaW50ZXJuYWwgYXR0cmlidXRlcyBoYXNoLiBGaXJlcyBhICdjaGFuZ2UnXG4gICAgICogZXZlbnQgdW5sZXNzIHNpbGVudCBpcyBwYXNzZWQgYXMgYW4gb3B0aW9uLlxuICAgICAqXG4gICAgICogRm9yIERTQiBtb2RlbHMsIHRoZSBiZWhhdmlvciBpcyBhIGJpdCBkaWZmZXJlbnQ6XG4gICAgICogIDEpIENhbGxpbmcgdW5zZXQoKSBvbiBhIGRlZmluZWQgYXR0cmlidXRlIHdpbGwgY2F1c2UgdGhhdCB0byBiZSByZXNldCB0byBpdHMgZGVmYXVsdCB2YWx1ZSwgdW5sZXNzIGl0IGlzIGFuXG4gICAgICogICAgIGVtYmVkZGVkIG9iamVjdCwgaW4gd2hpY2ggY2FzZSBpdCBpcyBlcXVpdmFsZW50IHRvIGNhbGxpbmcgY2xlYXIoKSBvbiBpdC5cbiAgICAgKiAgMikgQ2FsbGluZyB1bnNldCgpIGFuIGF0dHJpYnV0ZSB0aGF0IGlzbid0IGRlZmluZWQgaW4gdGhlIHNjaGVtYXMgd2lsbCB0aHJvdyBhbiBlcnJvclxuICAgICAqICAzKSBjYWxsaW5nIHVuc2V0KCckYXR0cmlidXRlJykgd2lsbCB1bnNldCAnYXR0cmlidXRlJ1xuICAgICAqICA0KSBUaGlzIGNvbnNpZGVycyB0aGUgZGVmYXVsdCBvZiBhICd0eXBlJyBhdHRyaWJ1dGUgdG8gYmUgdGhlIHNjaGVtYSBuYW1lLCBhbmQgc28gdW5zZXQgd2lsbCBuZXZlciBhY3R1YWxseVxuICAgICAqICAgICBjaGFuZ2UgaXQuXG4gICAgICovXG4gICAgZnVuY3Rpb24gZHhVbnNldChhdHRyTmFtZSwgb3B0aW9ucykge1xuICAgICAgICB2YXIgaW5mbyA9IGFzc2VydEFuZEdldEF0dHJJbmZvKHRoaXMsIGF0dHJOYW1lKTtcblxuICAgICAgICBpZiAoYXR0ck5hbWUgPT09ICd0eXBlJykge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGlzRW1iZWRkZWRQcm9wKGluZm8ucHJvcERlZikpIHtcbiAgICAgICAgICAgIHRoaXMuYXR0cmlidXRlc1thdHRyTmFtZV0uY2xlYXIob3B0aW9ucyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnNldChpbmZvLmJhc2VOYW1lLCBkZWZhdWx0Rm9yKGluZm8ucHJvcERlZiwgdGhpcy5fZHhJc0NsaWVudE1vZGVsKSwgb3B0aW9ucyk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKlxuICAgICAqIEJhY2tib25lIGRlZmluZXMgdGhpcyBhczogUmVtb3ZlcyBhbGwgYXR0cmlidXRlcyBmcm9tIHRoZSBtb2RlbCwgaW5jbHVkaW5nIHRoZSBpZCBhdHRyaWJ1dGUuIEZpcmVzIGEgJ2NoYW5nZSdcbiAgICAgKiBldmVudCB1bmxlc3Mgc2lsZW50IGlzIHBhc3NlZCBhcyBhbiBvcHRpb24uXG4gICAgICpcbiAgICAgKiBGb3IgRFNCIG1vZGVscywgdGhpcyByZXNldHMgYWxsIGF0dHJpYnV0ZXMgdG8gdGhlaXIgZGVmYXVsdCB2YWx1ZXMsIHVubGVzcyB0aGV5IGFyZSBlbWJlZGRlZCBvYmplY3RzLCBpbiB3aGljaFxuICAgICAqIGNhc2UgY2xlYXIoKSBpcyByZWN1cnNpdmVseSBjYWxsZWQgb24gdGhlbS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBkeENsZWFyKG9wdGlvbnMpIHtcbiAgICAgICAgdmFyIGNoYW5nZXMgPSB7fTtcbiAgICAgICAgXy5lYWNoKHRoaXMuX2R4U2NoZW1hLnByb3BlcnRpZXMsIGZ1bmN0aW9uKHByb3BEZWYsIHByb3BOYW1lKSB7XG4gICAgICAgICAgICBpZiAocHJvcE5hbWUgPT09ICd0eXBlJykge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChpc0VtYmVkZGVkUHJvcChwcm9wRGVmKSkge1xuICAgICAgICAgICAgICAgIHRoaXMuYXR0cmlidXRlc1twcm9wTmFtZV0uX2R4Q2xlYXIob3B0aW9ucyk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGNoYW5nZXNbcHJvcE5hbWVdID0gZGVmYXVsdEZvcihwcm9wRGVmLCB0aGlzLl9keElzQ2xpZW50TW9kZWwpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LCB0aGlzKTtcblxuICAgICAgICBpZiAoIV8uaXNFbXB0eShjaGFuZ2VzKSkge1xuICAgICAgICAgICAgdGhpcy5fZHhTZXQoY2hhbmdlcywgb3B0aW9ucyk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKlxuICAgICAqIEJhY2tib25lIGRlZmluZXMgdGhpcyBhczogUmV0dXJuIGEgY29weSBvZiB0aGUgbW9kZWwncyBhdHRyaWJ1dGVzIGZvciBKU09OIHN0cmluZ2lmaWNhdGlvbi4gVGhpcyBjYW4gYmUgdXNlZCBmb3JcbiAgICAgKiBwZXJzaXN0ZW5jZSwgc2VyaWFsaXphdGlvbiwgb3IgZm9yIGF1Z21lbnRhdGlvbiBiZWZvcmUgYmVpbmcgc2VudCB0byB0aGUgc2VydmVyLlxuICAgICAqXG4gICAgICogT3VyIGRpZmZlcmVuY2VzIGFyZSB0aGF0IHdlIHdpbGwgcmVjdXJzaXZlbHkgY2FsbCB0aGlzIG9uIGFueSBlbWJlZGRlZCBvYmplY3RzLCBhbmQgd2UgZG8gZGVlcCBjbG9uZXMgb2YgYW55XG4gICAgICogb2JqZWN0cyBvciBhcnJheXMuXG4gICAgICovXG4gICAgZnVuY3Rpb24gZHhUb0pTT04oKSB7XG4gICAgICAgIHJldHVybiBqc29uSXplKHRoaXMpO1xuICAgIH1cblxuICAgIC8qXG4gICAgICogV3JhcHBlciBhcm91bmQgc3RhbmRhcmQgQmFja2JvbmUgdXJsKCkuICBXZSBkbyB0aGlzIGJlY2F1c2Ugd2UgYnVpbGQgYSBjb21tb24gdXJsIGFjY2VzcyBzY2hlbWUgdGhhdCBpc1xuICAgICAqIGF2YWlsYWJsZSB0byBib3RoIHJvb3Qgb3BlcmF0aW9ucyBhbmQgb2JqZWN0IG9wZXJhdGlvbnMuXG4gICAgICovXG4gICAgZnVuY3Rpb24gZHhVcmwoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnVybCgpO1xuICAgIH1cblxuICAgIC8qXG4gICAgICogQmFja2JvbmUgZGVmaW5lcyB0aGlzIGFzOiBwYXJzZSgpIGlzIGNhbGxlZCB3aGVuZXZlciBhIG1vZGVsJ3MgZGF0YSBpcyByZXR1cm5lZCBieSB0aGUgc2VydmVyLiBUaGUgZnVuY3Rpb24gaXNcbiAgICAgKiBwYXNzZWQgdGhlIHJhdyByZXNwb25zZSBvYmplY3QsIGFuZCByZXR1cm5zIHRoZSBhdHRyaWJ1dGVzIGhhc2ggdG8gYmUgc2V0IG9uIHRoZSBtb2RlbC5cbiAgICAgKlxuICAgICAqIERlbHBoaXggdmFsdWVzIHJldHVybmVkIGZyb20gdGhlIHNlcnZlciBjb21lIGluIHNldmVyYWwgZmxhdm9yczpcbiAgICAgKiAgMSkgYW4gRXJyb3JSZXN1bHQuIFRoaXMgbWVhbnMgdGhhdCB3aGF0ZXZlciByZXF1ZXN0IGdvdCB0byB1cyBmYWlsZWQuXG4gICAgICogIDIpIGFuIE9LUmVzdWx0LiBUaGlzIGlzIHRoZSByZXN1bHQgb2YgYSBzdWNjZXNzZnVsIGNhbGxcbiAgICAgKiAgMykgYSAnbmFrZWQnIERlbHBoaXggb2JqZWN0IHR5cGUuIFRoaXMgaGFwcGVucyB3aGVuIGEgY29sbGVjdGlvbiBpcyBwYXJzaW5nIGVhY2ggb2JqZWN0IGluIGl0cyByZXR1cm5lZCBhcnJheS5cbiAgICAgKiAgNCkgYSBMaXN0UmVzdWx0LCBvciBvdGhlciBEZWxwaGl4IHJldHVybiB2YWx1ZS4gIFRoZXNlIHNob3VsZCBuZXZlciBoYXBwZW4gaGVyZS5cbiAgICAgKlxuICAgICAqIEluIHRoZSBjYXNlIG9mIHByb2JsZW1zIChjYXNlcyAxIGFuZCA0KSwgd2UgcmV0dXJuIHVuZGVmaW5lZCAod2UgcmVwb3J0IHRoZSBlcnJvciByZXN1bHQgdGhyb3VnaCB0aGUgZXJyb3IgcmVzdWx0XG4gICAgICogaGFuZGxlcikuICBGb3IgMiB3ZSBleHRyYWN0IHRoZSBvYmplY3QgaW4gdGhlIHJlc3VsdCBhbmQgcmV0dXJuIHRoYXQuIEZvciAzLCBhc3N1bWluZyB0aGUgdHlwZSBpcyBvbmUgd2Uga25vdyxcbiAgICAgKiByZXR1cm4gdGhhdCB1bmNoYW5nZWQuICBJZiBpdCBpcyBhbiB1bmtub3duIHR5cGUsIGhvd2V2ZXIsIHdlIGxvZyBhbiBlcnJvciBhbmQgcmV0dXJuIHVuZGVmaW5lZC4gQW4gdW5kZWZpbmVkXG4gICAgICogcmV0dXJuIHZhbHVlIGluZGljYXRlcyB0aGF0IHRoZXJlIGlzIG5vIGRhdGEgdG8gYmUgcGFyc2VkIG91dCBvZiB0aGUgcmVzcG9uc2UuXG4gICAgICovXG4gICAgZnVuY3Rpb24gZHhQYXJzZShyZXNwb25zZSkge1xuICAgICAgICBpZiAoIXJlc3BvbnNlIHx8ICFyZXNwb25zZS50eXBlKSB7XG4gICAgICAgICAgICBkeFV0aWwud2FybignR290IGFuIHVuZGVmaW5lZCByZXNwb25zZSwgb3Igb25lIHdpdGhvdXQgYSB0eXBlIGluIHBhcnNlKCkuJyk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBpZiAocmVzcG9uc2UudHlwZSA9PT0gJ09LUmVzdWx0Jykge1xuICAgICAgICAgICAgcmV0dXJuIHJlc3BvbnNlLnJlc3VsdDtcbiAgICAgICAgfSBlbHNlIGlmIChpc1NjaGVtYVR5cGUocmVzcG9uc2UudHlwZSkpIHtcbiAgICAgICAgICAgIHJldHVybiByZXNwb25zZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGR4VXRpbC53YXJuKCdHb3QgYW4gdW5leHBlY3RlZCB0eXBlIG9mIHJlc3BvbnNlICgnICsgcmVzcG9uc2UudHlwZSArICcpIGluIHBhcnNlKCkuJyk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKlxuICAgICAqIEJhY2tib25lIGRlZmluZXMgdGhpcyBhczogUmV0dXJucyBhIG5ldyBpbnN0YW5jZSBvZiB0aGUgbW9kZWwgd2l0aCBpZGVudGljYWwgYXR0cmlidXRlcy5cbiAgICAgKlxuICAgICAqIEZvciBEU0IgbW9kZWxzLCB0aGlzIHJldHVybnMgYSBjbGllbnQgbW9kZWwgdGhhdCBpcyBhIGRlZXAgY29weSBvZiB0aGUgbW9kZWwuIEFsbCBlbWJlZGRlZCBtb2RlbHMgYXJlIGFsc29cbiAgICAgKiBtYWRlIGFzIGNsaWVudCBtb2RlbHMuXG4gICAgICovXG4gICAgZnVuY3Rpb24gZHhDbG9uZSgpIHtcbiAgICAgICAgdmFyIG5ld01vZGVsID0gbmV3Q2xpZW50TW9kZWwodGhpcy5fZHhTY2hlbWEubmFtZSk7XG5cbiAgICAgICAgbmV3TW9kZWwuc2V0KHRoaXMudG9KU09OKCkpO1xuICAgICAgICBuZXdNb2RlbC5jaGFuZ2VkID0ge307ICAvLyBTaGhoLiB3ZSBkaWRuJ3QgYWN0dWFsbHkgY2hhbmdlIGFueXRoaW5nIVxuXG4gICAgICAgIHJldHVybiBuZXdNb2RlbDtcbiAgICB9XG5cbiAgICAvKlxuICAgICAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgcHJvdmlkZWQgdHlwZSBuYW1lIGlzIHRoaXMgb2JqZWN0J3MgdHlwZSBuYW1lLCBvciB0aGUgdHlwZSBuYW1lIG9mIG9uZSBvZiB0aGlzIG1vZGVsJ3NcbiAgICAgKiBleHRlbmRlZCB0eXBlcy4gIFdpbGwgdGhyb3cgYW4gZXhjZXB0aW9uIGlmIHRoZSBwcm92aWRlZCB0eXBlIG5hbWUgaXNuJ3Qgb25lIG9mIHRoZSBzY2hlbWEgdHlwZXMuXG4gICAgICovXG4gICAgZnVuY3Rpb24gaW5zdGFuY2VPZih0eXBlTmFtZSkge1xuICAgICAgICBpZiAoIV8uaXNTdHJpbmcodHlwZU5hbWUpKSB7XG4gICAgICAgICAgICBkeFV0aWwuZmFpbCgnaW5zdGFuY2VPZigpIHJlcXVpcmVzIGEgdHlwZSBuYW1lIGFzIGEgcGFyYW1ldGVyLicpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFpc1NjaGVtYVR5cGUodHlwZU5hbWUpKSB7XG4gICAgICAgICAgICBkeFV0aWwuZmFpbCh0eXBlTmFtZSArICcgaXMgbm90IGEga25vd24gdHlwZSBuYW1lLicpO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGNhbmRpZGF0ZVR5cGVJbmZvID0gdGhpcy5fZHhTY2hlbWE7XG5cbiAgICAgICAgd2hpbGUgKGNhbmRpZGF0ZVR5cGVJbmZvKSB7XG4gICAgICAgICAgICBpZiAoY2FuZGlkYXRlVHlwZUluZm8ubmFtZSA9PT0gdHlwZU5hbWUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY2FuZGlkYXRlVHlwZUluZm8gPSBjYW5kaWRhdGVUeXBlSW5mby5wYXJlbnRTY2hlbWE7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaXNTZXJ2ZXJNb2RlbCgpIHtcbiAgICAgICAgcmV0dXJuICF0aGlzLl9keElzQ2xpZW50TW9kZWw7XG4gICAgfVxuXG4gICAgLypcbiAgICAgKiBFbnRpcmVseSBibG9jayB0aGUgc3RhbmRhcmQgQmFja2JvbmUgZGVzdHJveSgpIHJvdXRpbmUuIFdlIHdhbnQgdXNlcnMgdG8gY2FsbCAkJGRlbGV0ZSgpIGluc3RlYWQuXG4gICAgICovXG4gICAgZnVuY3Rpb24gbm9EZXN0cm95KCkge1xuICAgICAgICBkeFV0aWwuZmFpbCgnRG8gbm90IGNhbGwgZGVzdHJveSgpIGRpcmVjdGx5LiBJbnN0ZWFkLCBjYWxsICQkZGVsZXRlKCkuJyk7XG4gICAgfVxuXG4gICAgLypcbiAgICAgKiBEZWxldGUgdGhpcyBtb2RlbCBvbiB0aGUgc2VydmVyLiAgT24gc3VjY2VzcywgdGhpcyB3aWxsIGNsZWFyKCkgdGhpcyBtb2RlbC4gIFRoaXMgd2lsbCBhbHNvIGZpcmVcbiAgICAgKiBhICdyZXF1ZXN0JyBldmVudCBvbiB0aGUgbW9kZWwgYmVmb3JlIG1ha2luZyB0aGUgY2FsbCwgYW5kIGEgJ3N5bmMnIGFuZCAnZGVzdHJveScgYWZ0ZXJ3YXJkcyBvbiBzdWNjZXNzLlxuICAgICAqIERlcGVuZGluZyBvbiB0aGUgdW5kZXJseWluZyBzY2hlbWEgZGVmaW5pdGlvbiwgdGhpcyBjYW4gYmUgY2FsbGVkIGluIGFueSBvZiB0aGVzZSB3YXlzOlxuICAgICAqICAgICQkZGVsZXRlKFtzdWNjZXNzRXJyb3JdKSAgLy8gaW4gY2FzZSBvZiBubyBwYXlsb2FkIGRlZmluZWRcbiAgICAgKiAgICAkJGRlbGV0ZShwYXlsb2FkWywgc3VjY2Vzc0Vycm9yXSkgIC8vIGluIGNhc2Ugb2YgcGF5bG9hZCByZXF1aXJlZFxuICAgICAqICAgICQkZGVsZXRlKFtwYXlsb2FkXVssIHN1Y2Nlc3NFcnJvcl0pICAvLyBpbiBjYXNlIG9mIHBheWxvYWQgb3B0aW9uYWxcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBkeERlbGV0ZShhcmcxLCBhcmcyKSB7XG4gICAgICAgIHZhciBvcERlZiA9IHRoaXMuX2R4U2NoZW1hLmRlbGV0ZTtcblxuICAgICAgICBpZiAoKGFyZzEgaW5zdGFuY2VvZiBCYWNrYm9uZS5Nb2RlbCkgJiYgIW9wRGVmLnBheWxvYWQpIHtcbiAgICAgICAgICAgIGR4VXRpbC5mYWlsKCckJGRlbGV0ZSBkb2VzIG5vdCBhbGxvdyBhIHBheWxvYWQuJyk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgcGF5bG9hZCA9IGFyZzE7XG4gICAgICAgIHZhciBzdWNjZXNzRXJyb3IgPSBhcmcyO1xuICAgICAgICBpZiAoIW9wRGVmLnBheWxvYWQgfHxcbiAgICAgICAgICAgICFvcERlZi5yZXF1aXJlZCAmJiAhKGFyZzEgaW5zdGFuY2VvZiBCYWNrYm9uZS5Nb2RlbCkpIHtcbiAgICAgICAgICAgIHBheWxvYWQgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICBzdWNjZXNzRXJyb3IgPSBhcmcxO1xuICAgICAgICB9XG5cbiAgICAgICAgYXNzZXJ0SGFzUmVmZXJlbmNlQXR0cih0aGlzLCAnJGRlbGV0ZScsIHRydWUpO1xuICAgICAgICB2YXIgcHJlcGFyZWREYXRhID0gYXNzZXJ0QW5kUHJlcGFyZVBheWxvYWQoJyRkZWxldGUnLCBvcERlZiwgcGF5bG9hZCk7XG5cbiAgICAgICAgcmV0dXJuIGNhbGxPcGVyYXRpb24odGhpcywge1xuICAgICAgICAgICAgZGF0YTogcHJlcGFyZWREYXRhLFxuICAgICAgICAgICAgdXJsOiB0aGlzLnVybCgpXG4gICAgICAgIH0sICdERUxFVEUnLCBvcERlZiwgc3VjY2Vzc0Vycm9yKTtcbiAgICB9XG5cbiAgICAvKlxuICAgICAqIENyZWF0ZSBhIG5ldyBvYmplY3Qgb24gdGhlIHNlcnZlci4gSXQgaXMgbm9ybWFsbHkgY2FsbGVkIGxpa2UgdGhpczpcbiAgICAgKiAgICAkJGNyZWF0ZShwYXlsb2FkWywgc3VjY2Vzc0Vycm9yXSlcbiAgICAgKiBIb3dldmVyLCBpdCBjb3VsZCBiZSBjYWxsZWQgaW4gdGhlIGZvbGxvd2luZyB3YXlzIHNob3VsZCBhIHNjaGVtYSBvbmUgZGF5IG5vdCByZXF1aXJlIHBheWxvYWQgdG8gZG8gY3JlYXRlXG4gICAgICogICAgJCRjcmVhdGUoW3N1Y2Nlc3NFcnJvcl0pICAvLyBpbiBjYXNlIG9mIG5vIHBheWxvYWQgZGVmaW5lZFxuICAgICAqICAgICQkY3JlYXRlKFtwYXlsb2FkXVssIHN1Y2Nlc3NFcnJvcl0pICAvLyBpbiBjYXNlIG9mIHBheWxvYWQgb3B0aW9uYWxcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBkeENyZWF0ZShvcERlZiwgdXJsLCBhcmcxLCBhcmcyKSB7XG4gICAgICAgIGlmICgoYXJnMSBpbnN0YW5jZW9mIEJhY2tib25lLk1vZGVsKSAmJiAhb3BEZWYucGF5bG9hZCkge1xuICAgICAgICAgICAgZHhVdGlsLmZhaWwoJyQkY3JlYXRlIGRvZXMgbm90IGFsbG93IGEgcGF5bG9hZC4nKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBwYXlsb2FkID0gYXJnMTtcbiAgICAgICAgdmFyIHN1Y2Nlc3NFcnJvciA9IGFyZzI7XG4gICAgICAgIGlmICghb3BEZWYucGF5bG9hZCB8fFxuICAgICAgICAgICAgIW9wRGVmLnJlcXVpcmVkICYmICEoYXJnMSBpbnN0YW5jZW9mIEJhY2tib25lLk1vZGVsKSkge1xuICAgICAgICAgICAgcGF5bG9hZCA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIHN1Y2Nlc3NFcnJvciA9IGFyZzE7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gY2FsbE9wZXJhdGlvbih7fSwge1xuICAgICAgICAgICAgZGF0YTogYXNzZXJ0QW5kUHJlcGFyZVBheWxvYWQoJyRjcmVhdGUnLCBvcERlZiwgcGF5bG9hZCksXG4gICAgICAgICAgICB1cmw6IHVybFxuICAgICAgICB9LCAnUE9TVCcsIG9wRGVmLCBzdWNjZXNzRXJyb3IpO1xuICAgIH1cblxuICAgIC8qXG4gICAgICogRW50aXJlbHkgYmxvY2sgdGhlIHN0YW5kYXJkIEJhY2tib25lIHNhdmUoKSByb3V0aW5lLiBXZSB3YW50IHVzZXJzIHRvIGNhbGwgJCR1cGRhdGUoKSBpbnN0ZWFkLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIG5vU2F2ZSgpIHtcbiAgICAgICAgZHhVdGlsLmZhaWwoJ0RvIG5vdCBjYWxsIHNhdmUoKSBkaXJlY3RseS4gSW5zdGVhZCwgY2FsbCAkJHVwZGF0ZSgpLicpO1xuICAgIH1cblxuICAgIC8qXG4gICAgICogVXBkYXRlIHRoZSB2ZXJzaW9uIG9mIHRoaXMgbW9kZWwgb24gdGhlIHNlcnZlci4gVGhpcyBzZW5kcyB0byB0aGUgc2VydmVyOlxuICAgICAqICAxKSBBbnkgcmVxdWlyZWQgb3IgdXBkYXRlOnJlcXVpcmVkIGF0dHJpYnV0ZXMgZGVmaW5lZCBmb3IgdGhpcyB0eXBlXG4gICAgICogIDIpIEFueSByZXF1aXJlZDpmYWxzZSBvciB1cGRhdGU6b3B0aW9uYWwgYXR0cmlidXRlcyBmcm9tIHRoZSBzZXQgcGFzc2VkIGluIHRoaXMgZnVuY3Rpb25cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBkeFVwZGF0ZShhdHRyaWJ1dGVzLCBzdWNjZXNzRXJyb3IpIHtcbiAgICAgICAgdmFyIG9wRGVmID0gdGhpcy5fZHhTY2hlbWEudXBkYXRlO1xuXG4gICAgICAgIGlmIChkeFV0aWwuaXNOb25lKGF0dHJpYnV0ZXMpIHx8IF8uaXNFbXB0eShhdHRyaWJ1dGVzKSkge1xuICAgICAgICAgICAgZHhVdGlsLmZhaWwoJyQkdXBkYXRlIG11c3QgYmUgY2FsbGVkIHdpdGggYSBub24tZW1wdHkgc2V0IG9mIGF0dHJpYnV0ZXMuJyk7XG4gICAgICAgIH1cbiAgICAgICAgYXNzZXJ0SGFzUmVmZXJlbmNlQXR0cih0aGlzLCAnJHVwZGF0ZScsICF0aGlzLl9keFNjaGVtYS5zaW5nbGV0b24pO1xuXG4gICAgICAgIHZhciBuZXdNb2RlbCA9IHRoaXMuY2xvbmUoKTtcbiAgICAgICAgbmV3TW9kZWwuc2V0KGF0dHJpYnV0ZXMpO1xuXG4gICAgICAgIHZhciBwcmVwYXJlZERhdGEgPSBKU09OLnN0cmluZ2lmeShqc29uSXplRm9yVXBkYXRlKGF0dHJpYnV0ZXMsIG5ld01vZGVsLCB0aGlzLCB0cnVlKSk7XG5cbiAgICAgICAgcmV0dXJuIGNhbGxPcGVyYXRpb24odGhpcywge1xuICAgICAgICAgICAgZGF0YTogcHJlcGFyZWREYXRhLFxuICAgICAgICAgICAgdXJsOiB0aGlzLl9keEdldFVybCgpXG4gICAgICAgIH0sICdQT1NUJywgb3BEZWYsIHN1Y2Nlc3NFcnJvcik7XG4gICAgfVxuXG4gICAgLypcbiAgICAgKiBFbnRpcmVseSBibG9jayB0aGUgc3RhbmRhcmQgQmFja2JvbmUgZmV0YygpIHJvdXRpbmUuXG4gICAgICovXG4gICAgZnVuY3Rpb24gbm9GZXRjaCgpIHtcbiAgICAgICAgZHhVdGlsLmZhaWwoJ0RvIG5vdCBjYWxsIGZldGNoKCkgZGlyZWN0bHkuIEluc3RlYWQsIGNhbGwgZ2V0U2VydmVyTW9kZWwoKS4nKTtcbiAgICB9XG5cbiAgICAvKlxuICAgICAqIE1hcmsgdGhlIHNwZWNpZmllZCBtb2RlbCBhcyAncmVhZHknLiBUaGUgJ3RyaWdnZXJOb3RpZnknIHBhcmFtZXRlciBjb250cm9scyB3aGV0aGVyIHdlIHRyaWdnZXIgdGhlICdyZWFkeSdcbiAgICAgKiBldmVudC4gVGhpcyBpcyBleHBvc2VkIHRvIHRoZSBsZXZlbDMgQVBJIHNvIHRoYXQgYSBjb2xsZWN0aW9uIGNhbiBiZSBtYXJrZWQgYXMgcmVhZHkgYmVmb3JlIG5vdGlmeWluZyBjb25zdW1lcnMuXG4gICAgICovXG4gICAgZnVuY3Rpb24gbWFrZVJlYWR5KG1vZGVsLCB0cmlnZ2VyTm90aWZ5KSB7XG4gICAgICAgIG1vZGVsLl9keElzUmVhZHkgPSB0cnVlO1xuXG4gICAgICAgIF8uZWFjaChtb2RlbC5fZHhTY2hlbWEucHJvcGVydGllcywgZnVuY3Rpb24ocHJvcERlZiwgcHJvcE5hbWUpIHtcbiAgICAgICAgICAgIGlmIChpc0VtYmVkZGVkUHJvcChwcm9wRGVmKSAmJiBtb2RlbC5nZXQocHJvcE5hbWUpKSB7XG4gICAgICAgICAgICAgICAgbWFrZVJlYWR5KG1vZGVsLmdldChwcm9wTmFtZSksIHRyaWdnZXJOb3RpZnkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICBpZiAodHJpZ2dlck5vdGlmeSkge1xuICAgICAgICAgICAgdHJpZ2dlclJlYWR5KG1vZGVsKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qXG4gICAgICogSGFuZGxlIGFuIGVycm9yIGZvciBhIHN1Y2Nlc3NFcnJvciBjYWxsYmFjayBvciBhbiBhcnJheSBvZiBjYWxsYmFja3MuXG4gICAgICogVGhlIGNvbnRleHQgZXJyb3IgaGFuZGxlciBpcyBpbnZva2VkIG9uY2UgdW5sZXNzIGFsbCBjYWxsYmFja3MgZGVmaW5lIGEgY3VzdG9tIGVycm9yIGhhbmRsZXIuXG4gICAgICovXG4gICAgZnVuY3Rpb24gaGFuZGxlRXJyb3JSZXN1bHQocHJvY2Vzc2VkUmVzdWx0LCBzdWNjZXNzRXJyb3IpIHtcbiAgICAgICAgdmFyIGNhbGxiYWNrcyA9IF8uaXNBcnJheShzdWNjZXNzRXJyb3IpID8gc3VjY2Vzc0Vycm9yIDogW3N1Y2Nlc3NFcnJvcl07XG4gICAgICAgIHZhciByZXBvcnRlZEVycm9yID0gZmFsc2U7XG4gICAgICAgIF8uZWFjaChjYWxsYmFja3MsIGZ1bmN0aW9uKHN1Y2Nlc3NFcnJvcikge1xuICAgICAgICAgICAgaWYgKHN1Y2Nlc3NFcnJvciAmJiBzdWNjZXNzRXJyb3IuZXJyb3IpIHtcbiAgICAgICAgICAgICAgICBzdWNjZXNzRXJyb3IuZXJyb3IocHJvY2Vzc2VkUmVzdWx0KTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoIXJlcG9ydGVkRXJyb3IgJiYgKCFzdWNjZXNzRXJyb3IgfHwgIXN1Y2Nlc3NFcnJvci5zdXBwcmVzc0RlZmF1bHRFcnJvckhhbmRsZXIpKSB7XG4gICAgICAgICAgICAgICAgY29udGV4dC5yZXBvcnRFcnJvclJlc3VsdChwcm9jZXNzZWRSZXN1bHQpO1xuICAgICAgICAgICAgICAgIHJlcG9ydGVkRXJyb3IgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICAvKlxuICAgICAqIEZldGNoZXMgYSBtb2RlbCBmcm9tIHRoZSBzZXJ2ZXIsIHVzaW5nIEJhY2tib25lJ3Mgc3luYygpIGZ1bmN0aW9uIHVuZGVyIHRoZSBob29kLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGR4RmV0Y2goc3VjY2Vzc0Vycm9yKSB7XG4gICAgICAgIHZhciBtb2RlbCA9IHRoaXM7XG4gICAgICAgIG1vZGVsLl9keEZldGNoUXVldWUgPSBtb2RlbC5fZHhGZXRjaFF1ZXVlIHx8IFtdO1xuICAgICAgICBtb2RlbC5fZHhGZXRjaFF1ZXVlLnB1c2goc3VjY2Vzc0Vycm9yKTtcbiAgICAgICAgaWYgKG1vZGVsLl9keEZldGNoUXVldWUubGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgICBkeEZldGNoTm93KG1vZGVsKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGR4RmV0Y2hOb3cobW9kZWwpIHtcblxuICAgICAgICAvKlxuICAgICAgICAgKiBBcHBsaWVzIHRoZSBoYW5kbGVyIHRvIHRoZSBwZW5kaW5nIHJlcXVlc3QgcXVldWUuXG4gICAgICAgICAqXG4gICAgICAgICAqIElmIHRoZXJlIGlzIG1vcmUgdGhhbiBvbmUgY2FsbGJhY2sgaW4gdGhlIHF1ZXVlLCBhcHBseSB0aGUgcmVzcG9uc2UgdG8gZW50cmllcyAwLi5OLTIgYW5kIGlzc3VlIGEgbmV3XG4gICAgICAgICAqIGR4RmV0Y2ggZm9yIHRoZSBtb3N0IHJlY2VudCByZXF1ZXN0LlxuICAgICAgICAgKlxuICAgICAgICAgKiBJZiBkeEZldGNoIHJlcXVlc3RzIGFyZSBpc3N1ZWQgZHVyaW5nIGNhbGxiYWNrIGV4ZWN1dGlvbiwgdGhleSBkbyBub3QgcmVzb2x2ZSBpbW1lZGlhdGVseS5cbiAgICAgICAgICovXG4gICAgICAgIGZ1bmN0aW9uIG1ha2VIYW5kbGVyKG1haW5IYW5kbGVyKSB7XG4gICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gZHhGZXRjaENhbGxiYWNrSGFuZGxlcihhcmcpIHtcbiAgICAgICAgICAgICAgICB2YXIgcXVldWUgPSBtb2RlbC5fZHhGZXRjaFF1ZXVlO1xuICAgICAgICAgICAgICAgIGRlbGV0ZSBtb2RlbC5fZHhGZXRjaFF1ZXVlO1xuICAgICAgICAgICAgICAgIHZhciBjYWxsYmFja3MgPSBfLmZpcnN0KHF1ZXVlLCBNYXRoLm1heCgxLCBxdWV1ZS5sZW5ndGggLSAxKSk7XG4gICAgICAgICAgICAgICAgbWFpbkhhbmRsZXIoYXJnLCBjYWxsYmFja3MpO1xuICAgICAgICAgICAgICAgIGlmIChxdWV1ZS5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgICAgICAgICAgIG1vZGVsLl9keEZldGNoKF8ubGFzdChxdWV1ZSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgb3B0aW9ucyA9IHtcbiAgICAgICAgICAgIHBhcnNlOiB0cnVlLFxuICAgICAgICAgICAgc3VjY2VzczogbWFrZUhhbmRsZXIoZnVuY3Rpb24ocmVzcCwgY2FsbGJhY2tzKSB7XG4gICAgICAgICAgICAgICAgaWYgKHJlc3AgJiYgcmVzcC50eXBlID09PSAnRXJyb3JSZXN1bHQnKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBwcm9jZXNzZWRSZXN1bHQgPSByZXN1bHRUb01vZGVsKHJlc3ApO1xuICAgICAgICAgICAgICAgICAgICBtb2RlbC5fZHhFcnJvclJlc3VsdCA9IHByb2Nlc3NlZFJlc3VsdDtcbiAgICAgICAgICAgICAgICAgICAgdHJpZ2dlckVycm9yKG1vZGVsKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGhhbmRsZUVycm9yUmVzdWx0KHByb2Nlc3NlZFJlc3VsdCwgY2FsbGJhY2tzKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBtb2RlbC5fZHhFcnJvclJlc3VsdCA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICBtb2RlbC5fZHhTZXQobW9kZWwucGFyc2UocmVzcCksIG9wdGlvbnMpO1xuXG4gICAgICAgICAgICAgICAgbWFrZVJlYWR5KG1vZGVsLCB0cnVlKTtcblxuICAgICAgICAgICAgICAgIF8uZWFjaChjYWxsYmFja3MsIGZ1bmN0aW9uKHN1Y2Nlc3NFcnJvcikge1xuICAgICAgICAgICAgICAgICAgICBpZiAoc3VjY2Vzc0Vycm9yICYmIHN1Y2Nlc3NFcnJvci5zdWNjZXNzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdWNjZXNzRXJyb3Iuc3VjY2Vzcyhtb2RlbCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgIG1vZGVsLnRyaWdnZXIoJ3N5bmMnLCBtb2RlbCk7XG4gICAgICAgICAgICB9KSxcbiAgICAgICAgICAgIGVycm9yOiBtYWtlSGFuZGxlcihmdW5jdGlvbih4aHIsIGNhbGxiYWNrcykge1xuICAgICAgICAgICAgICAgIHZhciBlcnJvclJlc3VsdCA9IGNvbnZlcnRYaHJUb0Vycm9yUmVzdWx0KHhocik7XG4gICAgICAgICAgICAgICAgaGFuZGxlRXJyb3JSZXN1bHQoZXJyb3JSZXN1bHQsIGNhbGxiYWNrcyk7XG4gICAgICAgICAgICAgICAgaWYgKHhociAmJiB4aHIuc3RhdHVzID09PSA0MDQpIHtcbiAgICAgICAgICAgICAgICAgICAgbW9kZWwudHJpZ2dlcignYmFkUmVmZXJlbmNlJywgbW9kZWwsIGVycm9yUmVzdWx0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbW9kZWwuX2R4RXJyb3JSZXN1bHQgPSBlcnJvclJlc3VsdDtcbiAgICAgICAgICAgICAgICB0cmlnZ2VyRXJyb3IobW9kZWwpO1xuICAgICAgICAgICAgfSlcbiAgICAgICAgfTtcblxuICAgICAgICBCYWNrYm9uZS5zeW5jKCdyZWFkJywgbW9kZWwsIG9wdGlvbnMpO1xuICAgIH1cblxuICAgIC8qXG4gICAgICogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICAgICAqIE9wZXJhdGlvbnM6IGNyZWF0aW9uIGFuZCBoYW5kbGluZ1xuICAgICAqID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAgICAgKi9cblxuICAgIC8qXG4gICAgICogRXhhbWluZSB0aGUgb3BlcmF0aW9ucyBwcm92aWRlZCwgYW5kIGFkZCB0aGVtIHRvIHRoZSB0YXJnZXQgb2JqZWN0LlxuICAgICAqXG4gICAgICogdGFyZ2V0OiAgICAgVGhlIG9iamVjdCB0byBhZGQgdGhlIGNvbnN0cnVjdGVkIGZ1bmN0aW9ucyB0b1xuICAgICAqIG9wZXJhdGlvbnM6IEEgSlNPTiBvYmplY3Qgd2l0aCBrZXlzIGFzIHRoZSBvcGVyYXRpb24gbmFtZXMsIGFuZCAgdmFsdWVzIGFzIGRlZmluaXRpb25zIG9mIHRoYXQgb3BlcmF0aW9uLlxuICAgICAqIG5hbWVQcmVmaXggIEEgc3RyaW5nIHRvIHByZWZpeCB0byB0aGUgbmFtZSBvZiB0aGUgb3BlcmF0aW9uIHdoZW4gYWRkaW5nIHRvIHRoZSB0YXJnZXRcbiAgICAgKiB1cmxQcmVmaXg6ICBBIHN0cmluZyB0byBwcmVmaXggdG8gdGhlIGNvbnN0cnVjdGVkIHVybCBmb3IgdGhlIG9wZXJhdGlvblxuICAgICAqIHBlck9iamVjdDogIFdoZXRoZXIgdGhlc2Ugb3BlcmF0aW9ucyBhcmUgb25lcyB0aGF0IHJlcXVpcmUgdGhlIG9iamVjdCdzIHJlZmVyZW5jZS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBhZGRPcGVyYXRpb25zKHRhcmdldCwgb3BlcmF0aW9ucywgbmFtZVByZWZpeCwgdXJsUHJlZml4LCBwZXJPYmplY3QpIHtcbiAgICAgICAgXy5lYWNoKG9wZXJhdGlvbnMsIGZ1bmN0aW9uKG9wRGVmLCBvcE5hbWUpIHtcbiAgICAgICAgICAgIHZhciBvcEZ1bmN0aW9uO1xuICAgICAgICAgICAgdmFyIG9wVXJsID0gKHVybFByZWZpeCA9PT0gJycpID8gb3BOYW1lIDogdXJsUHJlZml4ICsgJy8nICsgb3BOYW1lO1xuXG4gICAgICAgICAgICBpZiAoIV8uaXNVbmRlZmluZWQob3BEZWYucGF5bG9hZCkpIHtcbiAgICAgICAgICAgICAgICBvcEZ1bmN0aW9uID0gKF8uaXNFbXB0eShvcERlZi5wYXlsb2FkKSkgP1xuICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbihzdWNjZXNzRXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBub1BheWxvYWRGdW5jdGlvbih0aGlzLCBvcFVybCwgb3BEZWYsIHBlck9iamVjdCwgc3VjY2Vzc0Vycm9yKTtcbiAgICAgICAgICAgICAgICAgICAgfSA6XG4gICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uKHBheWxvYWQsIHN1Y2Nlc3NGYWlsdXJlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcGF5bG9hZEZ1bmN0aW9uKHRoaXMsIG9wVXJsLCBvcERlZiwgcGVyT2JqZWN0LCBwYXlsb2FkLCBzdWNjZXNzRmFpbHVyZSk7XG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIG9wRnVuY3Rpb24gPSAoXy5pc0VtcHR5KG9wRGVmLnBhcmFtZXRlcnMpKSA/XG4gICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uKHN1Y2Nlc3NFcnJvcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5vUGFyYW1ldGVyc0Z1bmN0aW9uKHRoaXMsIG9wVXJsLCBvcERlZiwgcGVyT2JqZWN0LCBzdWNjZXNzRXJyb3IpO1xuICAgICAgICAgICAgICAgICAgICB9IDpcbiAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb24ocGFyYW1ldGVycywgc3VjY2Vzc0ZhaWx1cmUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBwYXJhbWV0ZXJzRnVuY3Rpb24odGhpcywgb3BVcmwsIG9wRGVmLCBwZXJPYmplY3QsIHBhcmFtZXRlcnMsIHN1Y2Nlc3NGYWlsdXJlKTtcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKF8uaGFzKG9wRGVmLCAnZHhPcGVyYXRpb25zJykpIHtcbiAgICAgICAgICAgICAgICBhZGRPcGVyYXRpb25zKHRhcmdldCwgb3BEZWYuZHhPcGVyYXRpb25zLCBuYW1lUHJlZml4ICsgb3BOYW1lICsgJ18nLCBvcFVybCwgcGVyT2JqZWN0KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGFyZ2V0WyckJyArIG5hbWVQcmVmaXggKyBvcE5hbWVdID0gb3BGdW5jdGlvbjtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgLypcbiAgICAgKiBDYWxsIGEgc2VydmVyIGZ1bmN0aW9uIHRoYXQgaGFzIG5vIHBheWxvYWQuXG4gICAgICovXG4gICAgZnVuY3Rpb24gbm9QYXlsb2FkRnVuY3Rpb24oY2FsbGVyLCBvcE5hbWUsIG9wRGVmLCBwZXJPYmplY3QsIHN1Y2Nlc3NFcnJvcikge1xuICAgICAgICBhc3NlcnRIYXNSZWZlcmVuY2VBdHRyKGNhbGxlciwgb3BOYW1lLCBwZXJPYmplY3QpO1xuXG4gICAgICAgIGlmIChzdWNjZXNzRXJyb3IgaW5zdGFuY2VvZiBCYWNrYm9uZS5Nb2RlbCkge1xuICAgICAgICAgICAgZHhVdGlsLmZhaWwoJyQnICsgb3BOYW1lICsgJyBjYW4gbm90IGJlIGNhbGxlZCB3aXRoIGEgcGF5bG9hZCAob25seSBhIHN1Y2Nlc3MvZXJyb3Igb2JqZWN0KS4nKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBjYWxsT3BlcmF0aW9uKGNhbGxlciwge1xuICAgICAgICAgICAgdXJsOiBjYWxsZXIuX2R4R2V0VXJsKCkgKyAnLycgKyBvcE5hbWVcbiAgICAgICAgfSwgJ1BPU1QnLCBvcERlZiwgc3VjY2Vzc0Vycm9yKTtcbiAgICB9XG5cbiAgICAvKlxuICAgICAqIENhbGwgYSBzZXJ2ZXIgZnVuY3Rpb24gdGhhdCBoYXMgYSBwYXlsb2FkICh3aGljaCBpcyBhbHdheXMgYSBzaW5nbGUgRFNCIG1vZGVsKS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBwYXlsb2FkRnVuY3Rpb24oY2FsbGVyLCBvcE5hbWUsIG9wRGVmLCBwZXJPYmplY3QsIHBheWxvYWQsIHN1Y2Nlc3NFcnJvcikge1xuICAgICAgICBhc3NlcnRIYXNSZWZlcmVuY2VBdHRyKGNhbGxlciwgb3BOYW1lLCBwZXJPYmplY3QpO1xuXG4gICAgICAgIHJldHVybiBjYWxsT3BlcmF0aW9uKGNhbGxlciwge1xuICAgICAgICAgICAgZGF0YTogYXNzZXJ0QW5kUHJlcGFyZVBheWxvYWQob3BOYW1lLCBvcERlZiwgcGF5bG9hZCksXG4gICAgICAgICAgICB1cmw6IGNhbGxlci5fZHhHZXRVcmwoKSArICcvJyArIG9wTmFtZVxuICAgICAgICB9LCAnUE9TVCcsIG9wRGVmLCBzdWNjZXNzRXJyb3IpO1xuICAgIH1cblxuICAgIC8qXG4gICAgICogQ2FsbCBhIHNlcnZlciBmdW5jdGlvbiB0aGF0IGlzIGEgJ0dFVCcsIGFuZCB0YWtlcyBubyBwYXJhbWV0ZXJzLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIG5vUGFyYW1ldGVyc0Z1bmN0aW9uKGNhbGxlciwgb3BOYW1lLCBvcERlZiwgcGVyT2JqZWN0LCBzdWNjZXNzRXJyb3IpIHtcbiAgICAgICAgYXNzZXJ0SGFzUmVmZXJlbmNlQXR0cihjYWxsZXIsIG9wTmFtZSwgcGVyT2JqZWN0KTtcblxuICAgICAgICByZXR1cm4gY2FsbE9wZXJhdGlvbihjYWxsZXIsIHtcbiAgICAgICAgICAgIHVybDogY2FsbGVyLl9keEdldFVybCgpICsgJy8nICsgb3BOYW1lXG4gICAgICAgIH0sICdHRVQnLCBvcERlZiwgc3VjY2Vzc0Vycm9yKTtcbiAgICB9XG5cbiAgICAvKlxuICAgICAqIENhbGwgYSBzZXJ2ZXIgZnVuY3Rpb24gdGhhdCBleHBlY3RzIG9uZSBvciBtb3JlIHBhcmFtZXRlcnMuXG4gICAgICovXG4gICAgZnVuY3Rpb24gcGFyYW1ldGVyc0Z1bmN0aW9uKGNhbGxlciwgb3BOYW1lLCBvcERlZiwgcGVyT2JqZWN0LCBwYXJhbWV0ZXJzLCBzdWNjZXNzRXJyb3IpIHtcbiAgICAgICAgdmFyIHNlbmRhYmxlUGFyYW1zO1xuICAgICAgICBhc3NlcnRIYXNSZWZlcmVuY2VBdHRyKGNhbGxlciwgb3BOYW1lLCBwZXJPYmplY3QpO1xuXG4gICAgICAgIGlmICghXy5pc09iamVjdChwYXJhbWV0ZXJzKSAmJiAhZHhVdGlsLmlzTm9uZShwYXJhbWV0ZXJzKSkge1xuICAgICAgICAgICAgZHhVdGlsLmZhaWwoJyQnICsgb3BOYW1lICsgJyBtdXN0IGJlIHBhc3NlZCBhIChwb3NzaWJseSBlbXB0eSkgaGFzaCBvZiBwYXJhbWV0ZXJzLicpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFkeFV0aWwuaXNOb25lKHBhcmFtZXRlcnMpKSB7XG4gICAgICAgICAgICBzZW5kYWJsZVBhcmFtcyA9IGNoZWNrQW5kQ29udmVydFBhcmFtZXRlcnMocGFyYW1ldGVycywgb3BEZWYucGFyYW1ldGVycyk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gY2FsbE9wZXJhdGlvbihjYWxsZXIsIHtcbiAgICAgICAgICAgIGRhdGE6IHNlbmRhYmxlUGFyYW1zLFxuICAgICAgICAgICAgdXJsOiBjYWxsZXIuX2R4R2V0VXJsKCkgKyAnLycgKyBvcE5hbWVcbiAgICAgICAgfSwgJ0dFVCcsIG9wRGVmLCBzdWNjZXNzRXJyb3IpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGFzc2VydEhhc1JlZmVyZW5jZUF0dHIobW9kZWwsIG9wTmFtZSwgcGVyT2JqZWN0KSB7XG4gICAgICAgIGlmICghbW9kZWwuaWQgJiYgcGVyT2JqZWN0KSB7XG4gICAgICAgICAgICBkeFV0aWwuZmFpbCgnJCcgKyBvcE5hbWUgKyAnIGNhbiBub3QgYmUgY2FsbGVkIHdpdGhvdXQgYSByZWZlcmVuY2UgcHJvcGVydHkgc2V0LicpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLypcbiAgICAgKiBJbnZva2Ugd2hhdGV2ZXIgb3BlcmF0aW9uIHdhcyBzZXQgdXAsIGFib3ZlLCBhbmQgdGhlbiBoYW5kbGUgdGhlIHJldHVybiB2YWx1ZXMuXG4gICAgICogSGFuZGxpbmcgYSByZXR1cm4gdmFsdWUgbWVhbnM6XG4gICAgICogIDEpIElmIGEgc3VjY2VzcyBoYW5kbGVyIHdhcyBwcm92aWRlZCwgYW5kIE9LUmVzdWx0IChvciBzdWJ0eXBlKSB3YXMgcmV0dXJuZWQsIHBhc3MgdGhhdCB0byB0aGUgaGFuZGxlci5cbiAgICAgKiAgMikgSUYgYW4gZXJyb3IgaGFuZGxlciB3YXMgcHJvdmlkZWQsIGFuZCBhbiBFcnJvclJlc3VsdCB3YXMgcmV0dXJuZWQsIHBhc3MgdGhlIEVycm9yUmVzdWx0IHRvIHRoZSBoYW5kbGVyLlxuICAgICAqICAgICBPdGhlcndpc2UgcGFzcyBpdCBvbiB0byB0aGUgc3RhbmRhcmQgYXBwbGljYXRpb24td2lkZSBlcnJvciBoYW5kbGVyLCB1bmxlc3Mgc3VwcHJlc3NFcnJvckhhbmRsZXIgd2FzXG4gICAgICogICAgIHNwZWNpZmllZC5cbiAgICAgKiAgMykgSUYgc29tZSBvdGhlciBlcnJvciBvY2N1cnJlZCwgd3JhcCB0aGUgSFRUUCBmYWlsdXJlIGluZm9ybWF0aW9uIGludG8gYSBuZXcgRXJyb3JSZXN1bHQgYW5kIGVpdGhlciBwYXNzXG4gICAgICogICAgIG9udG8gdGhlIHByb3ZpZGVkIGhhbmRsZXIgb3IgdGhlIHN5c3RlbS13aWRlIGhhbmRlciwgdW5sZXNzIHN1cHByZXNzRXJyb3JIYW5kbGVyIHdhcyBzcGVjaWZpZWQuXG4gICAgICovXG4gICAgZnVuY3Rpb24gY2FsbE9wZXJhdGlvbihjYWxsZXIsIG9wdGlvbnMsIHR5cGUsIG9wRGVmLCBzdWNjZXNzRXJyb3IpIHtcbiAgICAgICAgaWYgKHN1Y2Nlc3NFcnJvciAmJiBfLmhhcyhzdWNjZXNzRXJyb3IsICdzdWNjZXNzJykgJiYgIV8uaXNGdW5jdGlvbihzdWNjZXNzRXJyb3Iuc3VjY2VzcykpIHtcbiAgICAgICAgICAgIGR4VXRpbC5mYWlsKCdUaGUgc3VjY2VzcyBoYW5kbGVyIG11c3QgYmUgYSBmdW5jdGlvbiwgYnV0IGZvdW5kIGEgJyArIHR5cGVvZiBzdWNjZXNzRXJyb3Iuc3VjY2VzcyArICcuJyk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoc3VjY2Vzc0Vycm9yICYmIF8uaGFzKHN1Y2Nlc3NFcnJvciwgJ2Vycm9yJykgJiYgIV8uaXNGdW5jdGlvbihzdWNjZXNzRXJyb3IuZXJyb3IpKSB7XG4gICAgICAgICAgICBkeFV0aWwuZmFpbCgnVGhlIGVycm9yIGhhbmRsZXIgbXVzdCBiZSBhIGZ1bmN0aW9uLCBidXQgZm91bmQgYSAnICsgdHlwZW9mIHN1Y2Nlc3NFcnJvci5lcnJvciArICcuJyk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgZGVmZXJyZWQgPSBuZXcgJC5EZWZlcnJlZCgpO1xuXG4gICAgICAgIHZhciBwYXJhbXMgPSB7XG4gICAgICAgICAgICBzdWNjZXNzOiBmdW5jdGlvbihyZXN1bHQpIHtcbiAgICAgICAgICAgICAgICB2YXIgcHJvY2Vzc2VkUmVzdWx0O1xuICAgICAgICAgICAgICAgIGlmIChyZXN1bHQgJiYgcmVzdWx0LnR5cGUgPT09ICdFcnJvclJlc3VsdCcpIHtcbiAgICAgICAgICAgICAgICAgICAgcHJvY2Vzc2VkUmVzdWx0ID0gcmVzdWx0VG9Nb2RlbChyZXN1bHQpO1xuICAgICAgICAgICAgICAgICAgICBoYW5kbGVFcnJvclJlc3VsdChwcm9jZXNzZWRSZXN1bHQsIHN1Y2Nlc3NFcnJvcik7XG4gICAgICAgICAgICAgICAgICAgIGRlZmVycmVkLnJlamVjdChwcm9jZXNzZWRSZXN1bHQpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChkeFV0aWwuaXNOb25lKHJlc3VsdCkgfHwgZHhVdGlsLmlzTm9uZShyZXN1bHQudHlwZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGR4VXRpbC5mYWlsKCdPcGVyYXRpb24gcmV0dXJuZWQgc3VjY2VzcywgYnV0IHdpdGhvdXQgYSB0eXBlZCBvYmplY3Q6ICcgKyByZXN1bHQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChkeFV0aWwuaXNOb25lKG9wRGVmLnJldHVybikgJiYgcmVzdWx0LnJlc3VsdCA9PT0gJycpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlbGV0ZSByZXN1bHQucmVzdWx0O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGFzc2VydFZhbHVlTWF0Y2hlc0RlZmluaXRpb24oJyhyZXR1cm4gdmFsdWUpJywgcmVzdWx0LnJlc3VsdCwgb3BEZWYucmV0dXJuKTtcbiAgICAgICAgICAgICAgICAgICAgcHJvY2Vzc2VkUmVzdWx0ID0gcmVzdWx0VG9Nb2RlbChyZXN1bHQpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoc3VjY2Vzc0Vycm9yICYmIHN1Y2Nlc3NFcnJvci5zdWNjZXNzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdWNjZXNzRXJyb3Iuc3VjY2Vzcyhwcm9jZXNzZWRSZXN1bHQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChzdWNjZXNzRXJyb3IgJiYgc3VjY2Vzc0Vycm9yLmpzb25TdWNjZXNzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdWNjZXNzRXJyb3IuanNvblN1Y2Nlc3MocmVzdWx0KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBkZWZlcnJlZC5yZXNvbHZlKHByb2Nlc3NlZFJlc3VsdCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGVycm9yOiBmdW5jdGlvbih4aHIpIHtcbiAgICAgICAgICAgICAgICB2YXIgZXJyb3JSZXN1bHQgPSBjb252ZXJ0WGhyVG9FcnJvclJlc3VsdCh4aHIpO1xuICAgICAgICAgICAgICAgIGhhbmRsZUVycm9yUmVzdWx0KGVycm9yUmVzdWx0LCBzdWNjZXNzRXJyb3IpO1xuICAgICAgICAgICAgICAgIGRlZmVycmVkLnJlamVjdChlcnJvclJlc3VsdCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICAgICAgaWYgKF8uaXNGdW5jdGlvbihjYWxsZXIudHJpZ2dlcikpIHtcbiAgICAgICAgICAgIGNhbGxlci50cmlnZ2VyKCdyZXF1ZXN0JywgY2FsbGVyKTtcbiAgICAgICAgfVxuXG4gICAgICAgIF8uZXh0ZW5kKHBhcmFtcywgb3B0aW9ucyk7XG5cbiAgICAgICAgcGFyYW1zLnR5cGUgPSB0eXBlO1xuICAgICAgICBkeEFqYXguYWpheENhbGwocGFyYW1zKTtcbiAgICAgICAgcmV0dXJuIGRlZmVycmVkLnByb21pc2UoKTtcbiAgICB9XG5cbiAgICAvKlxuICAgICAqIFZhbGlkYXRlIHRoYXQgdGhlIHBheWxvYWQgbWF0Y2hlcyB0aGUgZGVmaW5pdGlvbiBmb3IgdGhlIG9wZXJhdGlvbi5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBhc3NlcnRBbmRQcmVwYXJlUGF5bG9hZChvcE5hbWUsIG9wRGVmLCBwYXlsb2FkKSB7XG4gICAgICAgIGlmIChkeFV0aWwuaXNOb25lKHBheWxvYWQpICYmIG9wRGVmLnBheWxvYWQgJiYgb3BEZWYucGF5bG9hZC5yZXF1aXJlZCkge1xuICAgICAgICAgICAgZHhVdGlsLmZhaWwoJ011c3QgY2FsbCAkJyArIG9wTmFtZSArICcgd2l0aCBhIHBheWxvYWQgb2YgdHlwZSAnICsgb3BEZWYucGF5bG9hZC4kcmVmICsgJy4nKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghZHhVdGlsLmlzTm9uZShwYXlsb2FkKSkge1xuICAgICAgICAgICAgaWYgKCFfLmlzT2JqZWN0KHBheWxvYWQpIHx8ICEocGF5bG9hZCBpbnN0YW5jZW9mIEJhY2tib25lLk1vZGVsKSkge1xuICAgICAgICAgICAgICAgIGR4VXRpbC5mYWlsKCdNdXN0IGNhbGwgJCcgKyBvcE5hbWUgKyAnIHdpdGggYSBiYWNrYm9uZSBtb2RlbC4nKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKCFwYXlsb2FkLmluc3RhbmNlT2Yob3BEZWYucGF5bG9hZC4kcmVmKSkge1xuICAgICAgICAgICAgICAgIGR4VXRpbC5mYWlsKCdNdXN0IGNhbGwgJCcgKyBvcE5hbWUgKyAnIHdpdGggYW4gaW5zdGFuY2Ugb2YgJyArIG9wRGVmLnBheWxvYWQuJHJlZiArICcuJyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBKU09OLnN0cmluZ2lmeShqc29uSXplKHBheWxvYWQsIG9wRGVmLnZhbGlkYXRlQXMgfHwgJ3NlbmQnKSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKlxuICAgICAqIEdpdmVuIGEgcGFyYW1ldGVycyBvYmplY3QgKGFuIG9yZGluYXJ5IEpTT04gb2JqZWN0KSwgY29tcGFyZSB0aGVzZSB3aXRoIHRoZSBwYXJhbWV0ZXIgZGVmaW5pdGlvbnMgZnJvbSB0aGVcbiAgICAgKiBzY2hlbWFzLiAgSWYgdGhlcmUgYXJlIGFueSB0eXBlIG1pc21hdGNoZXMsIHBhcmFtZXRlcnMgdGhhdCBhcmUgbm90IHN1cHBvcnRlZCwgb3IgcmVxdWlyZWQgcGFyYW1ldGVycyB0aGF0IGFyZVxuICAgICAqIG1pc3NpbmcsIHRocm93IGFuIGVycm9yLlxuICAgICAqXG4gICAgICogUmV0dXJuIGEgY29weSBvZiB0aGUgcGFyYW1ldGVycyB0aGF0IGFyZSBzdWl0YWJsZSBmb3IgcGFzc2luZyB0byBhbiBBSkFYIGNhbGwgKERhdGUgb2JqZWN0IGNvbnZlcnRlZCB0b1xuICAgICAqIHRoZSBzZXJ2ZXIgZGF0ZSBzdHJpbmcgZm9ybWF0KVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNoZWNrQW5kQ29udmVydFBhcmFtZXRlcnMocGFyYW1ldGVycywgcGFyYW1EZWZpbml0aW9ucykge1xuICAgICAgICBwYXJhbWV0ZXJzID0gcGFyYW1ldGVycyB8fCB7fTtcbiAgICAgICAgdmFyIHVuZGVmaW5lZFBhcmFtcyA9IF8ub21pdChwYXJhbWV0ZXJzLCBfLmtleXMocGFyYW1EZWZpbml0aW9ucykpO1xuICAgICAgICBpZiAoIV8uaXNFbXB0eSh1bmRlZmluZWRQYXJhbXMpKSB7XG4gICAgICAgICAgICBkeFV0aWwuZmFpbChfLmtleXModW5kZWZpbmVkUGFyYW1zKS5qb2luKCcsICcpICsgJyBpcyBub3QgYSB2YWxpZCBwYXJhbWV0ZXIgbmFtZS4nKTtcbiAgICAgICAgfVxuXG4gICAgICAgIF8uZWFjaChwYXJhbWV0ZXJzLCBmdW5jdGlvbih2YWx1ZSwga2V5KSB7XG4gICAgICAgICAgICBpZiAoXy5pc1VuZGVmaW5lZCh2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICBkeFV0aWwuZmFpbCgnQ2FuIG5vdCBzZW5kIGEgcmVxdWVzdCB3aXRoIGFuIHVuZGVmaW5lZCBwYXJhbWV0ZXIgKCcgKyBrZXkgKyAnIGlzIHVuZGVmaW5lZCkuJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIF8uZWFjaChwYXJhbURlZmluaXRpb25zLCBmdW5jdGlvbihwYXJhbURlZiwgcGFyYW1OYW1lKSB7XG4gICAgICAgICAgICBpZiAoXy5oYXMocGFyYW1ldGVycywgcGFyYW1OYW1lKSkge1xuICAgICAgICAgICAgICAgIGFzc2VydFZhbHVlTWF0Y2hlc0RlZmluaXRpb24ocGFyYW1OYW1lLCBwYXJhbWV0ZXJzW3BhcmFtTmFtZV0sIHBhcmFtRGVmKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAocGFyYW1EZWYucmVxdWlyZWQpIHtcbiAgICAgICAgICAgICAgICBkeFV0aWwuZmFpbChwYXJhbU5hbWUgKyAnIGlzIHJlcXVpcmVkLCBidXQgaGFzIG5vdCBiZWVuIHBhc3NlZC4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgLy8gc2xpZ2h0bHkgbWlzdXNlIHRoZSBqc29uSXplKCkgcm91dGluZS4gSXQgZG9lcyB3aGF0IHdlIG5lZWQsIGV2ZW4gaWYgcGFyYW1ldGVycyBpc24ndCBhIEJhY2tib25lIG1vZGVsLlxuICAgICAgICByZXR1cm4ganNvbkl6ZShwYXJhbWV0ZXJzLCAnc2VuZCcpO1xuICAgIH1cblxuICAgIC8qXG4gICAgICogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICAgICAqIE1vZGVsIGNyZWF0aW9uIGZ1bmN0aW9uc1xuICAgICAqID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAgICAgKi9cblxuICAgIC8qXG4gICAgICogUmV0dXJucyBhIG5ldyBEU0IgbW9kZWwgd2hpY2ggaXMgc2V0IHRvIGJlIGEgc2VydmVyIG1vZGVsLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIG5ld1NlcnZlck1vZGVsKHR5cGVOYW1lKSB7XG4gICAgICAgIHZhciBtb2RlbCA9IG1ha2VOZXdNb2RlbCh0eXBlTmFtZSwgZmFsc2UpO1xuXG4gICAgICAgIG1ha2VJbnRvU2VydmVyTW9kZWwobW9kZWwpO1xuXG4gICAgICAgIHJldHVybiBtb2RlbDtcbiAgICB9XG5cbiAgICAvKlxuICAgICAqIFJldHVybnMgYSBuZXcgRFNCIG1vZGVsIHdoaWNoIGlzIHNldCB0byBiZSBhIGNsaWVudCBtb2RlbC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBuZXdDbGllbnRNb2RlbCh0eXBlTmFtZSkge1xuICAgICAgICB2YXIgbW9kZWwgPSBtYWtlTmV3TW9kZWwodHlwZU5hbWUsIHRydWUpO1xuICAgICAgICBtYWtlUmVhZHkobW9kZWwsIHRydWUpO1xuICAgICAgICByZXR1cm4gbW9kZWw7XG4gICAgfVxuXG4gICAgLypcbiAgICAgKiBDb252ZXJ0IGEgSlNPTiByZXN1bHQgb2JqZWN0IGludG8gYSBjbGllbnQgbW9kZWwuXG4gICAgICovXG4gICAgZnVuY3Rpb24gcmVzdWx0VG9Nb2RlbChyZXN1bHQpIHtcbiAgICAgICAgdmFyIG1vZGVsID0gbmV3Q2xpZW50TW9kZWwocmVzdWx0LnR5cGUpO1xuICAgICAgICBtb2RlbC5zZXQocmVzdWx0KTtcbiAgICAgICAgcmV0dXJuIG1vZGVsO1xuICAgIH1cblxuICAgIC8qXG4gICAgICogQ3JlYXRlIGEgbmV3IG1vZGVsIGluc3RhbmNlLiBBc2lkZSBmcm9tIGNyZWF0aW5nIHRoZSBtb2RlbCwgd2UgbWFudWFsbHkgcG9wdWxhdGUgdGhlIGRlZmF1bHQgc2V0IG9mIGF0dHJpYnV0ZXMsXG4gICAgICogc2luY2UgdGhlIEJhY2tib25lIHN5c3RlbSBkb2Vzbid0IHJlYWxseSB1bmRlcnN0YW5kIGVtYmVkZGVkIG1vZGVscy5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBtYWtlTmV3TW9kZWwodHlwZU5hbWUsIGlzQ2xpZW50KSB7XG4gICAgICAgIGlmIChkeFV0aWwuaXNOb25lKHR5cGVOYW1lKSkge1xuICAgICAgICAgICAgZHhVdGlsLmZhaWwoJ1RvIGNyZWF0ZSBhIG5ldyBtb2RlbCwgYSB0eXBlIG5hbWUgbXVzdCBiZSBwcm92aWRlZC4nKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghaXNTY2hlbWFUeXBlKHR5cGVOYW1lKSkge1xuICAgICAgICAgICAgZHhVdGlsLmZhaWwodHlwZU5hbWUgKyAnIGlzIG5vdCBhIGtub3duIHR5cGUgbmFtZS4gQ2FuIG5vdCBjcmVhdGUgb25lLicpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdmFyIG1vZGVsID0gbmV3IGNvbnRleHQuX21vZGVsQ29uc3RydWN0b3JzW3R5cGVOYW1lXSgpO1xuICAgICAgICAgICAgbW9kZWwuX2R4SXNDbGllbnRNb2RlbCA9IGlzQ2xpZW50O1xuICAgICAgICAgICAgYnVpbGREZWZhdWx0QXR0cmlidXRlcyhtb2RlbCwgbW9kZWwuX2R4U2NoZW1hLnByb3BlcnRpZXMgfHwge30pO1xuICAgICAgICAgICAgcmV0dXJuIG1vZGVsO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLypcbiAgICAgKiBGaWxsIGluIHRoZSBkZWZhdWx0cyBmb3IgYWxsIGF0dHJpYnV0ZXMgb24gdGhlIHNwZWNpZmllZCBtb2RlbC4gIFRoaXMgZGlyZWN0bHkgbWFuaXB1bGF0ZXMgdGhlIGF0dHJpYnV0ZXNcbiAgICAgKiBwcm9wZXJ0eSwgdGh1cyBieXBhc3NpbmcgdGhlIG5vcm1hbCBzZXQoKSBzZW1hbnRpY3MuICBUaGlzIGlzIGFjdHVhbGx5IE9LLCBhcyB0aGUgZGVmYXVsdCBCYWNrYm9uZSBiZWhhdmlvciBpc1xuICAgICAqIG5vdCB0byBjaGFuZ2UgaXRzIGNoYW5nZWRBdHRyaWJ1dGVzKCkgdmFsdWVzIChldGMpIGF0IGNyZWF0aW9uIHRpbWUuIEFkZGl0aW9uYWxseSwgd2UgZG9uJ3Qgd2FudCB0byBiZSB0cmlnZ2VyaW5nXG4gICAgICogZXZlbnRzIHdoZW4gZG9pbmcgdGhpcy5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBidWlsZERlZmF1bHRBdHRyaWJ1dGVzKG1vZGVsLCBwcm9wRGVmcykge1xuICAgICAgICBfLmVhY2gocHJvcERlZnMsIGZ1bmN0aW9uKHByb3BEZWYsIHByb3BOYW1lKSB7XG4gICAgICAgICAgICBtb2RlbC5hdHRyaWJ1dGVzW3Byb3BOYW1lXSA9IGRlZmF1bHRGb3IocHJvcERlZiwgbW9kZWwuX2R4SXNDbGllbnRNb2RlbCk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGlmICghXy5pc1VuZGVmaW5lZChwcm9wRGVmcy50eXBlKSkge1xuICAgICAgICAgICAgbW9kZWwuYXR0cmlidXRlcy50eXBlID0gbW9kZWwuX2R4U2NoZW1hLm5hbWU7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKlxuICAgICAqIEdpdmVuIGEgdHlwZSBkZWZpbml0aW9uLCByZXR1cm4gdGhlIGRlZmF1bHQgdmFsdWUgZm9yIHRoYXQgdHlwZS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBkZWZhdWx0Rm9yKHByb3BEZWYsIGlzQ2xpZW50TW9kZWwpIHtcbiAgICAgICAgdmFyIGRlZmF1bHRWYWx1ZSA9IHByb3BEZWYuZGVmYXVsdDtcblxuICAgICAgICAvLyBFeHBvc2UgXCJudWxsXCIgZnJvbSB0aGUgc2VydmVyIGFzIFwidW5kZWZpbmVkXCIgdG8gb3VyIGNsaWVudHNcbiAgICAgICAgaWYgKHByb3BEZWYuZGVmYXVsdCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgZGVmYXVsdFZhbHVlID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKF8uaXNVbmRlZmluZWQoZGVmYXVsdFZhbHVlKSAmJlxuICAgICAgICAgICAgcHJvcERlZi50eXBlID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgaWYgKF8uaGFzKHByb3BEZWYsICckcmVmJykgJiYgcHJvcERlZi4kcmVmICE9PSAnSnNvbicpIHtcbiAgICAgICAgICAgICAgICBkZWZhdWx0VmFsdWUgPSBpc0NsaWVudE1vZGVsID8gbmV3Q2xpZW50TW9kZWwocHJvcERlZi4kcmVmKSA6IG5ld1NlcnZlck1vZGVsKHByb3BEZWYuJHJlZik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZGVmYXVsdFZhbHVlO1xuICAgIH1cblxuICAgIC8qXG4gICAgICogQ2hhbmdlcyB0aGUgc3BlY2lmaWVkIG1vZGVsIChhbmQgaXRzIGVtYmVkZGVkIG1vZGVscykgaW50byBhIHNlcnZlciBtb2RlbC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBtYWtlSW50b1NlcnZlck1vZGVsKG1vZGVsKSB7XG4gICAgICAgIG1vZGVsLl9keElzQ2xpZW50TW9kZWwgPSBmYWxzZTtcblxuICAgICAgICBpZiAobW9kZWwuX2R4U2NoZW1hLmRlbGV0ZSkge1xuICAgICAgICAgICAgbW9kZWwuJCRkZWxldGUgPSBtb2RlbC5fZHhTdGFuZGFyZE9wcy4kJGRlbGV0ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChtb2RlbC5fZHhTY2hlbWEudXBkYXRlKSB7XG4gICAgICAgICAgICBtb2RlbC4kJHVwZGF0ZSA9IG1vZGVsLl9keFN0YW5kYXJkT3BzLiQkdXBkYXRlO1xuICAgICAgICB9XG5cbiAgICAgICAgbW9kZWwuc2V0ID0gY2FudE1vZGlmeVNlcnZlck1vZGVsO1xuICAgICAgICBtb2RlbC5jbGVhciA9IGNhbnRNb2RpZnlTZXJ2ZXJNb2RlbDtcbiAgICAgICAgbW9kZWwudW5zZXQgPSBjYW50TW9kaWZ5U2VydmVyTW9kZWw7XG4gICAgICAgIG1vZGVsLnN5bmMgPSBjYW50TW9kaWZ5U2VydmVyTW9kZWw7XG5cbiAgICAgICAgXy5lYWNoKG1vZGVsLl9keFNjaGVtYS5wcm9wZXJ0aWVzLCBmdW5jdGlvbihwcm9wRGVmLCBwcm9wTmFtZSkge1xuICAgICAgICAgICAgaWYgKGlzRW1iZWRkZWRQcm9wKHByb3BEZWYpKSB7XG4gICAgICAgICAgICAgICAgbWFrZUludG9TZXJ2ZXJNb2RlbChtb2RlbC5nZXQocHJvcE5hbWUpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY2FudE1vZGlmeVNlcnZlck1vZGVsKCkge1xuICAgICAgICBkeFV0aWwuZmFpbCgnQ2FuIG5vdCBtb2RpZnkgYSBzZXJ2ZXIgJyArIHRoaXMuX2R4U2NoZW1hLm5hbWUgKyAnIGluc3RhbmNlLicpO1xuICAgIH1cblxuICAgIC8qXG4gICAgICogR2l2ZW4gYSB0eXBlLCBsb2NhdGUgdGhlIHJvb3QgcGFyZW50IHR5cGUgKHdoaWNoIHdpbGwgYmUsIHdoZW4gd2Fsa2luZyB1cCB0aGUgaW5oZXJpdGFuY2UgY2hhaW4sIHRoZSBsYXN0IHR5cGVcbiAgICAgKiB0aGF0IGhhcyB0aGUgc2FtZSB2YWx1ZSBpbiBpdHMgcm9vdCBwcm9wZXJ0eSlcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBnZXRSb290VHlwZShjaGlsZFR5cGUpIHtcbiAgICAgICAgaWYgKCFfLmlzU3RyaW5nKGNoaWxkVHlwZSkpIHtcbiAgICAgICAgICAgIGR4VXRpbC5mYWlsKCdNdXN0IGNhbGwgd2l0aCBhIHR5cGUgbmFtZS4nKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghaXNTY2hlbWFUeXBlKGNoaWxkVHlwZSkpIHtcbiAgICAgICAgICAgIGR4VXRpbC5mYWlsKGNoaWxkVHlwZSArICcgaXMgbm90IGEga25vd24gdHlwZSBuYW1lLicpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGNvbnRleHQuX21vZGVsQ29uc3RydWN0b3JzW2NoaWxkVHlwZV0ucHJvdG90eXBlLl9keFNjaGVtYS5yb290VHlwZU5hbWU7XG4gICAgfVxuXG4gICAgLypcbiAgICAgKiBHaXZlbiB4biBYbWxIdHRwUmVxdWVzdCAob3IgdGhlIGVxdWl2YWxlbnQpLCBlaXRoZXIgZXh0cmFjdCB0aGUgRXJyb3JSZXN1bHQgb2JqZWN0IGZyb20gd2l0aGluIGl0IGFuZCByZXR1cm5cbiAgICAgKiB0aGF0LCBvciBtYW51ZmFjdHVyZSBhbiBFcnJvclJlc3VsdCBvYmplY3Qgd2hpY2ggY29udGFpbnMgdGhlIEhUVFAgZmFpbHVyZSBpbmZvcm1hdGlvbiBhbmQgcmV0dXJuIHRoYXQuXG4gICAgICovXG4gICAgZnVuY3Rpb24gY29udmVydFhoclRvRXJyb3JSZXN1bHQoeGhyKSB7XG4gICAgICAgIHZhciByZXNwb25zZUluZm8gPSB4aHIucmVzcG9uc2VUZXh0O1xuXG4gICAgICAgIC8vIGZvciB0ZXN0aW5nIHhociBtYXkgbm90IGhhdmUgZ2V0UmVzcG9uc2VIZWFkZXIsIGFuZCBub3QgYWxsIHJlc3BvbnNlcyBoYXZlIGEgY29udGVudC10eXBlIVxuICAgICAgICB2YXIgY29udGVudFR5cGUgPSBkeFV0aWwuaXNOb25lKHhoci5nZXRSZXNwb25zZUhlYWRlcikgPyB1bmRlZmluZWQgOlxuICAgICAgICAgICAgeGhyLmdldFJlc3BvbnNlSGVhZGVyKCdjb250ZW50LXR5cGUnKTtcblxuICAgICAgICBpZiAoIWR4VXRpbC5pc05vbmUoY29udGVudFR5cGUpICYmXG4gICAgICAgICAgICBjb250ZW50VHlwZS5pbmRleE9mKCdhcHBsaWNhdGlvbi9qc29uJykgPiAtMSAmJlxuICAgICAgICAgICAgIV8uaXNPYmplY3QocmVzcG9uc2VJbmZvKSkge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICByZXNwb25zZUluZm8gPSBKU09OLnBhcnNlKHJlc3BvbnNlSW5mbyk7XG4gICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgZHhVdGlsLmZhaWwoJ1NlcnZlciByZXNwb25zZSBjbGFpbWVkIHRvIGJlIGFwcGxpY2F0aW9uL2pzb24sIGJ1dCBjb3VsZG5cXCd0IGJlIHBhcnNlZCBhcyBKU09OICgnICtcbiAgICAgICAgICAgICAgICAgICAgeGhyLnJlc3BvbnNlVGV4dCArICcpLicpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHJlc3BvbnNlSW5mbyAmJiByZXNwb25zZUluZm8udHlwZSA9PT0gJ0Vycm9yUmVzdWx0Jykge1xuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdFRvTW9kZWwocmVzcG9uc2VJbmZvKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHZhciBlcnJvclJlc3VsdCA9IG5ld0NsaWVudE1vZGVsKCdFcnJvclJlc3VsdCcpO1xuICAgICAgICAgICAgZXJyb3JSZXN1bHQuZ2V0KCdlcnJvcicpLnNldCh7XG4gICAgICAgICAgICAgICAgZGV0YWlsczogJ0NvbW11bmljYXRpb24gRXJyb3InLFxuICAgICAgICAgICAgICAgIGNvbW1hbmRPdXRwdXQ6ICdIVFRQIEVycm9yOiAnICsgeGhyLnN0YXR1cyArICdcXG4nICtcbiAgICAgICAgICAgICAgICAgICAgICdTdGF0dXMgdGV4dDogJyArIHhoci5zdGF0dXNUZXh0ICsgJ1xcbicgK1xuICAgICAgICAgICAgICAgICAgICAgJ1Jlc3BvbnNlIHRleHQ6ICcgKyB4aHIucmVzcG9uc2VUZXh0XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiBlcnJvclJlc3VsdDtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qXG4gICAgICogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICAgICAqICdzdWJyb3V0aW5lcycgYW5kIHV0aWxpdHkgZnVuY3Rpb25zXG4gICAgICogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICAgICAqL1xuXG4gICAgLypcbiAgICAgKiBWYWxpZGF0ZXMgdGhhdCB0aGUgYXR0cmlidXRlIG5hbWUgaXMgYSB2YWxpZCBhdHRyaWJ1dGUgbmFtZSBmb3IgdGhlIG1vZGVsLiBJZiBzbywgdGhpcyByZXR1cm5zIGluZm9ybWF0aW9uIGFib3V0XG4gICAgICogdGhlIGF0dHJpYnV0ZSAoc2VlIGdldEF0dHJJbmZvKS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBhc3NlcnRBbmRHZXRBdHRySW5mbyhtb2RlbCwgYXR0ck5hbWUpIHtcbiAgICAgICAgdmFyIGluZm8gPSBnZXRBdHRySW5mbyhtb2RlbCwgYXR0ck5hbWUpO1xuXG4gICAgICAgIGlmIChfLmlzVW5kZWZpbmVkKGluZm8ucHJvcERlZikpIHtcbiAgICAgICAgICAgIGR4VXRpbC5mYWlsKGF0dHJOYW1lICsgJyBpcyBub3QgYSBrbm93biBhdHRyaWJ1dGUuJyk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gaW5mbztcbiAgICB9XG5cbiAgICAvKlxuICAgICAqIFRoaXMgcmV0dXJucyBpbmZvcm1hdGlvbiBhYm91dCB0aGUgYXR0cmlidXRlLCBpbmNsdWRpbmcgaXRzIGJhc2UgbmFtZSAoaWYgdGhlIHZhbHVlIHBhc3NlZCB3YXMgJGF0dHIsIHRoaXNcbiAgICAgKiByZXR1cm5zICdhdHRyJyksIHdoZXRoZXIgdGhpcyB3YXMgYSAkLXByZWZpeGVkIG5hbWUgKGFuZCB0aHVzIGl0IGlzIGFjdHVhbGx5IGFza2luZyBmb3IgdGhlIHJlZmVyZW5jZWQgbW9kZWwpLFxuICAgICAqIGFuZCB0aGUgZGVmaW5pdGlvbiBvZiB0aGUgc2NoZW1hIHByb3BlcnR5LlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGdldEF0dHJJbmZvKG1vZGVsLCBhdHRyTmFtZSkge1xuICAgICAgICBpZiAoIV8uaXNTdHJpbmcoYXR0ck5hbWUpKSB7XG4gICAgICAgICAgICBkeFV0aWwuZmFpbCgnTXVzdCBwcm92aWRlIGFuIGF0dHJpYnV0ZSBuYW1lLicpO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGJhc2VOYW1lID0gYXR0ck5hbWU7XG4gICAgICAgIHZhciB3YW50c01vZGVsID0gZmFsc2U7XG4gICAgICAgIGlmIChiYXNlTmFtZS5jaGFyQXQoMCkgPT09ICckJykge1xuICAgICAgICAgICAgYmFzZU5hbWUgPSBiYXNlTmFtZS5zdWJzdHJpbmcoMSk7XG4gICAgICAgICAgICB3YW50c01vZGVsID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgcHJvcHMgPSBtb2RlbC5fZHhTY2hlbWEucHJvcGVydGllcztcbiAgICAgICAgdmFyIHByb3BEZWYgPSBwcm9wcyA/IHByb3BzW2Jhc2VOYW1lXSA6IHVuZGVmaW5lZDtcblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgYmFzZU5hbWU6IGJhc2VOYW1lLFxuICAgICAgICAgICAgd2FudHNNb2RlbDogd2FudHNNb2RlbCxcbiAgICAgICAgICAgIHByb3BEZWY6IHByb3BEZWZcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICB2YXIgZGF0ZVN0cmluZ1JlZ2V4ID0gL1xcZFxcZFxcZFxcZC1cXGRcXGQtXFxkXFxkVFxcZFxcZDpcXGRcXGQ6XFxkXFxkLlxcZFxcZFxcZFovO1xuXG4gICAgLypcbiAgICAgKiBBc3NlcnRzIHRoYXQgdGhlIHNwZWNpZmllZCB2YWx1ZSBtYXRjaGVzIChpcyBjb21wYXRpYmxlIHdpdGgpIHRoZSB0eXBlIHNwZWNpZmllZCBieSB0aGUgZGVmaW5pdGlvbi5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBhc3NlcnRWYWx1ZU1hdGNoZXNEZWZpbml0aW9uKG5hbWUsIHZhbHVlLCBkZWYpIHtcbiAgICAgICAgLypcbiAgICAgICAgICogUmV0dXJucyB0aGUgdHlwZSBvZiB0aGUgdmFsdWUuICBUaGUgcmV0dXJuIHZhbHVlcyBpbmNsdWRlIEphdmFzY3JpcHQgdHlwZW9mIHR5cGUgKHVuZGVmaW5lZCwgb2JqZWN0LFxuICAgICAgICAgKiBib29sZWFuLCBudW1iZXIsIHN0cmluZywgZXRjKSB0eXBlcywgd2l0aCBKU09OIFNjaGVtYSB0eXBlIHJlZmluZW1lbnRzIChudWxsLCBhcnJheSwgaW50ZWdlcikuXG4gICAgICAgICAqL1xuICAgICAgICBmdW5jdGlvbiB0eXBlT2ZWYWx1ZSh2YWx1ZSkge1xuICAgICAgICAgICAgaWYgKF8uaXNOdWxsKHZhbHVlKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiAnbnVsbCc7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChfLmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICdhcnJheSc7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICh0eXBlb2YgdmFsdWUgID09PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgICAgIHJldHVybiAodmFsdWUgPT09IE1hdGguZmxvb3IodmFsdWUpKSA/ICdpbnRlZ2VyJyA6ICdudW1iZXInO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAodmFsdWUgaW5zdGFuY2VvZiBEYXRlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICdkYXRlJztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycgJiYgZGF0ZVN0cmluZ1JlZ2V4LmV4ZWModmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICdkYXRlLW9yLXN0cmluZyc7IC8vIGNvdWxkIGJlIGVpdGhlci5cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIHR5cGVvZiB2YWx1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIGlzVHlwZUNvbXBhdGlibGUoYWN0dWFsVHlwZSwgb2JqZWN0VHlwZSwgZGVmVHlwZSwgZGVmT2JqZWN0VHlwZSwgZGVmRm9ybWF0KSB7XG4gICAgICAgICAgICBpZiAoYWN0dWFsVHlwZSA9PT0gJ2ludGVnZXInICYmIGRlZlR5cGUgPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGFjdHVhbFR5cGUgPT09ICdudWxsJyB8fCBhY3R1YWxUeXBlID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlOyAgICAvLyBjYW4gYXNzaWduIG51bGwgb3IgdW5kZWZpbmVkIHRvIGFsbCB0eXBlc1xuICAgICAgICAgICAgfSBlbHNlIGlmIChhY3R1YWxUeXBlID09PSAnZGF0ZScgJiYgZGVmVHlwZSA9PT0gJ3N0cmluZycgJiYgZGVmRm9ybWF0ID09PSAnZGF0ZScpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoYWN0dWFsVHlwZSA9PT0gJ2RhdGUtb3Itc3RyaW5nJyAmJiBkZWZUeXBlID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgIGlmIChkZWZGb3JtYXQgPT09ICdkYXRlJykge1xuICAgICAgICAgICAgICAgICAgICB0eXBlID0gJ2RhdGUnO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHR5cGUgPSAnc3RyaW5nJztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKChkZWZUeXBlID09PSAnb2JqZWN0JykgJiYgKGFjdHVhbFR5cGUgPT09ICdvYmplY3QnKSkge1xuICAgICAgICAgICAgICAgIGlmIChfLmlzVW5kZWZpbmVkKGRlZk9iamVjdFR5cGUpIHx8IC8vIGRlZmluaXRpb24gaXMgdHlwZWxlc3NcbiAgICAgICAgICAgICAgICAgICAgKCFfLmlzVW5kZWZpbmVkKGRlZk9iamVjdFR5cGUpICYmIF8uaXNVbmRlZmluZWQob2JqZWN0VHlwZSkpIHx8IC8vIG5ldyB2YWx1ZSBpcyB0eXBlbGVzc1xuICAgICAgICAgICAgICAgICAgICBkZWZPYmplY3RUeXBlID09PSBvYmplY3RUeXBlIHx8IC8vIHR5cGVzIHNhbWVcbiAgICAgICAgICAgICAgICAgICAgZmlyc3RJc1N1YnR5cGVPZlNlY29uZChvYmplY3RUeXBlLCBkZWZPYmplY3RUeXBlKSkgeyAvLyBuZXcgdmFsdWUgaXMgc3VidHlwZVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZGVmVHlwZSA9PT0gYWN0dWFsVHlwZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHZhciB0eXBlID0gdHlwZU9mVmFsdWUodmFsdWUpO1xuICAgICAgICB2YXIgb2JqZWN0VHlwZSA9ICh0eXBlID09PSAnb2JqZWN0JykgPyB2YWx1ZS50eXBlIDogdW5kZWZpbmVkO1xuICAgICAgICB2YXIgdHlwZU1hdGNoZXM7XG5cbiAgICAgICAgaWYgKF8uaXNVbmRlZmluZWQoZGVmKSkge1xuICAgICAgICAgICAgaWYgKGR4VXRpbC5pc05vbmUodmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHR5cGU7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGR4VXRpbC5mYWlsKG5hbWUgKyAnIGhhcyBhIHZhbHVlLCBidXQgaXQgaGFzIG5vIGRlZmluaXRpb24uJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoXy5pc0FycmF5KGRlZi50eXBlKSkge1xuICAgICAgICAgICAgdHlwZU1hdGNoZXMgPSBfLmZpbmQoZGVmLnR5cGUsIGZ1bmN0aW9uKGRlZlR5cGUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaXNUeXBlQ29tcGF0aWJsZSh0eXBlLCBvYmplY3RUeXBlLCBkZWZUeXBlLCBkZWYuJHJlZiwgZGVmLmZvcm1hdCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHR5cGVNYXRjaGVzID0gaXNUeXBlQ29tcGF0aWJsZSh0eXBlLCBvYmplY3RUeXBlLCBkZWYudHlwZSwgZGVmLiRyZWYsIGRlZi5mb3JtYXQpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCF0eXBlTWF0Y2hlcykge1xuICAgICAgICAgICAgaWYgKCFkZWYuJHJlZikge1xuICAgICAgICAgICAgICAgIGR4VXRpbC5mYWlsKG5hbWUgKyAnIGhhcyB0byBiZSB0eXBlICcgKyAoKGRlZi50eXBlID09PSAnc3RyaW5nJyAmJiBkZWYuZm9ybWF0ID09PSAnZGF0ZScpID9cbiAgICAgICAgICAgICAgICAgICAgJ2RhdGUnIDogZGVmLnR5cGUpICsgJyBidXQgaXMgJyArIHR5cGUgKyAnICgnICsgSlNPTi5zdHJpbmdpZnkodmFsdWUpICsgJyknKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgZHhVdGlsLmZhaWwobmFtZSArICcgaGFzIHRvIGJlIHR5cGUgJyArIGRlZi50eXBlICsgJy8nICsgZGVmLiRyZWYgKyAnIGJ1dCBpcyAnICsgdHlwZSArICcvJyArXG4gICAgICAgICAgICAgICAgICAgIG9iamVjdFR5cGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLypcbiAgICAgICAgICogTm90ZTogZGVmLmVudW0gdGhyb3dzIGFuIGVycm9yIGluIElFOC4gIFdlJ3JlIGFsc28gZ29vZCB3aXRoIHVuZGVmaW5lZC9udWxsIGZyb20gcHJldmlvdXMgY2hlY2tzIGJ1dCB0aG9zZVxuICAgICAgICAgKiB2YWx1ZXMgb2J2aW91c2x5IGFyZW4ndCBwYXJ0IG9mIHRoZSBlbnVtXG4gICAgICAgICAqL1xuICAgICAgICBpZiAoZGVmLmVudW0gJiYgIWR4VXRpbC5pc05vbmUodmFsdWUpICYmICFfLmNvbnRhaW5zKGRlZi5lbnVtLCB2YWx1ZSkpIHtcbiAgICAgICAgICAgIGR4VXRpbC5mYWlsKG5hbWUgKyAnIGlzIGFuIGVudW0gYW5kIGhhcyB0byBiZSBvbmUgb2YgJyArIEpTT04uc3RyaW5naWZ5KGRlZi5lbnVtKSArICcgYnV0IGlzICcgK1xuICAgICAgICAgICAgICAgIEpTT04uc3RyaW5naWZ5KHZhbHVlKSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdHlwZTtcbiAgICB9XG5cbiAgICAvKlxuICAgICAqIENoYW5nZSB0aGUgbW9kZWwgdG8gYW5vdGhlciB0eXBlLiAgVGhpcyBpcyBkb25lIFwiaW4gcGxhY2VcIiBzaW5jZSB3ZSB3YW50IHRvIHByZXNlcnZlIGFueSBsaXN0ZW5lcnMgdGhhdCBtYXlcbiAgICAgKiBoYXZlIGJlZW4gYXR0YWNoZWQgdG8gdGhpcyBvYmplY3QuXG4gICAgICpcbiAgICAgKiBUaGlzIHJldHVybnMgdHJ1ZSBpZiB0aGlzIHJlbW92ZWQgYW55IGF0dHJpYnV0ZXMgKGl0IGFsc28gdHJpZ2dlcnMgYSAnY2hhbmdlOmF0dHJOYW1lJyBldmVudCBmb3IgZWFjaClcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjb252ZXJ0VG9UeXBlKG1vZGVsLCBuZXdUeXBlKSB7XG4gICAgICAgIHZhciBTb3VyY2VDb25zdHJ1Y3RvciA9IGNvbnRleHQuX21vZGVsQ29uc3RydWN0b3JzW21vZGVsLmdldCgndHlwZScpXTtcbiAgICAgICAgdmFyIFRhcmdldENvbnN0cnVjdG9yID0gY29udGV4dC5fbW9kZWxDb25zdHJ1Y3RvcnNbbmV3VHlwZV07XG5cbiAgICAgICAgLy8gYWRkIG1ldGFkYXRhIGZyb20gdGhlIHRhcmdldCB0eXBlLCBvdmVycmlkaW5nIG91ciBvd24uXG4gICAgICAgIG1vZGVsLl9keFNjaGVtYSA9IFRhcmdldENvbnN0cnVjdG9yLnByb3RvdHlwZS5fZHhTY2hlbWE7XG4gICAgICAgIG1vZGVsLnVybFJvb3QgPSBUYXJnZXRDb25zdHJ1Y3Rvci5wcm90b3R5cGUuX2R4U2NoZW1hLnJvb3Q7XG5cbiAgICAgICAgLy8gcmVwbGFjZSBvdXIgYXR0cmlidXRlc1xuICAgICAgICBtb2RlbC5hdHRyaWJ1dGVzID0ge307XG4gICAgICAgIGJ1aWxkRGVmYXVsdEF0dHJpYnV0ZXMobW9kZWwsIG1vZGVsLl9keFNjaGVtYS5wcm9wZXJ0aWVzKTtcblxuICAgICAgICAvLyBSZW1vdmUgYW55IG9wZXJhdGlvbnMgd2UgcHJldmlvdXNseSBtYXkgaGF2ZSBhZGRlZCB0byB0aGlzIG9iamVjdC5cbiAgICAgICAgXy5lYWNoKG1vZGVsLCBmdW5jdGlvbih2YWx1ZSwgbmFtZSkge1xuICAgICAgICAgICAgaWYgKG5hbWUuY2hhckF0KDApID09PSAnJCcpIHtcbiAgICAgICAgICAgICAgICBkZWxldGUgbW9kZWxbbmFtZV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIC8qXG4gICAgICAgICAqIFRoaXMgaXMgcmVhbGx5IHNhZC4gU2luY2Ugd2UgY2FuJ3QgY2hhbmdlIHRoZSBwcm90b3R5cGUgb2YgdGhlIG9iamVjdCBhdCBydW50aW1lLCB3ZSBuZWNlc3NhcmlseSBpbmhlcml0IHRoZVxuICAgICAgICAgKiBvcGVyYXRpb25zIGZyb20gaXRzIHByb3RvdHlwZS4gIEJ1dCBpZiBieSBjaGFuY2Ugd2UgYXJlIGNvbnZlcnRpbmcgdG8gYSB0eXBlIHRoYXQgZG9lc24ndCBoYXZlIHRob3NlXG4gICAgICAgICAqIG9wZXJhdGlvbnMsIHdlIHNob3VsZCBub3QgYWxsb3cgc29tZW9uZSB0byBjYWxsIHRoZW0uIEluc2VydCBhIGR1bW15IGZ1bmN0aW9uIG9uIHRoZSBsZWFmIG9iamVjdCBpbiB0aGVcbiAgICAgICAgICogcHJvdG90eXBlIGNoYWluIHRvIGtlZXAgYW55b25lIGZyb20gYWN0dWFsbHkgY2FsbGluZyBpdC5cbiAgICAgICAgICovXG4gICAgICAgIF8uZWFjaChTb3VyY2VDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIGZ1bmN0aW9uKHZhbHVlLCBuYW1lKSB7XG4gICAgICAgICAgICBpZiAobmFtZS5jaGFyQXQoMCkgPT09ICckJykge1xuICAgICAgICAgICAgICAgIG1vZGVsW25hbWVdID0gYmxvY2tQcm90b3R5cGVPcGVyYXRpb247XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIC8vIE5vdyBhY3R1YWxseSBhZGQgdGhlIG9wZXJhdGlvbnMgdG8gdGhpcyB0aGF0IGl0IHNob3VsZCBoYXZlIGJhc2VkIG9uIHRoZSB0eXBlIGl0IGlzIGJlaW5nIGNvbnZlcnRlZCB0by5cbiAgICAgICAgXy5lYWNoKFRhcmdldENvbnN0cnVjdG9yLnByb3RvdHlwZSwgZnVuY3Rpb24odmFsdWUsIG5hbWUpIHtcbiAgICAgICAgICAgIGlmIChuYW1lLmNoYXJBdCgwKSA9PT0gJyQnKSB7XG4gICAgICAgICAgICAgICAgbW9kZWxbbmFtZV0gPSB2YWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgaWYgKG1vZGVsLl9keFNjaGVtYS5kZWxldGUpIHtcbiAgICAgICAgICAgIG1vZGVsLiQkZGVsZXRlID0gZHhEZWxldGU7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAobW9kZWwuX2R4U2NoZW1hLnVwZGF0ZSkge1xuICAgICAgICAgICAgbW9kZWwuJCR1cGRhdGUgPSBkeFVwZGF0ZTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGJsb2NrUHJvdG90eXBlT3BlcmF0aW9uKCkge1xuICAgICAgICBkeFV0aWwuZmFpbCgnVGhpcyBvcGVyYXRpb24gZG9lcyBub3QgZXhpc3Qgb24gdGhpcyBpbnN0YW5jZS4gKGl0IGhhcyBiZWVuIGNvbnZlcnRlZCBmcm9tIGEgdHlwZSB0aGF0IGhhZCBpdCkuJyk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZmlyc3RJc1N1YnR5cGVPZlNlY29uZChjaGlsZFR5cGUsIHBhcmVudFR5cGUpIHtcbiAgICAgICAgdmFyIGNhbmRpZGF0ZUluZm8gPSBpc1NjaGVtYVR5cGUoY2hpbGRUeXBlKSA/XG4gICAgICAgICAgICBjb250ZXh0Ll9tb2RlbENvbnN0cnVjdG9yc1tjaGlsZFR5cGVdLnByb3RvdHlwZS5fZHhTY2hlbWEgOlxuICAgICAgICAgICAgdW5kZWZpbmVkO1xuXG4gICAgICAgIHdoaWxlIChjYW5kaWRhdGVJbmZvKSB7XG4gICAgICAgICAgICBpZiAoY2FuZGlkYXRlSW5mby5uYW1lID09PSBwYXJlbnRUeXBlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGNhbmRpZGF0ZUluZm8gPSBjYW5kaWRhdGVJbmZvLnBhcmVudFNjaGVtYTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICAvKlxuICAgICAqIEFzIHBhcnQgb2YgdGhlIHNldCgpIHByb2Nlc3MsIHdlIGNhbiB0YWtlIGEgSlNPTiBhcnJheSwgYW5kIGNvbnZlcnQgaXQgaW50byBhbiBhcnJheSByZWFkeSB0byBiZSBzZXQgb24gdGhlXG4gICAgICogbW9kZWwuIFRoaXMgaW52b2x2ZXMgdHdvIHNwZWNpYWwgcHJvY2Vzc2VzOiBJZiBhbiAnaXRlbXMnIHByb3BlcnR5IGhhcyBiZWVuIHNwZWNpZmllZCwgZW5mb3JjZSB0aGUgdHlwZVxuICAgICAqIGNvbnN0cmFpbnQgZXhwcmVzc2VkIHRoZXJlLCBhbmQgaWYgYW4gb2JqZWN0IGlzIGZvdW5kIHRoYXQgY291bGQgYmUgY29udmVydGVkIGludG8gYSBEU0IgbW9kZWwsIGNyZWF0ZSBhIG5ld1xuICAgICAqIG1vZGVsIGFuZCBhZGQgaXQuXG4gICAgICovXG4gICAgZnVuY3Rpb24gc2V0dXBBcnJheShhcnJheVZhbHVlLCBpdGVtRGVmKSB7XG4gICAgICAgIHZhciBuZXdBcnJheSA9IFtdO1xuXG4gICAgICAgIF8uZWFjaChhcnJheVZhbHVlLCBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICAgICAgaWYgKCFfLmlzVW5kZWZpbmVkKGl0ZW1EZWYpKSB7XG4gICAgICAgICAgICAgICAgYXNzZXJ0VmFsdWVNYXRjaGVzRGVmaW5pdGlvbignKGFycmF5IGl0ZW0pJywgdmFsdWUsIGl0ZW1EZWYpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoXy5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgICAgICAgICAgIG5ld0FycmF5LnB1c2goc2V0dXBBcnJheSh2YWx1ZSkpO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChfLmlzT2JqZWN0KHZhbHVlKSkge1xuICAgICAgICAgICAgICAgIG5ld0FycmF5LnB1c2goc2V0dXBPYmplY3QodmFsdWUpKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgbmV3QXJyYXkucHVzaCh2YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJldHVybiBuZXdBcnJheTtcbiAgICB9XG5cbiAgICAvKlxuICAgICAqIEFzIHBhcnQgb2YgdGhlIHNldCgpIHByb2Nlc3MsIHRha2UgdGhlIHByb3ZpZGVkIEpTT04gb2JqZWN0IGRhdGEsIGFuZCBlaXRoZXIgY29udmVydCBpdCBpbnRvIGEgRFNCIG1vZGVsLCB1c2luZ1xuICAgICAqIHRoZSB0eXBlIHZhbHVlIGluIHRoZSBKU09OIG9iamVjdCwgb3IgcmVjdXJzaXZlbHkgcHJvY2VzcyBhbGwgdGhlIGVsZW1lbnRzIGluIHRoZSBvYmplY3QgYW5kIHNldCB0aG9zZSBvbiB0aGVcbiAgICAgKiBvYmplY3QgdGhpcyByZXR1cm5zLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHNldHVwT2JqZWN0KG9iamVjdFZhbHVlKSB7XG4gICAgICAgIHZhciBuZXdPYmogPSB7fTtcblxuICAgICAgICBpZiAob2JqZWN0VmFsdWUgaW5zdGFuY2VvZiBCYWNrYm9uZS5Nb2RlbCkge1xuICAgICAgICAgICAgb2JqZWN0VmFsdWUgPSBvYmplY3RWYWx1ZS50b0pTT04oKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChpc1NjaGVtYVR5cGUob2JqZWN0VmFsdWUudHlwZSkpIHtcbiAgICAgICAgICAgIG5ld09iaiA9IGNvbnRleHQuX2NhY2hlLmdldENhY2hlZE1vZGVsRnJvbVByb3BlcnRpZXMob2JqZWN0VmFsdWUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgXy5lYWNoKG9iamVjdFZhbHVlLCBmdW5jdGlvbih2YWx1ZSwga2V5KSB7XG4gICAgICAgICAgICAgICAgaWYgKF8uaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgbmV3T2JqW2tleV0gPSBzZXR1cEFycmF5KHZhbHVlKTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKF8uaXNPYmplY3QodmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgICAgIG5ld09ialtrZXldID0gc2V0dXBPYmplY3QodmFsdWUpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIG5ld09ialtrZXldID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbmV3T2JqO1xuICAgIH1cblxuICAgIC8qXG4gICAgICogUmV0dXJuIGEgdmVyc2lvbiBvZiB0aGlzIG1vZGVsIGluIEpTT04gZm9ybWF0LCBhY2NvcmRpbmcgdG8gdGhlIHNwZWNpZmllZCBtb2RlLiBUaGUgbW9kZSBtYXkgaGF2ZSBzZXZlcmFsIHZhbHVlc1xuICAgICAqIHdoaWNoIGNhdXNlIGRpZmZlcmVudCB2ZXJzaW9ucyBvZiB0aGUgbW9kZWwgdG8gYmUgcmV0dXJuZWQ6XG4gICAgICpcbiAgICAgKiB1bmRlZmluZWQ6IFJldHVybiBhbGwgcHJvcGVydGllcy5cbiAgICAgKiBzZW5kOiBSZXR1cm4gYWxsIG5vbi1udWxsIHJlcXVpcmVkIGFuZCBvcHRpb25hbCB2YWx1ZXMuXG4gICAgICogY3JlYXRlOiBSZXR1cm4gYWxsIG5vbi1udWxsIGNyZWF0ZSByZXF1aXJlZCBhbmQgb3B0aW9uYWwgdmFsdWVzLCBhcyB3ZWxsIGFzIHJlcXVpcmVkIG9uZXMuXG4gICAgICogdXBkYXRlOiBSZXR1cm4gYWxsIG5vbi1udWxsIHVwZGF0ZSByZXF1aXJlZCBhbmQgb3B0aW9uYWwgdmFsdWVzLCBhcyB3ZWxsIGFzIHJlcXVpcmVkIG9uZXMuXG4gICAgICpcbiAgICAgKiBzZW5kLCBjcmVhdGUgYW5kIHVwZGF0ZSBhbGwgdGhyb3cgZXJyb3JzIGlmIGEgcmVxdWlyZWQgYXR0cmlidXRlIGlzIG51bGwgb3IgdW5kZWZpbmVkICh1bmxlc3MgdGhhdCBhdHRyaWJ1dGVcbiAgICAgKiBpcyBvZiB0eXBlICdudWxsJylcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBqc29uSXplKHZhbHVlLCBtb2RlKSB7XG4gICAgICAgIHZhciByZXN1bHQ7XG4gICAgICAgIGlmICh2YWx1ZSBpbnN0YW5jZW9mIEJhY2tib25lLk1vZGVsKSB7XG4gICAgICAgICAgICByZXN1bHQgPSB7fTtcbiAgICAgICAgICAgIF8uZWFjaCh2YWx1ZS5fZHhTY2hlbWEucHJvcGVydGllcywgZnVuY3Rpb24ocHJvcERlZiwga2V5KSB7XG4gICAgICAgICAgICAgICAgdmFyIGF0dHJWYWx1ZSA9IHZhbHVlLmdldChrZXkpO1xuXG4gICAgICAgICAgICAgICAgLy8gb3JkaW5hcnkganNvbml6aW5nIHJldHVybnMgZXZlcnl0aGluZ1xuICAgICAgICAgICAgICAgIGlmIChfLmlzVW5kZWZpbmVkKG1vZGUpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdFtrZXldID0ganNvbkl6ZShhdHRyVmFsdWUsIG1vZGUpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gRG9uJ3QgaW5jbHVkZSByZWFkLW9ubHkgcHJvcGVydGllcyB3aGVuIHNlbmRpbmcgYSBwcm9wZXJ0eVxuICAgICAgICAgICAgICAgIGlmIChpc1JlYWRPbmx5KHByb3BEZWYsIG1vZGUpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB2YXIgcmVxdWlyZWQgPSBpc1JlcXVpcmVkKHByb3BEZWYsIG1vZGUpO1xuXG4gICAgICAgICAgICAgICAgLy8gRG9uJ3Qgc2VuZCBudWxsIHdoZW4gaXQgd29uJ3QgYmUgYWNjZXB0ZWRcbiAgICAgICAgICAgICAgICBpZiAoZHhVdGlsLmlzTm9uZShhdHRyVmFsdWUpICYmICFpc051bGxhYmxlVHlwZShwcm9wRGVmKSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAocmVxdWlyZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGR4VXRpbC5mYWlsKCdUaGUgYXR0cmlidXRlICcgKyBrZXkgKyAnIGlzIHJlcXVpcmVkIHRvIGJlIG5vbi1udWxsL25vbi11bmRlZmluZWQuJyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHJlc3VsdFtrZXldID0ganNvbkl6ZShhdHRyVmFsdWUsIG1vZGUpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSBpZiAoXy5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgICAgICAgcmVzdWx0ID0gW107XG4gICAgICAgICAgICBfLmVhY2godmFsdWUsIGZ1bmN0aW9uKGl0ZW0pIHtcbiAgICAgICAgICAgICAgICByZXN1bHQucHVzaChqc29uSXplKGl0ZW0sIG1vZGUpKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2UgaWYgKF8uaXNPYmplY3QodmFsdWUpKSB7XG4gICAgICAgICAgICBpZiAodmFsdWUgaW5zdGFuY2VvZiBEYXRlKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gdmFsdWUudG9KU09OKCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJlc3VsdCA9IHt9O1xuICAgICAgICAgICAgICAgIF8uZWFjaCh2YWx1ZSwgZnVuY3Rpb24ocHJvcFZhbHVlLCBrZXkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0W2tleV0gPSBqc29uSXplKHByb3BWYWx1ZSwgbW9kZSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXN1bHQgPSBfLmlzVW5kZWZpbmVkKHZhbHVlKSA/IG51bGwgOiB2YWx1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLypcbiAgICAgKiBEb2luZyBhICQkdXBkYXRlIHJlcXVpcmVzIHNvbWUgc3BlY2lhbCBoYW5kbGluZywgaGVuY2UgaXQncyBvd24ganNvbml6ZSByb3V0aW5lIGhlcmUuICBUaGUgcGFyYW1ldGVycyB0byB0aGlzIGFyZVxuICAgICAqICAgIHVwZGF0ZUF0dHJzOiAgIEEgcmF3IG9iamVjdC9oYXNoIG9mIGF0dHJpYnV0ZXMgdGhhdCB0aGUgdXNlciBoYXMgYXNrZWQgdG8gc2VuZCBhcyBhbiB1cGRhdGVcbiAgICAgKiAgICAgICAgICAgICAgICAgICBUaGlzIGlzIG5lZWRlZCBiZWNhdXNlIGl0IGdpdmVzIHVzIGEgZGlyZWN0IHZpZXcgb2Ygd2hpY2ggYXR0cmlidXRlcyB0aGUgY2FsbGVyIHdhbnRzIHRvIHNlbmQuXG4gICAgICogICAgdXBkYXRlTW9kZWw6ICAgQSBtb2RlbCB0aGF0IGhhcyBiZWVuIC5zZXQoKSB3aXRoIHRob3NlIGF0dHJpYnV0ZXMuIFRoaXMgaXMgbmVlZGVkIGJlY2F1c2UgaXQgaGFzIHRoZSBmb3JtcyBvZlxuICAgICAqICAgICAgICAgICAgICAgICAgIHRoZSBhdHRyaWJ1dGVzIHRoYXQgaGF2ZSBhbHJlYWR5IGJlZW4gZnVsbHkgcHJvY2Vzc2VkIGJ5IHRoZSBvdmVyYWxsIG1vZGVsIHN5c3RlbSBoZXJlLlxuICAgICAqICAgIGJhc2VNb2RlbDogICAgIFRoZSBtb2RlbCB0aGF0IHRoZSB1cGRhdGUgaXMgcmVsYXRlZCB0by4gVGhpcyBpcyBuZWVkZWQgaW4gb3JkZXIgdG8gcmV0cmlldmUgc29tZSB2YWx1ZXMgdGhhdFxuICAgICAqICAgICAgICAgICAgICAgICAgIG11c3QgYmUgaW5jbHVkZWQgaW4gdGhlIHVwZGF0ZSBidXQgd2VyZSBub3QgZXhwbGljaXRseSBzZXQuIEl0IGFsc28gaGVscHMgdXMgZGV0ZXJtaW5lIHdoZW4gYVxuICAgICAqICAgICAgICAgICAgICAgICAgIHZhbHVlIGRvZXNuJ3QgbmVlZCB0byBiZSBzZW50IGJlY2F1c2UgdGhlIG5ldyB2YWx1ZSBpcyB0aGUgc2FtZSBhcyB0aGUgb2xkLlxuICAgICAqICAgIHByb3BzUmVxdWlyZWQ6IFdoZXRoZXIgdGhlIHByb3BlcnRpZXMgZ2VuZXJhdGVkIGJ5IHRoaXMgY2FsbCBtdXN0IGJlIGluY2x1ZGVkLiBBbHdheXMgdHJ1ZSBhdCB0aGUgdG9wIGxldmVsLFxuICAgICAqICAgICAgICAgICAgICAgICAgIGFuZCBlYWNoIHJlY3Vyc2l2ZSBjYWxsIHNldHMgaXQgYmFzZWQgb24gdGhlIHNjaGVtYSBkZWZpbml0aW9uLlxuICAgICAqXG4gICAgICogVGhlIGJhc2ljIGFsZ29yaXRobSBoZXJlIGlzOlxuICAgICAqICAgIEdvIG92ZXIgZWFjaCBwcm9wZXJ0eSBpbiB0aGUgc2NoZW1hIGRlZmluaXRpb25cbiAgICAgKiAgICBJZiB0aGVyZSBpcyBhbiB1cGRhdGUgYXR0cmlidXRlIGZvciBpdCwgdGhlbiBhZGQgdGhhdCB0byB0aGUgaGFzaCBvZiBwcm9wZXJ0aWVzIHdlIHdpbGwgcmV0dXJuXG4gICAgICogICAgICAoYnV0IHVzZSB0aGUganNvbkl6ZWQgdmVyc2lvbiBvZiB0aGF0IGF0dHJpYnV0ZSBmcm9tIHRoZSB1cGRhdGVNb2RlbCwgdG8gZ2V0IGFsbCB0aGUgYmVuZWZpdHMgb2YgcHJvcGVyXG4gICAgICogICAgICBqc29uaXphdGlvbilcbiAgICAgKiAgICBIb3dldmVyLCB0aGVyZSBhcmUgc29tZSBjYXZlYXRzOlxuICAgICAqICAgICAgIC0gSWYgdGhlIHVwZGF0ZSBzcGVjaWZpZXMgYSB2YWx1ZSB3aGljaCBpcyBub3QgY2hhbmdlZCwgZG9uJ3Qgc2VuZCBhIGR1cGxpY2F0ZVxuICAgICAqICAgICAgIC0gSWYgYSBwcm9wZXJ0eSBpcyByZXF1aXJlZCBmb3IgdXBkYXRlLCBidXQgaXNuJ3QgaW5jbHVkZWQgaW4gdGhlIGF0dHJpYnV0ZXMsIGdyYWIgaXQgZnJvbSB0aGVcbiAgICAgKiAgICAgICAgIGJhc2UgbW9kZWxcbiAgICAgKiAgICAgICAtIElmIHRoZSB1cGRhdGUgYXR0cmlidXRlcyBzcGVjaWZpZWQgYW4gdW5kZWZpbmVkIHZhbHVlLCBhbmQgdGhlIHByb3BlcnR5IGlzIGFsbG93ZWQgdG8gYmUgbnVsbCxcbiAgICAgKiAgICAgICAgIHdlIHNlbmQgYSBudWxsLlxuICAgICAqICAgICAgIC0gRW1iZWRkZWQgbW9kZWxzIG5lZWQgc3BlY2lhbCBoYW5kbGluZy4gIElmIHRoZSBlbWJlZGRlZCBtb2RlbCBpcyByZXF1aXJlZCwgdGhlbiB3ZSBzaW1wbHkgYWRkIGl0IHRvXG4gICAgICogICAgICAgICB0aGUgc2V0IG9mIHByb3BlcnRpZXMgd2UgYXJlIHJldHVybmluZy4gSWYgdGhlIGVtYmVkZGVkIG1vZGVsIGlzIG9wdGlvbmFsLCBob3dldmVyLCB0aGVuIGlmIHRoZXJlIGFyZSBub1xuICAgICAqICAgICAgICAgbmV3IHZhbHVlcyBpbiB0aGF0IGVtYmVkZGVkIG1vZGVsIChldmVuIGlmIHRoZXJlIGFyZSByZXF1aXJlZCBwcm9wZXJ0aWVzIHRoZXJlKSB0aGVuIGl0IGlzIG5vdCBpbmNsdWRlZFxuICAgICAqICAgICAgICAgaW4gdGhlIHVwZGF0ZS4gIFRoaXMsIHRoZW4sIGlzIHRoZSByZWFzb24gZm9yIHRoZSBwcm9wc1JlcXVpcmVkIHBhcmFtZXRlciBhbmQgdGhlIHByb3BDb3VudCBpbiB0aGVcbiAgICAgKiAgICAgICAgIHJvdXRpbmUuICBXZSB0ZWxsIGVhY2ggc3Vic2VxdWVudCBjYWxsIHdoZXRoZXIgd2Ugd2FudCBpdCB0byByZXR1cm4gdGhlIHByb3BlcnRpZXMgZXZlbiBpZiB0aGVyZSBpc1xuICAgICAqICAgICAgICAgbm90aGluZyBuZXcuXG4gICAgICovXG4gICAgZnVuY3Rpb24ganNvbkl6ZUZvclVwZGF0ZShyYXdVcGRhdGVPYmosIHVwZGF0ZU1vZGVsLCBiYXNlTW9kZWwsIHByb3BzUmVxdWlyZWQpIHtcbiAgICAgICAgdmFyIGpzb25VcGRhdGVQYXlsb2FkID0ge307XG4gICAgICAgIHZhciBwcm9wQ291bnQgPSAwO1xuICAgICAgICBfLmVhY2godXBkYXRlTW9kZWwuX2R4U2NoZW1hLnByb3BlcnRpZXMsIGZ1bmN0aW9uKHByb3BEZWYsIGtleSkge1xuICAgICAgICAgICAgLy8gRG9uJ3QgaW5jbHVkZSByZWFkLW9ubHkgcHJvcGVydGllcyB3aGVuIHNlbmRpbmcgYSBwcm9wZXJ0eVxuICAgICAgICAgICAgaWYgKGlzUmVhZE9ubHkocHJvcERlZiwgJ3VwZGF0ZScpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgcmVxdWlyZWQgPSBpc1JlcXVpcmVkKHByb3BEZWYsICd1cGRhdGUnKTtcblxuICAgICAgICAgICAgaWYgKGlzRW1iZWRkZWRQcm9wKHByb3BEZWYpKSB7XG4gICAgICAgICAgICAgICAgdmFyIHN1YlByb3BzID0gcmF3VXBkYXRlT2JqID8gcmF3VXBkYXRlT2JqW2tleV0gOiB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgdmFyIGJhc2VFbWJlZGRlZCA9IGJhc2VNb2RlbC5nZXQoa2V5KTtcbiAgICAgICAgICAgICAgICB2YXIgdXBkYXRlRW1iZWRkZWQgPSB1cGRhdGVNb2RlbC5nZXQoa2V5KTtcbiAgICAgICAgICAgICAgICB2YXIgZW1iSnNvbjtcbiAgICAgICAgICAgICAgICAvKlxuICAgICAgICAgICAgICAgICAqIFRoZSB1cGRhdGUgbWF5IGxlZ2l0aW1hdGVseSBiZSB0cnlpbmcgdG8gY2hhbmdlIHRoZSB0eXBlIG9mIGFuIGVtYmVkZGVkIG9iamVjdC4gSW4gdGhpcyBjYXNlIHdlIGNhbid0XG4gICAgICAgICAgICAgICAgICoga2VlcCB1c2luZyB0aGUgYmFzZU1vZGVsJ3MgZW1iZWRkZWQgbW9kZWwgdG8gZXh0cmFjdCBwcm9wZXJ0aWVzIGZyb20gKGluIHBhcnRpY3VsYXIsIHRoZXJlIG1heSBiZVxuICAgICAgICAgICAgICAgICAqIHByb3BlcnRpZXMgaW4gdGhlICd1cGRhdGUnIGRhdGEgdGhhdCBhcmVuJ3QgaW4gdGhlIGVtYmVkZGVkIG1vZGVsLCBzbyB0aGVyZSdzIG5vdGhpbmcgdG8gZXh0cmFjdCkuXG4gICAgICAgICAgICAgICAgICogRnVydGhlciwgb3VyIGRlZmluaXRpb24gb2YgY2hhbmdpbmcgdHlwZXMgaW4gZW1iZWRkZWQgbW9kZWxzIGlzIHRoYXQgd2UgZG8gbm90IHByZXNlcnZlIGFueVxuICAgICAgICAgICAgICAgICAqIHByb3BlcnRpZXMgcHJvcGVydGllcyB0aGF0IHdlcmUgdGhlcmUgYmVmb3JlLCBldmVuIGlmIHRoZXkgY291bGQgYmUuIEluIHRoaXMgcmVnYXJkLCBjaGFuZ2luZyB0aGVcbiAgICAgICAgICAgICAgICAgKiB0eXBlIGlzbid0IGFuIG92ZXJsYXksIGJ1dCBpcyBpbnN0ZWFkIGEgcmVwbGFjZSBvcGVyYXRpb24uIFRvIG1ha2UgdGhpcyB3b3JrIGhlcmUgd2UgY3JlYXRlIGEgbmV3XG4gICAgICAgICAgICAgICAgICogbW9kZWwgdG8gYmUgdXNlZCBhcyB0aGUgYmFzZSBtb2RlbCBmb3IgdGhlIHJlY3Vyc2l2ZSBjYWxsIHRvIGpzb25JemluZy5cbiAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICBpZiAoYmFzZUVtYmVkZGVkLmdldCgndHlwZScpICE9PSB1cGRhdGVFbWJlZGRlZC5nZXQoJ3R5cGUnKSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBEb2luZyBhbiB1cGRhdGUgdGhhdCBjaGFuZ2VzIHRoZSB0eXBlIHJlYWxseSBtZWFucyB3ZSBhcmUganVzdCBzZW5kaW5nIHRoZSBuZXcgZGF0YVxuICAgICAgICAgICAgICAgICAgICBlbWJKc29uID0ganNvbkl6ZSh1cGRhdGVFbWJlZGRlZCwgJ3VwZGF0ZScpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGVtYkpzb24gPSBqc29uSXplRm9yVXBkYXRlKHN1YlByb3BzLCB1cGRhdGVFbWJlZGRlZCwgYmFzZUVtYmVkZGVkLCByZXF1aXJlZCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICghXy5pc1VuZGVmaW5lZChlbWJKc29uKSkge1xuICAgICAgICAgICAgICAgICAgICBqc29uVXBkYXRlUGF5bG9hZFtrZXldID0gZW1iSnNvbjtcbiAgICAgICAgICAgICAgICAgICAgcHJvcENvdW50Kys7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB2YXIgYmFzZUF0dHJKc29uID0ganNvbkl6ZShiYXNlTW9kZWwuZ2V0KGtleSksICd1cGRhdGUnKTtcbiAgICAgICAgICAgICAgICB2YXIgdXBkYXRlQXR0ckpzb24gPSBqc29uSXplKHVwZGF0ZU1vZGVsLmdldChrZXkpLCAndXBkYXRlJyk7XG4gICAgICAgICAgICAgICAgdmFyIHVwZGF0ZVZhbHVlID0gdXBkYXRlV2l0aENoYW5nZWRWYWx1ZShyYXdVcGRhdGVPYmosIGtleSwgYmFzZUF0dHJKc29uLCB1cGRhdGVBdHRySnNvbik7XG5cbiAgICAgICAgICAgICAgICBpZiAodXBkYXRlVmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3dJZkJhZE51bGwodXBkYXRlQXR0ckpzb24sIHByb3BEZWYsIGtleSk7XG4gICAgICAgICAgICAgICAgICAgIHByb3BDb3VudCsrO1xuICAgICAgICAgICAgICAgICAgICBqc29uVXBkYXRlUGF5bG9hZFtrZXldID0gdXBkYXRlQXR0ckpzb247XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChyZXF1aXJlZCAmJiAhdXBkYXRlVmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3dJZkJhZE51bGwoYmFzZUF0dHJKc29uLCBwcm9wRGVmLCBrZXkpO1xuICAgICAgICAgICAgICAgICAgICBqc29uVXBkYXRlUGF5bG9hZFtrZXldID0gYmFzZUF0dHJKc29uO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgdmFyIHJldHVyblZhbHVlID0gcHJvcHNSZXF1aXJlZCB8fCAocHJvcENvdW50ID4gMCk7XG5cbiAgICAgICAgcmV0dXJuIHJldHVyblZhbHVlID8ganNvblVwZGF0ZVBheWxvYWQgOiB1bmRlZmluZWQ7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gdXBkYXRlV2l0aENoYW5nZWRWYWx1ZShyYXdVcGRhdGVPYmosIGtleSwgYmFzZUF0dHJKc29uLCB1cGRhdGVBdHRySnNvbikge1xuICAgICAgICByZXR1cm4gKCFfLmlzVW5kZWZpbmVkKHJhd1VwZGF0ZU9iaikgJiYgXy5oYXMocmF3VXBkYXRlT2JqLCBrZXkpICYmICFfLmlzRXF1YWwoYmFzZUF0dHJKc29uLCB1cGRhdGVBdHRySnNvbikpO1xuICAgIH1cblxuICAgIC8qXG4gICAgICogRGV0ZXJtaW5lIHdoZXRoZXIgdGhlIHNwZWNpZmllZCBwcm9wZXJ0eSBpcyAncmVhZCBvbmx5JyBpbiB0aGUgY3VycmVudCBqc29uaXppbmcgbW9kZS4gSXQgaXMgcmVhZG9ubHkgaWZcbiAgICAgKiBpdCB0aGVyZSBhcmUgbm8gcmVxdWlyZWQgb3IgY3JlYXRlL3VwZGF0ZSBzZXR0aW5ncywgb3IgaWYgaXQgaXMgZXhwbGljaXRseSByZWFkb25seS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpc1JlYWRPbmx5KHByb3BEZWYsIG1vZGUpIHtcbiAgICAgICAgdmFyIHJlYWRPbmx5ID1cbiAgICAgICAgICAgIChtb2RlID09PSAnY3JlYXRlJyAmJlxuICAgICAgICAgICAgICAgICgoXy5pc1VuZGVmaW5lZChwcm9wRGVmLmNyZWF0ZSkgJiYgXy5pc1VuZGVmaW5lZChwcm9wRGVmLnJlcXVpcmVkKSkgfHxcbiAgICAgICAgICAgICAgICAgICAgcHJvcERlZi5jcmVhdGUgPT09ICdyZWFkb25seScpKSB8fFxuICAgICAgICAgICAgKG1vZGUgPT09ICd1cGRhdGUnICYmXG4gICAgICAgICAgICAgICAgKChfLmlzVW5kZWZpbmVkKHByb3BEZWYudXBkYXRlKSAmJiBfLmlzVW5kZWZpbmVkKHByb3BEZWYucmVxdWlyZWQpKSB8fFxuICAgICAgICAgICAgICAgICAgICBwcm9wRGVmLnVwZGF0ZSA9PT0gJ3JlYWRvbmx5JykpO1xuICAgICAgICByZXR1cm4gcmVhZE9ubHk7XG4gICAgfVxuXG4gICAgLypcbiAgICAgKiBEZXRlcm1pbmUgd2hldGhlciB0aGUgc3BlY2lmaWVkIHByb3BlcnR5IGlzICdyZXF1aXJlZCcgZ2l2ZW4gdGhlIHNwZWNpZmllZCBqc29uaXppbmcgbW9kZS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpc1JlcXVpcmVkKHByb3BEZWYsIG1vZGUpIHtcbiAgICAgICAgdmFyIHJlcXVpcmVkID0gKHByb3BEZWYucmVxdWlyZWQgPT09IHRydWUpIHx8XG4gICAgICAgICAgICAocHJvcERlZi5jcmVhdGUgPT09ICdyZXF1aXJlZCcgJiYgbW9kZSA9PT0gJ2NyZWF0ZScpIHx8XG4gICAgICAgICAgICAocHJvcERlZi51cGRhdGUgPT09ICdyZXF1aXJlZCcgJiYgbW9kZSA9PT0gJ3VwZGF0ZScpO1xuICAgICAgICByZXR1cm4gcmVxdWlyZWQ7XG4gICAgfVxuXG4gICAgLypcbiAgICAgKiBEZXRlcm1pbmUgd2hldGhlciB0aGUgc3BlY2lmaWVkIHByb3BlcnR5IGlzIG9uZSB0aGF0IGFsbG93cyBudWxsIHZhbHVlc1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzTnVsbGFibGVUeXBlKHByb3BEZWYpIHtcbiAgICAgICAgcmV0dXJuIF8uaXNBcnJheShwcm9wRGVmLnR5cGUpID8gXy5jb250YWlucyhwcm9wRGVmLnR5cGUsICdudWxsJykgOiAocHJvcERlZi50eXBlID09PSAnbnVsbCcpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGlzRW1iZWRkZWRQcm9wKHByb3BEZWYpIHtcbiAgICAgICAgcmV0dXJuIChwcm9wRGVmLnR5cGUgPT09ICdvYmplY3QnICYmIF8uaGFzKHByb3BEZWYsICckcmVmJykgJiYgcHJvcERlZi4kcmVmICE9PSAnSnNvbicpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGlzT2JqZWN0UmVmUHJvcChwcm9wRGVmKSB7XG4gICAgICAgIGlmIChfLmlzQXJyYXkocHJvcERlZi50eXBlKSkge1xuICAgICAgICAgICAgcmV0dXJuIF8uY29udGFpbnMocHJvcERlZi50eXBlLCAnc3RyaW5nJykgJiYgcHJvcERlZi5mb3JtYXQgPT09ICdvYmplY3RSZWZlcmVuY2UnO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAocHJvcERlZi50eXBlID09PSAnc3RyaW5nJyAmJiBwcm9wRGVmLmZvcm1hdCA9PT0gJ29iamVjdFJlZmVyZW5jZScpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHRocm93SWZCYWROdWxsKHZhbHVlLCBwcm9wRGVmLCBrZXkpIHtcbiAgICAgICAgaWYgKGR4VXRpbC5pc05vbmUodmFsdWUpICYmICFpc051bGxhYmxlVHlwZShwcm9wRGVmKSkge1xuICAgICAgICAgICAgZHhVdGlsLmZhaWwoJ1RoZSBhdHRyaWJ1dGUgJyArIGtleSArICcgaXMgcmVxdWlyZWQgdG8gYmUgbm9uLW51bGwvbm9uLXVuZGVmaW5lZC4nKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGlzU2NoZW1hVHlwZSh0eXBlTmFtZSkge1xuICAgICAgICByZXR1cm4gISFjb250ZXh0Ll9tb2RlbENvbnN0cnVjdG9yc1t0eXBlTmFtZV07XG4gICAgfVxuXG4gICAgLypcbiAgICAgKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gICAgICogQWN0dWFsbHkgZG8gdGhlIHdvcmsgb2YgdGhpcyBmdW5jdGlvblxuICAgICAqID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAgICAgKi9cblxuICAgIGNvbnRleHQgPSBjb250ZXh0IHx8IHRoaXM7XG4gICAgY29udGV4dC5fbW9kZWxDb25zdHJ1Y3RvcnMgPSBjb250ZXh0Ll9tb2RlbENvbnN0cnVjdG9ycyB8fCB7fTtcbiAgICBjb250ZXh0LnJvb3RPcHMgPSBjb250ZXh0LnJvb3RPcHMgfHwge307XG5cbiAgICBfLmVhY2goc2NoZW1hcywgZnVuY3Rpb24oc2NoZW1hLCB0eXBlTmFtZSkge1xuICAgICAgICB2YXIgcndNb2RlbCA9IHtcbiAgICAgICAgICAgIF9keFNjaGVtYTogc2NoZW1hLFxuICAgICAgICAgICAgX2R4SXNSZWFkeTogZmFsc2UsXG4gICAgICAgICAgICBfZHhFcnJvclJlc3VsdDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgX2R4SXNDbGllbnRNb2RlbDogZmFsc2UsXG4gICAgICAgICAgICBfZHhTdGFuZGFyZE9wczoge30sXG4gICAgICAgICAgICBpZEF0dHJpYnV0ZTogJ3JlZmVyZW5jZScsXG4gICAgICAgICAgICB1cmxSb290OiBzY2hlbWEucm9vdCxcbiAgICAgICAgICAgIF9keFNldDogZHhTZXQsXG4gICAgICAgICAgICBfZHhDbGVhcjogZHhDbGVhcixcbiAgICAgICAgICAgIF9keEZldGNoOiBkeEZldGNoLFxuICAgICAgICAgICAgX2R4R2V0VXJsIDogZHhVcmwsXG4gICAgICAgICAgICBfZHhNYWtlUmVhZHk6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIG1ha2VSZWFkeSh0aGlzLCBmYWxzZSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgb246IGR4T24sXG4gICAgICAgICAgICBnZXQ6IGR4R2V0LFxuICAgICAgICAgICAgc2V0OiBkeFNldCxcbiAgICAgICAgICAgIGhhczogZHhIYXMsXG4gICAgICAgICAgICB1bnNldDogZHhVbnNldCxcbiAgICAgICAgICAgIGNsZWFyOiBkeENsZWFyLFxuICAgICAgICAgICAgdG9KU09OOiBkeFRvSlNPTixcbiAgICAgICAgICAgIGZldGNoOiBub0ZldGNoLFxuICAgICAgICAgICAgc2F2ZTogbm9TYXZlLFxuICAgICAgICAgICAgZGVzdHJveTogbm9EZXN0cm95LFxuICAgICAgICAgICAgcGFyc2U6IGR4UGFyc2UsXG4gICAgICAgICAgICBjbG9uZTogZHhDbG9uZSxcbiAgICAgICAgICAgIGluc3RhbmNlT2Y6IGluc3RhbmNlT2YsXG4gICAgICAgICAgICBpc1NlcnZlck1vZGVsOiBpc1NlcnZlck1vZGVsXG4gICAgICAgIH07XG5cbiAgICAgICAgZnVuY3Rpb24gZ2V0Um9vdFVybCgpIHtcbiAgICAgICAgICAgIHJldHVybiBzY2hlbWEucm9vdDtcbiAgICAgICAgfVxuXG4gICAgICAgIGFkZE9wZXJhdGlvbnMocndNb2RlbCwgc2NoZW1hLm9wZXJhdGlvbnMsICcnLCAnJywgdHJ1ZSk7XG5cbiAgICAgICAgaWYgKHNjaGVtYS5yb290T3BlcmF0aW9ucykge1xuICAgICAgICAgICAgLypcbiAgICAgICAgICAgICAqIFJvb3Qgb3BlcmF0aW9ucyBvbiBzaW5nbGV0b25zIGFyZSwgZXNzZW50aWFsbHkgb2JqZWN0IG9wZXJhdGlvbnMsIGFzIGZhciBhcyB0aGUgY2xpZW50IG9iamVjdCBtb2RlbFxuICAgICAgICAgICAgICogaXMgY29uY2VybmVkLiBTbywgdHJlYXQgdGhvc2Ugcm9vdCBvcGVyYXRpb25zIGFzIG9iamVjdCBvcGVyYXRpb25zLiAgSG93ZXZlciwgdGhlcmUgYXJlIGFsc28gc29tZVxuICAgICAgICAgICAgICogc2luZ2xldG9uICdwc2V1ZG8tb2JqZWN0cycgKGUuZy4gZGVscGhpeF9jb21tb24pIHdoaWNoIG9ubHkgZXhpc3QgdG8gaG9sZCBhIGZldyBvcGVyYXRpb25zLCBzbyB0aG9zZSB3ZVxuICAgICAgICAgICAgICogcHV0IG9uIHRoZSByb290T3BzIG9iamVjdC4gIFRoZXNlIHBzZXVkby1vYmplY3RzIGFsbCBwcmVmaXhlZCBieSAnZGVscGhpeF8nLlxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBpZiAoc2NoZW1hLnNpbmdsZXRvbiAmJiBzY2hlbWEubmFtZS5pbmRleE9mKCdkZWxwaGl4XycpICE9PSAwKSB7XG4gICAgICAgICAgICAgICAgYWRkT3BlcmF0aW9ucyhyd01vZGVsLCBzY2hlbWEucm9vdE9wZXJhdGlvbnMsICcnLCAnJywgZmFsc2UpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBjb250ZXh0LnJvb3RPcHNbdHlwZU5hbWVdID0ge307XG4gICAgICAgICAgICAgICAgY29udGV4dC5yb290T3BzW3R5cGVOYW1lXS5fZHhHZXRVcmwgPSBnZXRSb290VXJsO1xuICAgICAgICAgICAgICAgIGFkZE9wZXJhdGlvbnMoY29udGV4dC5yb290T3BzW3R5cGVOYW1lXSwgc2NoZW1hLnJvb3RPcGVyYXRpb25zLCAnJywgJycsIGZhbHNlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChzY2hlbWEuY3JlYXRlKSB7XG4gICAgICAgICAgICBjb250ZXh0LnJvb3RPcHNbdHlwZU5hbWVdID0gY29udGV4dC5yb290T3BzW3R5cGVOYW1lXSB8fCB7fTtcbiAgICAgICAgICAgIGNvbnRleHQucm9vdE9wc1t0eXBlTmFtZV0uJCRjcmVhdGUgPSBmdW5jdGlvbihwYXlsb2FkLCBzdWNjZXNzRXJyb3IpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZHhDcmVhdGUoc2NoZW1hLmNyZWF0ZSwgZ2V0Um9vdFVybCgpLCBwYXlsb2FkLCBzdWNjZXNzRXJyb3IpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChzY2hlbWEuZGVsZXRlKSB7XG4gICAgICAgICAgICByd01vZGVsLl9keFN0YW5kYXJkT3BzLiQkZGVsZXRlID0gZHhEZWxldGU7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoc2NoZW1hLnVwZGF0ZSkge1xuICAgICAgICAgICAgcndNb2RlbC5fZHhTdGFuZGFyZE9wcy4kJHVwZGF0ZSA9IGR4VXBkYXRlO1xuICAgICAgICB9XG5cbiAgICAgICAgY29udGV4dC5fbW9kZWxDb25zdHJ1Y3RvcnNbdHlwZU5hbWVdID0gQmFja2JvbmUuTW9kZWwuZXh0ZW5kKHJ3TW9kZWwpO1xuICAgIH0pO1xuXG4gICAgXy5leHRlbmQoY29udGV4dCwge1xuICAgICAgICBfY2hlY2tBbmRDb252ZXJ0UGFyYW1ldGVyczogY2hlY2tBbmRDb252ZXJ0UGFyYW1ldGVycyxcbiAgICAgICAgX25ld1NlcnZlck1vZGVsOiBuZXdTZXJ2ZXJNb2RlbCxcbiAgICAgICAgX25ld0NsaWVudE1vZGVsOiBuZXdDbGllbnRNb2RlbCxcbiAgICAgICAgX2dldFJvb3RUeXBlOiBnZXRSb290VHlwZSxcbiAgICAgICAgX2NvbnZlcnRYaHJUb0Vycm9yUmVzdWx0OiBjb252ZXJ0WGhyVG9FcnJvclJlc3VsdCxcbiAgICAgICAgX2hhbmRsZUVycm9yUmVzdWx0OiBoYW5kbGVFcnJvclJlc3VsdFxuICAgIH0pO1xuXG4gICAgLy8gQWRkIGEgdHJpdmlhbCBmdW5jdGlvbiBmb3IgcmVwb3J0aW5nIGFuIEVycm9yUmVzdWx0LiAgVGhpcyBpcyBhZGRlZCBmb3IgdGVzdGluZyBhbmQgb25seSBpZiBsZXZlbDMgaXNuJ3QgaGVyZS5cbiAgICBpZiAoIWNvbnRleHQucmVwb3J0RXJyb3JSZXN1bHQpIHtcbiAgICAgICAgY29udGV4dC5yZXBvcnRFcnJvclJlc3VsdCA9IGZ1bmN0aW9uKCkge307XG4gICAgfVxufTtcbiIsIi8qXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTMsIDIwMTUgYnkgRGVscGhpeC4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqL1xuXG4vKiBnbG9iYWwgJCwgXywgQmFja2JvbmUgKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCBkeFV0aWwgPSByZXF1aXJlKCdkeGNvcmUvanMvdXRpbC5qcycpLFxuICAgIGR4Q3JlYXRpb25MaXN0ZW5lciA9IHJlcXVpcmUoJ2R4Y29yZS9kYXRhL2xheWVyMi9qcy9jcmVhdGlvbkxpc3RlbmVyLmpzJyksXG4gICAgZHhTY2hlbWEgPSByZXF1aXJlKCdkeGNvcmUvZGF0YS9sYXllcjEvanMvc2NoZW1hLmpzJyksXG4gICAgZHhDYWNoZSA9IHJlcXVpcmUoJ2R4Y29yZS9kYXRhL2xheWVyMi9qcy9jYWNoZS5qcycpLFxuICAgIGR4TW9kZWwgPSByZXF1aXJlKCdkeGNvcmUvZGF0YS9sYXllcjIvanMvbW9kZWwuanMnKSxcbiAgICBkeENvbGxlY3Rpb24gPSByZXF1aXJlKCdkeGNvcmUvZGF0YS9sYXllcjIvanMvY29sbGVjdGlvbi5qcycpLFxuICAgIGR4Tm90aWZpY2F0aW9uID0gcmVxdWlyZSgnZHhjb3JlL2RhdGEvbGF5ZXIzL2pzL25vdGlmaWNhdGlvbi5qcycpLFxuICAgIGR4RmlsdGVyID0gcmVxdWlyZSgnZHhjb3JlL2RhdGEvbGF5ZXIyL2pzL2ZpbHRlci5qcycpO1xuXG4vKlxuICogVGhpcyBkZWZpbmVzIHRoZSBwdWJsaWMgQVBJIG9mIHRoZSBEZWxwaGl4IERhdGEgU3lzdGVtLiBJdCByZWxpZXMgaGVhdmlseSBvbiB0aGUgaW5mcmFzdHJ1Y3R1cmUgYnVpbHQgaW4gdGhlXG4gKiBmaWxlcyBjb250YWluaW5nIHRoZSBsZXZlbCAxIGFuZCBsZXZlbCAyIGNvZGUuXG4gKlxuICogVGhpcyBwcm92aWRlcyBzZXZlcmFsIHB1YmxpYyBmdW5jdGlvbnMgdG8gZ2V0IGF0IERlbHBoaXgtU2NoZW1hLUJhc2VkIG1vZGVscyBhbmQgY29sbGVjdGlvbnM6XG4gKiAgICAgbmV3Q2xpZW50TW9kZWwgICAgICAgICAgICAgICAgICBSZXR1cm5zIGEgJ3JlYWQvd3JpdGUnIG1vZGVsIG9mIHRoZSBzcGVjaWZpZWQgc2NoZW1hIHR5cGUuXG4gKlxuICogICAgIGdldFNlcnZlck1vZGVsICAgICAgICAgICAgICAgICAgUmV0dXJucyBhICdyZWFkLW9ubHknIG1vZGVsIG9mIHRoZSBzcGVjaWZpZWQgc2NoZW1hIHR5cGUgd2hpY2ggaXMga2VwdCBpblxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3luYyB3aXRoIHRoZSBzZXJ2ZXIgYXMgbG9uZyBhcyBpdCByZW1haW5zIGEgbWVtYmVyIG9mIGEgU2VydmVyIENvbGxlY3Rpb24uXG4gKlxuICogICAgIGdldFNlcnZlclNpbmdsZXRvbiAgICAgICAgICAgICAgUmV0dXJucyBhICdyZWFkLW9ubHknIG1vZGVsIG9mIHRoZSBzcGVjaWZpZWQgc2NoZW1hIHR5cGUuXG4gKlxuICogICAgIGdldFNlcnZlckNvbGxlY3Rpb24gICAgICAgICAgICAgUmV0dXJucyBhICdyZWFkLW9ubHknIGNvbGxlY3Rpb24gd2hpY2ggY29udGFpbnMgU2VydmVyIE1vZGVscyBvZiBhIHBhcnRpY3VsYXJcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGUuXG4gKlxuICogICAgIGdldENyZWF0aW9uTGlzdGVuZXIgICAgICAgICAgICAgUmVnaXN0ZXIgYSBjcmVhdGlvbiBsaXN0ZW5lciBmb3IgYSBwYXJ0aWN1bGFyIHR5cGUuXG4gKlxuICogICAgIGdldENvbGxlY3Rpb25UeXBlRnJvbU1vZGVsVHlwZSAgUmV0dXJucyB0aGUgbmFtZSBvZiB0aGUgY29sbGVjdGlvbiB0eXBlIHRoYXQgdGhlIHNwZWNpZmllZCBtb2RlbCB0eXBlIGJlbG9uZ3MgdG8uXG4gKlxuICogICAgIHNldEVycm9yQ2FsbGJhY2sgICAgICAgICAgICAgICAgU2V0IGFuIGVycm9yIGNhbGxiYWNrIGZ1bmN0aW9uIHRoYXQgd2lsbCBiZSBjYWxsZWQgYnkgcmVwb3J0RXJyb3JSZXN1bHQgb24gYW5cbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVycm9yLlxuICpcbiAqICAgICByZXBvcnRFcnJvclJlc3VsdCAgICAgICAgICAgICAgIENvbnZlbmllbmNlIHJvdXRpbmUgd2hpY2ggd2lsbCBkaXNwbGF5IGFuIEVycm9yUmVzdWx0IG9iamVjdCB0byB0aGUgdXNlciBvbiB0aGVcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNjcmVlbi4gVGhpcyBpcyBtYWlubHkgdXNlZnVsIGlmIHlvdSBoYXZlIGFuIG9wZXJhdGlvbiBlcnJvciBoYW5kbGVyIHdoaWNoLFxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYWZ0ZXIgZXhhbWluaW5nIHRoZSBFcnJvclJlc3VsdCBtb2RlbCwgeW91IHN0aWxsIHdpc2ggdG8gc2hvdyBpdCB0byB0aGUgdXNlci5cbiAqL1xubW9kdWxlLmV4cG9ydHMuc2V0dXBEYXRhU3lzdGVtID0gZnVuY3Rpb24gc2V0dXBEYXRhU3lzdGVtKHNjaGVtYXMsIGNvbnRleHQpIHtcbiAgICAvKlxuICAgICAqIFJldHVybnMgYSBuZXcgY2xpZW50IG1vZGVsLlxuICAgICAqXG4gICAgICogdHlwZU5hbWU6IFRoZSB0eXBlIG9mIHRoZSBtb2RlbC4gSWYgYSBEQjJDb250YWluZXIgaXMgZGVzaXJlZCwgdGhlbiBEQjJDb250YWluZXIgc2hvdWxkIGJlIHBhc3NlZC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBuZXdDbGllbnRNb2RlbCh0eXBlTmFtZSkge1xuICAgICAgICByZXR1cm4gY29udGV4dC5fbmV3Q2xpZW50TW9kZWwodHlwZU5hbWUpO1xuICAgIH1cblxuICAgIC8qXG4gICAgICogUmV0dXJucyBhIFNlcnZlciBDb2xsZWN0aW9uIGZvciB0aGUgc3BlY2lmaWVkIHR5cGUuICBFYWNoIGNhbGwgcmV0dXJucyBhIG5ldyBjb2xsZWN0aW9uLCB3aGljaCBtYXkgY29udGFpblxuICAgICAqIGRpc3RpbmN0IGVsZW1lbnRzIGZyb20gb3RoZXIgY29sbGVjdGlvbnMgb2YgdGhlIHNhbWUgdHlwZS4gIFRoZSBjb2xsZWN0aW9uIGlzICdyZWFkIG9ubHknLCB3aGljaCBtZWFucyBpdHNcbiAgICAgKiBjb250ZW50cyBtYXkgbm90IGJlIGRpcmVjdGx5IG1hbmlwdWxhdGVkLiBIb3dldmVyLCBpdHMgY29udGVudHMgbWF5IGJlIGNoYW5nZWQgd2l0aCB0aGUgJCRsaXN0KCkgb3BlcmF0aW9uIG9uXG4gICAgICogdGhlIGNvbGxlY3Rpb24uXG4gICAgICpcbiAgICAgKiB0eXBlTmFtZTogICAgVGhpcyBzaG91bGQgYmUgdGhlICdyb290IHR5cGUnIGZvciB0aGUgY29sbGVjdGlvbiB0eXBlIHdhbnRlZC4gVGhhdCBpcywgaWYgb25lIHdhbnRzIGEgY29sbGVjdGlvblxuICAgICAqICAgICAgICAgICAgICBvZiBEQjJDb250YWluZXJzLCBvbmUgc2hvdWxkIHBhc3MgJ0NvbnRhaW5lcicgaGVyZS5cbiAgICAgKiByZXNldE9uTGlzdDogSWYgdHJ1ZSwgJCRsaXN0KCkncyB3aWxsIG9ubHkgdHJpZ2dlciBhIHNpbmdsZSAncmVzZXQnIGV2ZW50IHJhdGhlciB0aGFuIGluZGl2aWR1YWwgJ2FkZCcgYW5kXG4gICAgICogICAgICAgICAgICAgICdyZW1vdmUnIGV2ZW50cy4gT3RoZXJ3aXNlIHRoaXMgaGFwcGVucyBvbmx5IHdoZW4gdGhlICQkbGlzdCgpIGZ1bGx5IHJlcGxhY2VzIHRoZSBjb250ZW50cyBvZiB0aGVcbiAgICAgKiAgICAgICAgICAgICAgY29sbGVjdGlvbi5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBnZXRTZXJ2ZXJDb2xsZWN0aW9uKHR5cGVOYW1lLCByZXNldE9uTGlzdCkge1xuICAgICAgICB2YXIgY29sbGVjdGlvbiA9IGNvbnRleHQuX25ld1NlcnZlckNvbGxlY3Rpb24odHlwZU5hbWUsIHJlc2V0T25MaXN0KTtcbiAgICAgICAgY29udGV4dC5fbW9kZWxTdWJzY3JpYmVyc1N0b3JlLmFkZChjb2xsZWN0aW9uKTtcbiAgICAgICAgcmV0dXJuIGNvbGxlY3Rpb247XG4gICAgfVxuXG4gICAgLypcbiAgICAgKiBSZXR1cm5zIGEgY3JlYXRpb24gbGlzdGVuZXIgZm9yIHRoZSBzcGVjaWZpZWQgdHlwZS4gRWFjaCBjYWxsIHJldHVybnMgYSBuZXcgbGlzdGVuZXIsIHdoaWNoIG11c3QgYmUgZGlzcG9zZWRcbiAgICAgKiBzbyBhcyB0byBmcmVlIHJlc291cmNlcy5cbiAgICAgKlxuICAgICAqICAgdHlwZU5hbWUgICAgICAgVGhlIHNjaGVtYSB0eXBlIGZvciB3aGljaCBvbmUgcmVjZWl2ZXMgbm90aWZpY2F0aW9ucy5cbiAgICAgKlxuICAgICAqICAgY2FsbGJhY2sgICAgICAgQSBmdW5jdGlvbiB0byBiZSBpbnZva2VkIHdpdGggYSBsZXZlbDIgbW9kZWwgYXMgYXJndW1lbnQgZm9yIGVhY2ggY3JlYXRlIG5vdGlmaWNhdGlvbi5cbiAgICAgKlxuICAgICAqICAgcXVlcnlQYXJhbXMgICAgT3B0aW9uYWwgcXVlcnkgcGFyYW1ldGVycyB1c2VkIHRvIGZpbHRlciBub3RpZmljYXRpb25zLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGdldENyZWF0aW9uTGlzdGVuZXIoc2V0dGluZ3MpIHtcbiAgICAgICAgaWYgKGR4VXRpbC5pc05vbmUoc2V0dGluZ3MpKSB7XG4gICAgICAgICAgICBkeFV0aWwuZmFpbCgnU2V0dGluZ3MgbXVzdCBiZSBzcGVjaWZpZWQuJyk7XG4gICAgICAgIH1cbiAgICAgICAgXy5leHRlbmQoc2V0dGluZ3MsIHtcbiAgICAgICAgICAgIGNvbnRleHQ6IGNvbnRleHRcbiAgICAgICAgfSk7XG5cbiAgICAgICAgdmFyIGNyZWF0aW9uTGlzdGVuZXIgPSBuZXcgZHhDcmVhdGlvbkxpc3RlbmVyLkNyZWF0aW9uTGlzdGVuZXIoc2V0dGluZ3MpO1xuICAgICAgICBjb250ZXh0Ll9tb2RlbFN1YnNjcmliZXJzU3RvcmUuYWRkKGNyZWF0aW9uTGlzdGVuZXIpO1xuICAgICAgICByZXR1cm4gY3JlYXRpb25MaXN0ZW5lcjtcbiAgICB9XG5cbiAgICAvKlxuICAgICAqIFJldHVybnMgdGhlIFNlcnZlciBNb2RlbCByZXByZXNlbnRpbmcgdGhlIHNwZWNpZmllZCBzaW5nbGV0b24uIElmIGl0IGFscmVhZHkgZXhpc3RzIGluIHRoZSBzZXQgb2YgbW9kZWxzIHRoZSBkYXRhXG4gICAgICogc3lzdGVtIGlzIG1haW50YWluaW5nLCB0aGF0IHNhbWUgaW5zdGFuY2Ugd2lsbCBiZSByZXR1cm5lZC4gT3RoZXJ3aXNlIGEgbmV3IGluc3RhbmNlIHdpbGwgYmUgcmV0dXJuZWQgYW5kIGl0c1xuICAgICAqIGRhdGEgYXN5bmNocm9ub3VzbHkgcmV0cmlldmVkIGZyb20gdGhlIHNlcnZlci5cbiAgICAgKlxuICAgICAqIHR5cGVOYW1lOiAgICAgVGhlIG5hbWUgb2YgdGhlIHR5cGUgdG8gZmV0Y2hcbiAgICAgKiBvcHRpb25zOiAgICAgIEFuIG9iamVjdCB0aGF0IG1heSBjb250YWluIHN1Y2Nlc3MgYW5kL29yIGVycm9yIGNhbGxiYWNrIGZ1bmN0aW9ucy4gSWYgdGhlIG1vZGVsIGlzIGFscmVhZHkgcHJlc2VudFxuICAgICAqICAgICAgICAgICAgICAgc3VjY2VzcyB3aWxsIGJlIGludm9rZWQgaW1tZWRpYXRlbHkuIElmIGl0IGlzbid0IHByZXNlbnQsIHN1Y2Nlc3Mgb3IgZXJyb3Igd2lsbCBiZSBjYWxsZWQgb25jZSB0aGVcbiAgICAgKiAgICAgICAgICAgICAgIHVuZGVybHlpbmcgZmV0Y2ggaGFzIGJlZW4gY29tcGxldGVkLiBBZGRpdGlvbmFsbHksIG9uZSBtYXkgc2V0IHN1cHByZXNzRGVmYXVsdEVycm9ySGFuZGxlciBhcyBhblxuICAgICAqICAgICAgICAgICAgICAgb3B0aW9uIGhlcmUgdG8gcHJldmVudCB0aGUgZGVmYXVsdCBlcnJvciBoYW5kbGVyIGZyb20gYmVpbmcgZXhlY3V0ZWQgb24gZXJyb3IuXG4gICAgICovXG4gICAgZnVuY3Rpb24gZ2V0U2VydmVyU2luZ2xldG9uKHR5cGVOYW1lLCBvcHRpb25zKSB7XG4gICAgICAgIG9wdGlvbnMgPSBfLmV4dGVuZChfLmNsb25lKG9wdGlvbnMgfHwge30pLCB7XG4gICAgICAgICAgICB1cGRhdGU6ICFjb250ZXh0Lm5vdGlmaWNhdGlvbi5pc1N0YXJ0ZWQoKVxuICAgICAgICB9KTtcbiAgICAgICAgdmFyIG1vZGVsID0gY29udGV4dC5fY2FjaGUuZ2V0Q2FjaGVkU2luZ2xldG9uKHR5cGVOYW1lLCBvcHRpb25zKTtcblxuICAgICAgICBpZiAoIWNvbnRleHQubm90aWZpY2F0aW9uLmlzU3RhcnRlZCgpKSB7XG4gICAgICAgICAgICBtb2RlbC5fZHhJc1JlYWR5ID0gZmFsc2U7ICAgLy8gaWYgc29tZW9uZSBzZXRzIGEgcmVhZHkgaGFuZGxlciwgZG9uJ3QgbGV0IGl0IGZpcmUgdW50aWwgbmV3IGRhdGEgaXMgYmFja1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG1vZGVsO1xuICAgIH1cblxuICAgIC8qXG4gICAgICogUmV0dXJuIHRoZSBTZXJ2ZXIgTW9kZWwgaW5zdGFuY2Ugd2l0aCB0aGUgc3BlY2lmaWVkIHJlZmVyZW5jZSBhbmQgb2YgdGhlIHNwZWNpZmllZCB0eXBlLiBJZiB0aGUgbW9kZWwgYWxyZWFkeVxuICAgICAqIGlzIGJlaW5nIG1haW50YWluZWQgYnkgdGhlIGRhdGEgc3lzdGVtLCB0aGlzIHdpbGwgcmV0dXJuIHRoZSBzYW1lIGluc3RhbmNlLiBJZiBub3QsIGEgbmV3IGluc3RhbmNlIHdpbGwgYmVcbiAgICAgKiByZXR1cm5lZCwgYW5kIGEgcmVxdWVzdCB0byBwb3B1bGF0ZSBpdCBmcm9tIGRhdGEgb24gdGhlIHNlcnZlci4gIFRvIGRldGVybWluZSBpZiB0aGUgbW9kZWwgaGFzIGF0IGxlYXN0IGFuXG4gICAgICogaW5pdGlhbCBzZXQgb2YgZGF0YSwgb25lIHNob3VsZCBhc3NpZ24gYSAncmVhZHknIGV2ZW50IGhhbmRsZXIgKHByb2JhYmx5IHdpdGggdGhlIG9uY2UoKSBmdW5jdGlvbikuXG4gICAgICpcbiAgICAgKiByZWZlcmVuY2U6ICAgIFRoZSByZWZlcmVuY2UgZm9yIHRoZSBtb2RlbFxuICAgICAqIHR5cGVOYW1lOiAgICAgVGhlIHR5cGUgZm9yIHRoZSBtb2RlbC4gSWYgdGhlIGRlc2lyZWQgbW9kZWwgaXMgYSBEQjJDb250YWluZXIsIGNhbiBiZSAnQ29udGFpbmVyJyBvclxuICAgICAqICAgICAgICAgICAgICAgJ0RCMkNvbnRhaW5lcicuIElmIHRoZSB0eXBlIGlzIG5vdCBrbm93biwgYXNzdW1lIHRoZSBtb3N0IGdlbmVyYWwgcm9vdCB0eXBlICgnQ29udGFpbmVyJykgc2hvdWxkIGJlXG4gICAgICogICAgICAgICAgICAgICBwYXNzZWQuXG4gICAgICogc3VwcHJlc3NEZWZhdWx0RXJyb3JIYW5kbGVyOiAgICAgIElmIHRydXRoeSwgdGhlIGRlZmF1bHQgZXJyb3IgaGFuZGxlZCBpcyBub3QgdHJpZ2dlcmVkIG9uIGVycm9ycy5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBnZXRTZXJ2ZXJNb2RlbChyZWZlcmVuY2UsIHR5cGVOYW1lLCBzdXBwcmVzc0RlZmF1bHRFcnJvckhhbmRsZXIpIHtcbiAgICAgICAgdmFyIG1vZGVsID0gY29udGV4dC5fY2FjaGUuZ2V0Q2FjaGVkTW9kZWwocmVmZXJlbmNlLCB0eXBlTmFtZSxcbiAgICAgICAgICAgIHsgc3VwcHJlc3NEZWZhdWx0RXJyb3JIYW5kbGVyOiBzdXBwcmVzc0RlZmF1bHRFcnJvckhhbmRsZXIgfSk7XG5cbiAgICAgICAgaWYgKCFjb250ZXh0Lm5vdGlmaWNhdGlvbi5pc1N0YXJ0ZWQoKSkge1xuICAgICAgICAgICAgbW9kZWwuX2R4SXNSZWFkeSA9IGZhbHNlOyAgIC8vIGlmIHNvbWVvbmUgc2V0cyBhIHJlYWR5IGhhbmRsZXIsIGRvbid0IGxldCBpdCBmaXJlIHVudGlsIG5ldyBkYXRhIGlzIGJhY2tcbiAgICAgICAgICAgIG1vZGVsLl9keEZldGNoKHsgc3VwcHJlc3NEZWZhdWx0RXJyb3JIYW5kbGVyOiBzdXBwcmVzc0RlZmF1bHRFcnJvckhhbmRsZXIgfSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbW9kZWw7XG4gICAgfVxuXG4gICAgLypcbiAgICAgKiBHZXRzIGEgc2VydmVyIG1vZGVsIGFuZCByZXR1cm5zIGEgalF1ZXJ5IFByb21pc2UuXG4gICAgICogVGhpcyBwcm9taXNlIGlzIHJlc29sdmVkIHdpdGggdGhlIG1vZGVsIGlmL3doZW4gdGhlIG1vZGVsJ3MgcmVhZHknIGV2ZW50IGlzIHRyaWdnZXJlZC5cbiAgICAgKiBJdCBpcyByZWplY3RlZCBpZi93aGVuIHRoZSBtb2RlbCdzICdlcnJvcicgZXZlbnQgaXMgdHJpZ2dlcmVkLlxuICAgICAqIEZvciBhIGRlc2NyaXB0aW9uIG9mIHRoZSBwYXJhbWV0ZXJzIHNlZSBjb250ZXh0LmdldFNlcnZlck1vZGVsKClcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBnZXRTZXJ2ZXJNb2RlbFByb21pc2UocmVmZXJlbmNlLCB0eXBlTmFtZSwgc3VwcHJlc3NEZWZhdWx0RXJyb3JIYW5kbGVyKSB7XG4gICAgICAgIHZhciBkZWZlcnJlZCA9IG5ldyAkLkRlZmVycmVkKCk7XG4gICAgICAgIHZhciBtb2RlbCA9IGNvbnRleHQuZ2V0U2VydmVyTW9kZWwocmVmZXJlbmNlLCB0eXBlTmFtZSwgc3VwcHJlc3NEZWZhdWx0RXJyb3JIYW5kbGVyKTtcblxuICAgICAgICByZXR1cm4gc2V0dXBQcm9taXNlKG1vZGVsLCBkZWZlcnJlZCk7XG4gICAgfVxuXG4gICAgLypcbiAgICAgKiBHZXRzIGEgc2VydmVyIHNpbmdsZXRvbiBhbmQgcmV0dXJucyBhIGpRdWVyeSBQcm9taXNlLlxuICAgICAqIFRoaXMgcHJvbWlzZSBpcyByZXNvbHZlZCB3aXRoIHRoZSBzaW5nbGV0b24gaWYvd2hlbiB0aGUgbW9kZWwncyByZWFkeScgZXZlbnQgaXMgdHJpZ2dlcmVkLlxuICAgICAqIEl0IGlzIHJlamVjdGVkIGlmL3doZW4gdGhlIHNpbmdsZXRvbidzICdlcnJvcicgZXZlbnQgaXMgdHJpZ2dlcmVkLlxuICAgICAqIEZvciBhIGRlc2NyaXB0aW9uIG9mIHRoZSBwYXJhbWV0ZXJzIHNlZSBjb250ZXh0LmdldFNlcnZlclNpbmdsZXRvbigpXG4gICAgICovXG4gICAgZnVuY3Rpb24gZ2V0U2VydmVyU2luZ2xldG9uUHJvbWlzZSh0eXBlTmFtZSwgc3VjY2Vzc0Vycm9yKSB7XG4gICAgICAgIHZhciBkZWZlcnJlZCA9IG5ldyAkLkRlZmVycmVkKCk7XG4gICAgICAgIHZhciBtb2RlbCA9IGNvbnRleHQuZ2V0U2VydmVyU2luZ2xldG9uKHR5cGVOYW1lLCBzdWNjZXNzRXJyb3IpO1xuXG4gICAgICAgIHJldHVybiBzZXR1cFByb21pc2UobW9kZWwsIGRlZmVycmVkKTtcbiAgICB9XG5cbiAgICAvKlxuICAgICAqIEhlbHBlciBmdW5jdGlvbiBmb3IgZ2V0U2VydmVyTW9kZWxQcm9taXNlIGFuZCBnZXRTZXJ2ZXJTaW5nbGV0b25Qcm9taXNlLlxuICAgICAqIE5vdGU6IFRoaXMgaXMgZXhwb3NlZCBhcyBfc2V0dXBQcm9taXNlIGZvciB0ZXN0aW5nIHB1cnBvc2VzIG9ubHkuXG4gICAgICovXG4gICAgZnVuY3Rpb24gc2V0dXBQcm9taXNlKG1vZGVsLCBkZWZlcnJlZCkge1xuICAgICAgICBmdW5jdGlvbiBvblJlYWR5Q2FsbGJhY2soKSB7XG4gICAgICAgICAgICBkZWZlcnJlZC5yZXNvbHZlKG1vZGVsKTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBvbkVycm9yQ2FsbGJhY2soKSB7XG4gICAgICAgICAgICBkZWZlcnJlZC5yZWplY3QobW9kZWwpO1xuICAgICAgICB9XG5cbiAgICAgICAgbW9kZWwub25jZSgncmVhZHknLCBvblJlYWR5Q2FsbGJhY2spO1xuICAgICAgICBtb2RlbC5vbmNlKCdlcnJvcicsIG9uRXJyb3JDYWxsYmFjayk7XG5cbiAgICAgICAgLy8gdXNlIHByb21pc2UoKSB0byBsb2NrIHRvIGRlZmVycmVkLCBleHBvc2luZyBvbmx5IG1ldGhvZHMgdG8gYXR0YWNoIGNhbGxiYWNrc1xuICAgICAgICByZXR1cm4gZGVmZXJyZWQucHJvbWlzZSgpO1xuICAgIH1cblxuICAgIC8qXG4gICAgICogR2l2ZW4gYSBtb2RlbCB0eXBlLCByZXR1cm4gdGhlIG5hbWUgb2YgdGhlICdyb290IHR5cGUnLiBHaXZlbiBEQjJDb250YWluZXIsIE9yYWNsZUNvbnRhaW5lciwgb3IgQ29udGFpbmVyLCB0aGlzXG4gICAgICogd2lsbCByZXR1cm4gQ29udGFpbmVyLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGdldENvbGxlY3Rpb25UeXBlRnJvbU1vZGVsVHlwZShtb2RlbFR5cGUpIHtcbiAgICAgICAgcmV0dXJuIGNvbnRleHQuX2dldFJvb3RUeXBlKG1vZGVsVHlwZSk7XG4gICAgfVxuXG4gICAgLypcbiAgICAgKiBTZXRzIGFuIGVycm9yIGNhbGxiYWNrIHRoYXQgd2lsbCBiZSBjYWxsZWQgYnkgcmVwb3J0RXJyb3JSZXN1bHQuIFRoaXMgaXMgdXNlZnVsIGZvciBhbiBleHRlcm5hbCBzeXN0ZW0gdG8gZGVmaW5lXG4gICAgICogYmVoYXZpb3IgdGhhdCB3aWxsIGJlIHVzZWQgYnkgdGhlIGR4RGF0YSBzeXN0ZW0gd2hlbiBhbiBFcnJvclJlc3VsdCBpcyByZXBvcnRlZCBieSBhbiBvcGVyYXRpb25cbiAgICAgKi9cbiAgICB2YXIgZXJyb3JDYWxsYmFjaztcbiAgICBmdW5jdGlvbiBzZXRFcnJvckNhbGxiYWNrKGZ1bmMpIHtcbiAgICAgICAgaWYgKCFfLmlzRnVuY3Rpb24oZnVuYykpIHtcbiAgICAgICAgICAgIGR4VXRpbC5mYWlsKCdzZXRFcnJvckNhbGxiYWNrIGV4cGVjdHMgYSBmdW5jdGlvbiBhcyBhbiBhcmd1bWVudC4nKTtcbiAgICAgICAgfVxuICAgICAgICBlcnJvckNhbGxiYWNrID0gZnVuYztcbiAgICB9XG5cbiAgICAvKlxuICAgICAqIFJlcG9ydHMgYW4gRXJyb3JSZXN1bHQgbW9kZWwgdG8gdGhlIGVuZCB1c2VyIGluIHRoZSBiZXN0IGZhc2hpb24gYXZhaWxhYmxlIGF0IHRoaXMgdGltZS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiByZXBvcnRFcnJvclJlc3VsdChlcnJvclJlc3VsdCkge1xuICAgICAgICBpZiAoIShlcnJvclJlc3VsdCBpbnN0YW5jZW9mIEJhY2tib25lLk1vZGVsKSB8fCBlcnJvclJlc3VsdC5nZXQoJ3R5cGUnKSAhPT0gJ0Vycm9yUmVzdWx0Jykge1xuICAgICAgICAgICAgZHhVdGlsLmZhaWwoJ3JlcG9ydEVycm9yUmVzdWx0IGV4cGVjdHMgYW4gRXJyb3JSZXN1bHQgbW9kZWwgYXMgYW4gYXJndW1lbnQuJyk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBlcnJvckNhbGxiYWNrIGlzIHNldCBieSBhbiBleHRlcm5hbCBzb3VyY2UgdXNpbmcgc2V0RXJyb3JDYWxsYmFja1xuICAgICAgICBpZiAoZXJyb3JDYWxsYmFjaykge1xuICAgICAgICAgICAgZXJyb3JDYWxsYmFjayhlcnJvclJlc3VsdCk7XG4gICAgICAgIH1cblxuICAgICAgICBkeFV0aWwud2FybignRXJyb3IgcmVzdWx0OiAnICsgSlNPTi5zdHJpbmdpZnkoZXJyb3JSZXN1bHQudG9KU09OKCkpKTtcbiAgICB9XG5cbiAgICAvKlxuICAgICAqIFN0YXJ0IHRoZSByZWFsIHdvcmsgaGVyZS4gSW5pdGlhbGl6ZSBldmVyeXRoaW5nICdiZWxvdycgdXMuXG4gICAgICovXG4gICAgY29udGV4dCA9IGNvbnRleHQgfHwgdGhpcztcbiAgICB2YXIgcGFyc2VkU2NoZW1hcyA9IGR4U2NoZW1hLl9wcmVwYXJlU2NoZW1hcyhzY2hlbWFzKTtcbiAgICB2YXIgZW51bXMgPSBkeFNjaGVtYS5fcHJlcGFyZUVudW1zKHBhcnNlZFNjaGVtYXMpO1xuICAgIGR4Q2FjaGUuX2luaXRDYWNoZShjb250ZXh0KTtcbiAgICBkeEZpbHRlci5faW5pdEZpbHRlcnMoY29udGV4dCk7XG4gICAgZHhNb2RlbC5fZ2VuZXJhdGVNb2RlbENvbnN0cnVjdG9ycyhwYXJzZWRTY2hlbWFzLCBjb250ZXh0KTtcbiAgICBkeENvbGxlY3Rpb24uX2dlbmVyYXRlQ29sbGVjdGlvbkNvbnN0cnVjdG9ycyhwYXJzZWRTY2hlbWFzLCBjb250ZXh0KTtcbiAgICBkeE5vdGlmaWNhdGlvbi5fc2V0dXBOb3RpZmljYXRpb25TeXN0ZW0oY29udGV4dCk7XG5cbiAgICBfLmV4dGVuZChjb250ZXh0LCB7XG4gICAgICAgIHBhcnNlZFNjaGVtYXM6IHBhcnNlZFNjaGVtYXMsXG4gICAgICAgIGVudW1zOiBlbnVtcyxcbiAgICAgICAgZ2V0U2VydmVyQ29sbGVjdGlvbjogZ2V0U2VydmVyQ29sbGVjdGlvbixcbiAgICAgICAgZ2V0Q3JlYXRpb25MaXN0ZW5lcjogZ2V0Q3JlYXRpb25MaXN0ZW5lcixcbiAgICAgICAgZ2V0U2VydmVyU2luZ2xldG9uOiBnZXRTZXJ2ZXJTaW5nbGV0b24sXG4gICAgICAgIG5ld0NsaWVudE1vZGVsOiBuZXdDbGllbnRNb2RlbCxcbiAgICAgICAgZ2V0U2VydmVyTW9kZWw6IGdldFNlcnZlck1vZGVsLFxuICAgICAgICBzZXRFcnJvckNhbGxiYWNrOiBzZXRFcnJvckNhbGxiYWNrLFxuICAgICAgICBnZXRTZXJ2ZXJNb2RlbFByb21pc2U6IGdldFNlcnZlck1vZGVsUHJvbWlzZSxcbiAgICAgICAgZ2V0U2VydmVyU2luZ2xldG9uUHJvbWlzZTogZ2V0U2VydmVyU2luZ2xldG9uUHJvbWlzZSxcbiAgICAgICAgX3NldHVwUHJvbWlzZTogc2V0dXBQcm9taXNlLCAvLyBFeHBvc2VkIGZvciB0ZXN0aW5nIHB1cnBvc2VzXG4gICAgICAgIHJlcG9ydEVycm9yUmVzdWx0OiByZXBvcnRFcnJvclJlc3VsdCxcbiAgICAgICAgZ2V0Q29sbGVjdGlvblR5cGVGcm9tTW9kZWxUeXBlOiBnZXRDb2xsZWN0aW9uVHlwZUZyb21Nb2RlbFR5cGVcbiAgICB9KTtcbn07XG4iLCIvKlxuICogQ29weXJpZ2h0IChjKSAyMDE0LCAyMDE1IGJ5IERlbHBoaXguIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKi9cblxuLyogZ2xvYmFsIF8gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCBkeFV0aWwgPSByZXF1aXJlKCdkeGNvcmUvanMvdXRpbC5qcycpLFxuICAgIGR4TG9jYWxlID0gcmVxdWlyZSgnZHhjb3JlL2pzL2xvY2FsZS5qcycpO1xuXG4vKlxuICogVGhpcyBub3RpZmljYXRpb24gc3lzdGVtIHJlY2VpdmVzIHVwZGF0ZXMgZnJvbSB0aGUgc2VydmVyIGFib3V0IG9iamVjdHMgdGhhdCBoYXZlIGJlZW4gY3JlYXRlZCwgZGVsZXRlZCBvciB1cGRhdGVkLlxuICogVGhpcyBzeXN0ZW0sIGluIHR1cm4sIGNvbnZlcnRzIHRob3NlIG5vdGlmaWNhdGlvbnMgaW50byBjYWxscyB0byB0aGUgdW5kZXJseWluZyBjYWNoZSBzeXN0ZW0gc28gYWxsIG1vZGVscyBhbmRcbiAqIGNvbGxlY3Rpb25zIGJlaW5nIHVzZWQgYXJlIHVwIHRvIGRhdGUgd2l0aCB3aGF0ZXZlciBpbmZvcm1hdGlvbiBpcyBpbiB0aGUgc2VydmVyLiAgV2l0aG91dCB0aGUgbm90aWZpY2F0aW9uIHN5c3RlbVxuICogdHVybmVkIG9uLCB0aGUgbW9kZWxzIGFuZCBjb2xsZWN0aW9ucyBhcmUgbm90IGFzc3VyZWQgb2YgYmVpbmcgdXAgdG8gZGF0ZSB3aXRoIHdoYXQgdGhlIHNlcnZlciBrbm93cyBhYm91dC5cbiAqXG4gKiBUbyB1c2UgdGhlIG5vdGlmaWNhdGlvbiBzeXN0ZW0sIHNpbXBseSBjYWxsIHRoZSBzdGFydCgpIGZ1bmN0aW9uIGF0IHRoZSBzdGFydCBvZiB5b3VyIHByb2dyYW0uIFRvIHN0b3AgcmVjZWl2aW5nXG4gKiBub3RpZmljYXRpb25zLCBjYWxsIHN0b3AoKS4gWW91IGNhbiBhbHNvIGNhbGwgaXNTdGFydGVkKCkgdG8gdmVyaWZ5IHdoZXRoZXIgdGhlIG5vdGlmaWNhdGlvbiBzeXN0ZW0gaXMgdHVybmVkIG9uLlxuICovXG5tb2R1bGUuZXhwb3J0cy5fc2V0dXBOb3RpZmljYXRpb25TeXN0ZW0gPSBmdW5jdGlvbiBfc2V0dXBOb3RpZmljYXRpb25TeXN0ZW0oY29udGV4dCkge1xuXG4gICAgLypcbiAgICAgKiBXZSB1c2UgbG9uZyBwb2xsaW5nIHRvIGZldGNoIG5vdGlmaWNhdGlvbnMuIFdlIHdhbnQgdG8gbWFrZSBzdXJlIG91ciB0aW1lb3V0IGlzIGxlc3MgdGhhbiB0aGUgYnJvd3NlciB0aW1lb3V0LFxuICAgICAqIGJ1dCBvdGhlcndpc2UgdGhlIGNhbGwgd2lsbCByZXR1cm4gYXMgc29vbiBhcyBkYXRhIGlzIGF2YWlsYWJsZS5cbiAgICAgKi9cbiAgICB2YXIgVElNRU9VVF9TRUMgPSAxMjtcblxuICAgIC8qXG4gICAgICogSWYgdGhlIGNhbGwgZmFpbHMsIHdlIGRvbid0IHdhbnQgdG8gc3BpbiBpbiBhIGxvb3AgcmV0cnlpbmcuIEF0dGVtcHQgYSBuZXcgcmVxdWVzdCBhZnRlciB0aGlzIHRpbWUgcGVyaW9kLlxuICAgICAqL1xuICAgIHZhciBSRVRSWV9TRUMgPSAxMDtcblxuICAgIHZhciBkYXRlID0gbmV3IERhdGUoKTtcbiAgICB2YXIgdGltZW91dDtcbiAgICB2YXIgc3RvcHBlZCA9IHRydWU7XG4gICAgdmFyIG5vdGlmaWNhdGlvbjtcbiAgICB2YXIgbm90aWZpY2F0aW9uQ2hhbm5lbCA9IGRhdGUuZ2V0VGltZSgpICsgJ19odG1sJztcblxuICAgIGZ1bmN0aW9uIHByb2Nlc3NOb3RpZmljYXRpb25zKG5vdGlmaWNhdGlvbnMsIHJlbG9hZENsaWVudCkge1xuICAgICAgICB2YXIgdW5pcXVlT2JqZWN0Tm90aWZpY2F0aW9ucyA9IHt9O1xuICAgICAgICB2YXIgdW5pcXVlU2luZ2xldG9uTm90aWZpY2F0aW9ucyA9IHt9O1xuXG4gICAgICAgIC8qXG4gICAgICAgICAqIFByZS1wcm9jZXNzIG5vdGlmaWNhdGlvbnMuIEtlZXAgb25seSB0aGUgbGFzdCBub3RpZmljYXRpb24gZm9yIGEgcGFydGljdWxhciBvYmplY3QuIFRodXMsIHNob3VsZCB3ZSByZWNlaXZlIGFcbiAgICAgICAgICogY3JlYXRlLCB1cGRhdGUgYW5kIGRlbGV0ZSBub3RpZmljYXRpb24gZm9yIGFuIG9iamVjdCwgd2Ugd2lsbCBvbmx5IGtlZXAgdGhlIGRlbGV0ZS4gVGhpcyBhc3N1bWVzIHRoYXQgd2VcbiAgICAgICAgICogbmV2ZXIgZ2V0IGEgbm9uLWRlbGV0ZSBub3RpZmljYXRpb24gYWZ0ZXIgZ2V0dGluZyBhIGRlbGV0ZSBub3RpZmljYXRpb24uXG4gICAgICAgICAqL1xuICAgICAgICBub3RpZmljYXRpb25zLmVhY2goZnVuY3Rpb24obW9kZWwpIHtcbiAgICAgICAgICAgIHN3aXRjaCAobW9kZWwuZ2V0KCd0eXBlJykpIHtcbiAgICAgICAgICAgICAgICBjYXNlICdPYmplY3ROb3RpZmljYXRpb24nOlxuICAgICAgICAgICAgICAgICAgICB2YXIgcmVmZXJlbmNlID0gbW9kZWwuZ2V0KCdvYmplY3QnKTtcbiAgICAgICAgICAgICAgICAgICAgdW5pcXVlT2JqZWN0Tm90aWZpY2F0aW9uc1tyZWZlcmVuY2VdID0gbW9kZWw7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgJ1NpbmdsZXRvblVwZGF0ZSc6XG4gICAgICAgICAgICAgICAgICAgIHZhciB0eXBlID0gbW9kZWwuZ2V0KCdvYmplY3RUeXBlJyk7XG4gICAgICAgICAgICAgICAgICAgIGlmICghXy5oYXModW5pcXVlU2luZ2xldG9uTm90aWZpY2F0aW9ucywgdHlwZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHVuaXF1ZVNpbmdsZXRvbk5vdGlmaWNhdGlvbnNbdHlwZV0gPSBtb2RlbDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlICdOb3RpZmljYXRpb25Ecm9wJzpcbiAgICAgICAgICAgICAgICAgICAgcmVsb2FkQ2xpZW50KGR4TG9jYWxlLmdscygnZHgubm90aWZpY2F0aW9uX2Ryb3AnLCBtb2RlbC5nZXQoJ2Ryb3BDb3VudCcpKSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIC8vIHdlIGlnbm9yZSBhbGwgb3RoZXIgdHlwZXNcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgLypcbiAgICAgICAgICogV2l0aCB0aGUgdW5pcXVpZmllZCBzZXQgb2Ygb2JqZWN0IG5vdGlmaWNhdGlvbnMsIGxvb3AgdGhyb3VnaCB0aGVtIGFuZCByZXRyaWV2ZSBvciBkZWxldGUgb3VyIGNvcGllcyBvZiB0aGVcbiAgICAgICAgICogb2JqZWN0cyBvbiB0aGUgc2VydmVyXG4gICAgICAgICAqL1xuICAgICAgICBfLmVhY2godW5pcXVlT2JqZWN0Tm90aWZpY2F0aW9ucywgZnVuY3Rpb24obm90aWZpY2F0aW9uLCBvYmpSZWYpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgdmFyIHR5cGUgPSBub3RpZmljYXRpb24uZ2V0KCdvYmplY3RUeXBlJyk7XG4gICAgICAgICAgICAgICAgdmFyIHJvb3RUeXBlID0gY29udGV4dC5nZXRDb2xsZWN0aW9uVHlwZUZyb21Nb2RlbFR5cGUodHlwZSk7XG5cbiAgICAgICAgICAgICAgICBzd2l0Y2ggKG5vdGlmaWNhdGlvbi5nZXQoJ2V2ZW50VHlwZScpKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ0NSRUFURSc6XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ1VQREFURSc6XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgc3Vic2NyaXB0aW9uVXNlc01vZGVsID0gY29udGV4dC5fbW9kZWxTdWJzY3JpYmVyc1N0b3JlLmhhc1R5cGUocm9vdFR5cGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGhhc01vZGVsID0gY29udGV4dC5fY2FjaGUuY29udGFpbnNDYWNoZWRNb2RlbChvYmpSZWYsIHJvb3RUeXBlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzdWJzY3JpcHRpb25Vc2VzTW9kZWwgfHwgaGFzTW9kZWwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgbW9kZWwgPSBjb250ZXh0Ll9jYWNoZS5nZXRDYWNoZWRNb2RlbChvYmpSZWYsIHJvb3RUeXBlLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVwZGF0ZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FjaGVPbmx5SWZOZWVkZWQ6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN1cHByZXNzRGVmYXVsdEVycm9ySGFuZGxlcjogdHJ1ZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGxpc3RlbmVyQ29udGV4dCA9IHt9O1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLypcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBBZnRlciB3ZSd2ZSBmZXRjaGVkIHRoZSBtb2RlbCwgbm90aWZ5IHRoZSBjYWNoZSB0aGF0IHRoaXMgbW9kZWwgbWF5IG5lZWQgdG8gYmUgYWRkZWQgb3JcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiByZW1vdmVkIGZyb20gY29sbGVjdGlvbnMuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICogSW4gdGhlIGNhc2Ugb2YgYSBiYWRSZWZlcmVuY2UgKGUuZy4gdGhlIG1vZGVsIGhhcyBiZWVuIGRlbGV0ZWQpLCBtYWtlIHN1cmUgd2UgY2xlYW4gdXBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiB0aGUgc3luYyBsaXN0ZW5lci4gV2UgZG8gbm90IHVzZSB0aGUgXCJlcnJvclwiIGV2ZW50IGJlY2F1c2UgaXQncyBhIG9uZSB0aW1lIGV2ZW50IGZvciB0aGVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBmaXJzdCBmZXRjaC4gRm9yIGZldGNoaW5nIGVycm9ycyBvdGhlciB0aGFuIGJhZFJlZmVyZW5jZSwgd2Ugd291bGQgdGVjaG5pY2FsbHkgbGVhayB0aGVzZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIGxpc3RlbmVycywgYnV0IHJlYWxpc3RpY2FsbHkgdGhpcyBsaWtlbHkgaW5kaWNhdGVzIHNvbWV0aGluZyBiYWQgaGFwcGVuZWQgb24gdGhlIHNlcnZlclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIHRoYXQgd2lsbCByZXF1aXJlIHNwZWNpYWwgYXR0ZW50aW9uLlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1vZGVsLm9uY2UoJ3N5bmMnLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbW9kZWwub2ZmKHVuZGVmaW5lZCwgdW5kZWZpbmVkLCBsaXN0ZW5lckNvbnRleHQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250ZXh0Ll9jYWNoZS5tb2RlbE1heUhhdmVDaGFuZ2VkKG1vZGVsLCByb290VHlwZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSwgbGlzdGVuZXJDb250ZXh0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtb2RlbC5vbmNlKCdiYWRSZWZlcmVuY2UnLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbW9kZWwub2ZmKHVuZGVmaW5lZCwgdW5kZWZpbmVkLCBsaXN0ZW5lckNvbnRleHQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sIGxpc3RlbmVyQ29udGV4dCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnREVMRVRFJzpcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRleHQuX2NhY2hlLmRlbGV0ZUNhY2hlZE1vZGVsKG9ialJlZiwgcm9vdFR5cGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgICAgICBkeFV0aWwud2FybignVW5rbm93biBldmVudCB0eXBlOiAnICsgbm90aWZpY2F0aW9uLmdldCgnZXZlbnRUeXBlJykpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAvLyBXZSByZWFsbHkgZG9uJ3Qgd2FudCBub3RpZmljYXRpb24gcHJvY2Vzc2luZyB0byBzdG9wLCBzbyBzd2FsbG93IGFueSBleGNlcHRpb24gYW5kIGtlZXAgZ29pbmdcbiAgICAgICAgICAgICAgICBkeFV0aWwud2Fybignbm90aWZpY2F0aW9uIHByb2Nlc3NpbmcgZmFpbGVkOiAnICsgZS5tZXNzYWdlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgLypcbiAgICAgICAgICogRmluYWxseSwgdXBkYXRlIGFsbCB0aGUgc2luZ2xldG9ucyB0aGF0IGhhdmUgYmVlbiBjaGFuZ2VkLCBhcyB3ZWxsLlxuICAgICAgICAgKi9cbiAgICAgICAgXy5lYWNoKHVuaXF1ZVNpbmdsZXRvbk5vdGlmaWNhdGlvbnMsIGZ1bmN0aW9uKG5vdGlmaWNhdGlvbiwgdHlwZSkge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBjb250ZXh0Ll9jYWNoZS5nZXRDYWNoZWRTaW5nbGV0b24odHlwZSwge3VwZGF0ZTogdHJ1ZX0pO1xuICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgIC8vIFdlIHJlYWxseSBkb24ndCB3YW50IG5vdGlmaWNhdGlvbiBwcm9jZXNzaW5nIHRvIHN0b3AsIHNvIHN3YWxsb3cgYW55IGV4Y2VwdGlvbiBhbmQga2VlcCBnb2luZ1xuICAgICAgICAgICAgICAgIGR4VXRpbC53YXJuKCdub3RpZmljYXRpb24gcHJvY2Vzc2luZyBmYWlsZWQ6ICcgKyBlLm1lc3NhZ2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBmZXRjaE5vdGlmaWNhdGlvbnMocmVsb2FkQ2xpZW50KSB7XG4gICAgICAgIHRpbWVvdXQgPSB1bmRlZmluZWQ7XG5cbiAgICAgICAgbm90aWZpY2F0aW9uLiQkbGlzdCh7XG4gICAgICAgICAgICB0aW1lb3V0OiAnJyArIFRJTUVPVVRfU0VDICogMTAwMCxcbiAgICAgICAgICAgIGNoYW5uZWw6IG5vdGlmaWNhdGlvbkNoYW5uZWxcbiAgICAgICAgfSwge1xuICAgICAgICAgICAgc3VjY2VzczogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgLy8gV2Ugd2FudCB0byBtYWtlIHN1cmUgbm90aWZpY2F0aW9ucyBkb24ndCBldmVyIHN0YWxsLCBldmVuIGlmIHRoZXJlIGlzIHNvbWUgdW5rbm93biBwcm9ibGVtXG4gICAgICAgICAgICAgICAgaWYgKCFzdG9wcGVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwcm9jZXNzTm90aWZpY2F0aW9ucyhub3RpZmljYXRpb24sIHJlbG9hZENsaWVudCk7XG4gICAgICAgICAgICAgICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBmZXRjaE5vdGlmaWNhdGlvbnMocmVsb2FkQ2xpZW50KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBlcnJvcjogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFzdG9wcGVkKSB7XG4gICAgICAgICAgICAgICAgICAgIGR4VXRpbC53YXJuKCdOb3RpZmljYXRpb24gY2FsbCBmYWlsZWQuJyk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKHN0b3BwZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHRpbWVvdXQgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkgeyBmZXRjaE5vdGlmaWNhdGlvbnMocmVsb2FkQ2xpZW50KTsgfSwgUkVUUllfU0VDICogMTAwMCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIC8qXG4gICAgICogRm9yIHRlc3RpbmcgcHVycG9zZXMuIFRoaXMgcmV0dXJucyB0aGUgdGltZW91dCB1c2VkIGZvciByZXRyaWVzIGZvciBwcmVkaWN0YWJsZSByZXN1bHRzLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIF9nZXRSZXRyeVRpbWVvdXQoKSB7XG4gICAgICAgIHJldHVybiBSRVRSWV9TRUMgKiAxMDAwO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHN0YXJ0KHJlbG9hZENsaWVudCkge1xuICAgICAgICBpZiAoXy5pc1VuZGVmaW5lZChub3RpZmljYXRpb24pKSB7XG4gICAgICAgICAgICBub3RpZmljYXRpb24gPSBjb250ZXh0LmdldFNlcnZlckNvbGxlY3Rpb24oJ05vdGlmaWNhdGlvbicpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZHhVdGlsLmZhaWwoJ05vdGlmaWNhdGlvbiBzeXN0ZW0gYWxyZWFkeSBzdGFydGVkLicpO1xuICAgICAgICB9XG4gICAgICAgIHN0b3BwZWQgPSBmYWxzZTtcbiAgICAgICAgZmV0Y2hOb3RpZmljYXRpb25zKHJlbG9hZENsaWVudCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaXNTdGFydGVkKCkge1xuICAgICAgICByZXR1cm4gIXN0b3BwZWQ7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gc3RvcCgpIHtcbiAgICAgICAgaWYgKG5vdGlmaWNhdGlvbikge1xuICAgICAgICAgICAgbm90aWZpY2F0aW9uID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aW1lb3V0KSB7XG4gICAgICAgICAgICBjbGVhclRpbWVvdXQodGltZW91dCk7XG4gICAgICAgIH1cbiAgICAgICAgc3RvcHBlZCA9IHRydWU7XG4gICAgfVxuXG4gICAgY29udGV4dCA9IGNvbnRleHQgfHwgdGhpcztcbiAgICBjb250ZXh0Lm5vdGlmaWNhdGlvbiA9IGNvbnRleHQubm90aWZpY2F0aW9uIHx8IHt9O1xuICAgIF8uZXh0ZW5kKGNvbnRleHQubm90aWZpY2F0aW9uLCB7XG4gICAgICAgIF9nZXRSZXRyeVRpbWVvdXQ6IF9nZXRSZXRyeVRpbWVvdXQsXG4gICAgICAgIHN0YXJ0OiBzdGFydCxcbiAgICAgICAgaXNTdGFydGVkOiBpc1N0YXJ0ZWQsXG4gICAgICAgIHN0b3A6IHN0b3BcbiAgICB9KTtcbn07XG4iLCIvKlxuICogQ29weXJpZ2h0IChjKSAyMDEzLCAyMDE1IGJ5IERlbHBoaXguIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKi9cblxuLyogZ2xvYmFsICQsIF8gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCBkeFV0aWwgPSByZXF1aXJlKCdkeGNvcmUvanMvdXRpbC5qcycpO1xuXG4vKlxuICogc2hvcnRoYW5kIGZvciBQT1NUIGFqYXggY2FsbHNcbiAqICAgIGNvbmZpZyAtICQuYWpheCBjb25maWd1cmF0aW9uIG9iamVjdC5cbiAqL1xuZnVuY3Rpb24gcG9zdChjb25maWcpIHtcbiAgICBpZiAoZHhVdGlsLmlzTm9uZShjb25maWcpKSB7XG4gICAgICAgIGR4VXRpbC5mYWlsKCdwb3N0KCkgcmVxdWlyZXMgYSBzZXQgb2YgalF1ZXJ5IGFqYXggb3B0aW9ucy4nKTtcbiAgICB9XG4gICAgY29uZmlnLnR5cGUgPSAnUE9TVCc7XG4gICAgYWpheENhbGwoY29uZmlnKTtcbn1cblxuLypcbiAqIHNob3J0aGFuZCBmb3IgR0VUIGFqYXggY2FsbHNcbiAqICAgIGNvbmZpZyAtICQuYWpheCBjb25maWd1cmF0aW9uIG9iamVjdC5cbiAqL1xuZnVuY3Rpb24gZ2V0KGNvbmZpZykge1xuICAgIGlmIChkeFV0aWwuaXNOb25lKGNvbmZpZykpIHtcbiAgICAgICAgZHhVdGlsLmZhaWwoJ2dldCgpIHJlcXVpcmVzIGEgc2V0IG9mIGpRdWVyeSBhamF4IG9wdGlvbnMuJyk7XG4gICAgfVxuICAgIGNvbmZpZy50eXBlID0gJ0dFVCc7XG4gICAgYWpheENhbGwoY29uZmlnKTtcbn1cblxuLypcbiAqIFdyYXBwZXIgZnVuY3Rpb24gZm9yIGpxdWVyeSAkLmFqYXggZnVuY3Rpb25cbiAqICAgIGNvbmZpZyAtICQuYWpheCBjb25maWd1cmF0aW9uIG9iamVjdC5cbiAqL1xuZnVuY3Rpb24gYWpheENhbGwoY29uZmlnKSB7XG4gICAgaWYgKGNvbmZpZyAmJiBjb25maWcudXJsKSB7XG4gICAgICAgIGNvbmZpZy50eXBlID0gY29uZmlnLnR5cGUgfHwgJ0dFVCc7XG4gICAgICAgIGNvbmZpZy5jb250ZW50VHlwZSA9IGNvbmZpZy5jb250ZW50VHlwZSB8fCAnYXBwbGljYXRpb24vanNvbic7XG4gICAgICAgIGNvbmZpZy5kYXRhVHlwZSA9IGNvbmZpZy5kYXRhVHlwZSB8fCAnanNvbic7XG5cbiAgICAgICAgY29uZmlnLnhockZpZWxkcyA9IGNvbmZpZy54aHJGaWVsZHMgfHwge1xuICAgICAgICAgICAgd2l0aENyZWRlbnRpYWxzOiB0cnVlXG4gICAgICAgIH07XG5cbiAgICAgICAgY29uZmlnLnN1Y2Nlc3MgPSBjb25maWcuc3VjY2VzcyB8fCBmdW5jdGlvbihkKSB7XG4gICAgICAgICAgICBkeFV0aWwuZGVidWcoZCk7XG4gICAgICAgIH07XG5cbiAgICAgICAgY29uZmlnLmVycm9yID0gY29uZmlnLmVycm9yIHx8IGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgICAgIGR4VXRpbC5kZWJ1ZyhlKTtcbiAgICAgICAgfTtcblxuICAgICAgICBjb25maWcuY2FjaGUgPSBjb25maWcuY2FjaGUgfHwgZmFsc2U7XG5cbiAgICAgICAgY29uZmlnLnVybCA9IGR4VXRpbC5nZXRXaW5kb3dVUkxPcmlnaW4oKSArIGNvbmZpZy51cmw7XG5cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICQuYWpheChjb25maWcpO1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICBkeFV0aWwuZmFpbChlLm1lc3NhZ2UpO1xuICAgICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgICAgZHhVdGlsLmZhaWwoJ0ludmFsaWQgY29uZmlndXJhdGlvbiBmb3IgalF1ZXJ5IGFqYXggY2FsbC4gVW5hYmxlIHRvIGNvbXBsZXRlIHRoZSBvcGVyYXRpb24uJyk7XG4gICAgfVxufVxuXG4vKlxuICogU2V0cyB0aGUgZ2xvYmFsIGFqYXggY29uZmlndXJhdGlvbiBhbmQgc2V0cyB1cCBDU1JGIGhlYWRlciBpbmNsdXNpb25cbiAqL1xuZnVuY3Rpb24gYWpheFNldHVwKGNvbmZpZykge1xuICAgIGNvbmZpZyA9IGNvbmZpZyB8fCB7fTtcbiAgICBjb25maWcuY2FjaGUgPSBjb25maWcuY2FjaGUgfHwgZmFsc2U7XG4gICAgJC5hamF4U2V0dXAoY29uZmlnKTtcblxuICAgICQuYWpheFByZWZpbHRlcigoZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBzZXNzaW9uUm91dGUgPSAvXFwvcmVzb3VyY2VzXFwvanNvblxcL2RlbHBoaXhcXC9zZXNzaW9uLztcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICAgICAgICAgIHZhciBodHRwVmVyYiA9IG9wdGlvbnMubWV0aG9kIHx8IG9wdGlvbnMudHlwZTtcbiAgICAgICAgICAgIGlmICgoKCFodHRwVmVyYiB8fCBodHRwVmVyYiA9PT0gJ0dFVCcpICYmIHNlc3Npb25Sb3V0ZS50ZXN0KG9wdGlvbnMudXJsKSkgfHxcbiAgICAgICAgICAgICAgICAoaHR0cFZlcmIgJiYgXy5jb250YWlucyhbJ1BPU1QnLCAnREVMRVRFJywgJ1BVVCddLCBodHRwVmVyYi50b1VwcGVyQ2FzZSgpKSkpIHtcblxuICAgICAgICAgICAgICAgIG9wdGlvbnMuaGVhZGVycyA9IG9wdGlvbnMuaGVhZGVycyB8fCB7fTtcbiAgICAgICAgICAgICAgICBvcHRpb25zLmhlYWRlcnNbJ1gtQnJvd3Nlci1TZXNzaW9uJ10gPSAnVHJ1ZSc7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgfSkoKSk7XG59XG5cbi8qXG4gKiBSb3V0aW5lIHdoaWNoIGluc3RhbGxzIGEgaGFuZGxlciB0byBtYW5hZ2UgaGFuZGxpbmcgb2YgYW55IGFqYXggZXJyb3JzIGF0IGEgZ2xvYmFsIGxldmVsLiBOb3RlIHRoYXQgd2l0aCBub1xuICogcGFyYW1ldGVyLCB0aGUgZGVmYXVsdCBEZWxwaGl4IGhhbmRsZXIgd2lsbCBiZSB1c2VkLlxuICovXG5mdW5jdGlvbiBhamF4RXJyb3JTZXR1cChoYW5kbGVyKSB7XG4gICAgJChkb2N1bWVudCkuYWpheEVycm9yKGhhbmRsZXIpO1xufVxuXG4vLyBDb3JyZXNwb25kaW5nIGNsZWFudXAgcm91dGluZSBmb3IgYWpheEVycm9yU2V0dXBcbmZ1bmN0aW9uIGFqYXhFcnJvckNsZWFudXAoKSB7XG4gICAgJChkb2N1bWVudCkub2ZmKCdhamF4RXJyb3InKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gICAgcG9zdDogcG9zdCxcbiAgICBnZXQ6IGdldCxcbiAgICBhamF4Q2FsbDogYWpheENhbGwsXG4gICAgYWpheFNldHVwOiBhamF4U2V0dXAsXG4gICAgYWpheEVycm9yU2V0dXA6IGFqYXhFcnJvclNldHVwLFxuICAgIGFqYXhFcnJvckNsZWFudXA6IGFqYXhFcnJvckNsZWFudXBcbn07XG5cbi8vIEltbWVkaWF0ZWx5IHNldCB1cCBkZWZhdWx0IGFqYXggY29uZmlndXJhdGlvbiBhbmQgQ1NSRiBoZWFkZXIgaW5jbHVzaW9uXG5hamF4U2V0dXAoKTtcbiIsIi8qXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTMsIDIwMTUgYnkgRGVscGhpeC4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqL1xuXG4vKiBnbG9iYWwgTW9kZXJuaXpyLCB3aW5kb3csIF8gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG4vKlxuICogQ29udGFpbmVyIGZvciBhbGwgYnJvd3Nlci1zcGVjaWZpYyB3b3JrYXJvdW5kcywgYXMgd2VsbCBhcyBhY2Nlc3MgdG8gd3JhcHBlcnMgYXJvdW5kIHBhcnRzIG9mIHRoZSBicm93c2VyIHRoYXRcbiAqIGNhbid0IGJlIG1vY2tlYy5cbiAqL1xuLypcbiAqIFByb3ZpZGUgYWNjZXNzIHRvIHdpbmRvdy5sb2NhdGlvbi4gIFRoaXMgaXMgcHJpbWFyaWx5IHRvIGFsbG93IHRlc3RzIHRvIG92ZXJyaWRlIGFjY2VzcyB0byB0aGlzIG1lbWJlclxuICogd2hpY2ggaXMgb2Z0ZW4gbm90IHZlcnkgbWFsZWFibGUgaW4gcmVhbCBicm93c2Vycy5cbiAqL1xuZnVuY3Rpb24gZ2V0V2luZG93TG9jYXRpb24oKSB7XG4gICAgcmV0dXJuIHdpbmRvdy5sb2NhdGlvbjtcbn1cblxuLypcbiAqIFNldHMgdGhlIHdpbmRvdy5sb2NhdGlvbi5oYXNoIHZhbHVlLiBUaGlzIGlzIGRvbmUgYmVjYXVzZSB3ZSBjYW4ndCBzcHkgb24gdGhlIGxvY2F0aW9uIHByb3BlcnRpZXMgaW4gdGVzdHMuXG4gKi9cbmZ1bmN0aW9uIHNldFdpbmRvd0hhc2gobmV3SGFzaCkge1xuICAgIHdpbmRvdy5sb2NhdGlvbi5oYXNoID0gbmV3SGFzaDtcbn1cblxuLypcbiAqIFJlbG9hZHMgdGhlIHBhZ2UuXG4gKi9cbmZ1bmN0aW9uIGxvY2F0aW9uUmVsb2FkKCkge1xuICAgIHdpbmRvdy5sb2NhdGlvbi5yZWxvYWQodHJ1ZSk7XG59XG5cbi8qXG4gKiBPcGVuIGFuIFVSTC5cbiAqL1xuZnVuY3Rpb24gb3Blbih1cmwsIHRhcmdldCwgZmVhdHVyZSwgcmVwbGFjZSkge1xuICAgIHdpbmRvdy5vcGVuKHVybCwgdGFyZ2V0LCBmZWF0dXJlLCByZXBsYWNlKTtcbn1cblxuLypcbiAqIEdlbmVyYWxpemVkIHJvdXRpbmUgZm9yIHdyaXRpbmcgdG8gdmFyaW91cyBjb25zb2xlIG91dHB1dCAnc3RyZWFtcycuICBUaGlzIGlzIHF1aXRlIHByb3RlY3RpdmUgc2luY2Ugc29tZVxuICogdmVyc2lvbnMgb2YgSUUgZG9uJ3QgYmVoYXZlIHdlbGwgKGFuZCwgZm9yIHRoYXQgbWF0dGVyLCB3aW5kb3cuY29uc29sZSBpc24ndCBwYXJ0IG9mIGEgc3RhbmRhcmQpLiBBbHNvLFxuICogSUU5J3MgY29uc29sZS5sb2cgZG9lc24ndCBhbHdheXMgaGF2ZSBhbiBhcHBseSgpIHJvdXRpbmUsIGFuZCB0aGlzIG1heSB3ZWxsIGJlIHRydWUgb2Ygb3RoZXJzIHRvby5cbiAqL1xuZnVuY3Rpb24gY29uc29sZVJlcG9ydChvcGVyYXRpb24sIG9yaWdpbmFsQXJncykge1xuICAgIGlmICghXy5pc1VuZGVmaW5lZCh3aW5kb3cuY29uc29sZSkpIHtcbiAgICAgICAgaWYgKHdpbmRvdy5jb25zb2xlW29wZXJhdGlvbl0pIHtcbiAgICAgICAgICAgIHZhciBoYXNBcHBseSA9IGZhbHNlO1xuICAgICAgICAgICAgLy8gVGhlIGFuZ3VsYXIgY29kZWJhc2Ugc2F5cyB0aGF0IElFMTEgaW4gSUU4IGVtdWxhdGlvbiBtb2RlIHdpbGwgdGhyb3cgYW4gZXhjZXB0aW9uIGlmIHJlYWRpbmcgYXBwbHlcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgaGFzQXBwbHkgPSAhIXdpbmRvdy5jb25zb2xlW29wZXJhdGlvbl0uYXBwbHk7XG4gICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgLy8gZW1wdHlcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChoYXNBcHBseSkge1xuICAgICAgICAgICAgICAgIHdpbmRvdy5jb25zb2xlW29wZXJhdGlvbl0uYXBwbHkod2luZG93LmNvbnNvbGUsIG9yaWdpbmFsQXJncyk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHdpbmRvdy5jb25zb2xlW29wZXJhdGlvbl0ob3JpZ2luYWxBcmdzWzBdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmIChvcGVyYXRpb24gIT09ICdsb2cnKSB7XG4gICAgICAgICAgICBtb2R1bGUuZXhwb3J0cy5jb25zb2xlUmVwb3J0KCdsb2cnLCBvcmlnaW5hbEFyZ3MpO1xuICAgICAgICB9XG4gICAgfVxufVxuXG4vKlxuICogV3JhcHBlciBhcm91bmQgaW50ZXJhY3Rpb24gd2l0aCB0aGUgY29uc29sZVxuICovXG5mdW5jdGlvbiBjb25zb2xlTG9nKCkge1xuICAgIG1vZHVsZS5leHBvcnRzLmNvbnNvbGVSZXBvcnQoJ2xvZycsIGFyZ3VtZW50cyk7XG59XG5cbi8qXG4gKiBXcmFwcGVyIGFyb3VuZCBpbnRlcmFjdGlvbiB3aXRoIHRoZSBjb25zb2xlXG4gKi9cbmZ1bmN0aW9uIGNvbnNvbGVJbmZvKCkge1xuICAgIG1vZHVsZS5leHBvcnRzLmNvbnNvbGVSZXBvcnQoJ2luZm8nLCBhcmd1bWVudHMpO1xufVxuXG4vKlxuICogV3JhcHBlciBhcm91bmQgaW50ZXJhY3Rpb24gd2l0aCB0aGUgY29uc29sZVxuICovXG5mdW5jdGlvbiBjb25zb2xlV2FybigpIHtcbiAgICBtb2R1bGUuZXhwb3J0cy5jb25zb2xlUmVwb3J0KCd3YXJuJywgYXJndW1lbnRzKTtcbn1cblxuLypcbiAqIFdyYXBwZXIgYXJvdW5kIGludGVyYWN0aW9uIHdpdGggdGhlIGNvbnNvbGVcbiAqL1xuZnVuY3Rpb24gY29uc29sZUVycm9yKCkge1xuICAgIG1vZHVsZS5leHBvcnRzLmNvbnNvbGVSZXBvcnQoJ2Vycm9yJywgYXJndW1lbnRzKTtcbn1cblxuLypcbiAqIFdyYXBwZXIgYXJvdW5kIGludGVyYWN0aW9uIHdpdGggdGhlIGNvbnNvbGVcbiAqL1xuZnVuY3Rpb24gY29uc29sZURlYnVnKCkge1xuICAgIG1vZHVsZS5leHBvcnRzLmNvbnNvbGVSZXBvcnQoJ2RlYnVnJywgYXJndW1lbnRzKTtcbn1cblxuLypcbiAqIFJldHVybiB0aGUgYXBwcm9wcmlhdGUgY2hhbmdlIGV2ZW50IGZvciBjaGVja2JveCB1bmRlciBkaWZmZXJlbnQgYnJvd3NlcnMuIFRoZSBwcm9ibGVtIHdpdGggdGhpcyBvbmUgaXMgdGhhdCBJRTgnc1xuICogY2hhbmdlIGV2ZW50IGlzIGZpcmVkIGJlZm9yZSB0aGUgYWN0dWFsIGNoYW5nZSB3YXMgbWFkZSBhbmQgaXQgd2FzIGltcG9zc2libGUgdG8gcXVlcnkgZm9yIHRoZSB1cGRhdGVkIHZhbHVlLlxuICovXG5mdW5jdGlvbiBjaGVja2JveENoYW5nZUV2ZW50KGVsZW1lbnQpIHtcbiAgICB2YXIgaGFzTmV3RXZlbnQgPSBNb2Rlcm5penIuaGFzRXZlbnQoJ2NoYW5nZScsIGVsZW1lbnQpO1xuICAgIHJldHVybiAoaGFzTmV3RXZlbnQpID8gJ2NoYW5nZScgOiAncHJvcGVydHljaGFuZ2UnO1xufVxuXG4vKlxuICogUGxlYXNlIGRvIG5vdCB1c2UgdGhpcyByb3V0aW5lLiBUcnkgdG8gdXNlIE1vZGVybml6ciBpbnN0ZWFkLiBUaGlzIGlzIG9ubHkgcHJvdmlkZWQgZm9yIHRoZSBleHRyZW1lIGNhc2UgdGhhdCBvbmVcbiAqIHJlYWxseSBuZWVkcyB0byBjYXJlIHRoYXQgdGhlIGJyb3dzZXIgaW4gcXVlc3Rpb24gaXMgSUUuXG4gKi9cbmZ1bmN0aW9uIGlzSUUoKSB7XG4gICAgLy8gc2VlIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvMTk5OTkzODgvanF1ZXJ5LWNoZWNrLWlmLXVzZXItaXMtdXNpbmctaWVcbiAgICB2YXIgdWEgPSB3aW5kb3cubmF2aWdhdG9yLnVzZXJBZ2VudDtcbiAgICB2YXIgbXNpZSA9IHVhLmluZGV4T2YoJ01TSUUgJyk7XG4gICAgcmV0dXJuIChtc2llID4gMCB8fCAhIW5hdmlnYXRvci51c2VyQWdlbnQubWF0Y2goL1RyaWRlbnQuKnJ2XFw6MTFcXC4vKSk7XG59XG5cbi8qXG4gKiBQbGVhc2UgZG8gbm90IHVzZSB0aGlzIHJvdXRpbmUsIGVpdGhlci5cbiAqL1xuZnVuY3Rpb24gaXNJRTlvcjEwKCkge1xuICAgIC8vIHNlZSBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzE5OTk5Mzg4L2pxdWVyeS1jaGVjay1pZi11c2VyLWlzLXVzaW5nLWllXG4gICAgdmFyIHVhID0gd2luZG93Lm5hdmlnYXRvci51c2VyQWdlbnQ7XG4gICAgdmFyIG1zaWUgPSB1YS5pbmRleE9mKCdNU0lFICcpO1xuICAgIHJldHVybiAobXNpZSA+IDApO1xufVxuXG4vKlxuICogU2V0cyB0aGUgdGl0bGUgaW4gdGhlIGJyb3dzZXIgdGFiXG4gKiBJZiB0aGUgaG9zdG5hbWUgaXMgYW4gSVAgYWRkcmVzcywgd2UgbGVhdmUgaXQgYXMgaXMuXG4gKiBJZiBpdCdzIGEgJ25vcm1hbCcgVVJMLCB3ZSBzdHJpcCBvZmYgdGhlIGRvbWFpbiBuYW1lIChldmVyeXRoaW5nIGFmdGVyIHRoZSBmaXJzdCAnLicpXG4gKiBBY2NlcHRzIGEgc3VmZml4IHdoaWNoIHdpbGwgYmUgYXBwZW5kZWQgYWZ0ZXIgdGhlIGhvc3RuYW1lXG4gKi9cbmZ1bmN0aW9uIHNldFRpdGxlKHN1ZmZpeCkge1xuICAgIHZhciB0aXRsZSxcbiAgICAgICAgaXNJUEFkZHJlc3MsXG4gICAgICAgIGhvc3RuYW1lICAgICA9IG1vZHVsZS5leHBvcnRzLmdldFdpbmRvd0xvY2F0aW9uKCkuaG9zdG5hbWUsXG4gICAgICAgIGhvc3RuYW1lU2VncyA9IGhvc3RuYW1lID8gaG9zdG5hbWUuc3BsaXQoJy4nKSA6IFtdO1xuXG4gICAgLy8gd2UncmUgZmFpcmx5IHN1cmUgaXQncyBhbiBJUCBhZGRyZXNzIGlmIGxhc3Qgc2VnbWVudCBoYXMgYSBudW1lcmljIGNoYXJhY3RlclxuICAgIGlzSVBBZGRyZXNzID0gL1xcZC8udGVzdChob3N0bmFtZVNlZ3NbaG9zdG5hbWVTZWdzLmxlbmd0aCAtIDFdKTtcblxuICAgIHRpdGxlID0gaXNJUEFkZHJlc3MgPyBob3N0bmFtZSA6IGhvc3RuYW1lU2Vnc1swXTtcblxuICAgIC8vIGFwcGVuZCBzdWZmaXhcbiAgICBpZiAoc3VmZml4KSB0aXRsZSArPSAnIC0gJyArIHN1ZmZpeDtcblxuICAgIGRvY3VtZW50LnRpdGxlID0gdGl0bGU7XG4gICAgcmV0dXJuIHRpdGxlOyAvLyBVc2VkIGZvciB0ZXN0aW5nIHB1cnBvc2VzXG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICAgIGdldFdpbmRvd0xvY2F0aW9uOiBnZXRXaW5kb3dMb2NhdGlvbixcbiAgICBzZXRXaW5kb3dIYXNoOiBzZXRXaW5kb3dIYXNoLFxuICAgIGxvY2F0aW9uUmVsb2FkOiBsb2NhdGlvblJlbG9hZCxcbiAgICBvcGVuOiBvcGVuLFxuICAgIGNvbnNvbGVMb2c6IGNvbnNvbGVMb2csXG4gICAgY29uc29sZUluZm86IGNvbnNvbGVJbmZvLFxuICAgIGNvbnNvbGVXYXJuOiBjb25zb2xlV2FybixcbiAgICBjb25zb2xlRXJyb3I6IGNvbnNvbGVFcnJvcixcbiAgICBjb25zb2xlRGVidWc6IGNvbnNvbGVEZWJ1ZyxcbiAgICBjb25zb2xlUmVwb3J0OiBjb25zb2xlUmVwb3J0LFxuICAgIGNoZWNrYm94Q2hhbmdlRXZlbnQ6IGNoZWNrYm94Q2hhbmdlRXZlbnQsXG4gICAgaXNJRTogaXNJRSxcbiAgICBpc0lFOW9yMTA6IGlzSUU5b3IxMCxcbiAgICBzZXRUaXRsZTogc2V0VGl0bGVcbn07XG4iLCIvKlxuICogQ29weXJpZ2h0IChjKSAyMDEzLCAyMDE1IGJ5IERlbHBoaXguIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKi9cblxuLypcbiAqIFRoaXMgZmlsZSBjb250YWlucyBhIG1hcCBvZiBjb21tb24gY29uc3RhbnRzLlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIFNFQ09ORF9JTl9NSUxMSVNFQ09ORFMgPSAxMDAwLFxuICAgIE1JTlVURV9JTl9NSUxMSVNFQ09ORFMgPSBTRUNPTkRfSU5fTUlMTElTRUNPTkRTICogNjAsXG4gICAgSE9VUl9JTl9NSUxMSVNFQ09ORFMgPSBNSU5VVEVfSU5fTUlMTElTRUNPTkRTICogNjAsXG4gICAgREFZX0lOX01JTExJU0VDT05EUyA9IEhPVVJfSU5fTUlMTElTRUNPTkRTICogMjQsXG4gICAgV0VFS19JTl9NSUxMSVNFQ09ORFMgPSBEQVlfSU5fTUlMTElTRUNPTkRTICogNyxcbiAgICBNT05USF9JTl9NSUxMSVNFQ09ORFMgPSBEQVlfSU5fTUlMTElTRUNPTkRTICogMzAsXG4gICAgWUVBUl9JTl9NSUxMSVNFQ09ORFMgPSBEQVlfSU5fTUlMTElTRUNPTkRTICogMzY1O1xuXG52YXIgaW5lcXVhbGl0eVR5cGVzID0ge1xuICAgIFNUUklDVDogICAgICdTVFJJQ1QnLFxuICAgIE5PTl9TVFJJQ1Q6ICdOT04tU1RSSUNUJ1xufTtcblxudmFyIGxpc3RUeXBlcyA9IHtcbiAgICBOT05FOiAgICdOT05FJyxcbiAgICBVQkVSOiAgICdVQkVSJyxcbiAgICBDVVNUT006ICdDVVNUT00nXG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgICBMREFQICAgICAgICAgICAgICAgICAgOiAnTERBUCcsXG4gICAgVkVSU0lPTl9NQUpPUiAgICAgICAgIDogMSxcbiAgICBWRVJTSU9OX01JTk9SICAgICAgICAgOiA3LFxuICAgIFZFUlNJT05fTUlDUk8gICAgICAgICA6IDAsXG4gICAgLy8gVGltZSBjb25zdGFudHNcbiAgICBTRUNPTkRfSU5fTUlMTElTRUNPTkRTOiAxMDAwLFxuICAgIE1JTlVURV9JTl9NSUxMSVNFQ09ORFM6IE1JTlVURV9JTl9NSUxMSVNFQ09ORFMsXG4gICAgSE9VUl9JTl9NSUxMSVNFQ09ORFMgIDogSE9VUl9JTl9NSUxMSVNFQ09ORFMsXG4gICAgREFZX0lOX01JTExJU0VDT05EUyAgIDogREFZX0lOX01JTExJU0VDT05EUyxcbiAgICBXRUVLX0lOX01JTExJU0VDT05EUyAgOiBXRUVLX0lOX01JTExJU0VDT05EUyxcbiAgICBNT05USF9JTl9NSUxMSVNFQ09ORFMgOiBNT05USF9JTl9NSUxMSVNFQ09ORFMsXG4gICAgWUVBUl9JTl9NSUxMSVNFQ09ORFMgIDogWUVBUl9JTl9NSUxMSVNFQ09ORFMsXG4gICAgSU5FUVVBTElUWV9UWVBFUyAgICAgIDogaW5lcXVhbGl0eVR5cGVzLFxuICAgIExJU1RfVFlQRVMgICAgICAgICAgICA6IGxpc3RUeXBlc1xufTtcblxuIiwiLypcbiAqIENvcHlyaWdodCAoYykgMjAxNCwgMjAxNSBieSBEZWxwaGl4LiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICovXG5cbi8qIGdsb2JhbCBfICovXG5cbid1c2Ugc3RyaWN0JztcblxuLypcbiAqIERlbHBoaXggZnJhbWV3b3JrL3RvcC1sZXZlbCBuYW1lc3BhY2VcbiAqL1xuXG53aW5kb3cuZHggPSB3aW5kb3cuZHggfHwge307XG5cbmlmIChfLmlzVW5kZWZpbmVkKHdpbmRvdy5keC5uYW1lc3BhY2UpKSB7XG4gICAgXy5leHRlbmQod2luZG93LmR4LCB7XG4gICAgICAgIG5hbWVzcGFjZTogZnVuY3Rpb24obmFtZXNwYWNlKSB7XG4gICAgICAgICAgICB2YXIgY3VycmVudCA9IHdpbmRvdztcbiAgICAgICAgICAgIF8uZWFjaChuYW1lc3BhY2Uuc3BsaXQoJy4nKSwgZnVuY3Rpb24ocE5hbWUpIHtcbiAgICAgICAgICAgICAgICBjdXJyZW50ID0gKGN1cnJlbnRbcE5hbWVdID0gY3VycmVudFtwTmFtZV0gfHwge30pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gY3VycmVudDtcbiAgICAgICAgfVxuICAgIH0pO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHdpbmRvdy5keDtcbiIsIi8qXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTQsIDIwMTUgYnkgRGVscGhpeC4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqL1xuXG4vKiBnbG9iYWwgJCwgXyAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbmNvbnN0IGR4VXRpbCA9IHJlcXVpcmUoJ2R4Y29yZS9qcy91dGlsLmpzJyk7XG5cbi8qXG4gKiB0aGlzIGZ1bmN0aW9uIHNldHMgdXAgdGhlIGxvY2FsZVxuICogICAgIGxvY2FsZUNvbmZpZyAtIGNvbmZvcm1pbmcgdG8gdGhlIGkxOG4ganF1ZXJ5IHBsdWdpbiBjb25maWcuXG4gKi9cbmZ1bmN0aW9uIHNldHVwTG9jYWxlKGxvY2FsZUNvbmZpZykge1xuICAgIC8vIGNoZWNrIHRvIGlmIGFuIGFycmF5IG9mIGxvY2FsZSBjb25maWcgaXMgcGFzc2VkXG4gICAgdHJ5IHtcbiAgICAgICAgaWYgKGxvY2FsZUNvbmZpZyBpbnN0YW5jZW9mIEFycmF5KSB7XG4gICAgICAgICAgICBmb3IgKHZhciBpIGluIGxvY2FsZUNvbmZpZykge1xuICAgICAgICAgICAgICAgIGlmIChsb2NhbGVDb25maWdbaV0pIHtcbiAgICAgICAgICAgICAgICAgICAgbG9jYWxlQ29uZmlnW2ldLm1vZGUgPSAnbWFwJztcbiAgICAgICAgICAgICAgICAgICAgJC5pMThuLnByb3BlcnRpZXMobG9jYWxlQ29uZmlnW2ldKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBsb2NhbGVDb25maWcubW9kZSA9ICdtYXAnO1xuICAgICAgICAgICAgJC5pMThuLnByb3BlcnRpZXMobG9jYWxlQ29uZmlnKTtcbiAgICAgICAgfVxuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgaWYgKGR4VXRpbC5pc05vbmUoJC5pMThuKSkge1xuICAgICAgICAgICAgZHhVdGlsLmZhaWwoJ0Vycm9yOiBMb2NhbGl6ZWQgdGV4dCBjYW5ub3QgYmUgaW5pdGlhbGl6ZWQuJyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBlO1xuICAgICAgICB9XG4gICAgfVxufVxuXG4vKlxuICogR2V0IHRoZSB1c2VyJ3MgcHJlZmVycmVkIGxvY2FsZSwgd2hpY2ggaXMgc2V0IGluIGEgY29va2llIGJ5IHRoZSBsb2dpbiBzY3JlZW4uIElmIG5vdCBzZXQsIGl0IGRlZmF1bHRzIHRvIEVuZ2xpc2guXG4gKi9cbmZ1bmN0aW9uIGdldEN1cnJlbnRMb2NhbGUoKSB7XG4gICAgdmFyIGxvY2FsZSA9IGR4VXRpbC5nZXRDb29raWUoJ2xvY2FsZScpIHx8ICdlbi1VUyc7XG4gICAgLy8gJC5pMThuIGxvb2tzIGZvciBtZXNzYWdlIGZpbGVzIHdpdGggdW5kZXJzY29yZXMuXG4gICAgbG9jYWxlID0gbG9jYWxlLnJlcGxhY2UoJy0nLCAnXycpO1xuXG4gICAgcmV0dXJuIGxvY2FsZTtcbn1cblxuLypcbiAqIGdscyA9PSBnZXRMb2NhbGVTdHJpbmcuICBUaGlzIGZ1bmN0aW9uIGdldHMgYSBjb25zdGFudHMgdmFsdWUgaW5pdGlhbGl6ZWQgYnkgbG9jYWxpemF0aW9uIGxpYnJhcnkuIFRoZSBmaXJzdFxuICogcGFyYW1ldGVyIGlzIHRoZSBsb2NhbGUga2V5IHRvIGxvb2sgdXAgdGhlIGxvY2FsaXplZCBzdHJpbmcuIEFkZGl0aW9uYWwgb3B0aW9uYWwgcGFyYW1ldGVycyBhcmUgdXNlZCBmb3JcbiAqIHN1YnN0aXR1dGlvbnMgYXMgezB9LCB7MX0sIGV0Yy5cbiAqL1xuZnVuY3Rpb24gZ2xzKCkge1xuICAgIGlmICgkLmkxOG4gJiYgJC5pMThuLnByb3ApIHtcbiAgICAgICAgcmV0dXJuICQuaTE4bi5wcm9wLmFwcGx5KHVuZGVmaW5lZCwgYXJndW1lbnRzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gJ0Vycm9yOiBMb2NhbGl6ZWQgdGV4dCBmYWlsZWQgdG8gaW5pdGlhbGl6ZS4nO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gc2NhbGVEZWNpbWFsTnVtYmVyQXNTdHJpbmcodmFsdWUsIHVuaXRzKSB7XG4gICAgcmV0dXJuIG51bWJlclRvU3RyaW5nKHZhbHVlLCAnZGVjaW1hbCcsIHVuaXRzKTtcbn1cblxuZnVuY3Rpb24gbnVtYmVyVG9TdHJpbmcodmFsdWUsIGJhc2VTdHJpbmcsIHVuaXRzKSB7XG4gICAgaWYgKCFfLmlzTnVtYmVyKHZhbHVlKSkge1xuICAgICAgICByZXR1cm4gJyc7XG4gICAgfVxuICAgIGlmIChiYXNlU3RyaW5nICYmIFsnZGVjaW1hbCcsICdiaW5hcnknXS5pbmRleE9mKGJhc2VTdHJpbmcpID09PSAtMSkge1xuICAgICAgICBkeFV0aWwuZmFpbCgnYmFzZVN0cmluZyBtdXN0IGJlIFwiZGVjaW1hbFwiIChvciB1bmRlZmluZWQpLCBcImJpbmFyeVwiLiBSZWNlaXZlZDogJyArIGJhc2VTdHJpbmcgKyAnLicpO1xuICAgIH1cblxuICAgIHZhciBiYXNlID0gKGJhc2VTdHJpbmcgPT09ICdiaW5hcnknID8gMTAyNCA6IDEwMDApO1xuICAgIHZhciBwcmVmaXhlcyA9IFsgJycsICdLJywgJ00nLCAnRycsICdUJywgJ1AnLCAnRScgXTtcbiAgICB2YXIgaW5kZXg7XG4gICAgZm9yIChpbmRleCA9IDA7IHZhbHVlID49IGJhc2UgJiYgaW5kZXggPCBwcmVmaXhlcy5sZW5ndGggLSAxOyBpbmRleCsrKSB7XG4gICAgICAgIHZhbHVlIC89IGJhc2U7XG4gICAgfVxuXG4gICAgaWYgKHZhbHVlID4gYmFzZSB8fCBNYXRoLnJvdW5kKHZhbHVlKSA9PT0gdmFsdWUpIHtcbiAgICAgICAgdmFsdWUgPSBNYXRoLnJvdW5kKHZhbHVlKS50b1N0cmluZygpO1xuICAgIH0gZWxzZSBpZiAodmFsdWUgPCAxMCkge1xuICAgICAgICB2YWx1ZSA9IHZhbHVlLnRvRml4ZWQoMik7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgdmFsdWUgPSB2YWx1ZS50b1ByZWNpc2lvbig0KTtcbiAgICB9XG5cbiAgICByZXR1cm4gdmFsdWUgKyBwcmVmaXhlc1tpbmRleF0gKyAoIV8uaXNVbmRlZmluZWQodW5pdHMpID8gbW9kdWxlLmV4cG9ydHMuZ2xzKHVuaXRzKSA6ICcnKTtcbn1cblxuLy8gRGVmaW5lIHRoZSBwdWJsaWMgYXBpXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgICBnbHM6IGdscyxcbiAgICBnZXRDdXJyZW50TG9jYWxlOiBnZXRDdXJyZW50TG9jYWxlLFxuICAgIHNldHVwTG9jYWxlOiBzZXR1cExvY2FsZSxcbiAgICBzY2FsZURlY2ltYWxOdW1iZXJBc1N0cmluZzogc2NhbGVEZWNpbWFsTnVtYmVyQXNTdHJpbmcsXG4gICAgbnVtYmVyVG9TdHJpbmc6IG51bWJlclRvU3RyaW5nXG59O1xuIiwiLypcbiAqIENvcHlyaWdodCAoYykgMjAxNCwgMjAxNSBieSBEZWxwaGl4LiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICovXG5cbi8qIGdsb2JhbCAkLCBfICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIG1vZGFsVmlzaWJsZSA9IG51bGwsXG4gICAgbmFtZWRNb2RhbCA9IHt9O1xuXG5jb25zdCBkeFV0aWwgPSByZXF1aXJlKCdkeGNvcmUvanMvdXRpbC5qcycpLFxuICAgIGR4TG9jYWxlID0gcmVxdWlyZSgnZHhjb3JlL2pzL2xvY2FsZS5qcycpLFxuICAgIGR4VGVtcGxhdGUgPSByZXF1aXJlKCdkeGNvcmUvanMvdGVtcGxhdGUuanMnKTtcblxuLypcbiAqIG1vZGFsLnNob3cob3B0aW9ucylcbiAqXG4gKiBEaXNwbGF5cyBhIG1vZGFsIGRpYWxvZy4gT25seSBvbmUgbW9kYWwgZGlhbG9nIGNhbiBiZSBzaG93biBhdCBhIHRpbWUuIFRoZSAnb3B0aW9ucycgYXJndW1lbnQgdGFrZXMgdGhlXG4gKiBmb2xsb3dpbmcgdmFsdWVzOlxuICpcbiAqICAgICAgY29udGVudCAgICAgICAgIENvbnRlbnQgZm9yIHRoZSBkaWFsb2csIGFzIGEgalF1ZXJ5IG5vZGUuXG4gKlxuICogICAgICB0aXRsZSAgICAgICAgICAgQW4gb3B0aW9uYWwgdGl0bGUgZm9yIHRoZSBkaWFsb2cuXG4gKlxuICogICAgICBub2Nsb3NlICAgICAgICAgQnkgZGVmYXVsdCwgYWxsIG1vZGFsIGRpYWxvZ3MgaGF2ZSBhIGNsb3NlIGJ1dHRvbiBpbiB0aGUgdG9wIHJpZ2h0IGNvcm5lciB0aGF0IGRpc21pc3Nlc1xuICogICAgICAgICAgICAgICAgICAgICAgdGhlIGRpYWxvZy4gSWYgdGhpcyBpcyBleHBsaWNpdGx5IHNldCB0byAndHJ1ZScsIHRoZW4gdGhpcyBjbG9zZSBib3ggaXMgaGlkZGVuLlxuICpcbiAqICAgICAgY3NzQ2xhc3MgICAgICAgIFRoaXMgaXMgYW4gb3B0aW9uYWwgcGFyYW1ldGVyLiBJZiBwcm92aWRlZCwgaXQgd2lsbCBvdmVycmlkZSB0aGUgZGVmYXVsdCBjc3MgZm9yIHRoZVxuICogICAgICAgICAgICAgICAgICAgICAgbW9kYWwgd2luZG93IGJ5IGFkZGluZyB0aGUgcHJvdmlkZWQgY3NzIGNsYXNzIHJlZmVyZW5jZSB0byB0aGUgY29udGFpbmVyIGRpdi5cbiAqXG4gKiAgICAgIHRlbXBsYXRlICAgICAgICBCeSBkZWZhdWx0LCB3ZSB1c2UgdGhlIGR4Y29yZS90ZW1wbGF0ZS9tb2RhbC9kaWFsb2cuaGpzIHRlbXBsYXRlIGZvciB0aGlzIG1vZGFsIGRpYWxvZy5cbiAqICAgICAgICAgICAgICAgICAgICAgIEhvd2V2ZXIsIGlmIHRoZSBkZXZlbG9wZXIgbmVlZHMgdG8gcG9wLXVwIGFuIGVudGlyZWx5IGRpZmZlcmVudCBraW5kIG9mIG1vZGFsLCBoZS9zaGUgY2FuXG4gKiAgICAgICAgICAgICAgICAgICAgICBwYXNzIGluIHBhdGggdG8gdGhlaXIgdGVtcGxhdGUgYW5kIG1vZGFsIHdpbGwgcmVuZGVyIGl0LlxuICpcbiAqICAgICAgYnV0dG9ucyAgICAgICAgIEFuIG9wdGlvbmFsIGFycmF5IG9mIG9iamVjdHMgdGhhdCBzcGVjaWZ5IGEgc2V0IG9mIGJ1dHRvbnMgdG8gZGlzcGxheSBpbiB0aGUgZm9vdGVyLiBUaGVzZVxuICogICAgICAgICAgICAgICAgICAgICAgYnV0dG9uIG9iamVjdHMgaW5jbHVkZSB0aGUgZm9sbG93aW5nIGF0dHJpYnV0ZXM6XG4gKlxuICogICAgICAgICAgICAgICAgICAgICAgICAgIGxhYmVsICAgICAgIFRleHQgbGFiZWwgZm9yIHRoZSBidXR0b24uXG4gKlxuICogICAgICAgICAgICAgICAgICAgICAgICAgIG9uQ2xpY2sgICAgIENhbGxiYWNrIGludm9rZWQgd2hlbiB0aGUgYnV0dG9uIGlzIGNsaWNrZWQuXG4gKlxuICogICAgICAgICAgICAgICAgICAgICAgICAgIHByaW1hcnkgICAgIElmIHRydWUsIHRoZW4gdGhpcyBidXR0b24gaXMgZ2l2ZW4gdGhlICdidG4tcHJpbWFyeScgY2xhc3MgdG8gaW5kaWNhdGUgaXQgaXNcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGUgZGVmYXVsdCBhY3Rpb24uIEl0IGRvZXMgbm90IGJpbmQgdGhlIGVudGVyIGtleSB0byBhY3R1YWxseSB0cmlnZ2VyIHRoZVxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoZSBidXR0b24uXG4gKlxuICogICAgICAgICAgICAgICAgICAgICAgICAgIGljb25DbGFzcyAgIE9wdGlvbmFsIHBhcmFtZXRlci4gSWYgcHJlc2VudCwgYWxsb3dzIGZvciBhbiBpY29uIHRvIGJlIHNob3duIGluIHRoZSBidXR0b25cbiAqXG4gKiAgICAgIGNhbmNlbCAgICAgICAgICBDb252ZW5pZW5jZSBhbGlhcy4gSWYgc2V0IHRvICd0cnVlJywgcHJlcGVuZCBhIHN0YW5kYXJkIGNhbmNlbCBidXR0b24gdG8gdGhlIGJ1dHRvbiBsaXN0XG4gKiAgICAgICAgICAgICAgICAgICAgICB0aGF0IGRpc21pc3NlcyB0aGUgY3VycmVudCBkaWFsb2cuXG4gKlxuICogICAgICBvayAgICAgICAgICAgICAgQ29udmVuaWVuY2UgYWxpYXMuIElmIHNldCB0byAndHJ1ZScsIGFwcGVuZCBhIHN0YW5kYXJkIE9LIGJ1dHRvbiB0byB0aGUgYnV0dG9uIGxpc3QgdGhhdFxuICogICAgICAgICAgICAgICAgICAgICAgZGlzbWlzc2VzIHRoZSBjdXJyZW50IGRpYWxvZy4gSWYgdGhpcyBpcyBhIGZ1bmN0aW9uLCB0aGVuIHRoZSBmdW5jdGlvbiBpcyBpbnZva2VkIHdoZW4gdGhlXG4gKiAgICAgICAgICAgICAgICAgICAgICBidXR0b24gaXMgcHJlc3NlZCBpbnN0ZWFkIG9mIGRpc21pc3NpbmcgdGhlIGRpYWxvZy5cbiAqXG4gKiAgICAgIG9uU2hvdyAgICAgICAgICBBIGNhbGxiYWNrIHRoYXQgaXMgaW52b2tlZCB3aGVuIHRoZSBkaWFsb2cgZWxlbWVudCBpcyB2aXNpYmxlLlxuICovXG5mdW5jdGlvbiBzaG93KG9wdGlvbnMpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgICBpZiAobW9kYWxWaXNpYmxlKSB7XG4gICAgICAgIGR4VXRpbC5mYWlsKCdhdHRlbXB0IHRvIHNob3cgbXVsdGlwbGUgbW9kYWwgZGlhbG9ncyBhdCBvbmNlJyk7XG4gICAgfVxuXG4gICAgdmFyIGJ1dHRvbnMgPSBvcHRpb25zLmJ1dHRvbnMgfHwgW107XG5cbiAgICAvLyBEZWZhdWx0IGNhbmNlbCBidXR0b25cbiAgICBpZiAob3B0aW9ucy5jYW5jZWwpIHtcbiAgICAgICAgYnV0dG9ucy51bnNoaWZ0KHtcbiAgICAgICAgICAgIGxhYmVsOiBkeExvY2FsZS5nbHMoJ2J1dHRvbi5jYW5jZWwnKSxcbiAgICAgICAgICAgIG9uQ2xpY2s6IGhpZGVcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgLy8gRGVmYXVsdCBPSyBidXR0b25cbiAgICBpZiAob3B0aW9ucy5vaykge1xuICAgICAgICBidXR0b25zLnB1c2goe1xuICAgICAgICAgICAgbGFiZWw6IGR4TG9jYWxlLmdscygnYnV0dG9uLm9rJyksXG4gICAgICAgICAgICBvbkNsaWNrOiBfLmlzRnVuY3Rpb24ob3B0aW9ucy5vaykgPyBvcHRpb25zLm9rIDogaGlkZSxcbiAgICAgICAgICAgIHByaW1hcnk6IHRydWUsXG4gICAgICAgICAgICBpY29uQ2xhc3M6ICdpY29uLWFjY2VwdCdcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgLy8gQmFzaWMgbGF5b3V0XG4gICAgdmFyIHRlbXBsYXRlTG9jYXRpb24gPSBvcHRpb25zLnRlbXBsYXRlIHx8ICdkeGNvcmUvdGVtcGxhdGUvbW9kYWwvZGlhbG9nJztcbiAgICBzZWxmLmhpZGVNb2RhbCA9IGhpZGU7XG5cbiAgICB2YXIgZGlhbG9nRWxlbSA9IGR4VGVtcGxhdGUudGVtcGxhdGUodGVtcGxhdGVMb2NhdGlvbiwge1xuICAgICAgICB0aXRsZTogb3B0aW9ucy50aXRsZSxcbiAgICAgICAgaGFzQ2xvc2U6ICFvcHRpb25zLm5vY2xvc2UsXG4gICAgICAgIGhhc0Zvb3RlcjogYnV0dG9ucy5sZW5ndGggIT09IDBcbiAgICB9KTtcblxuICAgIC8vIENvbnN0cnVjdCB0aGUgYnV0dG9uIGJhclxuICAgIHZhciBidXR0b25CYXIgPSAkKCc8ZGl2PjwvZGl2PicpO1xuICAgIF8uZWFjaChidXR0b25zLCBmdW5jdGlvbihidXR0b25EZWYpIHtcblxuICAgICAgICB2YXIgYnV0dG9uRWxlbSA9IGR4VGVtcGxhdGUudGVtcGxhdGUoJ2R4Y29yZS90ZW1wbGF0ZS9tb2RhbC9idXR0b24nLCB7XG4gICAgICAgICAgICBsYWJlbDogYnV0dG9uRGVmLmxhYmVsLFxuICAgICAgICAgICAgaWNvbkNsYXNzOiBidXR0b25EZWYuaWNvbkNsYXNzXG4gICAgICAgIH0pO1xuXG4gICAgICAgIGlmIChidXR0b25EZWYucHJpbWFyeSkge1xuICAgICAgICAgICAgYnV0dG9uRWxlbS5hZGRDbGFzcygnYnRuLXByaW1hcnknKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGJ1dHRvbkVsZW0ub24oJ2NsaWNrJywgYnV0dG9uRGVmLm9uQ2xpY2spO1xuICAgICAgICBidXR0b25CYXIuYXBwZW5kKGJ1dHRvbkVsZW0pO1xuICAgIH0pO1xuXG4gICAgaWYgKG9wdGlvbnMuY3NzQ2xhc3MpIHtcbiAgICAgICAgZGlhbG9nRWxlbS5yZW1vdmVDbGFzcygnbW9kYWwtZGl2Jyk7XG4gICAgICAgIGRpYWxvZ0VsZW0uYWRkQ2xhc3Mob3B0aW9ucy5jc3NDbGFzcyk7XG4gICAgfVxuXG4gICAgLy8gU2V0IHRoZSBkeW5hbWljIGNvbnRlbnRcbiAgICBkaWFsb2dFbGVtLmNoaWxkcmVuKCcubW9kYWwtYm9keScpLmFwcGVuZChvcHRpb25zLmNvbnRlbnQpO1xuICAgIGRpYWxvZ0VsZW0uY2hpbGRyZW4oJy5tb2RhbC1mb290ZXInKS5hcHBlbmQoYnV0dG9uQmFyKTtcblxuICAgIC8vIE5vdyBzZXQgdGhlIG1vZGFsIGhvbGRlciBhbmQgc2hvdyBpdFxuICAgICQoJyNtb2RhbEhvbGRlcicpLmVtcHR5KCk7XG4gICAgJCgnI21vZGFsSG9sZGVyJykuYXBwZW5kKGRpYWxvZ0VsZW0pO1xuXG4gICAgZGlhbG9nRWxlbS5vbignaGlkZGVuLmJzLm1vZGFsJywgZnVuY3Rpb24oKSB7XG4gICAgICAgIG1vZGFsVmlzaWJsZSA9IG51bGw7XG4gICAgfSk7XG5cbiAgICBpZiAob3B0aW9ucy5vblNob3cgJiYgXy5pc0Z1bmN0aW9uKG9wdGlvbnMub25TaG93KSkge1xuICAgICAgICBkaWFsb2dFbGVtLm9uKCdzaG93bi5icy5tb2RhbCcsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgb3B0aW9ucy5vblNob3coKTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgbW9kYWxWaXNpYmxlID0gZGlhbG9nRWxlbTtcbiAgICBkaWFsb2dFbGVtLm1vZGFsKHtcbiAgICAgICAgYmFja2Ryb3A6ICdzdGF0aWMnXG4gICAgfSk7XG59XG5cbi8qXG4gKiBtb2RhbC5oaWRlKClcbiAqXG4gKiBIaWRlIHRoZSBjdXJyZW50IG1vZGFsIGRpYWxvZy4gVGhpcyBoYXMgbm8gZWZmZWN0IGlmIG5vIG1vZGFsIGRpYWxvZyBpcyBjdXJyZW50bHkgc2hvd24uXG4gKi9cbmZ1bmN0aW9uIGhpZGUoKSB7XG4gICAgaWYgKG1vZGFsVmlzaWJsZSkge1xuICAgICAgICBtb2RhbFZpc2libGUubW9kYWwoJ2hpZGUnKTtcbiAgICB9XG59XG5cbi8qXG4gKiBNb2RhbCBkaWFsb2dzIGNhbiBiZSByZWdpc3RlcmVkIGJ5IG5hbWUsIGFsbG93aW5nIGNvbnN1bWVycyB0byBkaXNwbGF5IGNvbnRlbnQgd2l0aG91dCBuZWVkaW5nIHRvIGNhbGwgZGlyZWN0bHlcbiAqIGludG8gdGhlIGltcGxlbWVudGF0aW9uLiBUaGlzIGlzIGp1c3QgYSB3cmFwcGVyIGFyb3VuZCBjYWxsYmFjayByZWdpc3RyYXRpb24uXG4gKi9cbmZ1bmN0aW9uIHJlZ2lzdGVyTmFtZWQocGF0aCwgY2FsbGJhY2spIHtcbiAgICBpZiAoIV8uaXNGdW5jdGlvbihjYWxsYmFjaykpIHtcbiAgICAgICAgZHhVdGlsLmZhaWwoJ2F0dGVtcHQgdG8gcmVnaXN0ZXIgbmFtZWQgZGlhbG9nIFwiJyArIHBhdGggKyAnXCIgd2l0aCBpbnZhbGlkIGNhbGxiYWNrJyk7XG4gICAgfVxuXG4gICAgbmFtZWRNb2RhbFtwYXRoXSA9IGNhbGxiYWNrO1xufVxuXG5mdW5jdGlvbiBzaG93TmFtZWQocGF0aCkge1xuICAgIG5hbWVkTW9kYWxbcGF0aF0oKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gICAgc2hvdzogc2hvdyxcbiAgICBoaWRlOiBoaWRlLFxuICAgIHJlZ2lzdGVyTmFtZWQ6IHJlZ2lzdGVyTmFtZWQsXG4gICAgc2hvd05hbWVkOiBzaG93TmFtZWRcbn07XG4iLCIvKlxuICogQ29weXJpZ2h0IChjKSAyMDEzLCAyMDE1IGJ5IERlbHBoaXguIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKi9cblxuLyogZ2xvYmFsICQsIEJhY2tib25lLCBfLCBrbyAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbmNvbnN0IGR4VXRpbCA9IHJlcXVpcmUoJ2R4Y29yZS9qcy91dGlsLmpzJyksXG4gICAgZHhNb2RhbCA9IHJlcXVpcmUoJ2R4Y29yZS9qcy9tb2RhbC5qcycpLFxuICAgIGR4QnJvd3NlciA9IHJlcXVpcmUoJ2R4Y29yZS9qcy9icm93c2VyLmpzJyk7XG5cbi8vIEJhY2tib25lIHJvdXRlciBpbnN0YW5jZVxudmFyIERlbHBoaXhSb3V0ZXIgPSBCYWNrYm9uZS5Sb3V0ZXIuZXh0ZW5kKCk7XG52YXIgZGVscGhpeFJvdXRlcjtcbnZhciBxdWV1ZWRDYWxscyA9IFtdO1xudmFyIHJvdXRlclN0YXJ0ZWQgPSBmYWxzZTtcblxuLy8gU3RhdGUgZm9yIHJlbWVtYmVyaW5nIHByZXNlcnZlZCBzY3JlZW4gc3RhdGVcbnZhciBzYXZlZFNjcmVlbnMgPSB7fTtcblxuLy8gU3RhdGUgZm9yIGltcGxlbWVudGluZyBvbkV4aXQoKVxudmFyIGN1cnJlbnRTY3JlZW47XG52YXIgY3VycmVudFNjcmVlbk9wdGlvbnM7XG5cbi8vIENhbGxiYWNrcyB0byBiZSBjYWxsZWQgdXAgd2hlbiBleGlzdGluZyBhIHNjcmVlbiwgdW5sZXNzIHByZXNlcnZlQ29udGVudCBpcyB0cnVlXG52YXIgc2NyZWVuQ2xlYW51cCA9IFtdO1xuXG4vLyB0cmFja3MgbnVtYmVyIG9mIHJvdXRlIGNhbGxzLCBmb3IgdGVzdGluZyBwdXJwb3Nlc1xudmFyIHJvdXRlQ2FsbHMgPSAwO1xuXG4vKlxuICogUmVnaXN0ZXIgYSBzY3JlZW4gaW4gdGhlIGFwcGxpY2F0aW9uLiBFYWNoIGFwcGxpY2F0aW9uIGlzIGdyb3VwZWQgaW50byAnc2NyZWVucycgb2YgY29udGVudCwgd2hlcmUgZWFjaCBzY3JlZW5cbiAqIHJlcGxhY2VzIHRoZSBtYWluIGNvbnRlbnQgb2YgdGhlIHBhZ2UgKG5vdCBpbmNsdWRpbmcgbmF2YmFyIGFuZCBvdGhlciBuYXZpZ2F0aW9uYWwgZWxlbWVudHMpLiBJbiBhZGRpdGlvbiB0byB0aGVcbiAqIGNvbnRlbnQsIGV2ZXJ5IHNjcmVlbiBoYXMgYSBwYXRoIGFzc29jaWF0ZWQgaXQsIHdoaWNoIGlzIHRyYWNrZWQgaW4gdGhlIFVSTCAoJyNwYXRoL3RvL3RoaW5nJykgYW5kIGFsbG93cyBmb3JcbiAqIGJvb2ttYXJrcyBhbmQgZm9yd2FyZCAvIGJhY2sgYnJvd3NlciBuYXZpZ2F0aW9uLiBUbyByZWdpc3RlciBhIHNjcmVlbiwgeW91IGNhbGwgdGhlIGZvbGxvd2luZyBmcm9tIGdsb2JhbCBjb250ZXh0XG4gKiBvciBhICQoKS5yZWFkeSgpIGhhbmRsZXI6XG4gKlxuICogICAgICBzY3JlZW4ucmVnaXN0ZXIoe1xuICogICAgICAgICAgcGF0aDogJ3BhdGgvdG8vc2NyZWVuJyxcbiAqICAgICAgICAgIGNvbnN0cnVjdG9yOiBNeVNjcmVlblxuICogICAgICB9KTtcbiAqXG4gKiBUaGlzIHdpbGwgYnVpbGQgYSAnTXlTY3JlZW4nIG9iamVjdCB3aGVuZXZlciB0aGUgdXNlciBuYXZpZ2F0ZXMgdG8gdGhhdCBnaXZlbiBwYXRoIChlaXRoZXIgZnJvbSBhIGJvb2ttYXJrLFxuICogZm9yd2FyZC9iYWNrLCBvciBwcm9ncmFtbWF0aWNhbGx5KS4gUGF0aHMgZm9sbG93IHRoZSBCYWNrYm9uZSByb3V0ZXIgbW9kZWw6XG4gKlxuICogICAgICAvcm91dGUvOnBhdGgvaXRlbTppZFxuICpcbiAqIEFueSBwYXJhbWV0ZXJzIHdpbGwgYmUgcHJvdmlkZWQgdG8gdGhlIG9uRW50ZXIoKSBjYWxsYmFjayBhcyBhcmd1bWVudHMgaW4gdGhlIG9yZGVyIHRoZXkgYXBwZWFyIGluIHRoZSBwYXRoLiBNb3JlXG4gKiBpbmZvcm1hdGlvbiBjYW4gYmUgZm91bmQgaW4gdGhlIGJhY2tib25lIHJvdXRlciBkb2N1bWVudGF0aW9uOlxuICpcbiAqICAgICAgaHR0cDovL2JhY2tib25lanMub3JnLyNSb3V0ZXJcbiAqXG4gKiBUaGUgc2NyZWVuIGluZnJhc3RydWN0dXJlIHdpbGwgYnVpbGQgdGhlIG9iamVjdCBhbmQgc2hvd2luZyB0aGUgY29udGVudCB3aXRoaW4gdGhlIFVJLiBCeSBkZWZhdWx0LCBpdCB3aWxsIGRlc3Ryb3lcbiAqIGFuZCByZWNyZWF0ZSB0aGUgb2JqZWN0IGVhY2ggdGltZSB0aGUgdXNlciBuYXZpZ2F0ZXMgdG8gdGhlIHNjcmVlbiAoYnV0IG5vdCB3aGVuIHRoZSB1c2VyIG5hdmlnYXRlcyB0byBhIHNjcmVlbiB3aXRoXG4gKiBhbHJlYWR5IHNob3dpbmcgdGhhdCBzYW1lIHNjcmVlbi4gaW4gdGhhdCBjYXNlIG5hdmlnYXRpbmcgaXMgYSBuby1vcCksIGJ1dCB0aGUgc2NyZWVuIGNhbiBhbHNvIGJlIHJlZ2lzdGVyZWQgd2l0aFxuICogJ3ByZXNlcnZlQ29udGVudDogdHJ1ZScgdG8gaGF2ZSB0aGUgY29udGVudCBzdGF0ZSBiZSBrZXB0IGFzLWlzIG9mZiBzY3JlZW4uIFRoaXMgc2hvdWxkIG9ubHkgYmUgdXNlZCBmb3IgY29tcGxleFxuICogc2NyZWVucyB3aGVyZSBtYWludGFpbmluZyBzdGF0ZSAoc2VsZWN0ZWQgb2JqZWN0cywgZXRjKSBwcm92aWRlcyBhbiBpbXByb3ZlZCB1c2VyIGV4cGVyaWVuY2UgdGhhdCBpcyB3b3J0aCB0aGVcbiAqIG1lbW9yeSBjb3N0LiBQcmVzZXJ2ZWQgY29udGVudCBpcyB0cmFja2VkIGJ5IHRoZSByZWdpc3RlcmVkIHBhdGggKC9wYXRoLzpmb28pIG5vdCB0aGUgYWN0dWFsIHBhdGggKC9wYXRoL2JhciksIHNvXG4gKiB0aGVyZSBjYW4gYmUgb25seSBvbmUgcHJlc2VydmVkIHN0YXRlIHdoZW4gdXNpbmcgc3Vic3RpdHV0aW9ucy4gU2NyZWVucyBtdXN0IGltcGxlbWVudCB0aGUgZm9sbG93aW5nIG1ldGhvZDpcbiAqXG4gKiAgICAgIGdldENvbnRlbnQoKSAgICAgICAgUmV0dXJuIGEgalF1ZXJ5IG9yIERPTSBvYmplY3QgdGhhdCBpcyB0aGUgcm9vdCBvZiB0aGUgc2NyZWVuIGNvbnRlbnQuIFRoaXMgaXMgd2hhdCBpc1xuICogICAgICAgICAgICAgICAgICAgICAgICAgIGRpc3BsYXllZCBpbiB0aGUgbWFpbiBjb250ZW50LlxuICpcbiAqIFRoZSBmb2xsb3dpbmcgbWV0aG9kcyBhcmUgb3B0aW9uYWw6XG4gKlxuICogICAgICBiZWZvcmVFbnRlcigpICAgICAgIEludm9rZWQgd2hlbiB0aGUgc2NyZWVuIGNvbnRlbnQgaXMgZ29pbmcgdG8gYmUgZGlzcGxheWVkLiBUaGlzIGlzIG5lZWRlZCBpZiBvbmUgbXVzdCBkb1xuICogICAgICAgICAgICAgICAgICAgICAgICAgIHNvbWUga2luZCBvZiBzZXR1cCBiZWZvcmUgZ2VuZXJhdGluZyB0aGUgY29udGVudC5cbiAqXG4gKiAgICAgIG9uRW50ZXIoKSAgICAgICAgICAgSW52b2tlZCB3aGVuIHRoZSBzY3JlZW4gY29udGVudCBpcyBkaXNwbGF5ZWQuIFRoaXMgaXMgcmVhbGx5IG9ubHkgdXNlZnVsIGZvciBzY3JlZW5zIHRoYXRcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICBhcmUgcmVnaXN0ZXJlZCB3aXRoICdwcmVzZXJ2ZUNvbnRlbnQnIHNldCwgYW5kIGNhbiBiZSB1c2VkIHRvIGtpY2sgb2ZmIGFzeW5jaHJvbm91c1xuICogICAgICAgICAgICAgICAgICAgICAgICAgIGFjdGl2aXR5IHNwZWNpZmljIHRvIHRoZSBzY3JlZW4uXG4gKlxuICogICAgICBvbkV4aXQoKSAgICAgICAgICAgIEludm9rZWQgd2hlbiB0aGUgc2NyZWVuIGNvbnRlbnQgaXMgcmVtb3ZlZC4gVGhpcyBjYW4gYmUgdXNlZCB0byBjYW5jZWwgYW55IGFzeW5jaHJvbm91c1xuICogICAgICAgICAgICAgICAgICAgICAgICAgIGFjdGl2aXR5LlxuICovXG5mdW5jdGlvbiByZWdpc3RlcihvcHRpb25zKSB7XG4gICAgaWYgKCFkZWxwaGl4Um91dGVyKSB7XG4gICAgICAgIHF1ZXVlZENhbGxzLnB1c2gob3B0aW9ucyk7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBkZWxwaGl4Um91dGVyLnJvdXRlKG9wdGlvbnMucGF0aCwgb3B0aW9ucy5wYXRoLCBmdW5jdGlvbigpIHtcbiAgICAgICAgcm91dGVDYWxscysrO1xuXG4gICAgICAgIHZhciBodG1sQ29udGVudCA9ICQoJyNodG1sQ29udGVudCcpO1xuXG4gICAgICAgIC8vIE5hdmlnYXRlIGF3YXkgZnJvbSB0aGUgY3VycmVudCBzY3JlZW5cbiAgICAgICAgaWYgKGN1cnJlbnRTY3JlZW4pIHtcbiAgICAgICAgICAgIC8vIEludm9rZSBvbkV4aXQgaWYgc3VwcG9ydGVkIGJ5IHRoZSBjdXJyZW50IHNjcmVlblxuICAgICAgICAgICAgaWYgKGN1cnJlbnRTY3JlZW4ub25FeGl0KSB7XG4gICAgICAgICAgICAgICAgY3VycmVudFNjcmVlbi5vbkV4aXQoKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGN1cnJlbnRTY3JlZW5PcHRpb25zLnByZXNlcnZlQ29udGVudCkge1xuICAgICAgICAgICAgICAgIC8vIFByZXNlcnZlIHRoZSBjdXJyZW50IGNvbnRlbnQgaWYgcmVxdWVzdGVkXG4gICAgICAgICAgICAgICAgc2F2ZWRTY3JlZW5zW2N1cnJlbnRTY3JlZW5PcHRpb25zLnBhdGhdID0gY3VycmVudFNjcmVlbjtcbiAgICAgICAgICAgICAgICBjdXJyZW50U2NyZWVuLmdldENvbnRlbnQoKS5kZXRhY2goKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gT3RoZXJ3aXNlIGRpc2NhcmQgY3VycmVudCBjb250ZW50XG4gICAgICAgICAgICAgICAgY3VycmVudFNjcmVlbi5nZXRDb250ZW50KCkucmVtb3ZlKCk7XG4gICAgICAgICAgICAgICAgdmFyIHRvQmVDYWxsZWQgPSBfLmNsb25lKHNjcmVlbkNsZWFudXApO1xuICAgICAgICAgICAgICAgIHNjcmVlbkNsZWFudXAgPSBbXTtcbiAgICAgICAgICAgICAgICBfLmVhY2godG9CZUNhbGxlZCwgZnVuY3Rpb24oY2FsbGJhY2spIHtcbiAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2soKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFJlLXVzZSBwcmVzZXJ2ZWQgY29udGVudCBpZiByZXF1ZXN0ZWRcbiAgICAgICAgaWYgKHNhdmVkU2NyZWVuc1tvcHRpb25zLnBhdGhdKSB7XG4gICAgICAgICAgICBjdXJyZW50U2NyZWVuID0gc2F2ZWRTY3JlZW5zW29wdGlvbnMucGF0aF07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjdXJyZW50U2NyZWVuID0gbmV3IG9wdGlvbnMuY29uc3RydWN0b3IoKTtcbiAgICAgICAgfVxuICAgICAgICBjdXJyZW50U2NyZWVuT3B0aW9ucyA9IG9wdGlvbnM7XG5cbiAgICAgICAgLy8gSGlkZSBhbnkgbW9kYWwgZGlhbG9nIHRoYXQgbWlnaHQgYmUgcHJlc2VudFxuICAgICAgICBkeE1vZGFsLmhpZGUoKTtcblxuICAgICAgICAvLyBJbnZva2UgYmVmb3JlRW50ZXIoKSBpZiBwcm92aWRlZFxuICAgICAgICBpZiAoY3VycmVudFNjcmVlbi5iZWZvcmVFbnRlcikge1xuICAgICAgICAgICAgY3VycmVudFNjcmVlbi5iZWZvcmVFbnRlci5hcHBseShjdXJyZW50U2NyZWVuLCBhcmd1bWVudHMpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gVXBkYXRlIHRoZSBjdXJyZW50Um91dGUgb2JzZXJ2YWJsZVxuICAgICAgICBtb2R1bGUuZXhwb3J0cy5jdXJyZW50Um91dGUob3B0aW9ucy5wYXRoKTtcblxuICAgICAgICAvLyBBdHRhY2ggdGhlIGNvbnRlbnRcbiAgICAgICAgaHRtbENvbnRlbnQuYXBwZW5kKGN1cnJlbnRTY3JlZW4uZ2V0Q29udGVudCgpKTtcbiAgICAgICAgaWYgKCFvcHRpb25zLnN0YXJ0V2l0aENvbnRlbnRIaWRkZW4pIHtcbiAgICAgICAgICAgIGh0bWxDb250ZW50LnNob3coKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEludm9rZSBvbkVudGVyKCkgaWYgcHJvdmlkZWRcbiAgICAgICAgaWYgKGN1cnJlbnRTY3JlZW4ub25FbnRlcikge1xuICAgICAgICAgICAgY3VycmVudFNjcmVlbi5vbkVudGVyLmFwcGx5KGN1cnJlbnRTY3JlZW4sIGFyZ3VtZW50cyk7XG4gICAgICAgIH1cbiAgICB9KTtcblxufVxuXG4vKlxuICogQWN0aXZlbHkgY2hhbmdlIHRoZSBzY3JlZW4gdG8gdGhlIGdpdmVuIHBhdGgsIGludm9raW5nIHRoZSBvbkVudGVyKCkvb25FeGl0KCkgY2FsbGJhY2tzIGluIHRoZSBwcm9jZXNzLlxuICovXG5mdW5jdGlvbiBuYXZpZ2F0ZShwYXRoLCBza2lwSGlzdG9yeSkge1xuICAgIGRlbHBoaXhSb3V0ZXIubmF2aWdhdGUocGF0aCwgeyB0cmlnZ2VyOiB0cnVlLCByZXBsYWNlOiBza2lwSGlzdG9yeSB9KTtcbn1cblxuLypcbiAqXG4gKi9cbmZ1bmN0aW9uIGludGVybmFsRGVlcExpbmtOYXZpZ2F0ZShwYXRoLCBza2lwSGlzdG9yeSwgZGV0YWlscykge1xuICAgIGlmICghXy5pc09iamVjdChkZXRhaWxzKSkge1xuICAgICAgICBkeFV0aWwuZmFpbCgnTXVzdCBwYXNzIGEgZGV0YWlscyBvYmplY3Qgd2hlbiBkb2luZyBkZWVwIGxpbmtpbmcuJyk7XG4gICAgfVxuXG4gICAgbmF2aWdhdGUocGF0aCwgc2tpcEhpc3RvcnkpO1xuXG4gICAgLy8gZG9lcyB0aGUgZGVzdGluYXRpb24gcGFnZSBzdXBwb3J0IGRlZXAgbGlua2luZz9cbiAgICBpZiAoIWN1cnJlbnRTY3JlZW4uZG9EZWVwTGluaykge1xuICAgICAgICBkeFV0aWwuZmFpbCgnQXR0ZW1wdCB0byBkZWVwIGxpbmsgdG8gYSBwYWdlIHdoaWNoIGRvZXNuXFwndCBzdXBwb3J0IHRoaXMuJyk7XG4gICAgfVxuXG4gICAgY3VycmVudFNjcmVlbi5kb0RlZXBMaW5rKGRldGFpbHMpO1xufVxuXG4vKlxuICogVXBkYXRlIHRoZSBVUkwgZm9yIHRoZSBwYWdlLCB3aXRob3V0IGRvaW5nIGEgbmF2aWdhdGlvblxuICovXG5mdW5jdGlvbiB1cGRhdGVXaXRob3V0TmF2aWdhdGlvbihwYXRoLCBza2lwSGlzdG9yeSkge1xuICAgIGRlbHBoaXhSb3V0ZXIubmF2aWdhdGUocGF0aCwgeyB0cmlnZ2VyOiBmYWxzZSwgcmVwbGFjZTogc2tpcEhpc3RvcnkgfSk7XG59XG5cbi8qXG4gKiBOYXZpZ2F0ZSB0byBhbiBleHRlcm5hbCB1cmwuIFRoaXMgd2lsbCBsZWF2ZSB0aGUgY3VycmVudCBodG1sIGZpbGUgZW50aXJlbHkuIFRoaXMgZXhwZWN0cyB0byByZWNlaXZlIHRoZSBmdWxsXG4gKiBwYXRobmFtZSBhbmQgaGFzaCBwb3J0aW9uIG9mIHRoZSB1cmwuIFRoYXQgaXMsIGl0IGlzIHNvbWV0aGluZyBsaWtlIC9teWFwcC8jbGlicmFyeS5cbiAqL1xuZnVuY3Rpb24gbmF2aWdhdGVFeHRlcm5hbCh1cmwpIHtcbiAgICB3aW5kb3cubG9jYXRpb24uaHJlZiA9IGR4VXRpbC5nZXRXaW5kb3dVUkxPcmlnaW4oKSArIHVybDtcbn1cblxuLypcbiAqIEhpZGUgdGhlIGN1cnJlbnQgZnVsbCBzY3JlZW4gY29udGVudCwgZXhwb3NpbmcgdGhlIGZsZXggYXBwbGljYXRpb24gdW5kZXJuZWF0aC4gSXQgd2lsbCBhbHNvIGNhbGwgb25FeGl0IG9mIHRoZVxuICogY3VycmVudGx5IHZpc2libGUgSlMgc2NyZWVuLiBUaGlzIGlzIGNhbGxlZCBmcm9tIHRoZSBmbGV4L2h0bWwgaHlicmlkIGNvZGUgd2hlbiBzd2l0Y2hpbmcgdG8gYSBmbGV4IHNjcmVlbiwgc29cbiAqIHRoYXQgZXZlcnkgcm91dGUgbmVlZCBub3QgZG8gdGhpcyBpbiBhbiBvbkV4aXQgaGFuZGxlci5cbiAqIFRoaXMgd2lsbCBoYXZlIG5vIGVmZmVjdCBpZiB0aGUgc2NyZWVuIGNvbnRlbnQgaXMgY3VycmVudGx5IGhpZGRlbi5cbiAqL1xuZnVuY3Rpb24gaGlkZSgpIHtcbiAgICB2YXIgaHRtbENvbnRlbnQgPSAkKCcjaHRtbENvbnRlbnQnKTtcblxuICAgIC8vIENoZWNrIHRoYXQgdGhlIGh0bWwgY29udGVudCBpcyBhY3R1YWxseSB2aXNpYmxlIGluIGNhc2UgaXQgd2FzIGhpZGRlbiBieSBzb21lIG90aGVyIHNvdXJjZS5cbiAgICBpZiAoaHRtbENvbnRlbnQuaXMoJzp2aXNpYmxlJykgJiYgY3VycmVudFNjcmVlbiAmJiBjdXJyZW50U2NyZWVuLm9uRXhpdCkge1xuICAgICAgICBjdXJyZW50U2NyZWVuLm9uRXhpdCgpO1xuICAgICAgICBjdXJyZW50U2NyZWVuID0gbnVsbDtcbiAgICB9XG5cbiAgICBodG1sQ29udGVudC5oaWRlKCk7XG59XG5cbi8qXG4gKiBUaGlzIHNwZWNpYWwgZnVuY3Rpb24gaXMgY2FsbGVkIGRpcmVjdGx5IGZyb20gdGhlICQoKS5yZWFkeSgpIGhhbmRsZXIgaW4gdGhlIG1haW4gaW5kZXguaHRtbCBmaWxlLiBUaGlzIGVuc3VyZXMgdGhhdFxuICogaXQgaXMgY2FsbGVkIGFmdGVyIGFueSBzY3JlZW4ucmVnaXN0ZXIoKSBjYWxscyBpbnZva2VkIGZyb20gb3RoZXIgcmVhZHkgaGFuZGxlcnMsIGFuZCBpdCdzIHNhZmUgdG9cbiAqIGNhbGwgaGlzdG9yeS5zdGFydCgpIGFuZCByZWRpcmVjdCB0byBhbnkgcm91dGVzIGJhc2VkIG9uIGhhc2hjaGFuZ2UgZXZlbnRzLlxuICovXG5mdW5jdGlvbiBzdGFydCgpIHtcbiAgICBkZWxwaGl4Um91dGVyID0gbmV3IERlbHBoaXhSb3V0ZXIoKTtcblxuICAgIC8qXG4gICAgICogUmVnaXN0ZXIgYSBkZWZhdWx0IHJvdXRlIHRoYXQgaWdub3JlcyB1bmtub3duIHJvdXRlcyAoaWYgYSB1c2VyIG1hbnVhbGx5IHR5cGVzIGEgcGF0aCwgZm9yIGV4YW1wbGUpLiBOb3RlIHRoYXRcbiAgICAgKiB0aGlzIG1heSBhbHNvIGJlIGEgbGVnaXRpbWF0ZSB2aWV3IGluIHRoZSBGbGV4IGFwcGxpY2F0aW9uLCBzbyB3ZSBtYWtlIHN1cmUgdG8gaGlkZSB0aGUgaHRtbCBjb250ZW50LlxuICAgICAqL1xuICAgIGRlbHBoaXhSb3V0ZXIucm91dGUoJypwYXRoJywgJypwYXRoJywgZnVuY3Rpb24oKSB7XG4gICAgICAgIHJvdXRlQ2FsbHMrKztcbiAgICAgICAgbW9kdWxlLmV4cG9ydHMuaGlkZSgpO1xuICAgIH0pO1xuXG4gICAgXy5lYWNoKHF1ZXVlZENhbGxzLCByZWdpc3Rlcik7XG5cbiAgICBCYWNrYm9uZS5oaXN0b3J5LnN0YXJ0KCk7XG4gICAgcm91dGVyU3RhcnRlZCA9IHRydWU7XG59XG5cbi8qXG4gKiBBZGRzIGEgZnVuY3Rpb24gdGhhdCB3aWxsIGJlIGNhbGxlZCB3aGVuIHRoZSBjdXJyZW50IHNjcmVlbiBleGl0cy4gVGhpcyBpcyBpbnRlbmRlZCB0byBhbGxvdyBjb2RlIHRvIGRvIGFueSBjbGVhbnVwXG4gKiB0aGF0IGlzIG5lZWRlZC4gTm90ZSB0aGF0IGNsZWFudXAgd2lsbCBtYWtlIGEgY29weSBvZiB0aGUgaXRlbXMgdG8gYmUgY2xlYW5lZCwgYmVmb3JlIHN0YXJ0aW5nIHRoZSBjbGVhbnVwIGN5Y2xlLlxuICogVGhpcyBtZWFucyB0aGF0IGlmIHlvdSBoYXZlIHJlZ2lzdGVyZWQgYSBjbGVhbnVwIHJvdXRpbmUsIGFuZCBkaXNjb3ZlciBhdCBjbGVhbnVwIHRpbWUgdGhhdCB5b3UgY2FuJ3QgY2xlYW51cCBub3csXG4gKiB5b3UgY2FuIHJlY2FsbCB0aGlzIHJvdXRpbmUgdG8gcmUtcmVnaXN0ZXIgeW91cnNlbGYgd2l0aG91dCBwcm9ibGVtcy4gIFRoaXMgaXNuJ3QgZW5jb3VyYWdlZCwgYnV0IGl0IGlzIHNvbWV0aW1lc1xuICogbmVlZGVkLlxuICovXG5mdW5jdGlvbiByZWdpc3RlckNsZWFudXBDYWxsYmFjayhjYWxsYmFjaykge1xuICAgIGlmICghXy5pc0Z1bmN0aW9uKGNhbGxiYWNrKSkge1xuICAgICAgICBkeFV0aWwuZmFpbCgnTXVzdCBwYXNzIGEgZnVuY3Rpb24gdG8gY2xlYW51cE9uUGFnZUV4aXQoKScpO1xuICAgIH1cblxuICAgIHNjcmVlbkNsZWFudXAucHVzaChjYWxsYmFjayk7XG59XG5cbi8qXG4gKiBVcGRhdGVzIGEgcXVlcnkgcGFyYW1ldGVyIGluIHRoZSBoYXNoLXBvcnRpb24gb2YgdGhlIHVybCwgY2F1c2luZyBhIG5ldyBuYXZpZ2F0aW9uIHRvIGhhcHBlbi5cbiAqXG4gKiBUaGF0IGlzLCBpZiB0aGUgY3VycmVudCBwYWdlIGlzOlxuICogICAgaHR0cDovL3d3dy5leGFtcGxlLmNvbS8jZXhpdGluZy1yb3V0ZVxuICogYW5kIHdlIGNhbGwgdXBkYXRlUGFyYW0oJ2xldmVsJywgJ2hpZ2gnKSwgdGhlbiB0aGUgdXNlciB3aWxsIGJlIG5hdmlnYXRlZCB0bzpcbiAqICAgIGh0dHA6Ly93d3cuZXhhbXBsZS5jb20vI2V4aXRpbmctcm91dGU/bGV2ZWw9aGlnaFxuICogU2ltaWxhcmx5IGlmIHRoZSBjdXJyZW50IHBhZ2UgaXM6XG4gKiAgICBodHRwOi8vd3d3LmV4YW1wbGUuY29tLyNleGl0aW5nLXJvdXRlP2Z1bj1uZWNlc3NhcnkmbGV2ZWw9aGlnaCZ1cmxzPWZ1blxuICogYW5kIHdlIGNhbGwgdXBkYXRlUGFyYW0oJ2xldmVsJywgJ2V4cG9uZW50aWFsJyksIHRoZW4gdGhlIHVzZXIgd2lsbCBiZSBuYXZpZ2F0ZWQgdG86XG4gKiAgICBodHRwOi8vd3d3LmV4YW1wbGUuY29tLyNleGl0aW5nLXJvdXRlP2Z1bj1uZWNlc3NhcnkmbGV2ZWw9ZXhwb25lbnRpYWwmdXJscz1mdW5cbiAqICh0aGVzZSBuYXZpZ2F0aW9ucyBhcmUgbm90IHJlY29yZGVkIG9uIHRoZSBiYWNrLWhpc3RvcnkpXG4gKlxuICogQm90aCBuYW1lIGFuZCB2YWx1ZSBtdXN0IGJlIHN0cmluZ3MsIGFuZCBib3RoIHdpbGwgYmUgZXNjYXBlZCBpbiBjYXNlIHRoZXkgY29udGFpbiB1cmwtdW5zYWZlIGNoYXJhY3RlcnMuXG4gKi9cbmZ1bmN0aW9uIHVwZGF0ZVBhcmFtKG5hbWUsIHZhbHVlKSB7XG4gICAgaWYgKCFfLmlzU3RyaW5nKG5hbWUpKSB7XG4gICAgICAgIGR4VXRpbC5mYWlsKCdNdXN0IHNwZWNpZnkgYSBzdHJpbmcgZm9yIG5hbWUgdG8gdXBkYXRlUGFyYW0oKScpO1xuICAgIH1cblxuICAgIGlmICghXy5pc1N0cmluZyh2YWx1ZSkpIHtcbiAgICAgICAgZHhVdGlsLmZhaWwoJ011c3Qgc3BlY2lmeSBhIHN0cmluZyBmb3IgdmFsdWUgdG8gdXBkYXRlUGFyYW0oKScpO1xuICAgIH1cblxuICAgIHZhciBuZXdQYXJhbXM7XG4gICAgdmFyIGZvdW5kO1xuICAgIHZhciBuZXdQYWlyO1xuXG4gICAgdmFyIGN1cnJlbnRIYXNoID0gZHhCcm93c2VyLmdldFdpbmRvd0xvY2F0aW9uKCkuaGFzaDtcbiAgICB2YXIgcGFyYW1zTG9jID0gY3VycmVudEhhc2guaW5kZXhPZignPycpO1xuICAgIHZhciBiZWZvcmVQYXJhbXMgPSBjdXJyZW50SGFzaDtcbiAgICB2YXIgcGFyYW1zID0gJyc7XG5cbiAgICBuYW1lID0gZW5jb2RlVVJJQ29tcG9uZW50KG5hbWUpO1xuICAgIG5ld1BhaXIgPSBuYW1lICsgJz0nICsgZW5jb2RlVVJJQ29tcG9uZW50KHZhbHVlKTtcblxuICAgIGlmIChwYXJhbXNMb2MgIT09IC0xKSB7XG4gICAgICAgIGJlZm9yZVBhcmFtcyA9IGN1cnJlbnRIYXNoLnN1YnN0cigwLCBwYXJhbXNMb2MpO1xuICAgICAgICBwYXJhbXMgPSBjdXJyZW50SGFzaC5zdWJzdHJpbmcocGFyYW1zTG9jICsgMSk7XG4gICAgfVxuXG4gICAgdmFyIHBhaXJzID0gcGFyYW1zLnNwbGl0KCcmJyk7XG5cbiAgICBpZiAocGFpcnMubGVuZ3RoID09PSAxICYmIHBhaXJzWzBdID09PSAnJykge1xuICAgICAgICBwYWlycyA9IFtdO1xuICAgIH1cblxuICAgIF8uZWFjaChwYWlycywgZnVuY3Rpb24ocGFpciwgaW5kZXgpIHtcbiAgICAgICAgaWYgKHBhaXIuc3Vic3RyaW5nKDAsIG5hbWUubGVuZ3RoICsgMSkgPT09IChuYW1lICsgJz0nKSkge1xuICAgICAgICAgICAgcGFpcnNbaW5kZXhdID0gbmV3UGFpcjtcbiAgICAgICAgICAgIGZvdW5kID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH0pO1xuXG4gICAgaWYgKCFmb3VuZCkge1xuICAgICAgICBwYWlycy5wdXNoKG5ld1BhaXIpO1xuICAgIH1cblxuICAgIG5ld1BhcmFtcyA9IHBhaXJzLmpvaW4oJyYnKTtcblxuICAgIG1vZHVsZS5leHBvcnRzLnVwZGF0ZVdpdGhvdXROYXZpZ2F0aW9uKGJlZm9yZVBhcmFtcyArICc/JyArIG5ld1BhcmFtcyk7XG59XG5cbi8qXG4gKiBJbnRlcm5hbCBmdW5jdGlvbiBmb3IgdGVzdGluZywgd2hpY2ggY2xlYXJzIGFueSBleGlzdGluZyBzdGF0ZS4gVGhlcmUgaXMgbm8gc3VwcG9ydGVkIHdheSB0byBjbGVhciBleGlzdGluZ1xuICogcm91dGUgaGFuZGxlcnMuIFdlIGNvdWxkIHJlYWNoIGludG8gdGhlIEhpc3Rvcnkgb2JqZWN0IGFuZCBjbGVhciB0aGUgaGFuZGxlcnMgYXJyYXksIGJ1dCBzaW5jZSBuZXcgcm91dGVzIHRha2VcbiAqIHByZWZlcmVuY2Ugb3ZlciBvbGQgb25lcywgd2UgbGVhdmUgaXQgYWNyb3NzIGVhY2ggY2xlYXIoKSBpbnZvY2F0aW9uLlxuICovXG5mdW5jdGlvbiBfY2xlYXIoKSB7XG4gICAgaWYgKHJvdXRlclN0YXJ0ZWQpIHtcbiAgICAgICAgQmFja2JvbmUuaGlzdG9yeS5zdG9wKCk7XG4gICAgfVxuICAgIGN1cnJlbnRTY3JlZW4gPSB1bmRlZmluZWQ7XG4gICAgc2F2ZWRTY3JlZW5zID0ge307XG4gICAgc2NyZWVuQ2xlYW51cCA9IFtdO1xuICAgIHJvdXRlclN0YXJ0ZWQgPSBmYWxzZTtcbiAgICByb3V0ZUNhbGxzID0gMDtcbiAgICBxdWV1ZWRDYWxscyA9IFtdO1xuICAgIGRlbHBoaXhSb3V0ZXIgPSB1bmRlZmluZWQ7XG4gICAgbW9kdWxlLmV4cG9ydHMuY3VycmVudFJvdXRlKCcnKTtcbn1cblxuLypcbiAqIEFjY2VzcyB0byBpbnRlcm5hbCBzdGF0ZSBmb3IgdGVzdGluZyBwdXJwb3Nlcy5cbiAqL1xuZnVuY3Rpb24gX2dldFJvdXRlQ2FsbHMoKSB7XG4gICAgcmV0dXJuIHJvdXRlQ2FsbHM7XG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICAgIC8vIEV4cG9zZSBhbiBvYnNlcnZhYmxlIHdpdGggdGhlIGN1cnJlbnQgcm91dGVcbiAgICBjdXJyZW50Um91dGU6IGtvLm9ic2VydmFibGUoJycpLFxuICAgIHJlZ2lzdGVyOiByZWdpc3RlcixcbiAgICBuYXZpZ2F0ZTogbmF2aWdhdGUsXG4gICAgaW50ZXJuYWxEZWVwTGlua05hdmlnYXRlOiBpbnRlcm5hbERlZXBMaW5rTmF2aWdhdGUsXG4gICAgdXBkYXRlV2l0aG91dE5hdmlnYXRpb246IHVwZGF0ZVdpdGhvdXROYXZpZ2F0aW9uLFxuICAgIG5hdmlnYXRlRXh0ZXJuYWw6IG5hdmlnYXRlRXh0ZXJuYWwsXG4gICAgaGlkZTogaGlkZSxcbiAgICBzdGFydDogc3RhcnQsXG4gICAgcmVnaXN0ZXJDbGVhbnVwQ2FsbGJhY2s6IHJlZ2lzdGVyQ2xlYW51cENhbGxiYWNrLFxuICAgIHVwZGF0ZVBhcmFtOiB1cGRhdGVQYXJhbSxcbiAgICBfY2xlYXI6IF9jbGVhcixcbiAgICBfZ2V0Um91dGVDYWxsczogX2dldFJvdXRlQ2FsbHNcbn07XG4iLCIvKlxuICogQ29weXJpZ2h0IChjKSAyMDEzLCAyMDE1IGJ5IERlbHBoaXguIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKi9cblxuLyogZ2xvYmFsICQgKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCBkeFdpbmRvdyA9IHJlcXVpcmUoJ2R4Y29yZS9qcy93aW5kb3cuanMnKSxcbiAgICBkeERhdGEgPSByZXF1aXJlKCdkeGNvcmUvZGF0YS9qcy9pbmRleC5qcycpLFxuICAgIGR4Q29uc3RhbnRzID0gcmVxdWlyZSgnZHhjb3JlL2pzL2NvbnN0YW50cy5qcycpLFxuICAgIGR4QnJvd3NlciA9IHJlcXVpcmUoJ2R4Y29yZS9qcy9icm93c2VyLmpzJyksXG4gICAgZHhVdGlsID0gcmVxdWlyZSgnZHhjb3JlL2pzL3V0aWwuanMnKSxcbiAgICBkeExvY2FsZSA9IHJlcXVpcmUoJ2R4Y29yZS9qcy9sb2NhbGUuanMnKTtcblxuLypcbiAqIFRoaXMgcHJvdmlkZXMgdmFyaW91cyBzZXNzaW9uLXJlbGF0ZWQgdXRpbGl0eSByb3V0aW5lcy5cbiAqICAgIGNoZWNrU2Vzc2lvbklzQXV0aGVudGljYXRlZE9yRW5kKClcbiAqICAgICAgIFN0YXJ0cyBhIHByb2Nlc3Mgd2hlcmUgdGhpcyB3aWxsIGF0dGVtcHQgdG8gcmVwZWF0ZWRseSBnZXQgYSBzZXNzaW9uIGZyb20gdGhlIERlbHBoaXggZW5naW5lLiAgVGhpcyBpcyB1c2VmdWxcbiAqICAgICAgIGluIGNhc2Ugb2YgdHJhbnNpZW50IG5ldHdvcmsgcHJvYmxlbXMuIFNwZWNpZmljYWxseSwgdGhpcyB3aWxsOlxuICogICAgICAgICAgMSkgIFJlcGVhdGVkbHkgYXNrIHRoZSBEZWxwaGl4IEVuZ2luZSB0byBjcmVhdGUgYSBzZXNzaW9uIChvciByZXR1cm4gdGhlIGN1cnJlbnQgaWYgdGhlcmUgaXMgYWxyZWFkeSBvbmUpXG4gKiAgICAgICAgICAgICAgKikgSWYsIGFmdGVyIDUgc2Vjb25kcywgd2UgZG9uJ3QgZ2V0IGEgc2Vzc2lvbiwgZGlzcGxheSBhbiBhbGVydCBpbnZpdGluZyB0aGUgdXNlciB0byBsb2cgb2ZmLCBidXQga2VlcFxuICogICAgICAgICAgICAgICAgIHRyeWluZyB0byBnZXQgYSBzZXNzaW9uIHdoaWxlIHRoZSB1c2VyIHRoaW5rcyBhYm91dCB0aGlzLlxuICogICAgICAgICAgMikgIElmIHdlIGRvIGdldCBhIHNlc3Npb24sIHRoZW4gdHJ5IHRvIGdldCB0aGUgY3VycmVudCB1c2Vycywgd2hpY2ggaXMgYW5vdGhlciB3YXkgb2Ygc2F5aW5nOiBpcyB0aGlzIGFuXG4gKiAgICAgICAgICAgICAgYXV0aGVudGljYXRlZCBzZXNzaW9uPyAgSWYgd2UgZ2V0IGEgY3VycmVudCB1c2VyLCB0aGVuIHdlIGhhdmUgYW4gYXV0aGVudGljYXRlZCBzZXNzaW9uLCBhbGwgaXMgZ29vZC5cbiAqICAgICAgICAgICAgICBIb3dldmVyLCBpZiB3ZSBkbyBub3QgZ2V0IGEgdXNlciwgdGhlbiBsb2cgb3V0LlxuICpcbiAqICAgIGVuZFNlc3Npb24oKVxuICogICAgICAgRW5kcyB0aGUgY3VycmVudCBzZXNzaW9uLCBpZiBhbnkuXG4gKi9cbnZhciBDSEVDS0lOR19USU1FT1VUID0gMjUwMDtcbnZhciBUSU1FU19UT19DSEVDS19CRUZPUkVfQUxFUlQgPSAyO1xudmFyIGFscmVhZHlDaGVja2luZyA9IGZhbHNlO1xudmFyIGFsZXJ0V2luZG93O1xudmFyIHNodXR0aW5nRG93biA9IGZhbHNlO1xuXG5mdW5jdGlvbiBzaG93QWxlcnQoKSB7XG4gICAgYWxlcnRXaW5kb3cgPSBkeFdpbmRvdy5jb25uZWN0aXZpdHlFcnJvckFsZXJ0KHtcbiAgICAgICAgbG9nb3V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIGVuZFNlc3Npb25Mb2NhbGx5KCk7XG4gICAgICAgICAgICBhbGVydFdpbmRvdyA9IHVuZGVmaW5lZDtcbiAgICAgICAgfSxcbiAgICAgICAgZW5kU2Vzc2lvbjogZW5kU2Vzc2lvblxuICAgIH0pO1xufVxuXG5mdW5jdGlvbiBjbG9zZUFsZXJ0KCkge1xuICAgIGlmIChhbGVydFdpbmRvdykge1xuICAgICAgICBkeFdpbmRvdy5fY2xvc2UuYXBwbHkoYWxlcnRXaW5kb3cpO1xuICAgIH1cbiAgICBhbGVydFdpbmRvdyA9IHVuZGVmaW5lZDtcbn1cblxuLypcbiAqIFJlcGVhdGVkbHkgdHJ5IHRvIGdldCBhIHNlc3Npb24gZnJvbSB0aGUgc2VydmVyIHVudGlsIHdlIHN1Y2NlZWQgb3IgdGhlIHVzZXIgY2hvb3NlcyB0byBsb2cgb2ZmLiAgSWYgd2UgZmFpbCB0byBnZXRcbiAqIGEgc2Vzc2lvbiBhZnRlciBhIGNvdXBsZSB0cmllcywgcHV0IHVwIGFuIGFsZXJ0IGZvciB0aGUgdXNlciB0byBsZXQgdGhlbSBrbm93IHdoYXQgaXMgZ29pbmcgb24uXG4gKi9cbmZ1bmN0aW9uIGtlZXBDaGVja2luZ0ZvckF1dGhTZXNzaW9uKHRpbWVzVW50aWxBbGVydCwgc3VjY2VzcywgZmFpbHVyZSkge1xuICAgIHZhciBjcmVhdGVTZXNzaW9uUGF5bG9hZCA9IGR4RGF0YS5uZXdDbGllbnRNb2RlbCgnQVBJU2Vzc2lvbicpO1xuICAgIGNyZWF0ZVNlc3Npb25QYXlsb2FkLnNldCh7XG4gICAgICAgIHZlcnNpb246IHtcbiAgICAgICAgICAgIG1ham9yOiBkeENvbnN0YW50cy5WRVJTSU9OX01BSk9SLFxuICAgICAgICAgICAgbWlub3I6IGR4Q29uc3RhbnRzLlZFUlNJT05fTUlOT1IsXG4gICAgICAgICAgICBtaWNybzogZHhDb25zdGFudHMuVkVSU0lPTl9NSUNST1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgaWYgKHNodXR0aW5nRG93bikge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKHRpbWVzVW50aWxBbGVydCA9PT0gMCkge1xuICAgICAgICBzaG93QWxlcnQoKTtcbiAgICB9XG5cbiAgICBkeERhdGEucm9vdE9wcy5BUElTZXNzaW9uLiQkY3JlYXRlKGNyZWF0ZVNlc3Npb25QYXlsb2FkLCB7XG4gICAgICAgIHN1Y2Nlc3M6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgY2xvc2VBbGVydCgpO1xuICAgICAgICAgICAgZHhEYXRhLnJvb3RPcHMuVXNlci4kY3VycmVudCh7XG4gICAgICAgICAgICAgICAgc3VjY2Vzczogc3VjY2VzcyxcbiAgICAgICAgICAgICAgICBlcnJvcjogZmFpbHVyZVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0sXG4gICAgICAgIGVycm9yOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAga2VlcENoZWNraW5nRm9yQXV0aFNlc3Npb24odGltZXNVbnRpbEFsZXJ0IC0gMSwgc3VjY2VzcywgZmFpbHVyZSk7XG4gICAgICAgICAgICB9LCBDSEVDS0lOR19USU1FT1VUKTtcbiAgICAgICAgfVxuICAgIH0pO1xufVxuXG5mdW5jdGlvbiBjbGVhckNoZWNraW5nRmxhZygpIHtcbiAgICBhbHJlYWR5Q2hlY2tpbmcgPSBmYWxzZTtcbn1cblxuZnVuY3Rpb24gY2hlY2tTZXNzaW9uSXNBdXRoZW50aWNhdGVkT3JFbmQoKSB7XG4gICAgaWYgKGFscmVhZHlDaGVja2luZykge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGFscmVhZHlDaGVja2luZyA9IHRydWU7XG4gICAga2VlcENoZWNraW5nRm9yQXV0aFNlc3Npb24oVElNRVNfVE9fQ0hFQ0tfQkVGT1JFX0FMRVJULCBjbGVhckNoZWNraW5nRmxhZyxcbiAgICAgICAgaW50ZXJuYWxFbmRTZXNzaW9uKTtcbn1cblxuZnVuY3Rpb24gaW50ZXJuYWxFbmRTZXNzaW9uKCkge1xuICAgIGNsb3NlQWxlcnQoKTtcbiAgICBlbmRTZXNzaW9uTG9jYWxseSgpO1xufVxuXG5mdW5jdGlvbiBlbmRTZXNzaW9uKCkge1xuICAgIGR4RGF0YS5yb290T3BzLmRlbHBoaXhfY29tbW9uLiRsb2dvdXQoe1xuICAgICAgICBzdWNjZXNzOiBlbmRTZXNzaW9uTG9jYWxseSxcbiAgICAgICAgZXJyb3I6IGVuZFNlc3Npb25Mb2NhbGx5XG4gICAgfSk7XG59XG5cbmZ1bmN0aW9uIGVuZFNlc3Npb25Mb2NhbGx5KCkge1xuICAgIHNodXR0aW5nRG93biA9IHRydWU7XG4gICAgZHhCcm93c2VyLmdldFdpbmRvd0xvY2F0aW9uKCkuaHJlZiA9IGR4VXRpbC5nZXRXaW5kb3dVUkxPcmlnaW4oKSArICcvbG9naW4vaW5kZXguaHRtbCc7XG59XG5cbmZ1bmN0aW9uIHJlc2V0Rm9yVGVzdGluZygpIHtcbiAgICBjbG9zZUFsZXJ0KCk7XG4gICAgc2h1dHRpbmdEb3duID0gZmFsc2U7XG4gICAgYWxyZWFkeUNoZWNraW5nID0gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIHJlbG9hZENsaWVudChyZWFzb24pIHtcbiAgICAvKiBlc2xpbnQtZGlzYWJsZSBuby1hbGVydCAqL1xuICAgIGlmICh3aW5kb3cuY29uZmlybShkeExvY2FsZS5nbHMoJ3JlbG9hZC4nICsgcmVhc29uKSkgPT09IHRydWUpIHtcbiAgICAgICAgZHhCcm93c2VyLmxvY2F0aW9uUmVsb2FkKCk7XG4gICAgfVxuICAgIC8qIGVzbGludC1lbmFibGUgbm8tYWxlcnQgKi9cbn1cblxuLypcbiAqIEEgR0VORVJBTCBOT1RFIEFCT1VUIE9VUiBIQU5ETElORyBPRiBBSkFYIEVSUk9SU1xuICpcbiAqIEF0IHRoaXMgdGltZSBvdXIgc3RhY2sgaGFzIHNldmVyYWwgbWFqb3Igc3lzdGVtcyB3aGljaCBtYWtlIGh0dHAgcmVxdWVzdHMgdGhyb3VnaCBqUXVlcnkncyBhamF4IHN5c3RlbSwgaW5jbHVkaW5nXG4gKiBvdXIgaTE4biBzeXN0ZW0sIEJhY2tib25lLCBhbmQgb2YgY291cnNlIHRoZSBhYm92ZSBhamF4Q2FsbCgpLiBUaGUgY2xpZW50cyBvZiB0aGVzZSBhcmUgcmVzcG9uc2libGUgZm9yIGhhbmRsaW5nXG4gKiBhbGwgdGhlaXIgb3duIEhUVFAgZXJyb3JzLlxuICpcbiAqIE91ciBzdGFuZGFyZCBnbG9iYWwgYWpheCBoYW5kbGVyIGdldHMgY2FsbGVkIGFueSB0aW1lIGpRdWVyeSByZXBvcnRzIGFuIGVycm9yICh3aGljaCBqUXVlcnkgY29uc2lkZXJzIHRvIGFueSBzdGF0dXNcbiAqIG90aGVyIHRoYW4gMjAwLTMwMCBvciAzMDQpLiAgQXQgdGhpcyBnbG9iYWwgbGV2ZWwsIHdlIG9ubHkgcmVzcG9uZCB0byB0aGluZ3Mgd2UgdGhpbmsgb2YgYXMgJ2NhdGFzdHJvcGhpYycuIFRoaXNcbiAqIGluY2x1ZGVzIHN0YXR1cyAwIGFuZCA0MDMuXG4gKlxuICogRm9yIHN0YXR1cyA0MDMsIHdlIHNpbXBseSBmb3JjZSB0aGUgVUkgdG8gbG9nIG91dC5cbiAqXG4gKiBTdGF0dXMgMCBpcyB3aGVuIGpRdWVyeSBjb3VsZG4ndCBnZXQgYSBwcm9wZXIgcmVzcG9uc2UgYW5kIHN0YXR1cyBmcm9tIHRoZSBzZXJ2ZXIgKHN1Y2ggYXMgaWYgdGhlIGVudGlyZSBuZXR3b3JrXG4gKiBoYXMgZ29uZSBkb3duLCBhbmQgdGhlIEhUVFAgcmVxdWVzdCBjb3VsZG4ndCBiZSBpbml0aWF0ZWQsIGV0Yy4gKG5vdGU6IFRoaW5ncyBhbHJlYWR5IGluIGZsaWdodCBoYXZlIGFcbiAqIGJyb3dzZXItZGVwZW5kZW50IHRpbWVvdXQsIHdoaWNoIGlzIGluZmluaXRlIGluIHRoZSBjYXNlIG9mIENocm9tZSkuIEluIHRoaXMgY2FzZSwgdGhpcyBjb3VsZCBiZSBhIHRyYW5zaWVudCBwcm9ibGVtXG4gKiB3aGljaCB3ZSByZWFsbHkgZG9uJ3QgY2FyZSBhYm91dCBhdCBhIGdsb2JhbCBsZXZlbCAoaW5kaXZpZHVhbCBjYWxsZXJzIHNob3VsZCBoYW5kbGUgdGhpcyBvbiB0aGVpciBvd24sIG9mIGNvdXJzZSkuXG4gKiBUbyBkaXN0aW5ndWlzaCB0aGUgdHJhbnNpZW50IGZyb20gdGhlIHBlcm1hbmVudCwgd2UgYXNrIHRoZSBzZXNzaW9uIHN5c3RlbSB0byBwb2xsIHRoZSBzZXJ2ZXIgcGVyaW9kaWNhbGx5IGFuZCB0cnlcbiAqIHRvIGdldCBhIHdvcmtpbmcgc2Vzc2lvbiBhZ2Fpbi4gSWYgdGhpcyBmYWlscywgaXQgd2lsbCBsb2cgdGhlIHVzZXIgb2ZmLlxuICovXG5mdW5jdGlvbiBkZWZhdWx0RGVscGhpeEVycm9ySGFuZGxlcihldmVudCwganF4aHIpIHtcbiAgICBzd2l0Y2ggKGpxeGhyLnN0YXR1cykge1xuICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICBtb2R1bGUuZXhwb3J0cy5jaGVja1Nlc3Npb25Jc0F1dGhlbnRpY2F0ZWRPckVuZCgpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgNDAzOlxuICAgICAgICAgICAgbW9kdWxlLmV4cG9ydHMuZW5kU2Vzc2lvbkxvY2FsbHkoKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgIH1cblxuICAgIC8vIGZpbHRlcmluZyBvdXQgSFRNTCB0YWdzXG4gICAgZHhVdGlsLmRlYnVnKCQudHJpbShkeFV0aWwuaXNOb25lKGpxeGhyLnJlc3BvbnNlVGV4dCkgPyAnJyA6IGpxeGhyLnJlc3BvbnNlVGV4dC5yZXBsYWNlKC8oPChbXj5dKyk+KS9pZywgJyAnKSkpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgICBjaGVja1Nlc3Npb25Jc0F1dGhlbnRpY2F0ZWRPckVuZDogY2hlY2tTZXNzaW9uSXNBdXRoZW50aWNhdGVkT3JFbmQsXG4gICAgZW5kU2Vzc2lvbkxvY2FsbHk6IGVuZFNlc3Npb25Mb2NhbGx5LFxuICAgIGVuZFNlc3Npb246IGVuZFNlc3Npb24sXG4gICAgX3Jlc2V0Rm9yVGVzdGluZzogcmVzZXRGb3JUZXN0aW5nLFxuICAgIGtlZXBDaGVja2luZ0ZvckF1dGhTZXNzaW9uOiBrZWVwQ2hlY2tpbmdGb3JBdXRoU2Vzc2lvbixcbiAgICBjbG9zZUFsZXJ0OiBjbG9zZUFsZXJ0LFxuICAgIHJlbG9hZENsaWVudDogcmVsb2FkQ2xpZW50LFxuICAgIGRlZmF1bHREZWxwaGl4RXJyb3JIYW5kbGVyOiBkZWZhdWx0RGVscGhpeEVycm9ySGFuZGxlclxufTtcbiIsIi8qXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTMsIDIwMTUgYnkgRGVscGhpeC4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqL1xuXG4vKiBnbG9iYWwgZHgsICQsIEhhbmRsZWJhcnMsIGtvICovXG5cbid1c2Ugc3RyaWN0JztcblxuLy8gX3RlbXBsYXRlcyBpcyBkZWxpYmVyYXRlbHkgZXhwb3NlZCB0aGlzIHdheS4gU2VlIGJlbG93LlxucmVxdWlyZSgnZHhjb3JlL2pzL2RlbHBoaXguanMnKS5uYW1lc3BhY2UoJ2R4LmNvcmUuX3RlbXBsYXRlcycpO1xuXG5jb25zdCBkeFV0aWwgPSByZXF1aXJlKCdkeGNvcmUvanMvdXRpbC5qcycpLFxuICAgIGR4TG9jYWxlID0gcmVxdWlyZSgnZHhjb3JlL2pzL2xvY2FsZS5qcycpO1xuXG4vKlxuICogUmV0dXJucyBhIGpRdWVyeSBvYmplY3QgZm9yIHRoZSBnaXZlbiB0ZW1wbGF0ZSwgb3B0aW9uYWxseSBib3VuZCB0byB0aGUgZ2l2ZW4ga25vY2tiYWNrIHZpZXdtb2RlbC4gVGhlIHZpZXdtb2RlbCBpc1xuICogYWxzbyBwYXNzZWQgdG8gdGhlIEhhbmRsZWJhcnMgdGVtcGxhdGluZyBlbmdpbmUsIHNvIHN0YXRpYyBzdHJpbmctYmFzZWQgdGVtcGxhdGluZyBjYW4gYWxzbyBiZSB1c2VkLiBLbm9ja2JhY2sgd2lsbFxuICogbm90IGRvIGFueXRoaW5nIGlmIHRoZXJlIGFyZSBubyBkYXRhLWJpbmQgYXR0cmlidXRlcyB0byBiZSBmb3VuZCwgc28gaXQgY2FuIGJlIHVzZWQgaW4gZWl0aGVyIGZhc2hpb24uXG4gKlxuICogVGVtcGxhdGVzIGFyZSBkZWxpdmVyZWQgd2l0aGluIHRoZSBIVE1MIHN0cnVjdHVyZSBhczpcbiAqXG4gKiAgLzxhcHA+L1ttb2R1bGUvXS90ZW1wbGF0ZS88cGF0aD4uaGpzXG4gKlxuICogVGhlc2UgdGVtcGxhdGVzIGFyZSByZWZlcnJlZCB0byBieSB0aGUgcGF0aCBtaW51cyB0aGUgJy5oanMnIGV4dGVuc2lvbi4gQXMgcGFydCBvZiB0aGUgYnVpbGQgcHJvY2Vzcywgd2UgcHJlY29tcGlsZVxuICogdGhlc2UgdGVtcGxhdGVzIGFuZCBkZWxpdmVyIHRoZW0gYXMgc2luZ2xlIC5qcyBmaWxlcyB0aGF0IHBvcHVsYXRlIHRoZSAnX3RlbXBsYXRlcycgb2JqZWN0LiBXZSBhbHNvIGxvYWRcbiAqIHRlbXBsYXRlcyBkeW5hbWljYWxseSB2aWEgQUpBWCBzbyB0aGF0IHdlIGRvbid0IG5lZWQgYW4gZXhwbGljaXQgY29tcGlsYXRpb24gc3RlcCB3aGVuIG1ha2luZyBsb2NhbCBjaGFuZ2VzLlxuICovXG5mdW5jdGlvbiB0ZW1wbGF0ZShuYW1lLCBvcHRpb25zKSB7XG4gICAgdmFyIHRlbXBsYXRlcyA9IGR4LmNvcmUuX3RlbXBsYXRlcztcbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuICAgIGlmICghdGVtcGxhdGVzW25hbWVdKSB7XG4gICAgICAgICQuYWpheCh7XG4gICAgICAgICAgICB1cmw6ICcvJyArIG5hbWUgKyAnLmhqcycsXG4gICAgICAgICAgICBkYXRhdHlwZTogJ3RleHQvamF2YXNjcmlwdCcsXG4gICAgICAgICAgICBzdWNjZXNzOiBmdW5jdGlvbihyZXNwb25zZSwgc3RhdHVzLCBqcVhIUikge1xuICAgICAgICAgICAgICAgIHRlbXBsYXRlc1tuYW1lXSA9IEhhbmRsZWJhcnMuY29tcGlsZShqcVhIUi5yZXNwb25zZVRleHQpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGVycm9yOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICBkeFV0aWwuZmFpbCgnVW5rbm93biB0ZW1wbGF0ZTogJyArIG5hbWUpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGFzeW5jOiBmYWxzZVxuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICAvLyBmaWx0ZXIoKSBzdHJpcHMgb3V0IGFueSB0ZXh0IG9yIGNvbW1lbnQgbm9kZXNcbiAgICB2YXIgZWxlbXMgPSAkKHRlbXBsYXRlc1tuYW1lXShvcHRpb25zKSkuZmlsdGVyKCcqJyk7XG5cbiAgICBpZiAob3B0aW9ucy52bSkge1xuICAgICAgICAvLyBIYW5kbGUgdGhlIGNhc2Ugd2hlcmUgdGhlcmUgaXMgbW9yZSB0aGFuIG9uZSB0b3AgbGV2ZWwgZWxlbWVudCBpbiB0aGUgdGVtcGxhdGVcbiAgICAgICAgZWxlbXMuZWFjaChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIGtvLmFwcGx5QmluZGluZ3Mob3B0aW9ucy52bSwgdGhpcyk7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIHJldHVybiBlbGVtcztcbn1cblxuLypcbiAqIFJlZ2lzdGVyIGEgaGFuZGxlYmFycyBoZWxwZXIgdG8gZ2V0IGxvY2FsaXplZCB0ZXh0LiBUbyB1c2UgdGhpcyBoZWxwZXI6XG4gKlxuICogICAgICA8ZGl2Pnt7Z2xzICdzb21lLmxvY2FsZS5jb25zdGFudCd9fTwvZGl2PlxuICpcbiAqIFRoZSBwYXJhbWV0ZXJzIHBhc3NlZCB0byB0aGlzIGZ1bmN0aW9uIGFyZSBvZiB0aGUgZm9ybToga2V5LCBzdWJzdGl0dXRpb25zIC4uLlxuICovXG5IYW5kbGViYXJzLnJlZ2lzdGVySGVscGVyKCdnbHMnLCBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gZHhMb2NhbGUuZ2xzLmFwcGx5KHVuZGVmaW5lZCwgYXJndW1lbnRzKTtcbn0pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgICB0ZW1wbGF0ZTogdGVtcGxhdGVcbn07XG4iLCIvKlxuICogQ29weXJpZ2h0IChjKSAyMDEzLCAyMDE1IGJ5IERlbHBoaXguIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKi9cblxuLyogZ2xvYmFsIF8sICQgKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCBkeFV0aWwgPSByZXF1aXJlKCdkeGNvcmUvanMvdXRpbC5qcycpLFxuICAgIGR4RGF0YSA9IHJlcXVpcmUoJ2R4Y29yZS9kYXRhL2pzL2luZGV4LmpzJyk7XG5cbi8qXG4gKiBUaGlzIGZpbGUgaGFuZGxlcyBhIG51bWJlciBvZiB0YXNrcyByZWxhdGVkIHRvIHVzZXJzIGFuZCBwZXJtaXNzaW9ucy4gQW1vbmcgb3RoZXIgdGhpbmdzLCB0aGlzIHByb3ZpZGVzIGEgY2FjaGUgZm9yXG4gKiBnZXR0aW5nIHN5c3RlbS1kZWZpbmVkIGRlZmF1bHQgcm9sZXMuXG4gKi9cbnZhciByb2xlQ2FjaGUgPSB7fTtcblxuZnVuY3Rpb24gcmVzZXQoKSB7XG4gICAgcm9sZUNhY2hlID0ge307XG59XG5cbi8qXG4gKiBQcml2YXRlIGhlbHBlciBmdW5jdGlvbiBmb3IgZ2V0dGluZyBhIHJvbGUgZnJvbSB0aGUgcm9sZUNhY2hlIGlmIHByZXNlbnQsIG90aGVyd2lzZSByZXRyaWV2aW5nIGl0IGZyb20gdGhlIHNlcnZlclxuICogcm9sZSAgICAgICAgICAgICAgIGEgc3RyaW5nIGNvcnJlc3BvbmRpbmcgdG8gdGhlIG5hbWUgb2YgdGhlIHJvb3Qgb3BlcmF0aW9uIGZvciB0aGUgcm9sZSB0byByZXRyaWV2ZVxuICogc3VjY2Vzc0NhbGxiYWNrICAgIHRoZSBmdW5jdGlvbiB0aGF0IGlzIGNhbGxlZCBvbiBzdWNjZXNzIGFuZCBpcyBwYXNzZWQgYSBSb2xlIG1vZGVsXG4gKiByZXR1cm5zIGEgSlF1ZXJ5IFByb21pc2VcbiAqL1xuZnVuY3Rpb24gZ2V0Um9sZShyb2xlLCBzdWNjZXNzQ2FsbGJhY2spIHtcbiAgICBpZiAoc3VjY2Vzc0NhbGxiYWNrICYmICFfLmlzRnVuY3Rpb24oc3VjY2Vzc0NhbGxiYWNrKSkge1xuICAgICAgICBkeFV0aWwuZmFpbCgnVGhlIHN1Y2Nlc3MgY2FsbGJhY2sgbXVzdCBiZSBhIGZ1bmN0aW9uJyk7XG4gICAgfVxuXG4gICAgaWYgKCFyb2xlQ2FjaGVbcm9sZV0pIHtcbiAgICAgICAgcm9sZUNhY2hlW3JvbGVdID0gZHhEYXRhLnJvb3RPcHMuUm9sZVsnJCcgKyByb2xlXSgpLnRoZW4oZnVuY3Rpb24oT0tSZXN1bHQpIHtcbiAgICAgICAgICAgIHJldHVybiBPS1Jlc3VsdC5nZXQoJ3Jlc3VsdCcpO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICByZXR1cm4gcm9sZUNhY2hlW3JvbGVdLmRvbmUoc3VjY2Vzc0NhbGxiYWNrKTtcbn1cblxuZnVuY3Rpb24gZ2V0T3duZXIoc3VjY2Vzc0NhbGxiYWNrKSB7XG4gICAgcmV0dXJuIGdldFJvbGUoJ293bmVyUm9sZScsIHN1Y2Nlc3NDYWxsYmFjayk7XG59XG5cbmZ1bmN0aW9uIGdldFByb3Zpc2lvbmVyKHN1Y2Nlc3NDYWxsYmFjaykge1xuICAgIHJldHVybiBnZXRSb2xlKCdwcm92aXNpb25lclJvbGUnLCBzdWNjZXNzQ2FsbGJhY2spO1xufVxuXG5mdW5jdGlvbiBnZXRKZXRTdHJlYW1Vc2VyKHN1Y2Nlc3NDYWxsYmFjaykge1xuICAgIHJldHVybiBnZXRSb2xlKCdqZXRTdHJlYW1Vc2VyUm9sZScsIHN1Y2Nlc3NDYWxsYmFjayk7XG59XG5cbi8qXG4gKiBzdWNjZXNzQ2FsbGJhY2sgaXMgcGFzc2VkIGFuIG9iamVjdCBjb25zaXN0aW5nIG9mIHRoZSBkZWZhdWx0IHJvbGVzIG9uY2UgdGhleSBoYXZlIGFsbCBiZWVuIHJlc29sdmVkXG4gKiByZXR1cm5zIGEgSlF1ZXJ5IFByb21pc2VcbiAqL1xuZnVuY3Rpb24gZ2V0RGVmYXVsdFJvbGVzKHN1Y2Nlc3NDYWxsYmFjaykge1xuICAgIHZhciBkZWZhdWx0Um9sZXM7XG5cbiAgICByZXR1cm4gJC53aGVuKGdldE93bmVyKCksIGdldFByb3Zpc2lvbmVyKCksIGdldEpldFN0cmVhbVVzZXIoKSlcbiAgICAgICAgLnRoZW4oZnVuY3Rpb24ob3duZXJSb2xlLCBwcm92aXNpb25lclJvbGUsIGpldFN0cmVhbVVzZXJSb2xlKSB7XG4gICAgICAgICAgICAvLyBwYWNrYWdlIGludG8gYW4gb2JqZWN0IHRvIHBhc3MgdG8gY2FsbGJhY2tcbiAgICAgICAgICAgIGRlZmF1bHRSb2xlcyA9IHtcbiAgICAgICAgICAgICAgICBvd25lclJvbGU6IG93bmVyUm9sZSxcbiAgICAgICAgICAgICAgICBwcm92aXNpb25lclJvbGU6IHByb3Zpc2lvbmVyUm9sZSxcbiAgICAgICAgICAgICAgICBqZXRTdHJlYW1Vc2VyUm9sZTogamV0U3RyZWFtVXNlclJvbGVcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIGlmIChzdWNjZXNzQ2FsbGJhY2spIHtcbiAgICAgICAgICAgICAgICBzdWNjZXNzQ2FsbGJhY2soZGVmYXVsdFJvbGVzKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIGRlZmF1bHRSb2xlcztcbiAgICAgICAgfSk7XG59XG5cbi8qXG4gKiBDb252ZW5pZW5jZSBtZXRob2RzIGZvciBkZXRlcm1pbmluZyB0aGUgJ3R5cGUnIG9mIHVzZXIgZnJvbSBhdXRob3JpemF0aW9uc1xuICovXG5cbmZ1bmN0aW9uIGlzRGVscGhpeEFkbWluKHVzZXJSZWYsIGF1dGhvcml6YXRpb25zLCBkZWZhdWx0Um9sZXMpIHtcbiAgICByZXR1cm4gYXV0aG9yaXphdGlvbnMud2hlcmUoe1xuICAgICAgICB0YXJnZXQ6ICdET01BSU4nLFxuICAgICAgICB1c2VyOiB1c2VyUmVmLFxuICAgICAgICByb2xlOiBkZWZhdWx0Um9sZXMub3duZXJSb2xlLmdldCgncmVmZXJlbmNlJylcbiAgICB9KS5sZW5ndGggPiAwO1xufVxuXG5mdW5jdGlvbiBpc0RvbWFpblByb3Zpc2lvbmVyKHVzZXJSZWYsIGF1dGhvcml6YXRpb25zLCBkZWZhdWx0Um9sZXMpIHtcbiAgICAvLyBkZWxwaGl4QWRtaW4gYW5kIGRvbWFpblByb3Zpc2lvbmVyIGFyZSBtdXR1YWxseSBleGNsdXNpdmUuIElmIGJvdGggYXV0aG9yaXphdGlvbnMgZXhpc3QsIGRlbHBoaXhBZG1pbiB3aW5zXG4gICAgdmFyIGlzQWRtaW4gPSBpc0RlbHBoaXhBZG1pbih1c2VyUmVmLCBhdXRob3JpemF0aW9ucywgZGVmYXVsdFJvbGVzKTtcblxuICAgIHJldHVybiAhaXNBZG1pbiAmJiBhdXRob3JpemF0aW9ucy53aGVyZSh7XG4gICAgICAgIHRhcmdldDogJ0RPTUFJTicsXG4gICAgICAgIHVzZXI6IHVzZXJSZWYsXG4gICAgICAgIHJvbGU6IGRlZmF1bHRSb2xlcy5wcm92aXNpb25lclJvbGUuZ2V0KCdyZWZlcmVuY2UnKVxuICAgIH0pLmxlbmd0aCA+IDA7XG59XG5cbmZ1bmN0aW9uIGlzSmV0U3RyZWFtVXNlcih1c2VyUmVmLCBhdXRob3JpemF0aW9ucywgZGVmYXVsdFJvbGVzKSB7XG4gICAgLy8gZGVscGhpeEFkbWluIGFuZCBKZXRTdHJlYW1Vc2VyIGFyZSBtdXR1YWxseSBleGNsdXNpdmUuIElmIGJvdGggYXV0aG9yaXphdGlvbnMgZXhpc3QsIGRlbHBoaXhBZG1pbiB3aW5zXG4gICAgdmFyIGlzQWRtaW4gPSBpc0RlbHBoaXhBZG1pbih1c2VyUmVmLCBhdXRob3JpemF0aW9ucywgZGVmYXVsdFJvbGVzKTtcblxuICAgIHJldHVybiAhaXNBZG1pbiAmJiBhdXRob3JpemF0aW9ucy53aGVyZSh7XG4gICAgICAgIHRhcmdldDogdXNlclJlZixcbiAgICAgICAgdXNlcjogdXNlclJlZixcbiAgICAgICAgcm9sZTogZGVmYXVsdFJvbGVzLmpldFN0cmVhbVVzZXJSb2xlLmdldCgncmVmZXJlbmNlJylcbiAgICB9KS5sZW5ndGggPiAwO1xufVxuXG5mdW5jdGlvbiBzdGFydCgpIHtcbiAgICAvLyBwcmVlbXB0aXZlbHkgZmV0Y2ggdGhlIGRlZmF1bHQgcm9sZXMgdG8gcG9wdWxhdGUgdGhlIHJvbGVDYWNoZS5cbiAgICBnZXREZWZhdWx0Um9sZXMoKTtcbn1cblxuLy8gRGVmaW5lIGV4dGVybmFsbHkgdmlzaWJsZSBmdW5jdGlvbnNcbm1vZHVsZS5leHBvcnRzID0ge1xuICAgIGdldE93bmVyOiBnZXRPd25lcixcbiAgICBnZXRQcm92aXNpb25lcjogZ2V0UHJvdmlzaW9uZXIsXG4gICAgZ2V0SmV0U3RyZWFtVXNlcjogZ2V0SmV0U3RyZWFtVXNlcixcbiAgICBnZXREZWZhdWx0Um9sZXM6IGdldERlZmF1bHRSb2xlcyxcbiAgICBpc0RlbHBoaXhBZG1pbjogaXNEZWxwaGl4QWRtaW4sXG4gICAgaXNEb21haW5Qcm92aXNpb25lcjogaXNEb21haW5Qcm92aXNpb25lcixcbiAgICBpc0pldFN0cmVhbVVzZXI6IGlzSmV0U3RyZWFtVXNlcixcbiAgICBzdGFydDogc3RhcnQsXG4gICAgX3Jlc2V0OiByZXNldCAvLyBVc2VkIGZvciB0ZXN0aW5nXG59O1xuIiwiLypcbiAqIENvcHlyaWdodCAoYykgMjAxMywgMjAxNSBieSBEZWxwaGl4LiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICovXG5cbi8qIGdsb2JhbCAkLCBfLCBrbywgd2luZG93ICovXG5cbid1c2Ugc3RyaWN0JztcblxuY29uc3QgZHhCcm93c2VyID0gcmVxdWlyZSgnZHhjb3JlL2pzL2Jyb3dzZXIuanMnKTtcblxuLypcbiAqIFJlcG9ydCBhIGZhaWxpbmcgbWVzc2FnZS4gV3JpdGVzIHRoZSBpbmZvIHRvIHRoZSBjb25zb2xlIGFuZCB0aHJvd3MgYW4gZXJyb3JcbiAqL1xuZnVuY3Rpb24gZmFpbCgpIHtcbiAgICBkeEJyb3dzZXIuY29uc29sZUVycm9yLmFwcGx5KGR4QnJvd3NlciwgYXJndW1lbnRzKTtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYXJndW1lbnRzWzBdKTtcbn1cblxuLypcbiAqIFJlcG9ydCBhIHdhcm5pbmcgbWVzc2FnZS4gV3JpdGVzIHRoZSBpbmZvIHRvIHRoZSBjb25zb2xlXG4gKi9cbmZ1bmN0aW9uIHdhcm4oKSB7XG4gICAgZHhCcm93c2VyLmNvbnNvbGVXYXJuLmFwcGx5KGR4QnJvd3NlciwgYXJndW1lbnRzKTtcbn1cblxuLypcbiAqIFJlcG9ydCBhIHdhcm5pbmcgbWVzc2FnZS4gV3JpdGVzIHRoZSBpbmZvIHRvIHRoZSBjb25zb2xlXG4gKi9cbmZ1bmN0aW9uIGluZm8oKSB7XG4gICAgZHhCcm93c2VyLmNvbnNvbGVJbmZvLmFwcGx5KGR4QnJvd3NlciwgYXJndW1lbnRzKTtcbn1cblxuLypcbiAqIGlmIGRlYnVnIGZsYWcgaXMgJ29uJyB0aGlzIHdyaXRlIHRoZSBzcGVjaWZpZWQgaW5mbyB0byB0aGUgY29uc29sZS5cbiAqL1xuZnVuY3Rpb24gZGVidWcoKSB7XG4gICAgaWYgKCFtb2R1bGUuZXhwb3J0cy5kZWJ1Z01vZGUpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIGR4QnJvd3Nlci5jb25zb2xlRGVidWcuYXBwbHkoZHhCcm93c2VyLCBhcmd1bWVudHMpO1xuXG4gICAgcmV0dXJuIHRydWU7XG59XG5cbi8qXG4gKiAgQWxsb3cgdGltaW5nIG9mIHNjcmlwdCBleGVjdXRpb24uICBJdCBpcyBiYXNlZCBvbiBjb25zb2xlLnRpbWUgYW5kIGNvbnNvbGUudGltZUVuZCB0aGF0IGFyZSBwcmVzZW50IGluIENocm9tZSxcbiAqICBGaXJlZm94LCBhbmQgSUU5IGJ1dCBpcyBtaXNzaW5nIGZyb20gSUU4LiAgSW4gb3JkZXIgZm9yIHRpbWluZyB0byByZWNvcmQgcmVzdWx0LCBib3RoIG1vZHVsZS5leHBvcnRzLmRlYnVnTW9kZSBhbmRcbiAqICBtb2R1bGUuZXhwb3J0cy50aW1pbmdNb2RlIG11c3QgYmUgc2V0IHRvIHRydWVcbiAqXG4gKiAgVXNhZ2U6XG4gKiAgdGltZSg8a2V5Pik7IC8vIHdoZXJlIDxrZXk+IGlzIG9mIHR5cGUgU3RyaW5nXG4gKiAgLy8gY29kZSB0aGF0IGlzIGJlaW5nIHRpbWVkXG4gKiAgZW5kVGltZSg8a2V5Pik7XG4gKlxuICogIEV4YW1wbGU6XG4gKiAgdGltZSgnY29tcHV0ZUZvbycpO1xuICogIHZhciBmb28gPSBjb21wdXRlRm9vKCk7XG4gKiAgdGltZUVuZCgnY29tcHV0ZUZvbycpO1xuICpcbiAqICBDb25zb2xlIE91dHB1dDpcbiAqICBjb21wdXRlRm9vOiAyM21zXG4gKlxuICogIE5vdGU6IElmIHNvbWVvbmUgYWxyZWFkeSBjYWxsZWQgdGltZSB3aXRoIG9uZSBrZXksIHRoZSBzZWNvbmQgY2FsbCB0byB0aW1lIHdpdGggdGhlIHNhbWUga2V5IGlzIGlnbm9yZWQuXG4gKi9cbihmdW5jdGlvbigpIHtcbiAgICB2YXIgdGltZUNvdW50ZXJzID0ge307XG4gICAgdmFyIHRpbWUsIHRpbWVFbmQ7XG4gICAgbW9kdWxlLmV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyB8fCB7fTtcbiAgICAvLyBFeHBvc2VkIGp1c3QgZm9yIHRlc3RpbmdcbiAgICBtb2R1bGUuZXhwb3J0cy5fdGltZUZvck9sZEJyb3dzZXJzID0gZnVuY3Rpb24gX3RpbWVGb3JPbGRCcm93c2VycyhuYW1lKSB7XG4gICAgICAgIGlmICghbmFtZSB8fCAhaXNOb25lKHRpbWVDb3VudGVyc1tuYW1lXSkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciB0aW1lID0gbmV3IERhdGUoKS5nZXRUaW1lKCk7XG4gICAgICAgIHRpbWVDb3VudGVyc1tuYW1lXSA9IHRpbWU7XG4gICAgfTtcblxuICAgIC8vIEV4cG9zZWQganVzdCBmb3IgdGVzdGluZ1xuICAgIG1vZHVsZS5leHBvcnRzLl90aW1lRW5kRm9yT2xkQnJvd3NlcnMgPSBmdW5jdGlvbiBfdGltZUVuZEZvck9sZEJyb3dzZXJzKG5hbWUpIHtcbiAgICAgICAgdmFyIHRpbWUgPSBuZXcgRGF0ZSgpLmdldFRpbWUoKTtcblxuICAgICAgICBpZiAoIW5hbWUgfHwgaXNOb25lKHRpbWVDb3VudGVyc1tuYW1lXSkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBkaWZmID0gdGltZSAtIHRpbWVDb3VudGVyc1tuYW1lXTtcbiAgICAgICAgdmFyIGxhYmVsID0gbmFtZSArICc6ICcgKyBkaWZmICsgJ21zJztcbiAgICAgICAgbW9kdWxlLmV4cG9ydHMud2FybihsYWJlbCk7XG4gICAgICAgIGRlbGV0ZSB0aW1lQ291bnRlcnNbbmFtZV07XG4gICAgfTtcblxuICAgIGlmICh3aW5kb3cuY29uc29sZSAmJiB3aW5kb3cuY29uc29sZS50aW1lKSB7XG4gICAgICAgIHRpbWUgPSB3aW5kb3cuY29uc29sZS50aW1lLmJpbmQod2luZG93LmNvbnNvbGUpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHRpbWUgPSBtb2R1bGUuZXhwb3J0cy5fdGltZUZvck9sZEJyb3dzZXJzO1xuICAgIH1cblxuICAgIGlmICh3aW5kb3cuY29uc29sZSAmJiB3aW5kb3cuY29uc29sZS50aW1lRW5kKSB7XG4gICAgICAgIHRpbWVFbmQgPSB3aW5kb3cuY29uc29sZS50aW1lRW5kLmJpbmQod2luZG93LmNvbnNvbGUpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHRpbWVFbmQgPSBtb2R1bGUuZXhwb3J0cy5fdGltZUVuZEZvck9sZEJyb3dzZXJzO1xuICAgIH1cblxuICAgIG1vZHVsZS5leHBvcnRzLnRpbWUgPSBmdW5jdGlvbihuYW1lKSB7XG4gICAgICAgIGlmICghbW9kdWxlLmV4cG9ydHMudGltaW5nTW9kZSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRpbWUobmFtZSk7XG4gICAgfTtcblxuICAgIG1vZHVsZS5leHBvcnRzLnRpbWVFbmQgPSBmdW5jdGlvbihuYW1lKSB7XG4gICAgICAgIGlmICghbW9kdWxlLmV4cG9ydHMudGltaW5nTW9kZSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRpbWVFbmQobmFtZSk7XG4gICAgfTtcbn0pKCk7XG5cbi8qXG4gKiBBbiBlYXNpbHkgYWNjZXNzaWJsZSBmdW5jdGlvbiB0byB0dXJuIG51bWJlcnMgaW50byBweCB2YWx1ZXMuXG4gKi9cbmZ1bmN0aW9uIHB4KHBpeGVscykge1xuICAgIHJldHVybiBwaXhlbHMgKyAncHgnO1xufVxuXG4vKlxuICogUmV0dXJucyB0cnVlIGlmIHBhcmFtZXRlciBpcyBudWxsIG9yIHVuZGVmaW5lZC5cbiAqL1xuZnVuY3Rpb24gaXNOb25lKHZhbHVlKSB7XG4gICAgcmV0dXJuIF8uaXNOdWxsKHZhbHVlKSB8fCBfLmlzVW5kZWZpbmVkKHZhbHVlKTtcbn1cblxuZnVuY3Rpb24gZ2V0Q29va2llKGNvb2tpZU5hbWUpIHtcbiAgICB2YXIgbmFtZSA9IGNvb2tpZU5hbWUgKyAnPSc7XG4gICAgdmFyIGNhID0gZG9jdW1lbnQuY29va2llLnNwbGl0KCc7Jyk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjYS5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgYyA9ICQudHJpbShjYVtpXSk7XG4gICAgICAgIGlmIChjLmluZGV4T2YobmFtZSkgPT09IDApXG4gICAgICAgICAgICByZXR1cm4gYy5zdWJzdHJpbmcobmFtZS5sZW5ndGgsIGMubGVuZ3RoKTtcbiAgICB9XG59XG5cbi8qXG4gKiBTZXRzIHNpdGV3aWRlIGNvb2tpZS5cbiAqL1xuZnVuY3Rpb24gc2V0Q29va2llKGNuYW1lLCBjdmFsdWUsIGV4ZGF5cykge1xuICAgIHZhciBkID0gbmV3IERhdGUoKTtcbiAgICBkLnNldFRpbWUoZC5nZXRUaW1lKCkgKyAoZXhkYXlzICogMjQgKiA2MCAqIDYwICogMTAwMCkpO1xuICAgIHZhciBleHBpcmVzID0gJ2V4cGlyZXM9JyArIGQudG9HTVRTdHJpbmcoKTtcbiAgICBkb2N1bWVudC5jb29raWUgPSBjbmFtZSArICc9JyArIGN2YWx1ZSArICc7ICcgKyBleHBpcmVzICsgJzsgcGF0aD0vJztcbn1cblxuZnVuY3Rpb24gZGVsZXRlQ29va2llKGNuYW1lKSB7XG4gICAgc2V0Q29va2llKGNuYW1lLCAnJywgLTEpO1xufVxuXG4vKlxuICogdGhpcyBmdW5jdGlvbiBzaW1wbHkgcmV0dXJucyB0aGUgb3JpZ2luIHVybCBvZiBjdXJyZW50IHBhZ2UuXG4gKi9cbmZ1bmN0aW9uIGdldFdpbmRvd1VSTE9yaWdpbigpIHtcbiAgICB2YXIgbG9jID0gZHhCcm93c2VyLmdldFdpbmRvd0xvY2F0aW9uKCk7XG4gICAgaWYgKGlzTm9uZShsb2Mub3JpZ2luKSkge1xuICAgICAgICByZXR1cm4gbG9jLnByb3RvY29sICsgJy8vJyArIGxvYy5ob3N0O1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBsb2Mub3JpZ2luO1xuICAgIH1cbn1cblxuLypcbiAqIFJldHVybnMgYSBuZXcgb2JqZWN0IHdpdGggb2JqJ3Mga28gdW53cmFwcGVkIHByb3BlcnRpZXMuXG4gKi9cbmZ1bmN0aW9uIHVud3JhcFByb3BlcnRpZXMob2JqKSB7XG4gICAgdmFyIHJlc3VsdCA9IHt9O1xuXG4gICAgXy5lYWNoKG9iaiwgZnVuY3Rpb24odmFsdWUsIGtleSkge1xuICAgICAgICByZXN1bHRba2V5XSA9IGtvLnVud3JhcCh2YWx1ZSk7XG4gICAgfSk7XG5cbiAgICByZXR1cm4gcmVzdWx0O1xufVxuXG4vKlxuICogQmluZCB0aGUgZGVmYXVsdCBldmVudCB0cmlnZ2VyIHRvIHRoZSBpbnB1dCBmaWVsZC5cbiAqIFlvdSBjYW4gdGhlbiB1c2UgaXQgYnkgY2FsbGluZyAnaW5wdXRGaWVsZC5iaW5kKCdlbnRlcktleScsIGFjY2VwdEZ1bmN0aW9uKTsnXG4gKi9cbmZ1bmN0aW9uIGJpbmREZWZhdWx0S2V5VHJpZ2dlcnMoaW5wdXRGaWVsZCkge1xuICAgIHZhciAkaW5wdXRGaWVsZCA9ICQoaW5wdXRGaWVsZCk7XG5cbiAgICBpZiAoJGlucHV0RmllbGQuaXMoJ2lucHV0JykgfHwgJGlucHV0RmllbGQuaXMoJ3RleHRhcmVhJykpIHtcbiAgICAgICAgJGlucHV0RmllbGQua2V5dXAoZnVuY3Rpb24oZSkge1xuICAgICAgICAgICAgaWYgKGUua2V5Q29kZSA9PT0gMTMpIHtcbiAgICAgICAgICAgICAgICAkaW5wdXRGaWVsZC50cmlnZ2VyKCdlbnRlcktleScpO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChlLmtleUNvZGUgPT09IDI3KSB7XG4gICAgICAgICAgICAgICAgJGlucHV0RmllbGQudHJpZ2dlcignZXNjYXBlS2V5Jyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIGZhaWwoJ2JpbmREZWZhdWx0S2V5VHJpZ2dlcnMgbXVzdCBiZSB1c2VkIHdpdGggYW4gaW5wdXQnKTtcbiAgICB9XG59XG5cbi8qXG4gKiBSZXR1cm5zIGEgbmV3IG9iamVjdCB0aGF0IGlzIGEgZGVlcCBjbG9uZSBvZiB0aGUgaW5wdXQgb2JqZWN0LlxuICovXG5mdW5jdGlvbiBkZWVwQ2xvbmUob2JqKSB7XG4gICAgdmFyIHJlc3VsdCA9IG9iajtcblxuICAgIGlmIChfLmlzQXJyYXkob2JqKSkge1xuICAgICAgICByZXN1bHQgPSBbXTtcbiAgICAgICAgXy5lYWNoKG9iaiwgZnVuY3Rpb24odmFsdWUsIGluZGV4KSB7XG4gICAgICAgICAgICByZXN1bHRbaW5kZXhdID0gZGVlcENsb25lKHZhbHVlKTtcbiAgICAgICAgfSk7XG4gICAgfSBlbHNlIGlmIChfLmlzT2JqZWN0KG9iaikpIHtcbiAgICAgICAgaWYgKG9iaiBpbnN0YW5jZW9mIERhdGUpIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IG5ldyBEYXRlKG9iai5nZXRUaW1lKCkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmVzdWx0ID0ge307XG4gICAgICAgICAgICBfLmVhY2gob2JqLCBmdW5jdGlvbih2YWx1ZSwgaW5kZXgpIHtcbiAgICAgICAgICAgICAgICByZXN1bHRbaW5kZXhdID0gZGVlcENsb25lKHZhbHVlKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cblxuLy8gQ29tcGFyZSB0d28gZGF0ZXMsIGFsbG93aW5nIGVpdGhlciBvbmUgdG8gYmUgdW5kZWZpbmVkIG9yIG51bGxcbmZ1bmN0aW9uIGRhdGVzRXF1YWwoYSwgYikge1xuICAgIGlmIChpc05vbmUoYSkgfHwgaXNOb25lKGIpKVxuICAgICAgICByZXR1cm4gYSA9PT0gYjtcbiAgICByZXR1cm4gYS5nZXRUaW1lKCkgPT09IGIuZ2V0VGltZSgpO1xufVxuXG4vKlxuICogUGVyZm9ybXMgYSBkZWVwIGNvcHkgb2YgdGhlIHZhbHVlcyBmcm9tICdzcmMnIGludG8gJ2RzdCcsIG92ZXJsYXlpbmcgYW55IGNvbmZsaWN0aW5nIHByb3BlcnRpZXMuIEJlY2F1c2UgdGhpcyBpcyBhXG4gKiBkZWVwIGNvcHksIHRoaXMgc3VwcG9ydHMgc3BhcnNlIG92ZXJsYXlzIGZvciBvYmplY3RzLiBGb3IgZXhhbXBsZTpcbiAqXG4gKiAgICAgIG92ZXJsYXlQcm9wZXJ0aWVzKHsgY2hpbGQ6IHsgb25lOiAnZm9vJywgdHdvOiAnYmFyJyB9fSwgeyBjaGlsZDogeyB0d286ICdiYXonIH19KTtcbiAqICAgICAgPT4geyBjaGlsZDogeyBvbmU6ICdmb28nLCB0d286ICdiYXonIH19XG4gKlxuICogTm90aWNlIHRoYXQgdGhlIGVudGlyZXR5IG9mIHRoZSB0aGUgJ2NoaWxkJyBwcm9wZXJ0eSBpc24ndCBvdmVycmlkZGVuLCBvbmx5IHRob3NlIHNwZWNpZmllZCBpbiB0aGUgc291cmNlLiBPYmplY3RzXG4gKiB0aGF0IGRvbid0IGV4aXN0IGluIHRoZSBzb3VyY2Ugd2lsbCBiZSBjcmVhdGVkLiBBcnJheXMgYXJlIG1vcmUgZGlmZmljdWx0LCBhbmQgYXJlIGNvcGllZCBvdmVyIHdob2xlIGlmIHNwZWNpZmllZCBpblxuICogJ3NyYycuIEFsc2Ugbm90ZSB0aGF0IERhdGUgb2JqZWN0cyBhcmUgZ2l2ZW4gc3BlY2lhbCB0cmVhdG1lbnQgYW5kIGNvcGllZCBvdmVyIHdob2xlLlxuICovXG5mdW5jdGlvbiBvdmVybGF5UHJvcGVydGllcyhkc3QsIHNyYywgcHJlZml4KSB7XG4gICAgcHJlZml4ID0gcHJlZml4IHx8ICcnO1xuXG4gICAgXy5lYWNoKHNyYywgZnVuY3Rpb24ocHJvcHZhbCwgcHJvcG5hbWUpIHtcbiAgICAgICAgdmFyIGZ1bGxuYW1lID0gcHJlZml4ICsgcHJvcG5hbWU7XG4gICAgICAgIGlmIChfLmlzQXJyYXkocHJvcHZhbCkpIHtcbiAgICAgICAgICAgIGRzdFtwcm9wbmFtZV0gPSBfLmNsb25lKHByb3B2YWwpO1xuICAgICAgICB9IGVsc2UgaWYgKF8uaXNPYmplY3QocHJvcHZhbCkpIHtcbiAgICAgICAgICAgIGlmICghXy5pc09iamVjdChkc3RbcHJvcG5hbWVdKSkge1xuICAgICAgICAgICAgICAgIGRzdFtwcm9wbmFtZV0gPSB7fTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKF8uaXNEYXRlKHByb3B2YWwpKSB7XG4gICAgICAgICAgICAgICAgLy8gRGF0ZSBpc24ndCBhIG5vcm1hbCBvYmplY3QgYW5kIHNvIG11c3QgYmUgaGFuZGxlZCBzcGVjaWFsbHkgYW5kIGNvcGllZCBvdmVyIHdob2xlXG4gICAgICAgICAgICAgICAgZHN0W3Byb3BuYW1lXSA9IG5ldyBEYXRlKHByb3B2YWwuZ2V0VGltZSgpKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgb3ZlcmxheVByb3BlcnRpZXMoZHN0W3Byb3BuYW1lXSwgcHJvcHZhbCwgZnVsbG5hbWUgKyAnLicpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZHN0W3Byb3BuYW1lXSA9IHByb3B2YWw7XG4gICAgICAgIH1cbiAgICB9KTtcblxuICAgIHJldHVybiBkc3Q7XG59XG5cbmZ1bmN0aW9uIGFycmF5VG9NYXAoYXJyYXksIGtleVByb3BlcnR5TmFtZSkge1xuICAgIHZhciBtYXAgPSB7fTtcbiAgICBfLmVhY2goYXJyYXksIGZ1bmN0aW9uKGl0ZW0pIHtcbiAgICAgICAgdmFyIGlkID0gaXRlbVtrZXlQcm9wZXJ0eU5hbWVdO1xuICAgICAgICBpZiAoIV8uaXNVbmRlZmluZWQoaWQpKSB7XG4gICAgICAgICAgICBtYXBbaWRdID0gaXRlbTtcbiAgICAgICAgfVxuICAgIH0pO1xuXG4gICAgcmV0dXJuIG1hcDtcbn1cblxuKGZ1bmN0aW9uKCkge1xuICAgIHZhciBjb3VudGVyID0gMDtcblxuICAgIC8qXG4gICAgICogUmV0dXJucyBhIG5ldyB1bmlxdWUgaWQgb24gdGhlIGZseSB3aXRoIHRoZSBwcmVmaXguXG4gICAgICovXG4gICAgbW9kdWxlLmV4cG9ydHMubWFrZVVuaXF1ZUlkID0gZnVuY3Rpb24gbWFrZVVuaXF1ZUlkKHByZWZpeCkge1xuICAgICAgICBwcmVmaXggPSBwcmVmaXggfHwgJ3VuaXFpZCc7XG5cbiAgICAgICAgdmFyIGlkID0gcHJlZml4ICsgJycgKyAoY291bnRlcisrKTtcblxuICAgICAgICBpZiAoJCgnIycgKyBpZCkubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gaWQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gbW9kdWxlLmV4cG9ydHMubWFrZVVuaXF1ZUlkKHByZWZpeCk7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgbW9kdWxlLmV4cG9ydHMuX3Jlc2V0VW5pcXVlSWRDb3VudGVyID0gZnVuY3Rpb24gX3Jlc2V0VW5pcXVlSWRDb3VudGVyKCkge1xuICAgICAgICBjb3VudGVyID0gMDtcbiAgICB9O1xufSkoKTtcblxuLypcbiAqIENoZWNrcyB0byBzZWUgaWYgRE9NIGVsZW1lbmV0IGluIHF1ZXN0aW9uIGlzIGluIHRoZSB2aXNpYmxlIHZpZXdwb3J0IG9yIG5vdC5cbiAqIEBwYXJhbSB7RE9NIGVsZW1lbnR9IGVsIC0gRE9NIGVsZW1lbnQgdG8gYmUgY2hlY2tlZC5cbiAqL1xuZnVuY3Rpb24gaXNFbGVtZW50SW5WaWV3cG9ydChlbCkge1xuICAgIHZhciByZWN0ID0gZWwuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG5cbiAgICByZXR1cm4gKHJlY3QudG9wID49IDAgJiZcbiAgICAgICAgICAgIHJlY3QubGVmdCA+PSAwICYmXG4gICAgICAgICAgICByZWN0LmJvdHRvbSA8PSAod2luZG93LmlubmVySGVpZ2h0IHx8IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5jbGllbnRIZWlnaHQpICYmXG4gICAgICAgICAgICByZWN0LnJpZ2h0IDw9ICh3aW5kb3cuaW5uZXJXaWR0aCB8fCBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuY2xpZW50V2lkdGgpKTtcblxufVxuXG4vKlxuICogUmV0dXJuIGEgaHVtYW4gcmVhZGFibGUgZGF0ZSBzdHJpbmdcbiAqL1xuZnVuY3Rpb24gZGF0ZVRvUkZDMTEyM1N0cmluZyhkYXRlKSB7XG4gICAgdmFyIHN0cmluZ1ZhbHVlID0gZGF0ZS50b1VUQ1N0cmluZygpO1xuXG4gICAgLypcbiAgICAgKiBVZ2x5IGhhY2suIFNvbWUgYnJvd3NlcnMgcmVwb3J0ICdUdWUsIDAxIEphbiAyMDEzJywgd2hpbGUgb3RoZXJzIHJlcG9ydCAnVHVlLCAxIEphbiAyMDEzJy4gVGhpcyByZW1vdmVzIHRoZSAwLlxuICAgICAqIEJvdGggYXJlIGxlZ2FsIFJUQzExMjMgZGF0ZSBzdHJpbmdzLCBidXQgaXQgY2F1c2VzIHRlc3RpbmcgcHJvYmxlbXMgd2hlbiB0aGUgc3RyaW5nIGZvcm1hdCBpc24ndCBwcmVkaWN0YWJsZS5cbiAgICAgKi9cbiAgICBpZiAoc3RyaW5nVmFsdWUuY2hhckF0KDUpID09PSAnMCcpIHtcbiAgICAgICAgc3RyaW5nVmFsdWUgPSBzdHJpbmdWYWx1ZS5zdWJzdHIoMCwgNSkgKyBzdHJpbmdWYWx1ZS5zdWJzdHIoNik7XG4gICAgfVxuXG4gICAgcmV0dXJuIHN0cmluZ1ZhbHVlLnJlcGxhY2UoJ1VUQycsICdHTVQnKTtcbn1cblxuLypcbiAqIENoZWNrcyBpZiB0aGUgcGFzc2VkIGluIHN0cmluZyBoYXMgYSB2YWxpZCBlbWFpbCBmb3JtYXQgb3Igbm90LlxuICovXG5mdW5jdGlvbiBpc1ZhbGlkRW1haWwoZW1haWwpIHtcbiAgICB2YXIgcmVnZXggPSAvXlxcUytAXFxTKyQvO1xuICAgIHJldHVybiByZWdleC50ZXN0KGVtYWlsKTtcbn1cblxuZnVuY3Rpb24gZXh0ZW5kUHJvdG90eXBlKHN1YlR5cGUsIHByb3RvdHlwZSwgc3ViVHlwZU1lbWJlcnMpIHtcbiAgICBfLmV4dGVuZChzdWJUeXBlLnByb3RvdHlwZSwgcHJvdG90eXBlLCBzdWJUeXBlTWVtYmVycyk7XG4gICAgcmV0dXJuIHN1YlR5cGU7XG59XG5cbi8qXG4gKiBSZXRyaWV2ZXMgYSB2YWx1ZSB0aGF0IGFyZSBkZWVwIGRvd24gaW4gdGhlIG9iamVjdCBjaGFpbi4gVGhpcyBhbHNvIHdvcmtzIHdpdGggYXJyYXkgbWl4ZWQgd2l0aCB0aGUgb2JqZWN0LlxuICogRm9yIGV4YW1wbGU6IGlmIGhvc3QgaXMgeyBhOiA1LCBiOiBbNCwgJ21lJ10gfSBhbmQgeW91IGFzayBmb3IgJ2IuMScsIGl0IHdpbGwgcmV0dXJuICdtZScuXG4gKi9cbmZ1bmN0aW9uIGdldERlZXBQcm9wZXJ0eShob3N0LCB0aGVDaGFpbiwgZGVmYXVsdFZhbHVlKSB7XG4gICAgaWYgKCFob3N0KSByZXR1cm4gZGVmYXVsdFZhbHVlO1xuICAgIHZhciBjaGFpbnMgPSB0aGVDaGFpbi5zcGxpdCgnLicpO1xuICAgIHZhciBjdXJyZW50Q29udGV4dCA9IGhvc3Q7XG4gICAgdmFyIGFDaGFpbjtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2hhaW5zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGFDaGFpbiA9IGNoYWluc1tpXTtcbiAgICAgICAgaWYgKF8uaGFzKGN1cnJlbnRDb250ZXh0LCBhQ2hhaW4pKSB7XG4gICAgICAgICAgICBjdXJyZW50Q29udGV4dCA9IGN1cnJlbnRDb250ZXh0W2FDaGFpbl07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gZGVmYXVsdFZhbHVlO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGN1cnJlbnRDb250ZXh0O1xufVxuXG4vLyBEZWZpbmUgdGhlIHB1YmxpYyBhcGlcbl8uZXh0ZW5kKG1vZHVsZS5leHBvcnRzLCB7XG4gICAgLy8gZGVidWcgbW9kZSBmbGFnXG4gICAgZGVidWdNb2RlOiBmYWxzZSxcbiAgICAvLyB0aW1pbmcgbW9kZSBmbGFnXG4gICAgdGltaW5nTW9kZTogZmFsc2UsXG4gICAgZGVidWc6IGRlYnVnLFxuICAgIGlzTm9uZTogaXNOb25lLFxuICAgIHNldENvb2tpZTogc2V0Q29va2llLFxuICAgIGdldENvb2tpZTogZ2V0Q29va2llLFxuICAgIGRlbGV0ZUNvb2tpZTogZGVsZXRlQ29va2llLFxuICAgIGlzVmFsaWRFbWFpbDogaXNWYWxpZEVtYWlsLFxuICAgIGdldFdpbmRvd1VSTE9yaWdpbjogZ2V0V2luZG93VVJMT3JpZ2luLFxuICAgIGRlZXBDbG9uZTogZGVlcENsb25lLFxuICAgIHVud3JhcFByb3BlcnRpZXM6IHVud3JhcFByb3BlcnRpZXMsXG4gICAgYmluZERlZmF1bHRLZXlUcmlnZ2VyczogYmluZERlZmF1bHRLZXlUcmlnZ2VycyxcbiAgICBkYXRlc0VxdWFsOiBkYXRlc0VxdWFsLFxuICAgIG92ZXJsYXlQcm9wZXJ0aWVzOiBvdmVybGF5UHJvcGVydGllcyxcbiAgICBhcnJheVRvTWFwOiBhcnJheVRvTWFwLFxuICAgIGlzRWxlbWVudEluVmlld3BvcnQ6IGlzRWxlbWVudEluVmlld3BvcnQsXG4gICAgZGF0ZVRvUkZDMTEyM1N0cmluZzogZGF0ZVRvUkZDMTEyM1N0cmluZyxcbiAgICBleHRlbmRQcm90b3R5cGU6IGV4dGVuZFByb3RvdHlwZSxcbiAgICBnZXREZWVwUHJvcGVydHk6IGdldERlZXBQcm9wZXJ0eSxcbiAgICBmYWlsOiBmYWlsLFxuICAgIHdhcm46IHdhcm4sXG4gICAgaW5mbzogaW5mbyxcbiAgICBweDogcHhcbn0pO1xuIiwiLypcbiAqIENvcHlyaWdodCAoYykgMjAxMywgMjAxNSBieSBEZWxwaGl4LiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICovXG5cbi8qIGdsb2JhbCAkLCBfLCBrbywgQmFja2JvbmUgKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgbmFtZWRNb2RhbCA9IHt9O1xudmFyIG1vZGFsQ291bnRlciA9IDA7XG52YXIgbm9uTW9kYWxXaW5kb3dRdWV1ZSA9IFtdO1xuXG5jb25zdCBkeExvY2FsZSA9IHJlcXVpcmUoJ2R4Y29yZS9qcy9sb2NhbGUuanMnKSxcbiAgICBkeFV0aWwgPSByZXF1aXJlKCdkeGNvcmUvanMvdXRpbC5qcycpLFxuICAgIGR4VGVtcGxhdGUgPSByZXF1aXJlKCdkeGNvcmUvanMvdGVtcGxhdGUuanMnKSxcbiAgICBkeFVzZXJVdGlsID0gcmVxdWlyZSgnZHhjb3JlL2RhdGEvZGVscGhpeC9qcy91dGlsLmpzJyk7XG5cbi8qXG4gKiB3aW5kb3cuKiAob3B0aW9ucylcbiAqXG4gKiBXZSBoYXZlIGZpdmUgdmFyaWF0aW9ucyBvZiBkaWFsb2cgdHlwZXMsIG1vc3Qgb2YgdGhlbSBhcmUgYSB3cmFwcGVyIG92ZXIgdGhlIGJhc2ljIGRpYWxvZzpcbiAqIHdpbmRvdy5jb25maXJtIC8gd2luZG93LmFsZXJ0IC8gd2luZG93LmVycm9yQWxlcnQgLyB3aW5kb3cuY29ubmVjdGl2aXR5RXJyb3JBbGVydCBhbmQgd2luZG93LmRpYWxvZ1xuICpcbiAqIEZvciBtb3N0IG9mIHRoZSBkaWFsb2cgdHlwZXMgdGhlICdvcHRpb25zJyBhcmd1bWVudCB0YWtlcyB0aGUgZm9sbG93aW5nIGNvbW1vbiB2YWx1ZXM6XG4gKlxuICogICAgICB0aXRsZSAgICAgICAgICAgQW4gb3B0aW9uYWwgdGl0bGUgZm9yIHRoZSBkaWFsb2cuXG4gKlxuICogICAgICBjbG9zZU9uRXNjYXBlICAgU3BlY2lmaWVzIHdoZXRoZXIgdGhlIGRpYWxvZyBzaG91bGQgY2xvc2Ugd2hlbiBpdCBoYXMgZm9jdXMgYW5kIHRoZSB1c2VyIHByZXNzZXMgdGhlIGVzY2FwZVxuICogICAgICAgICAgICAgICAgICAgICAgKEVTQykga2V5LlxuICpcbiAqICAgICAgbm9DbG9zZSAgICAgICAgIElmIHRydWUsIHRoZSBkaWFsb2cgd291bGQgbm90IGhhdmUgYSBbeF0gb24gdGhlIHRvcCByaWdodC5cbiAqXG4gKiAgICAgIGRpYWxvZ0NsYXNzICAgICBUaGUgc3BlY2lmaWVkIGNsYXNzIG5hbWUocykgd2lsbCBiZSBhZGRlZCB0byB0aGUgZGlhbG9nLCBmb3IgYWRkaXRpb25hbCB0aGVtaW5nLlxuICpcbiAqICAgICAgdGVtcGxhdGUgICAgICAgIGlmIHRoZSBkZXZlbG9wZXIgbmVlZHMgdG8gcG9wLXVwIGFuIGVudGlyZWx5IGRpZmZlcmVudCBraW5kIG9mIGRpYWxvZywgaGUvc2hlIGNhblxuICogICAgICAgICAgICAgICAgICAgICAgcGFzcyBpbiBwYXRoIHRvIHRoZWlyIHRlbXBsYXRlIGFuZCB3aW5kb3cgd2lsbCByZW5kZXIgaXQuXG4gKlxuICogICAgICBidXR0b25zICAgICAgICAgQW4gb3B0aW9uYWwgYXJyYXkgb2Ygb2JqZWN0cyB0aGF0IHNwZWNpZnkgYSBzZXQgb2YgYnV0dG9ucyB0byBkaXNwbGF5IGluIHRoZSBmb290ZXIuIFRoZXNlXG4gKiAgICAgICAgICAgICAgICAgICAgICBidXR0b24gb2JqZWN0cyBpbmNsdWRlIHRoZSBmb2xsb3dpbmcgYXR0cmlidXRlczpcbiAqXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgdGV4dCAgICAgICBUZXh0IGxhYmVsIGZvciB0aGUgYnV0dG9uLlxuICpcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICBjbGljayAgICAgIENhbGxiYWNrIGludm9rZWQgd2hlbiB0aGUgYnV0dG9uIGlzIGNsaWNrZWQuXG4gKlxuICogICAgICAgICAgICAgICAgICAgICAgICAgICdjbGFzcycgICAgQ1NTIGNsYXNzIGZvciBidXR0b25cbiAqXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgaWNvbnMgICAgICBDU1MgY2xhc3MgZm9yIGJ1dHRvbiBpY29uXG4gKlxuICogICAgICBjYW5jZWwgICAgICAgICAgQ29udmVuaWVuY2UgYWxpYXMuIElmIHNldCB0byAndHJ1ZScsIHByZXBlbmQgYSBzdGFuZGFyZCBjYW5jZWwgYnV0dG9uIHRvIHRoZSBidXR0b24gbGlzdFxuICogICAgICAgICAgICAgICAgICAgICAgdGhhdCBkaXNtaXNzZXMgdGhlIGN1cnJlbnQgZGlhbG9nLklmIHRoaXMgaXMgYSBmdW5jdGlvbiwgdGhlbiB0aGUgZnVuY3Rpb24gaXMgaW52b2tlZCB3aGVuXG4gKiAgICAgICAgICAgICAgICAgICAgICB0aGUgYnV0dG9uIGlzIHByZXNzZWQgaW5zdGVhZCBvZiBkaXNtaXNzaW5nIHRoZSBkaWFsb2cuXG4gKlxuICogICAgICBvayAgICAgICAgICAgICAgQ29udmVuaWVuY2UgYWxpYXMuIElmIHNldCB0byAndHJ1ZScsIGFwcGVuZCBhIHN0YW5kYXJkIE9LIGJ1dHRvbiB0byB0aGUgYnV0dG9uIGxpc3QgdGhhdFxuICogICAgICAgICAgICAgICAgICAgICAgZGlzbWlzc2VzIHRoZSBjdXJyZW50IGRpYWxvZy4gSWYgdGhpcyBpcyBhIGZ1bmN0aW9uLCB0aGVuIHRoZSBmdW5jdGlvbiBpcyBpbnZva2VkIHdoZW4gdGhlXG4gKiAgICAgICAgICAgICAgICAgICAgICBidXR0b24gaXMgcHJlc3NlZCBpbnN0ZWFkIG9mIGRpc21pc3NpbmcgdGhlIGRpYWxvZy5cbiAqXG4gKiAgICAgICAgICAgICAgICAgICAgICBJdCBpcyBpbXBvcnRhbnQgdG8gbm90ZSB0aGF0IGNhbGxiYWNrIGZvciBhbnkgb2YgdGhlIGJ1dHRvbnMgbXVzdCByZXR1cm4gJ3RydWUnIElGIHRoZXkgd2FudFxuICogICAgICAgICAgICAgICAgICAgICAgdG8ga2VlcCB0aGUgZGlhbG9nIG9wZW4gYWZ0ZXIgdGhlIGNsaWNrIGV2ZW50LlxuICpcbiAqICAgICAgb3BlbiAgICAgICAgICAgIEEgY2FsbGJhY2sgdGhhdCBpcyBpbnZva2VkIHdoZW4gdGhlIGRpYWxvZyBlbGVtZW50IGlzIHZpc2libGUuXG4gKlxuICogICAgICBjcmVhdGUgICAgICAgICAgQSBjYWxsYmFjayB0aGF0IGlzIHRyaWdnZXJlZCB3aGVuIHRoZSBkaWFsb2cgaXMgY3JlYXRlZC5cbiAqXG4gKiAgICAgIGNsb3NlICAgICAgICAgICBBIGNhbGxiYWNrIHRoYXQgaXMgaW52b2tlZCB3aGVuIHRoZSBkaWFsb2cgaXMgZGlzbWlzc2VkLlxuICpcbiAqICAgICAgYmVmb3JlQ2xvc2UgICAgIHRyaWdnZXJlZCB3aGVuIGEgZGlhbG9nIGlzIGFib3V0IHRvIGNsb3NlLiBJZiB0aGUgZnVuY3Rpb24gcmV0dXJucyBmYWxzZSwgdGhlIGRpYWxvZyB3aWxsXG4gKiAgICAgICAgICAgICAgICAgICAgICBub3QgY2xvc2UuXG4gKlxuICovXG5cbi8qXG4gKiBQb3BzIHVwIGEgbW9kYWwgY29uZmlybSBkaWFsb2cgd2l0aCBZZXMgYW5kIE5vIGJ1dHRvbnMuXG4gKiBJdCBhY2NlcHRzOlxuICogICAgICAtIHRpdGxlXG4gKiAgICAgIC0gbWVzc2FnZSAtIGFuIG9wdGlvbmFsIGRldGFpbHMgbWVzc2FnZVxuICogICAgICAtIHF1ZXN0aW9uTWVzc2FnZSAtIGEgcXVlc3Rpb24gbWVzc2FnZVxuICogICAgICAtIGNoZWNrYm94TGFiZWwgLSBpZiBwcmVzZW50LCBhIHNpbmdsZSBjaGVja2JveCBpcyBzaG93biB3aXRoIHRoaXMgbGFiZWwuIEEgYm9vbGVhbiBpcyBwYXNzZWQgdG8gdGhlIG9rXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrOyB0cnVlIGlmIHRoZSBjaGVja2JveCBpcyBjaGVja2VkIGFuZCBmYWxzZSBvdGhlcndpc2UuIEZvciBmb3JtcyBtb3JlXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbXBsaWNhdGVkIHRoYW4gYSBzaW5nbGUgY2hlY2tib3gsIGN1c3RvbUNvbnRyb2xzQ29uc3RydWN0b3Igc2hvdWxkIGJlIHVzZWQgaW5zdGVhZC5cbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgY2hlY2tib3hMYWJlbCBhbmQgY3VzdG9tQ29udHJvbHNDb25zdHJ1Y3RvciBhcmUgbXV0dWFsbHkgZXhjbHVzaXZlLlxuICogICAgICAtIGN1c3RvbUNvbnRyb2xzQ29uc3RydWN0b3IgLSBBIGNvbnN0cnVjdG9yIGZ1bmN0aW9uIHRoYXQgc2hvdWxkIHByb2R1Y2UgYSBrbyBWaWV3TW9kZWwuIFRoZSB2aWV3XG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgIHdpbGwgYmUgYXR0YWNoZWQgdG8gdGhlIGNvbmZpcm0gd2luZG93LiBUaGUgdmlldyBtb2RlbCB3aWxsIGJlIHBhc3NlZCB0byBhbnkgT0sgb3JcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FuY2VsIGNhbGxiYWNrcy4gIFRoaXMgd2lsbCAuZGlzcG9zZSgpIHRoZSByZXN1bHRpbmcgdmlldyBtb2RlbC4gVGhpcyBvcHRpb24gaXNcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgbXV0dWFsbHkgZXhjbHVzaXZlIHdpdGggdGhlIGNoZWNrYm94TGFiZWwgb3B0aW9uLlxuICogICAgICAtIG9rIC0gY2FsbGJhY2sgZm9yIFllcy9PSy5cbiAqICAgICAgLSBva0xhYmVsIC0gZGVmYXVsdCBpcyBZZXMsIGJ1dCB5b3UgY2FuIHBhc3MgeW91ciBvd24uXG4gKiAgICAgIC0gY2FuY2VsIC0gY2FsbGJhY2sgZm9yIE5vL0NhbmNlbFxuICogICAgICAtIGNhbmNlbExhYmVsIC0gZGVmYXVsdCBpcyBObywgYnV0IHlvdSBjYW4gcGFzcyB5b3VyIG93bi5cbiAqL1xuZnVuY3Rpb24gY29uZmlybShvcHRpb25zKSB7XG4gICAgb3B0aW9ucyA9IF8uY2xvbmUob3B0aW9ucyk7XG4gICAgb3B0aW9ucy50ZW1wbGF0ZSA9IG9wdGlvbnMudGVtcGxhdGUgfHwgJ2R4Y29yZS90ZW1wbGF0ZS9kaWFsb2cvY29uZmlybSc7XG4gICAgb3B0aW9ucy5tb2RhbCA9IHRydWU7XG4gICAgb3B0aW9ucy5ub0Nsb3NlID0gdHJ1ZTtcbiAgICBvcHRpb25zLm9rID0gb3B0aW9ucy5vayB8fCB0cnVlO1xuICAgIG9wdGlvbnMub2tMYWJlbCA9IG9wdGlvbnMub2tMYWJlbCB8fCBkeExvY2FsZS5nbHMoJ2J1dHRvbi55ZXMnKTtcbiAgICBvcHRpb25zLmNhbmNlbCA9IG9wdGlvbnMuY2FuY2VsIHx8IHRydWU7XG4gICAgb3B0aW9ucy5jYW5jZWxMYWJlbCA9IG9wdGlvbnMuY2FuY2VsTGFiZWwgfHwgZHhMb2NhbGUuZ2xzKCdidXR0b24ubm8nKTtcbiAgICBvcHRpb25zLmRpYWxvZ0NsYXNzID0gJ2NvbmZpcm1EaWFsb2cnO1xuICAgIG9wdGlvbnMudGl0bGUgPSBvcHRpb25zLnRpdGxlIHx8IGR4TG9jYWxlLmdscygnZ2VuZXJpYy5sYWJlbC5jb25maXJtJyk7XG5cbiAgICBpZiAob3B0aW9ucy5jaGVja2JveExhYmVsICYmIG9wdGlvbnMuY3VzdG9tQ29udHJvbHNDb25zdHJ1Y3Rvcikge1xuICAgICAgICBkeFV0aWwuZmFpbCgnY2hlY2tib3hMYWJlbCBhbmQgY3VzdG9tQ29udHJvbHNDb25zdHJ1Y3RvciBhcmUgbXV0dWFsbHkgZXhjbHVzaXZlIG9wdGlvbnMuJyk7XG4gICAgfVxuXG4gICAgdmFyIGRpYWxvZ09wdGlvbnMgPSB7XG4gICAgICAgIG1lc3NhZ2U6IG9wdGlvbnMubWVzc2FnZSxcbiAgICAgICAgcXVlc3Rpb25NZXNzYWdlOiBvcHRpb25zLnF1ZXN0aW9uTWVzc2FnZSxcbiAgICAgICAgY2hlY2tib3hMYWJlbDogb3B0aW9ucy5jaGVja2JveExhYmVsXG4gICAgfTtcblxuICAgIC8vIENhbGwgdGhlIHNwZWNpZmllZCBjYWxsYmFjayAoaWYgZGVmaW5lZCkgd2l0aCB0aGUgdmlld21vZGVsLCB0aGVuIGRpc3Bvc2Ugdmlld01vZGVsXG4gICAgZnVuY3Rpb24gY2FsbEJhY2tBbmRDbGVhblVwKGNhbGxiYWNrLCB2aWV3TW9kZWwpIHtcbiAgICAgICAgdmFyIHJlc3VsdDtcblxuICAgICAgICBpZiAoXy5pc0Z1bmN0aW9uKGNhbGxiYWNrKSkge1xuICAgICAgICAgICAgcmVzdWx0ID0gY2FsbGJhY2sodmlld01vZGVsKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZpZXdNb2RlbC5kaXNwb3NlKCk7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgdmFyICRkaWFsb2dFbGVtID0gZHhUZW1wbGF0ZS50ZW1wbGF0ZShvcHRpb25zLnRlbXBsYXRlLCBkaWFsb2dPcHRpb25zKTtcblxuICAgIGlmIChvcHRpb25zLmNoZWNrYm94TGFiZWwgJiYgXy5pc0Z1bmN0aW9uKG9wdGlvbnMub2spKSB7XG4gICAgICAgIG9wdGlvbnMub2sgPSBfLndyYXAob3B0aW9ucy5vaywgZnVuY3Rpb24oY2IpIHtcbiAgICAgICAgICAgIHZhciBjaGVja2JveENoZWNrZWQgPSAkZGlhbG9nRWxlbS5maW5kKCcuc2lkLWNvbmZpcm0tY2hlY2tib3gnKS5pcygnOmNoZWNrZWQnKTtcbiAgICAgICAgICAgIHJldHVybiBjYihjaGVja2JveENoZWNrZWQpO1xuICAgICAgICB9KTtcbiAgICB9IGVsc2UgaWYgKG9wdGlvbnMuY3VzdG9tQ29udHJvbHNDb25zdHJ1Y3Rvcikge1xuICAgICAgICB2YXIgdmlld01vZGVsID0gbmV3IG9wdGlvbnMuY3VzdG9tQ29udHJvbHNDb25zdHJ1Y3RvcigpO1xuICAgICAgICB2YXIgdmlldyA9IHZpZXdNb2RlbC5hdHRhY2hWaWV3KCk7XG4gICAgICAgICRkaWFsb2dFbGVtLmZpbmQoJy5zaWQtb3B0aW9uYWwtY29udHJvbHMnKS5hcHBlbmQodmlldyk7XG4gICAgICAgIG9wdGlvbnMub2sgPSBfLmJpbmQoY2FsbEJhY2tBbmRDbGVhblVwLCB1bmRlZmluZWQsIG9wdGlvbnMub2ssIHZpZXdNb2RlbCk7XG4gICAgICAgIG9wdGlvbnMuY2FuY2VsID0gXy5iaW5kKGNhbGxCYWNrQW5kQ2xlYW5VcCwgdW5kZWZpbmVkLCBvcHRpb25zLmNhbmNlbCwgdmlld01vZGVsKTtcbiAgICB9XG5cbiAgICBvcHRpb25zLmNvbnRlbnQgPSAkZGlhbG9nRWxlbTtcblxuICAgIHJldHVybiBfc2hvdyhvcHRpb25zKTtcbn1cblxuLypcbiAqIFBvcHMgdXAgYSBtb2RhbCBmaWxlIHVwbG9hZCBkaWFsb2cuXG4gKiBUaGUgZGlhbG9nIHdpbGwgbGV0IHRoZSB1c2VyIHBpY2sgYSBmaWxlIHRvIHVwbG9hZC5cbiAqIEl0IGFjY2VwdHM6XG4gKiAgICAgIC0gdGl0bGUgLSB0aGUgdGl0bGUgb2YgdGhlIGRpYWxvZ1xuICogICAgICAtIG1lc3NhZ2UgLSBhbiBvcHRpb25hbCBkZXRhaWxzIG1lc3NhZ2VcbiAqICAgICAgLSB1cGxvYWRVcmwgLSB0aGUgdXJsIHRvIHBvc3QgdGhlIGZpbGUgdXBsb2FkIHRvXG4gKiAgICAgIC0gdXBsb2FkVG9rZW4gLSB0aGUgdXBsb2FkIHRva2VuIHRoYXQncyByZXF1aXJlZCB0byB1cGxvYWQgdGhlIGZpbGVcbiAqICAgICAgLSBjbG9zZSAtIGJvb2xlYW4gdmFsdWUgb3IgY2FsbGJhY2sgZnVuY3Rpb24gZm9yIGNsb3NpbmdcbiAqICAgICAgLSBjYW5jZWwgLSBib29sZWFuIHZhbHVlIG9yIGNhbGxiYWNrIGZ1bmN0aW9uIGZvciBjYW5jZWxcbiAqICAgICAgLSBzdWNjZXNzIC0gY2FsbGJhY2sgZm9yIHN1Y2Nlc3NmdWwgdXBsb2FkaW5nXG4gKiAgICAgIC0gc3RhcnQgLSBjYWxsYmFjayBmb3IgdXBsb2FkaW5nIHN0YXJ0XG4gKiAgICAgIC0gZmFpbCAtIGNhbGxiYWNrIGZvciBmYWlsZWQgdXBsb2FkaW5nXG4gKiBUaGVyZSBtdXN0IG9uZSBvZiBjbG9zZS9jYW5jZWwgb3B0aW9ucyBiZSBzcGVjaWZpZWQuIFNwZWNpZnlpbmcgYm90aCBvZiB0aGVtIGlzIG5vdyBhbGxvd2VkLlxuICovXG5mdW5jdGlvbiB1cGxvYWQob3B0aW9ucykge1xuICAgIG9wdGlvbnMgPSBfLmNsb25lKG9wdGlvbnMpO1xuICAgIG9wdGlvbnMudGVtcGxhdGUgPSBvcHRpb25zLnRlbXBsYXRlIHx8ICdkeGNvcmUvdGVtcGxhdGUvZGlhbG9nL2ZpbGUtdXBsb2FkJztcbiAgICBvcHRpb25zLm1vZGFsID0gdHJ1ZTtcbiAgICBvcHRpb25zLm5vQ2xvc2UgPSB0cnVlO1xuICAgIG9wdGlvbnMub2sgPSBmYWxzZTtcbiAgICBvcHRpb25zLmNhbmNlbCA9IG9wdGlvbnMuY2FuY2VsIHx8IGZhbHNlO1xuICAgIG9wdGlvbnMuY2xvc2UgPSBvcHRpb25zLmNsb3NlIHx8IGZhbHNlO1xuICAgIG9wdGlvbnMuZGlhbG9nQ2xhc3MgPSAnZmlsZVVwbG9hZERpYWxvZyc7XG4gICAgb3B0aW9ucy50aXRsZSA9IG9wdGlvbnMudGl0bGUgfHwgZHhMb2NhbGUuZ2xzKCd3aW5kb3cudGl0bGUuZmlsZVVwbG9hZCcpO1xuXG4gICAgaWYgKG9wdGlvbnMuY2xvc2UgJiYgb3B0aW9ucy5jYW5jZWwpIHtcbiAgICAgICAgZHhVdGlsLmZhaWwoJ0ludmFsaWQgY29uZmlndXJhdGlvbiBmb3IgdXBsb2FkKCkuIE11c3Qgc3BlY2lmeSBvbmx5IG9uZSBvZiBjYW5jZWwvY2xvc2Ugb3B0aW9ucycpO1xuICAgIH1cblxuICAgIGlmICghb3B0aW9ucy5jbG9zZSAmJiAhb3B0aW9ucy5jYW5jZWwpIHtcbiAgICAgICAgZHhVdGlsLmZhaWwoJ0ludmFsaWQgY29uZmlndXJhdGlvbiBmb3IgdXBsb2FkKCkuIE11c3Qgc3BlY2lmeSBvbmUgb2YgY2FuY2VsL2Nsb3NlIG9wdGlvbnMnKTtcbiAgICB9XG5cbiAgICB2YXIgdXBsb2FkVmlld01vZGVsID0ge1xuICAgICAgICBwcm9ncmVzczoga28ub2JzZXJ2YWJsZSgwKSxcbiAgICAgICAgcHJvZ3Jlc3NUZXh0OiBrby5vYnNlcnZhYmxlKCcnKSxcbiAgICAgICAgZXJyb3JUZXh0OiBrby5vYnNlcnZhYmxlKCcnKSxcbiAgICAgICAgdXBsb2FkU3RhcnRlZDoga28ub2JzZXJ2YWJsZShmYWxzZSlcbiAgICB9O1xuXG4gICAgdmFyIGRpYWxvZ0VsZW0gPSBkeFRlbXBsYXRlLnRlbXBsYXRlKG9wdGlvbnMudGVtcGxhdGUsIHtcbiAgICAgICAgbWVzc2FnZTogb3B0aW9ucy5tZXNzYWdlLFxuICAgICAgICBxdWVzdGlvbk1lc3NhZ2U6IG9wdGlvbnMucXVlc3Rpb25NZXNzYWdlLFxuICAgICAgICB2bTogdXBsb2FkVmlld01vZGVsXG4gICAgfSk7XG4gICAgdmFyIGZvcm0gPSBkaWFsb2dFbGVtLmZpbmQoJ2Zvcm0nKTtcbiAgICB2YXIganFYSFI7XG4gICAgZm9ybS5maWxldXBsb2FkKHtcbiAgICAgICAgdXJsOiBvcHRpb25zLnVwbG9hZFVybCxcbiAgICAgICAgZGF0YVR5cGU6ICdqc29uJyxcbiAgICAgICAgZm9ybURhdGE6IHtcbiAgICAgICAgICAgIHRva2VuOiBvcHRpb25zLnVwbG9hZFRva2VuXG4gICAgICAgIH0sXG4gICAgICAgIGRvbmU6IGZ1bmN0aW9uKGUsIGRhdGEpIHtcbiAgICAgICAgICAgIGpxWEhSID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgaWYgKGRhdGEucmVzdWx0LnN0YXR1cyA9PT0gJ09LJykge1xuICAgICAgICAgICAgICAgIHVwbG9hZFZpZXdNb2RlbC5wcm9ncmVzcygxMDApO1xuICAgICAgICAgICAgICAgIHVwbG9hZFZpZXdNb2RlbC5wcm9ncmVzc1RleHQoZHhMb2NhbGUuZ2xzKCd3aW5kb3cuZmlsZVVwbG9hZC5wcm9ncmVzcy5kb25lJykpO1xuICAgICAgICAgICAgICAgIGlmIChvcHRpb25zLnN1Y2Nlc3MpIHtcbiAgICAgICAgICAgICAgICAgICAgb3B0aW9ucy5zdWNjZXNzKGRhdGEucmVzdWx0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGR4VXRpbC53YXJuKCdGaWxlIHVwbG9hZCBmYWlsZWQuJyk7XG4gICAgICAgICAgICAgICAgdXBsb2FkVmlld01vZGVsLnByb2dyZXNzVGV4dChkeExvY2FsZS5nbHMoJ3dpbmRvdy5maWxlVXBsb2FkLnByb2dyZXNzLmVycm9yJykpO1xuICAgICAgICAgICAgICAgIHVwbG9hZFZpZXdNb2RlbC5lcnJvclRleHQoKCFfLmlzVW5kZWZpbmVkKGRhdGEucmVzdWx0LmVycm9yKSkgP1xuICAgICAgICAgICAgICAgICAgICBkYXRhLnJlc3VsdC5lcnJvci5kZXRhaWxzIDogJycpO1xuICAgICAgICAgICAgICAgIGlmIChvcHRpb25zLmZhaWwpIHtcbiAgICAgICAgICAgICAgICAgICAgb3B0aW9ucy5mYWlsKGRhdGEucmVzdWx0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIGZhaWw6IGZ1bmN0aW9uKGUsIGRhdGEpIHtcblxuICAgICAgICAgICAgLy8gZG9uJ3QgaGFuZGxlIGV2ZW50IGlmIHVwbG9hZCB3YXMgY2FuY2VsbGVkIChhYm9ydGVkKVxuICAgICAgICAgICAgaWYgKGRhdGEuZXJyb3JUaHJvd24gIT09ICdhYm9ydCcpIHtcbiAgICAgICAgICAgICAgICBqcVhIUiA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICB1cGxvYWRWaWV3TW9kZWwucHJvZ3Jlc3NUZXh0KGR4TG9jYWxlLmdscygnd2luZG93LmZpbGVVcGxvYWQucHJvZ3Jlc3MuZXJyb3InKSk7XG4gICAgICAgICAgICAgICAgaWYgKG9wdGlvbnMuZmFpbCkge1xuICAgICAgICAgICAgICAgICAgICBvcHRpb25zLmZhaWwoZGF0YS5yZXN1bHQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgcHJvZ3Jlc3NhbGw6IGZ1bmN0aW9uKGUsIGRhdGEpIHtcbiAgICAgICAgICAgIHZhciBwcm9ncmVzcyA9IHBhcnNlSW50KGRhdGEubG9hZGVkIC8gZGF0YS50b3RhbCAqIDEwMCwgMTApO1xuICAgICAgICAgICAgdXBsb2FkVmlld01vZGVsLnByb2dyZXNzKHByb2dyZXNzKTtcbiAgICAgICAgICAgIHVwbG9hZFZpZXdNb2RlbC5wcm9ncmVzc1RleHQoZHhMb2NhbGUuZ2xzKCd3aW5kb3cuZmlsZVVwbG9hZC5wcm9ncmVzcy5jb21wbGV0ZWQnLCBbcHJvZ3Jlc3NdKSk7XG4gICAgICAgIH0sXG4gICAgICAgIGFkZDogZnVuY3Rpb24oZSwgZGF0YSkge1xuICAgICAgICAgICAgZGlhbG9nRWxlbS5maW5kKCdmb3JtJykuaGlkZSgpO1xuICAgICAgICAgICAganFYSFIgPSBkYXRhLnN1Ym1pdCgpO1xuICAgICAgICB9LFxuICAgICAgICBzdGFydDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB1cGxvYWRWaWV3TW9kZWwucHJvZ3Jlc3MoMCk7XG4gICAgICAgICAgICB1cGxvYWRWaWV3TW9kZWwucHJvZ3Jlc3NUZXh0KCcnKTtcbiAgICAgICAgICAgIHVwbG9hZFZpZXdNb2RlbC51cGxvYWRTdGFydGVkKHRydWUpO1xuICAgICAgICAgICAgdXBsb2FkVmlld01vZGVsLmVycm9yVGV4dCgnJyk7XG4gICAgICAgICAgICBpZiAob3B0aW9ucy5zdGFydCkge1xuICAgICAgICAgICAgICAgIG9wdGlvbnMuc3RhcnQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgYXV0b1VwbG9hZDogdHJ1ZSxcbiAgICAgICAgbGltaXRNdWx0aUZpbGVVcGxvYWRzOiAxLFxuXG4gICAgICAgIC8vIHByZXZlbnRzIHByb3BhZ2F0aW5nIHByb2dyZXNzYWxsIGV2ZW50IGFmdGVyIGZhaWxlZC9hYm9ydGVkIGV2ZW50XG4gICAgICAgIHJlY2FsY3VsYXRlUHJvZ3Jlc3M6IGZhbHNlXG4gICAgfSk7XG5cbiAgICBvcHRpb25zLmNvbnRlbnQgPSBkaWFsb2dFbGVtO1xuXG4gICAgaWYgKG9wdGlvbnMuY2xvc2UpIHtcbiAgICAgICAgb3B0aW9ucy5idXR0b25zID0gWyB7XG4gICAgICAgICAgICB0ZXh0OiBkeExvY2FsZS5nbHMoJ0dlbmVyYWwuQ2xvc2UnKSxcbiAgICAgICAgICAgIGNsYXNzOiAnYnRuIGJ0bi1jbG9zZSdcbiAgICAgICAgfSBdO1xuICAgICAgICB2YXIgb3JpZ2luYWxDbG9zZSA9IG9wdGlvbnMuY2xvc2U7XG4gICAgICAgIG9wdGlvbnMuY2xvc2UgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgICAgICAgIF8uZWFjaChkaWFsb2dFbGVtLCBrby5jbGVhbk5vZGUpO1xuICAgICAgICAgICAgaWYgKF8uaXNGdW5jdGlvbihvcmlnaW5hbENsb3NlKSkge1xuICAgICAgICAgICAgICAgIG9yaWdpbmFsQ2xvc2UuY2FsbChzZWxmKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBpZiAob3B0aW9ucy5jYW5jZWwpIHtcbiAgICAgICAgdmFyIG9yaWdpbmFsQ2FuY2VsID0gb3B0aW9ucy5jYW5jZWw7XG4gICAgICAgIG9wdGlvbnMuY2FuY2VsID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICAgICAgICBfLmVhY2goZGlhbG9nRWxlbSwga28uY2xlYW5Ob2RlKTtcbiAgICAgICAgICAgIGlmIChqcVhIUikge1xuICAgICAgICAgICAgICAgIGpxWEhSLmFib3J0KCk7XG4gICAgICAgICAgICAgICAganFYSFIgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoXy5pc0Z1bmN0aW9uKG9yaWdpbmFsQ2FuY2VsKSkge1xuICAgICAgICAgICAgICAgIG9yaWdpbmFsQ2FuY2VsLmNhbGwoc2VsZik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgcmV0dXJuIF9zaG93KG9wdGlvbnMpO1xufVxuXG4vKlxuICogUG9wcyB1cCBhIG1vZGFsIGFsZXJ0IGRpYWxvZy5cbiAqIEl0IGFjY2VwdHM6XG4gKiAgICAgIC0gdGl0bGVcbiAqICAgICAgLSBtZXNzYWdlXG4gKiAgICAgIC0gb2sgLSBvcHRpb25hbCBjYWxsYmFjayBmb3IgT0suXG4gKi9cbmZ1bmN0aW9uIGFsZXJ0KG9wdGlvbnMpIHtcbiAgICBvcHRpb25zID0gXy5jbG9uZShvcHRpb25zKTtcbiAgICBvcHRpb25zLnRlbXBsYXRlID0gb3B0aW9ucy50ZW1wbGF0ZSB8fCAnZHhjb3JlL3RlbXBsYXRlL2RpYWxvZy9hbGVydCc7XG4gICAgb3B0aW9ucy5tb2RhbCA9IHRydWU7XG4gICAgb3B0aW9ucy5vayA9IG9wdGlvbnMub2sgfHwgdHJ1ZTtcbiAgICBvcHRpb25zLmJ1dHRvbnMgPSBudWxsO1xuICAgIG9wdGlvbnMuY2FuY2VsID0gbnVsbDtcbiAgICBvcHRpb25zLmRpYWxvZ0NsYXNzID0gJ2FsZXJ0RGlhbG9nJztcbiAgICBvcHRpb25zLnRpdGxlID0gb3B0aW9ucy50aXRsZSB8fCBkeExvY2FsZS5nbHMoJ2dlbmVyaWMubGFiZWwuYWxlcnQnKTtcblxuICAgIHZhciBkaWFsb2dFbGVtID0gZHhUZW1wbGF0ZS50ZW1wbGF0ZShvcHRpb25zLnRlbXBsYXRlLCB7XG4gICAgICAgIG1lc3NhZ2U6IG9wdGlvbnMubWVzc2FnZVxuICAgIH0pO1xuXG4gICAgb3B0aW9ucy5jb250ZW50ID0gZGlhbG9nRWxlbTtcbiAgICByZXR1cm4gX3Nob3cob3B0aW9ucyk7XG59XG5cbi8qXG4gKiBQb3BzIHVwIGEgbW9kYWwgZXJyb3IgYWxlcnQgZGlhbG9nLlxuICogSXQgYWNjZXB0czpcbiAqICAgICAgLSB0aXRsZVxuICogICAgICAtIG1lc3NhZ2UgLSB0aGUgZXJyb3IgbWVzc2FnZS5cbiAqICAgICAgLSBlcnJvckNvZGUgLSBlcnJvciBjb2RlIHJldHVybmVkIGJ5IHRoZSBzZXJ2ZXIuXG4gKiAgICAgIC0gc3VnZ2VzdGVkQWN0aW9uIC0gYW55IGFjdGlvbiBzZXJ2ZXIgbWF5IHdhbnQgdG8gc3VnZ2VzdCB0byB0aGUgdXNlci5cbiAqICAgICAgLSBjb21tYW5kT3V0cHV0IC0gb3B0aW9uYWwgY29tbWFuZCBvdXRwdXQsIGlmIGFueS5cbiAqICAgICAgLSBkaWFnbm9zZXMgLSBvcHRpb25hbCBsaXN0IG9mIGRpYWdub3NpbmcgaW5mb3JtYXRpb24sIGlmIGFueS5cbiAqICAgICAgLSBvayAtIG9wdGlvbmFsIGNhbGxiYWNrIGZvciBPSy5cbiAqL1xuZnVuY3Rpb24gZXJyb3JBbGVydChvcHRpb25zKSB7XG4gICAgb3B0aW9ucyA9IF8uY2xvbmUob3B0aW9ucyk7XG4gICAgb3B0aW9ucy50ZW1wbGF0ZSA9IG9wdGlvbnMudGVtcGxhdGUgfHwgJ2R4Y29yZS90ZW1wbGF0ZS9kaWFsb2cvZXJyb3InO1xuICAgIG9wdGlvbnMubW9kYWwgPSB0cnVlO1xuICAgIG9wdGlvbnMub2sgPSBvcHRpb25zLm9rIHx8IHRydWU7XG4gICAgb3B0aW9ucy5idXR0b25zID0gbnVsbDtcbiAgICBvcHRpb25zLmNhbmNlbCA9IG51bGw7XG4gICAgb3B0aW9ucy5kaWFsb2dDbGFzcyA9ICdlcnJvckRpYWxvZyc7XG4gICAgb3B0aW9ucy50aXRsZSA9IG9wdGlvbnMudGl0bGUgfHwgZHhMb2NhbGUuZ2xzKCdnZW5lcmljLmxhYmVsLmVycm9yJyk7XG5cbiAgICBvcHRpb25zLmVycm9yQ29kZSA9IG9wdGlvbnMuZXJyb3JDb2RlIHx8ICcnO1xuICAgIG9wdGlvbnMubWVzc2FnZSA9IG9wdGlvbnMubWVzc2FnZSB8fCAnJztcbiAgICBvcHRpb25zLnN1Z2dlc3RlZEFjdGlvbiA9IG9wdGlvbnMuc3VnZ2VzdGVkQWN0aW9uIHx8ICcnO1xuICAgIG9wdGlvbnMuY29tbWFuZE91dHB1dCA9IG9wdGlvbnMuY29tbWFuZE91dHB1dCA/IG9wdGlvbnMuY29tbWFuZE91dHB1dC5zcGxpdCgnXFxuJykgOiB1bmRlZmluZWQ7XG4gICAgb3B0aW9ucy5kaWFnbm9zZXMgPSBvcHRpb25zLmRpYWdub3NlcyB8fCBbXTtcblxuICAgIHZhciBkaWFsb2dFbGVtID0gZHhUZW1wbGF0ZS50ZW1wbGF0ZShvcHRpb25zLnRlbXBsYXRlLCB7XG4gICAgICAgIG1lc3NhZ2U6IG9wdGlvbnMubWVzc2FnZSxcbiAgICAgICAgZXJyb3JDb2RlOiBvcHRpb25zLmVycm9yQ29kZSxcbiAgICAgICAgc3VnZ2VzdGVkQWN0aW9uOiBvcHRpb25zLnN1Z2dlc3RlZEFjdGlvbixcbiAgICAgICAgY29tbWFuZE91dHB1dDogb3B0aW9ucy5jb21tYW5kT3V0cHV0LFxuICAgICAgICBkaWFnbm9zZXM6IG9wdGlvbnMuZGlhZ25vc2VzXG4gICAgfSk7XG5cbiAgICBvcHRpb25zLmNvbnRlbnQgPSBkaWFsb2dFbGVtO1xuICAgIHZhciBkaWFsb2cgPSBfc2hvdyhvcHRpb25zKTtcblxuICAgIHZhciAkc2Nyb2xsVGFyZ2V0ID0gZGlhbG9nLmZpbmQoJy5zY3JvbGwtdGFyZ2V0Jyk7XG5cbiAgICAvKlxuICAgICAqIEluIHNvbWUgdmVyc2lvbnMgb2YgSUUgc2V0dGluZyAnaGVpZ2h0JyB0byAnYXV0bycgY2FuIHJlc3VsdCBpbiByb3VuZGluZyBlcnJvcnMgd2hpY2ggY2FuIHJlc3VsdCBpblxuICAgICAqIGluY29ycmVjdGx5IHNob3dpbmcgYSBzY3JvbGxiYXIuIERldGVjdCB0aGlzIGJ5IGNoZWNraW5nIGlmIHRoZSBzY3JvbGxIZWlnaHQgaXMgb25lIHBpeGVsIChvciBsZXNzKSBncmVhdGVyXG4gICAgICogdGhhbiB0aGUgaGVpZ2h0LlxuICAgICAqL1xuICAgIGlmICgkc2Nyb2xsVGFyZ2V0Lmxlbmd0aCAhPT0gMCAmJiAkc2Nyb2xsVGFyZ2V0WzBdLnNjcm9sbEhlaWdodCAtICRzY3JvbGxUYXJnZXQuaGVpZ2h0KCkgPiAxKSB7XG5cbiAgICAgICAgLy8gV2Ugc3VwcG9ydCB0d28gZGlmZmVyZW50IHNjcm9sbGJhciBwbHVnaW5zLiBEbyBzaW1wbGUgZmVhdHVyZSBkZXRlY3Rpb24gdG8gZGVjaWRlIHdoaWNoIHRvIHVzZS5cbiAgICAgICAgaWYgKF8uaXNGdW5jdGlvbigkLmZuLmpTY3JvbGxQYW5lKSkge1xuICAgICAgICAgICAgLy8gU2V0dXAgc2Nyb2xsYmFyIGFuZCBzY3JvbGwgdG8gdG9wLiBOb3RlOiBqU2Nyb2xsUGFuZSBuZWVkcyB0aGUgZWxlbWVudCB0byBhbHJlYWR5IGJlIG9uIHNjcmVlblxuICAgICAgICAgICAgJHNjcm9sbFRhcmdldFxuICAgICAgICAgICAgICAgIC5qU2Nyb2xsUGFuZSh7IHNob3dBcnJvd3M6IHRydWUgfSlcbiAgICAgICAgICAgICAgICAuZGF0YSgnanNwJykuc2Nyb2xsVG9ZKDApO1xuICAgICAgICB9IGVsc2UgaWYgKF8uaXNGdW5jdGlvbigkLmZuLnBlcmZlY3RTY3JvbGxiYXIpKSB7XG4gICAgICAgICAgICAkc2Nyb2xsVGFyZ2V0XG4gICAgICAgICAgICAgICAgLnBlcmZlY3RTY3JvbGxiYXIoe1xuICAgICAgICAgICAgICAgICAgICBzdXBwcmVzc1Njcm9sbFg6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgIG1pblNjcm9sbGJhckxlbmd0aDogMjBcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBkaWFsb2c7XG59XG5cbi8qXG4gKiBQb3BzIHVwIGEgbW9kYWwgY29ubmVjdGl2aXR5IGVycm9yIGRpYWxvZyB0aGF0IGRpc3BsYXlzIGEgc2luZ2xlICdsb2dvdXQnIGJ1dHRvbiB0aGF0LCB3aGVuIGNsaWNrZWQsIHdpbGwgbG9nIG91dFxuICogdGhlIHVzZXIuXG4gKlxuICogSXQgYWNjZXB0czpcbiAqICAgICAgLSB0aXRsZVxuICogICAgICAtIG1lc3NhZ2VcbiAqICAgICAgLSBsb2dvdXQgLSBvcHRpb25hbCBjYWxsYmFjayB0byBwZXJmb3JtIHdoZW4gY2xpY2tpbmcgbG9nb3V0LiBJZiBwcm92aWRlZCwgeW91IG11c3QgZG8gdGhlIGxvZ2dpbmcgb3V0IVxuICovXG5mdW5jdGlvbiBjb25uZWN0aXZpdHlFcnJvckFsZXJ0KG9wdGlvbnMpIHtcbiAgICBpZiAoIV8uaXNOdWxsKG1vZHVsZS5leHBvcnRzLm1hbmFnZXIuZ2V0KCdjb25uZWN0aXZpdHktZXJyb3ItYWxlcnQtZGlhbG9nJykpKSB7XG4gICAgICAgIHJldHVybiBtb2R1bGUuZXhwb3J0cy5tYW5hZ2VyLmdldCgnY29ubmVjdGl2aXR5LWVycm9yLWFsZXJ0LWRpYWxvZycpO1xuICAgIH1cblxuICAgIG9wdGlvbnMgPSBfLmNsb25lKG9wdGlvbnMpIHx8IHt9O1xuICAgIG9wdGlvbnMuaWQgPSAnY29ubmVjdGl2aXR5LWVycm9yLWFsZXJ0LWRpYWxvZyc7XG4gICAgb3B0aW9ucy50ZW1wbGF0ZSA9IG9wdGlvbnMudGVtcGxhdGUgfHwgJ2R4Y29yZS90ZW1wbGFkaXNwbGF5RXJyb3JBbGVydHRlL2RpYWxvZy9jb25uZWN0aXZpdHktZXJyb3InO1xuICAgIG9wdGlvbnMubW9kYWwgPSB0cnVlO1xuICAgIG9wdGlvbnMubm9DbG9zZSA9IHRydWU7XG4gICAgb3B0aW9ucy5vayA9IGZhbHNlO1xuICAgIG9wdGlvbnMuYnV0dG9ucyA9IFsge1xuICAgICAgICB0ZXh0OiBkeExvY2FsZS5nbHMoJ2dlbmVyaWMuYWpheC5mYWlsdXJlLmxvZ291dEJ1dHRvbicpLFxuICAgICAgICBpY29uczoge1xuICAgICAgICAgICAgcHJpbWFyeTogJ2ljb24tYnV0dG9uIGljb24tYWNjZXB0J1xuICAgICAgICB9LFxuICAgICAgICBjbGljazogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBpZiAob3B0aW9ucy5sb2dvdXQpIHtcbiAgICAgICAgICAgICAgICBvcHRpb25zLmxvZ291dCgpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBvcHRpb25zLmVuZFNlc3Npb24oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgY2xhc3M6ICdidG4gYnRuLXByaW1hcnknXG4gICAgfV07XG4gICAgb3B0aW9ucy5jYW5jZWwgPSBudWxsO1xuICAgIG9wdGlvbnMuZGlhbG9nQ2xhc3MgPSAnY29ubmVjdGl2aXR5RXJyb3JEaWFsb2cnO1xuICAgIG9wdGlvbnMuY2xvc2VPbkVzY2FwZSA9IGZhbHNlO1xuICAgIG9wdGlvbnMudGl0bGUgPSBvcHRpb25zLnRpdGxlIHx8IGR4TG9jYWxlLmdscygnZ2VuZXJpYy5sYWJlbC5jb25uZWN0aXZpdHlFcnJvcicpO1xuICAgIG9wdGlvbnMuY29udGVudCA9IGR4TG9jYWxlLmdscygnZ2VuZXJpYy5hamF4LnNlcnZlci51bnJlYWNoYWJsZScpO1xuICAgIHJldHVybiBfc2hvdyhvcHRpb25zKTtcbn1cblxuLypcbiAqIFBvcHMgdXAgYSBnZW5lcmljIGRpYWxvZy4gVGhpcyBpcyB0b3RhbGx5IGN1c3RvbWl6YWJsZSBhbmQgYSB1c2VyIGNhbiB1dGlsaXplIGFsbCB0aGUgdW5kZXJseWluZyBqcXVlcnktdWlcbiAqIG9wdGlvbnMgdG8gYnVpbGQgdGhlIGRpYWxvZy4gTm8gY2hlY2tpbmcvY29uc3RyYWluaW5nIGlzIGRvbmUgb24gdGhpcyBmb3JtIG9mIGRpYWxvZy5cbiAqIERldmVsb3BlciBjYW4gcGFzcyBqUXVlcnkgZWxlbWVudHMgaW4gJ2NvbnRlbnQnIGNvbnN0cnVjdCBkaXJlY3RseS4gVGhpcyB3aWxsIGVzc2VudGlhbGx5IGxldCB0aGUgdXNlciBwYXNzIGluXG4gKiBhIGNvbXBpbGVkIHRlbXBsYXRlIHdoaWNoIG1heSBoYXZlIGEgVmlld01vZGVsIHdpdGggb2JzZXJ2YWJsZXMgYXR0YWNoZWQgdG8gaXQuXG4gKi9cbmZ1bmN0aW9uIGRpYWxvZyhvcHRpb25zKSB7XG4gICAgb3B0aW9ucyA9IF8uY2xvbmUob3B0aW9ucyk7XG4gICAgb3B0aW9ucy50ZW1wbGF0ZSA9IG9wdGlvbnMudGVtcGxhdGUgfHwgJ2R4Y29yZS90ZW1wbGF0ZS9kaWFsb2cvZ2VuZXJpYyc7XG4gICAgb3B0aW9ucy50aXRsZSA9IG9wdGlvbnMudGl0bGUgfHwgJ0RlbHBoaXgnO1xuXG4gICAgaWYgKCFvcHRpb25zLmNvbnRlbnQpIHtcbiAgICAgICAgdmFyIGRpYWxvZ0VsZW0gPSBkeFRlbXBsYXRlLnRlbXBsYXRlKG9wdGlvbnMudGVtcGxhdGUsIHtcbiAgICAgICAgICAgIG1lc3NhZ2U6IG9wdGlvbnMubWVzc2FnZVxuICAgICAgICB9KTtcblxuICAgICAgICBvcHRpb25zLmNvbnRlbnQgPSBkaWFsb2dFbGVtO1xuICAgIH1cblxuICAgIHJldHVybiBfc2hvdyhvcHRpb25zKTtcbn1cblxuLypcbiAqIEludGVybmFsIGZ1bmN0aW9uIHRvIGJ1aWxkIGFuZCBzaG93IGEgcG9wLXVwLlxuICovXG5mdW5jdGlvbiBfc2hvdyhvcHRpb25zKSB7XG4gICAgdmFyIGNvbmZpZyA9IG9wdGlvbnMgfHwge307XG4gICAgdmFyIGJ1dHRvbnMgPSBbXTtcblxuICAgIGNvbmZpZy5pZCA9IG9wdGlvbnMuaWQgfHwgZHhVdGlsLm1ha2VVbmlxdWVJZCgnZGlhbG9nJyk7XG4gICAgY29uZmlnLnJlc2l6YWJsZSA9IGZhbHNlO1xuICAgIGNvbmZpZy5jbG9zZVRleHQgPSAnJztcbiAgICBjb25maWcuZGlhbG9nQ2xhc3MgPSAnZGlhbG9nICcgKyAob3B0aW9ucy5kaWFsb2dDbGFzcyB8fCAnJyk7XG4gICAgY29uZmlnLmNsb3NlID0gb3B0aW9ucy5jbG9zZSB8fCBfY2xvc2U7XG4gICAgY29uZmlnLmNyZWF0ZSA9IG9wdGlvbnMuY3JlYXRlIHx8IG51bGw7XG4gICAgY29uZmlnLm9wZW4gPSBvcHRpb25zLm9wZW4gfHwgbnVsbDtcbiAgICBjb25maWcuaGVpZ2h0ID0gb3B0aW9ucy5oZWlnaHQgfHwgJ2F1dG8nO1xuICAgIGNvbmZpZy53aWR0aCA9IG9wdGlvbnMud2lkdGggfHwgJ2F1dG8nO1xuICAgIGNvbmZpZy5tYXhIZWlnaHQgPSBvcHRpb25zLm1heEhlaWdodCB8fCAnYXV0byc7XG4gICAgY29uZmlnLm1heFdpZHRoID0gb3B0aW9ucy5tYXhXaWR0aCB8fCAnYXV0byc7XG4gICAgY29uZmlnLnRpdGxlID0gb3B0aW9ucy50aXRsZSB8fCAnJztcbiAgICBjb25maWcuYmVmb3JlQ2xvc2UgPSBvcHRpb25zLmJlZm9yZUNsb3NlIHx8IG51bGw7XG4gICAgY29uZmlnLm5vQ2xvc2UgPSBjb25maWcubm9DbG9zZSB8fCBmYWxzZTtcblxuICAgIGlmIChjb25maWcubm9DbG9zZSkge1xuICAgICAgICBjb25maWcuZGlhbG9nQ2xhc3MgKz0gJyBuby1jbG9zZSAnO1xuICAgIH1cblxuICAgIHZhciBvbkNsaWNrRnVuY3Rpb24gPSBmdW5jdGlvbihjYWxsYmFjaykge1xuICAgICAgICB2YXIga2VlcERpYWxvZ09wZW4gPSBmYWxzZTtcbiAgICAgICAgaWYgKF8uaXNGdW5jdGlvbihjYWxsYmFjaykpIHtcbiAgICAgICAgICAgIGtlZXBEaWFsb2dPcGVuID0gY2FsbGJhY2soKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChrZWVwRGlhbG9nT3BlbiA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgX2Nsb3NlLmFwcGx5KHRoaXMpO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIF8uZWFjaChjb25maWcuYnV0dG9ucywgZnVuY3Rpb24oYnV0dG9uRGVmKSB7XG4gICAgICAgIGJ1dHRvbnMucHVzaCh7XG4gICAgICAgICAgICB0ZXh0OiBidXR0b25EZWYudGV4dCxcbiAgICAgICAgICAgIGNsaWNrOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICBvbkNsaWNrRnVuY3Rpb24uY2FsbCh0aGlzLCBidXR0b25EZWYuY2xpY2spO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGljb25zOiBidXR0b25EZWYuaWNvbnMgfHwge30sXG4gICAgICAgICAgICBjbGFzczogYnV0dG9uRGVmLmNsYXNzIHx8ICcnXG4gICAgICAgIH0pO1xuICAgIH0pO1xuXG4gICAgLy8gRGVmYXVsdCBjYW5jZWwgYnV0dG9uXG4gICAgaWYgKG9wdGlvbnMuY2FuY2VsKSB7XG4gICAgICAgIGJ1dHRvbnMudW5zaGlmdCh7XG4gICAgICAgICAgICB0ZXh0OiBvcHRpb25zLmNhbmNlbExhYmVsIHx8IGR4TG9jYWxlLmdscygnYnV0dG9uLmNhbmNlbCcpLFxuICAgICAgICAgICAgY2xpY2s6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIG9uQ2xpY2tGdW5jdGlvbi5jYWxsKHRoaXMsIG9wdGlvbnMuY2FuY2VsKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBpY29uczoge1xuICAgICAgICAgICAgICAgIHByaW1hcnk6ICdpY29uLWJ1dHRvbiBpY29uLWJ1dHRvbi1zZXBhcmF0b3IgaWNvbi1jYW5jZWwnXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgY2xhc3M6ICdidG4gc2lkLWNhbmNlbC1idXR0b24nXG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIC8vIERlZmF1bHQgT0sgYnV0dG9uXG4gICAgaWYgKG9wdGlvbnMub2spIHtcbiAgICAgICAgYnV0dG9ucy5wdXNoKHtcbiAgICAgICAgICAgIHRleHQ6IG9wdGlvbnMub2tMYWJlbCB8fCBkeExvY2FsZS5nbHMoJ2J1dHRvbi5vaycpLFxuICAgICAgICAgICAgaWNvbnM6IHtcbiAgICAgICAgICAgICAgICBwcmltYXJ5OiAnaWNvbi1idXR0b24gaWNvbi1idXR0b24tc2VwYXJhdG9yIGljb24tYWNjZXB0J1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGNsaWNrOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICBvbkNsaWNrRnVuY3Rpb24uY2FsbCh0aGlzLCBvcHRpb25zLm9rKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBjbGFzczogJ2J0biBidG4tcHJpbWFyeSBzaWQtYWNjZXB0LWJ1dHRvbidcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgY29uZmlnLmJ1dHRvbnMgPSBidXR0b25zO1xuXG4gICAgdmFyIGRpYWxvZ0NvbnRhaW5lciA9ICQoJzxkaXY+Jyk7XG4gICAgZGlhbG9nQ29udGFpbmVyLmF0dHIoJ2lkJywgY29uZmlnLmlkKTtcbiAgICBkaWFsb2dDb250YWluZXIuYXBwZW5kKG9wdGlvbnMuY29udGVudCk7XG5cbiAgICBtb2R1bGUuZXhwb3J0cy5tYW5hZ2VyLmFkZChkaWFsb2dDb250YWluZXIpO1xuXG4gICAgLypcbiAgICAgKiBJZiB3ZSBoYXZlIG1vZGFsIGRpYWxvZ3Mgb24gZGlzcGxheSwgd2UgY2Fubm90IHBvcC11cCByZWd1bGFyIGRpYWxvZ3MuXG4gICAgICogU28ganVzdCBxdWV1ZSBhbmQgcG9wIHRoZW0gdXAgd2hlbiBhbGwgbW9kYWwgZGlhbG9ncyBhcmUgY2xlYXJlZCBvdXQuXG4gICAgICovXG4gICAgaWYgKG1vZGFsQ291bnRlciA+IDAgJiYgIWNvbmZpZy5tb2RhbCkge1xuICAgICAgICBub25Nb2RhbFdpbmRvd1F1ZXVlLnB1c2goe2RpYWxvZ0NvbnRhaW5lcjogZGlhbG9nQ29udGFpbmVyLCBjb25maWc6IGNvbmZpZ30pO1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICBpZiAoY29uZmlnLm1vZGFsKSB7XG4gICAgICAgIG1vZGFsQ291bnRlcisrO1xuICAgIH1cblxuICAgIHJldHVybiBkaWFsb2dDb250YWluZXIuZGlhbG9nKGNvbmZpZyk7XG59XG5cbi8vIHRha2VzIGRpYWxvZyAoanF1ZXJ5IG5vZGUpIGFzIGlucHV0IGFuZCBhZGRzIGludG8gaXRzIHF1ZXVlIGJhc2VkIG9uIGl0cyBJRC5cbmZ1bmN0aW9uIGFkZChkaWFsb2cpIHtcbiAgICBtb2R1bGUuZXhwb3J0cy5tYW5hZ2VyID0gbW9kdWxlLmV4cG9ydHMubWFuYWdlciB8fCB7fTtcbiAgICB2YXIgZGlhbG9ncyA9IG1vZHVsZS5leHBvcnRzLm1hbmFnZXIuX2RpYWxvZ3MgPSBtb2R1bGUuZXhwb3J0cy5tYW5hZ2VyLl9kaWFsb2dzIHx8IHt9O1xuICAgIHZhciBpZCA9IGRpYWxvZy5hdHRyKCdpZCcpO1xuICAgIGlmICghXy5oYXMoZGlhbG9ncywgaWQpKSB7XG4gICAgICAgIGRpYWxvZ3NbaWRdID0gZGlhbG9nO1xuICAgIH1cbn1cblxuLy8gcmV0dXJucyBiYWNrIHRoZSBkaWFsb2cgKGpxdWVyeSBub2RlKSBnaXZlbiBpdHMgSUQuXG5mdW5jdGlvbiBnZXQoZGlhbG9nSWQpIHtcbiAgICBtb2R1bGUuZXhwb3J0cy5tYW5hZ2VyID0gbW9kdWxlLmV4cG9ydHMubWFuYWdlciB8fCB7fTtcbiAgICB2YXIgZGlhbG9ncyA9IG1vZHVsZS5leHBvcnRzLm1hbmFnZXIuX2RpYWxvZ3MgPSBtb2R1bGUuZXhwb3J0cy5tYW5hZ2VyLl9kaWFsb2dzIHx8IHt9O1xuICAgIGlmIChfLmhhcyhkaWFsb2dzLCBkaWFsb2dJZCkpIHtcbiAgICAgICAgcmV0dXJuIGRpYWxvZ3NbZGlhbG9nSWRdO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbn1cblxuLy8gaW4gY2FzZSB3ZSBuZWVkIHRvIGNsb3NlIGFsbCB0aGUgd2luZG93cyBvbiBzY3JlZW5cbmZ1bmN0aW9uIGNsb3NlQWxsKCkge1xuICAgIG1vZHVsZS5leHBvcnRzLm1hbmFnZXIgPSBtb2R1bGUuZXhwb3J0cy5tYW5hZ2VyIHx8IHt9O1xuICAgIHZhciBkaWFsb2dzID0gbW9kdWxlLmV4cG9ydHMubWFuYWdlci5fZGlhbG9ncyA9IG1vZHVsZS5leHBvcnRzLm1hbmFnZXIuX2RpYWxvZ3MgfHwge307XG4gICAgXy5lYWNoKGRpYWxvZ3MsIGZ1bmN0aW9uKGRpYWxvZywgaWQpIHtcbiAgICAgICAgZGlhbG9nLmRpYWxvZygnZGVzdHJveScpLnJlbW92ZSgpO1xuICAgICAgICBkZWxldGUgZGlhbG9nc1tpZF07XG4gICAgICAgIG1vZGFsQ291bnRlci0tO1xuICAgIH0pO1xufVxuXG4vLyBIaWRlcyB0aGUgY3VycmVudCBkaWFsb2cuIFRoaXMgaGFzIG5vIGVmZmVjdCBpZiB0aGUgZGlhbG9nIGlzIG5vdCBjdXJyZW50bHkgc2hvd24uXG5mdW5jdGlvbiBfY2xvc2UoKSB7XG4gICAgbW9kdWxlLmV4cG9ydHMubWFuYWdlciA9IG1vZHVsZS5leHBvcnRzLm1hbmFnZXIgfHwge307XG4gICAgdmFyIGRpYWxvZ3MgPSBtb2R1bGUuZXhwb3J0cy5tYW5hZ2VyLl9kaWFsb2dzID0gbW9kdWxlLmV4cG9ydHMubWFuYWdlci5fZGlhbG9ncyB8fCB7fTtcblxuICAgIGlmICgkKHRoaXMpLmRpYWxvZygnb3B0aW9uJywgJ21vZGFsJykgJiYgbW9kYWxDb3VudGVyID4gMCkge1xuICAgICAgICBtb2RhbENvdW50ZXItLTtcbiAgICB9XG5cbiAgICAkKHRoaXMpLmRpYWxvZygnY2xvc2UnKTtcblxuICAgIHRyeSB7XG4gICAgICAgIGlmICghJCh0aGlzKS5kaWFsb2coJ2lzT3BlbicpKSB7XG4gICAgICAgICAgICAkKHRoaXMpLnJlbW92ZSgpO1xuICAgICAgICB9XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAvKlxuICAgICAgICAgKiBJbiBzb21lIGluc3RhbmNlcywgZm9yIHJlYXNvbnMgYmV5b25kIG15IGdyYXNwLCB0aGUgalF1ZXJ5LVVJIHN0YWNrIGNhbGxzIGJhY2sgdGhpcyBtZXRob2QgdHdpY2UsIGV2ZW5cbiAgICAgICAgICogd2hlbiBkaWFsb2cgaGFzIGFscmVhZHkgYmVlbiBjbG9zZWQgYW5kIHVuLWluaXRpYWxpemVkLiBTbywgY2FsbGluZyBkaWFsb2coJ2lzT3BlbicpIGluIHN1Y2ggY2FzZXMgd291bGRcbiAgICAgICAgICogdGhyb3cgYW4gZXJyb3IgYmFjay4gVGhpcyB0cnkgY2F0Y2ggaXMgdG8gaGFuZGxlIHN1Y2ggc2NlbmFyaW9zLlxuICAgICAgICAgKi9cbiAgICAgICAgJCh0aGlzKS5yZW1vdmUoKTtcbiAgICB9XG5cbiAgICBkZWxldGUgZGlhbG9nc1t0aGlzLmlkIHx8IHRoaXMuYXR0cignaWQnKV07XG5cbiAgICBpZiAobW9kYWxDb3VudGVyID09PSAwICYmIG5vbk1vZGFsV2luZG93UXVldWUubGVuZ3RoKSB7XG4gICAgICAgIF8uZWFjaChub25Nb2RhbFdpbmRvd1F1ZXVlLCBmdW5jdGlvbihkaWFsb2dTdGF0ZSkge1xuICAgICAgICAgICAgZGlhbG9nU3RhdGUuZGlhbG9nQ29udGFpbmVyLmRpYWxvZyhkaWFsb2dTdGF0ZS5jb25maWcpO1xuICAgICAgICB9KTtcbiAgICAgICAgbm9uTW9kYWxXaW5kb3dRdWV1ZSA9IFtdO1xuICAgIH1cbn1cblxuLypcbiAqIERpYWxvZ3MgY2FuIGJlIHJlZ2lzdGVyZWQgYnkgbmFtZSwgYWxsb3dpbmcgY29uc3VtZXJzIHRvIGRpc3BsYXkgY29udGVudCB3aXRob3V0IG5lZWRpbmcgdG8gY2FsbCBkaXJlY3RseVxuICogaW50byB0aGUgaW1wbGVtZW50YXRpb24uIFRoaXMgaXMganVzdCBhIHdyYXBwZXIgYXJvdW5kIGNhbGxiYWNrIHJlZ2lzdHJhdGlvbi5cbiAqL1xuZnVuY3Rpb24gcmVnaXN0ZXJOYW1lZChwYXRoLCBjYWxsYmFjaykge1xuICAgIGlmICghXy5pc0Z1bmN0aW9uKGNhbGxiYWNrKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2F0dGVtcHQgdG8gcmVnaXN0ZXIgbmFtZWQgZGlhbG9nIFwiJyArIHBhdGggKyAnXCIgd2l0aCBpbnZhbGlkIGNhbGxiYWNrJyk7XG4gICAgfVxuXG4gICAgbmFtZWRNb2RhbFtwYXRoXSA9IGNhbGxiYWNrO1xufVxuXG5mdW5jdGlvbiBzaG93TmFtZWQocGF0aCkge1xuICAgIG5hbWVkTW9kYWxbcGF0aF0oKTtcbn1cblxuLypcbiAqIFdoZW4gZ2l2ZW4gYW4gRXJyb3JSZXN1bHQsIHRoaXMgd2lsbCBkaXNwbGF5IGFuIGVycm9yIGFsZXJ0IHRvIHRoZSB1c2VyXG4gKi9cbmZ1bmN0aW9uIGRpc3BsYXlFcnJvckFsZXJ0KGVycm9yUmVzdWx0KSB7XG4gICAgaWYgKCEoZXJyb3JSZXN1bHQgaW5zdGFuY2VvZiBCYWNrYm9uZS5Nb2RlbCkgfHwgZXJyb3JSZXN1bHQuZ2V0KCd0eXBlJykgIT09ICdFcnJvclJlc3VsdCcpIHtcbiAgICAgICAgZHhVdGlsLmZhaWwoJ2Rpc3BsYXlFcnJvckFsZXJ0IGV4cGVjdHMgYW4gRXJyb3JSZXN1bHQgbW9kZWwgYXMgYW4gYXJndW1lbnQuJyk7XG4gICAgfVxuXG4gICAgLy8gR2V0IHRoZSBBUElFcnJvclxuICAgIHZhciBhcGlFcnJvciA9IGVycm9yUmVzdWx0LmdldCgnZXJyb3InKTtcblxuICAgIG1vZHVsZS5leHBvcnRzLmVycm9yQWxlcnQoe1xuICAgICAgICBtZXNzYWdlOiBkeFVzZXJVdGlsLnByb2Nlc3NFcnJvclJlc3VsdERldGFpbHMoYXBpRXJyb3IpLFxuICAgICAgICBlcnJvckNvZGU6IGFwaUVycm9yLmdldCgnaWQnKSB8fCAnJyxcbiAgICAgICAgc3VnZ2VzdGVkQWN0aW9uOiBhcGlFcnJvci5nZXQoJ2FjdGlvbicpIHx8ICcnLFxuICAgICAgICBjb21tYW5kT3V0cHV0OiBhcGlFcnJvci5nZXQoJ2NvbW1hbmRPdXRwdXQnKSB8fCAnJ1xuICAgIH0pO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgICBjb25maXJtOiBjb25maXJtLFxuICAgIHVwbG9hZDogdXBsb2FkLFxuICAgIGFsZXJ0OiBhbGVydCxcbiAgICBlcnJvckFsZXJ0OiBlcnJvckFsZXJ0LFxuICAgIGNvbm5lY3Rpdml0eUVycm9yQWxlcnQ6IGNvbm5lY3Rpdml0eUVycm9yQWxlcnQsXG4gICAgZGlhbG9nOiBkaWFsb2csXG4gICAgc2hvd05hbWVkOiBzaG93TmFtZWQsXG4gICAgX3Nob3c6IF9zaG93LFxuICAgIF9jbG9zZTogX2Nsb3NlLFxuICAgIHJlZ2lzdGVyTmFtZWQ6IHJlZ2lzdGVyTmFtZWQsXG4gICAgZGlzcGxheUVycm9yQWxlcnQ6IGRpc3BsYXlFcnJvckFsZXJ0LFxuICAgIC8vIHdpbmRvdyBtYW5hZ2VyIGtlZXBzIHRyYWNrIG9mIGFsbCB0aGUgd2luZG93cyB0aGF0IHBvcC11cFxuICAgIG1hbmFnZXI6IHtcbiAgICAgICAgYWRkOiBhZGQsXG4gICAgICAgIGdldDogZ2V0LFxuICAgICAgICBjbG9zZUFsbDogY2xvc2VBbGwsXG4gICAgICAgIF9kaWFsb2dzOiB7fVxuICAgIH1cbn07XG4iLCIvKlxuICogQ29weXJpZ2h0IChjKSAyMDE0LCAyMDE1IGJ5IERlbHBoaXguIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKi9cblxuLyogZ2xvYmFsIF8sIGtvLCBCYWNrYm9uZSwgalF1ZXJ5ICovXG5cbid1c2Ugc3RyaWN0JztcblxuY29uc3QgZHhTeXN0ZW0gPSByZXF1aXJlKCdkeGNvcmUva28vanMvc3lzdGVtLmpzJyksXG4gICAgZHhVdGlsID0gcmVxdWlyZSgnZHhjb3JlL2pzL3V0aWwuanMnKSxcbiAgICBkeERhdGEgPSByZXF1aXJlKCdkeGNvcmUvZGF0YS9qcy9pbmRleC5qcycpLFxuICAgIGR4Q29tcGxleE9ic2VydmFibGVBdHRycyA9IHJlcXVpcmUoJ2R4Y29yZS9rby9qcy9Db21wbGV4T2JzZXJ2YWJsZUF0dHJpYnV0ZXMuanMnKSxcbiAgICBkeE9ic2VydmFibGVBdHRyID0gcmVxdWlyZSgnZHhjb3JlL2tvL2pzL09ic2VydmFibGVBdHRyaWJ1dGUuanMnKSxcbiAgICBkeFByb3h5ID0gcmVxdWlyZSgnZHhjb3JlL2RhdGEvZGVscGhpeC9qcy9wcm94eS5qcycpLFxuICAgIGR4T3BlcmF0aW9uID0gcmVxdWlyZSgnZHhjb3JlL2tvL2pzL29wZXJhdGlvbi5qcycpO1xuXG4vKlxuICogU2VydmVyT2JqZWN0KHJlZmVyZW5jZSwgdHlwZSwgb3B0aW9ucylcbiAqID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIENyZWF0ZXMgYW4gb2JqZWN0IHRoYXQgY29udGFpbnMgYSBzZXQgb2Ygb2JzZXJ2YWJsZXMgdGhhdCBjb3JyZXNwb25kIHRvIHByb3BlcnRpZXMgb2YgYSBzY2hlbWEgYmFzZWQgb2JqZWN0LiBXaGVuXG4gKiBjYWxsZWQsIHRoaXMgd2lsbCB0cnkgdG8gcmV0cmlldmUgYW4gb2JqZWN0IGZyb20gdGhlIHNlcnZlciB3aXRoIHRoZSBzcGVjaWZpZWQgcmVmZXJlbmNlIGFuZCB0aGUgc3BlY2lmaWVkIHJvb3QgdHlwZSxcbiAqIGFuZCB0aGVuIHNldCB1cCBhbiBvYnNlcnZhYmxlIGZvciBlYWNoIG9mIGl0cyBwcm9wZXJ0aWVzLCBvciBhIHN1Yi1vYnNlcnZhYmxlIHNlcnZlciBvYmplY3QgZm9yIGFueSBlbWJlZGRlZCBvYmplY3RzLlxuICpcbiAqIFNlcnZlck9iamVjdCBjb25zdHJ1Y3RzIGEgSmF2YXNjcmlwdCBvYmplY3Qgd2l0aCB0aGUgZm9sbG93aW5nIHByb3BlcnRpZXNcbiAqIChub3RlOiB0aGUgZHggcHJlZml4IGlzIHRvIGF2b2lkIGEgbmFtZSBjb25mbGljdCB3aXRoIHRoZSBzY2hlbWEgcHJvcGVydGllcykuXG4gKiAgICBzY2hlbWEtcHJvcHMgICAgICAgICAgICAgICAgOiBEaXNjdXNzZWQgbW9yZSBiZWxvd1xuICogaXQgd2lsbCBhbHNvIGhhdmUgdGhlc2UgZnVuY3Rpb25zLlxuICogICAgZHhEaXNwb3NlICAgICAgICAgICAgICAgICAgIDogQ2xlYW4gdXAgYWxsIGRlcGVuZGVuY2llcyBoZWxkIGJ5IHRoZSBzZXJ2ZXIgb2JqZWN0LlxuICogICAgZHhTZXREZWJ1ZyAgICAgICAgICAgICAgICAgIDogVHVybiBvbiBvciBvZmYgYSBkZWJ1Z2dpbmcgZmxhZy4gYWxsIGRhdGEgdXBkYXRlcyB3aWxsIGJlIHJlcG9ydGVkLlxuICpcbiAqIFRoZSBvcHRpb25zIHBhcmFtZXRlciBtYXkgY29udGFpbiBhbnkgb3Igbm9uZSBvZiB0aGVzZSB2YWx1ZXMuIElmIG5vbmUgYXJlIHByZXNlbnQsIHRoZSBzZXJ2ZXIgb2JqZWN0IHdpbGwgY29udGFpblxuICogYWxsIG9mIHRoZSBwcm9wZXJ0aWVzIGRlZmluZWQgaW4gdGhlIHNlcnZlciBvYmplY3QuXG4gKiAgICBkYXRhTWFwcGluZyAgICAgICAgICAgICAgICAgOiBBIG1hcHBpbmcgb2YgbmFtZXMgdG8gcHJvcGVydHkgcGF0aHMuIEVhY2ggbmFtZSB3aWxsIGJlIGFkZGVkIHRvIHRoZSBzZXJ2ZXIgb2JqZWN0XG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhcyBhIG5ldyBvYnNlcnZhYmxlLCBhbmQgdGhlIHByb3h5IHN5c3RlbSB3aWxsIGJlIHVzZWQgdG8gZ2VuZXJhdGUgdGhlXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlXG4gKiAgICBvbmx5VXNlTWFwcGluZyAgICAgICAgICAgICAgOiBJZiB0cnV0aHksIHRoZSBzZXJ2ZXIgb2JqZWN0IHdpbGwgb25seSBjb250YWluIHZhbHVlcyBkZWZpbmVkIGluIHRoZSBkYXRhIG1hcHBpbmcuXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBPdGhlcndpc2UsIGl0IHdpbGwgY29udGFpbiBhbGwgdGhlIHByb3BlcnRpZXMgZnJvbSBzZXJ2ZXIgb2JqZWN0IHBsdXMgdGhvc2UgZnJvbVxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhlIG1hcHBpbmcuXG4gKiAgICB3cml0ZXIgICAgICAgICAgICAgICAgICAgICAgOiBBIHJvdXRpbmUgcGFzc2VkIHRvIGFsbCBpbmRpdmlkdWFsIGF0dHJpYnV0ZXMuIFByb3ZpZGVzIGEgd2F5IHRvIG1hbmFnZSBhbnkgd3JpdGVzXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0byB0aGVzZSBwcm9wZXJ0aWVzLiBTZWUgT2JzZXJ2YWJsZUF0dHJpYnV0ZSBmb3IgbW9yZSBkZXRhaWxzLlxuICogICAgc3VwcHJlc3NEZWZhdWx0RXJyb3JIYW5kbGVyIDogSWYgdHJ1dGh5LCB0aGUgZGVmYXVsdCBlcnJvciBoYW5kbGVkIGlzIG5vdCB0cmlnZ2VyZWQgb24gZXJyb3JzLlxuICogICAgZGlzcG9zYWxDb250ZXh0ICAgICAgICAgICAgIDogVGhlIGRpc3Bvc2FsIGNvbnRleHQgdGhpcyBzaG91bGQgYmUgYWRkZWQgdG8uIEJ5IGRlZmF1bHQgaXQgd2lsbCBiZSBhZGRlZCB0byB0aGVcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhZ2UgY29udGV4dC5cbiAqXG4gKiBDbGllbnRPYmplY3QodHlwZSwgb3B0aW9ucylcbiAqID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIENyZWF0ZXMgYW4gb2JqZWN0IHRoYXQgY29udGFpbnMgYSBzZXQgb2Ygb2JzZXJ2YWJsZXMgdGhhdCBjb3JyZXNwb25kIHRvIHByb3BlcnRpZXMgaW4gdGhlIHNjaGVtYSBiYXNlZCBvYmplY3QuXG4gKiBUaGlzIGlzIGEgJ2NsaWVudCBvYmplY3QnLCB3aGljaCBtZWFucyBpdCBpcyBub3QgdGllZCB0byB0aGUgc2VydmVyIGluIGFueSB3YXksIGFuZCBjYW4gYmUgZGlyZWN0bHkgcmVhZCBhbmQgd3JpdHRlblxuICogdG8uXG4gKlxuICogbWFrZVNlcnZlck9iamVjdEZyb21Nb2RlbChtb2RlbCwgb3B0aW9ucylcbiAqID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBHaXZlbiBhIG1vZGVsIGFzIHByb3ZpZGVkIGJ5IGRhdGEgcm91dGluZXMsIHJldHVybiBhbiBvYmplY3Qgd2hpY2ggY29udGFpbnMgYW4gb2JzZXJ2YWJsZSBmb3IgZWFjaCBwcm9wZXJ0eVxuICogaW4gdGhlIG1vZGVsLiAgVGhlIG9iamVjdCByZXR1cm5lZCBoYXMgdGhlIHNhbWUgcHJvcGVydGllcyBhcyBkaXNjdXNzZWQgYWJvdmUuIFRoZSBvcHRpb25zIGlzIGFsc28gdGhlIHNhbWUgYXNcbiAqIGRvY3VtZW50ZWQgYWJvdmUuXG4gKi9cblxuLy8gQWRkIGEgc2luZ2xlIHByb3BlcnR5IGZyb20gdGhlIGRhdGEgbWFwcGluZyBvbnRvIHRoZSBzZXJ2ZXIgb2JqZWN0LlxuZnVuY3Rpb24gdXBkYXRlUHJveHlBdHRyaWJ1dGUodGhlT2JqZWN0LCBhdHRyTmFtZSwgcHJveHksIGRpc3Bvc2FsQ29udGV4dCkge1xuICAgIHZhciB2YWx1ZSA9IHByb3h5LmdldChhdHRyTmFtZSk7XG4gICAgdmFyIGV4aXN0aW5nT2JzZXJ2YWJsZSA9IHRoZU9iamVjdFthdHRyTmFtZV07XG5cbiAgICBpZiAoIV8uaXNVbmRlZmluZWQoZXhpc3RpbmdPYnNlcnZhYmxlKSkge1xuICAgICAgICB2YXIgY29udGVudHMgPSBleGlzdGluZ09ic2VydmFibGUucGVlaygpO1xuICAgICAgICBpZiAoY29udGVudHMgJiYgY29udGVudHMuZHhEaXNwb3NlKSB7XG4gICAgICAgICAgICBjb250ZW50cy5keERpc3Bvc2UoKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qXG4gICAgICogSWYgdGhlIHZhbHVlIGlzIGEgYmFja2JvbmUgbW9kZWwsIGFuZCB3aGF0IHdlIGhhdmUgc2V0IHVwIGN1cnJlbnRseSBpc24ndCBhIGJhY2tib25lIG1vZGVsLCB0aGVuIHdyYXAgdGhlIG1vZGVsXG4gICAgICogYXMgYW4gb2JzZXJ2YWJsZSBvYmplY3QuICBUaGlzIGNhbiBoYXBwZW4gaW4gYSBjb3VwbGUgd2F5czogRmlyc3QsIHdoZW4gdGhlIHByb3h5IGlzIGZpcnN0IHNldCB1cCwgdGhlIHByb3h5XG4gICAgICogYXR0cmlidXRlIG1heSBwb2ludCB0byBub3RoaW5nIHlldCwgYW5kIHNvIG1heSBiZSB1bmRlZmluZWQuIFRodXMsIHRoZSBmaXJzdCB0aW1lIHRoaXMgaXMgY2FsbGVkLCB3ZSdkIHNldCB1cFxuICAgICAqIGFuIG9yZGluYXJ5IG9ic2VydmFibGUuIFRoZSBzZWNvbmQgc2l0dWF0aW9uIHdvdWxkIGJlIHdoZXJlIHRoZSBwcm94eSBwb2ludHMgdG8gZGlmZmVyZW50IHR5cGVzIGVhY2ggdGltZSBpdCBpc1xuICAgICAqIHVwZGF0ZWQgKHVubGlrZWx5LCBidXQgcG9zc2libGUpXG4gICAgICovXG4gICAgaWYgKHZhbHVlIGluc3RhbmNlb2YgQmFja2JvbmUuTW9kZWwpIHtcbiAgICAgICAgaWYgKF8uaXNVbmRlZmluZWQoZXhpc3RpbmdPYnNlcnZhYmxlKSkge1xuICAgICAgICAgICAgdGhlT2JqZWN0W2F0dHJOYW1lXSA9IGtvLm9ic2VydmFibGUobWFrZU9iamVjdEZyb21Nb2RlbCh2YWx1ZSwgeyBkaXNwb3NhbENvbnRleHQ6IGRpc3Bvc2FsQ29udGV4dCB9KSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBleGlzdGluZ09ic2VydmFibGUobWFrZU9iamVjdEZyb21Nb2RlbCh2YWx1ZSwgeyBkaXNwb3NhbENvbnRleHQ6IGRpc3Bvc2FsQ29udGV4dCB9KSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8qXG4gICAgICogSW4gY29udHJhc3QsIGlmIHRoZSBjdXJyZW50IG9ic2VydmFibGUgZG9lc24ndCBleGlzdCwgb3IgaXMgYSBtb2RlbCwgd2UnbGwgd2FudCB0byBzZXQgdXAgYW4gb3JkaW5hcnlcbiAgICAgKiBvYnNlcnZhYmxlLlxuICAgICAqL1xuICAgIGlmIChfLmlzVW5kZWZpbmVkKGV4aXN0aW5nT2JzZXJ2YWJsZSkpIHtcbiAgICAgICAgdGhlT2JqZWN0W2F0dHJOYW1lXSA9IGtvLm9ic2VydmFibGUodmFsdWUpO1xuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gTmFoLCBpdCdzIGp1c3QgYW4gb3JkaW5hcnkgb2JzZXJ2YWJsZSwgYW5kIHdlJ3JlIHVwZGF0aW5nIGl0IGluIGFuIG9yZGluYXJ5IHdheS5cbiAgICBleGlzdGluZ09ic2VydmFibGUodmFsdWUpO1xufVxuXG4vLyBmb3IgZWFjaCBkYXRhIG1hcHBlZCBwcm9wZXJ0eSwgc2V0IHVwIGFuIG9ic2VydmFibGUuXG5mdW5jdGlvbiBhZGRQcm94eUF0dHJpYnV0ZXMocHJveHksIHByb3h5RGVmLCB0aGVPYmplY3QsIGRpc3Bvc2FsQ29udGV4dCkge1xuICAgIF8uZWFjaChwcm94eURlZiwgZnVuY3Rpb24odmFsdWUsIG5hbWUpIHtcbiAgICAgICAgdXBkYXRlUHJveHlBdHRyaWJ1dGUodGhlT2JqZWN0LCBuYW1lLCBwcm94eSwgZGlzcG9zYWxDb250ZXh0KTtcbiAgICAgICAgcHJveHkub24oJ2NoYW5nZTonICsgbmFtZSwgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB1cGRhdGVQcm94eUF0dHJpYnV0ZSh0aGVPYmplY3QsIG5hbWUsIHByb3h5LCBkaXNwb3NhbENvbnRleHQpO1xuICAgICAgICAgICAgaWYgKHRoZU9iamVjdC5fZHhEZWJ1Zykge1xuICAgICAgICAgICAgICAgIGR4VXRpbC5kZWJ1ZygnTUFQUEVEIEFUVFIgQ0hBTkdFOiAnICsgbmFtZSArICc9JyArIHByb3h5LmdldChuYW1lKSArICcgSU4gJyArXG4gICAgICAgICAgICAgICAgICAgIEpTT04uc3RyaW5naWZ5KHRoZU9iamVjdC5fZHhNb2RlbC5hdHRyaWJ1dGVzKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sIHRoZU9iamVjdC5fZHhTZWxmSWRlbnRpZmllcik7XG4gICAgfSwgdGhpcyk7XG59XG5cbi8qXG4gKiBJbnZva2UgYW4gb3BlcmF0aW9uLiAgQ29udmVydCBhZ3VtZW50cyB0byBiYWNrYm9uZSBlcXVpdmFsZW50cywgYW5kIGNhbGwgdGhlIGNvcnJlc3BvbmRpbmcgb3BlcmF0aW9uIG9uIHRoZSBtb2RlbFxuICovXG5mdW5jdGlvbiBjYWxsT3BlcmF0aW9uKG1vZGVsLCBvcGVyYXRpb25OYW1lLCBvdGhlckFyZ3MpIHtcbiAgICByZXR1cm4gZHhPcGVyYXRpb24uX2NhbGxPcGVyYXRpb24obW9kZWwsIGlzU2NoZW1hT2JqZWN0LCBtYWtlT2JqZWN0RnJvbU1vZGVsLCBvcGVyYXRpb25OYW1lLCBvdGhlckFyZ3MpO1xufVxuXG4vLyBhZGQgYW4gb2JqZWN0LSBvciBzdGFuZGFyZC1vcGVyYXRpb24gdG8gdGhlIG9iamVjdFxuZnVuY3Rpb24gYWRkT3BlcmF0aW9uKG1vZGVsLCBmdW5jTmFtZSwgdGhlT2JqZWN0KSB7XG4gICAgdGhlT2JqZWN0W2Z1bmNOYW1lXSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gY2FsbE9wZXJhdGlvbihtb2RlbCwgZnVuY05hbWUsIGFyZ3VtZW50cyk7XG4gICAgfTtcbn1cblxuLypcbiAqIEZvciBlYWNoIHByb3BlcnR5IGRlZmluZWQgaW4gdGhlIHNjaGVtYSBvZiB0aGUgbW9kZWwsIHNldCB1cCBhbiBvYnNlcnZhYmxlIGZvciB0aGF0IHByb3BlcnR5LiBXZSB1c2UgdGhlIG5vbi1wdWJsaWNcbiAqIHNjaGVtYSBkZWZpbml0aW9uLCBzaW5jZSB3ZSBjYW4ndCBpbmZlciB0eXBlcyBhY2N1cmF0ZWx5IGp1c3QgYnkgbG9va2luZyBhdCB3aGF0IGlzIGluIG1vZGVsLmF0dHJpYnV0ZXNcbiAqL1xuZnVuY3Rpb24gYWRkU2NoZW1hUHJvcGVydGllcyhtb2RlbCwgb3NvLCBvcHRpb25zKSB7XG4gICAgaWYgKG9wdGlvbnMub25seVVzZU1hcHBpbmcpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIF8uZWFjaChtb2RlbC5fZHhTY2hlbWEucHJvcGVydGllcywgZnVuY3Rpb24ocHJvcERlZiwgcHJvcE5hbWUpIHtcbiAgICAgICAgLy8gRG9uJ3QgcmVwbGFjZSBhbnkgZXhpc3RpbmcgcHJvcHMgKGRhdGEgbWFwcGVkIHByb3BlcnRpZXMgKHRoZXkgdGFrZSBwcmVjZWRlbmNlKSBvciBvbmVzIGFscmVhZHkgYWRkZWQpXG4gICAgICAgIGlmICghXy5pc1VuZGVmaW5lZChvc29bcHJvcE5hbWVdKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgLypcbiAgICAgICAgICogSGVyZSB3ZSBkZWFsIHdpdGggYSBzdHJhbmdlIGNhc2UgdGhhdCByZXF1aXJlcyBzb21lIGV4cGxhbmF0aW9uLCBib3RoIGJlY2F1c2UgaXQgaXMgbm90IG9idmlvdXMsIGFuZCBiZWNhdXNlXG4gICAgICAgICAqIHRoaXMgaXMgbm90IGEgMTAwJSBzb2x1dGlvbi4gIFNvbWUgc2NoZW1hIHR5cGVzIGFyZSBkZWNsYXJlZCBhcyBhcnJheXMgb2YgdHlwZXMgKG1vc3QgcHJvbWluZW50bHksIGxvb2sgYXRcbiAgICAgICAgICogdGhlIHJlc3VsdCBwcm9wZXJ0eSBvZiBPS1Jlc3VsdCkuIEluIHRoZXNlIGNhc2VzLCB3ZSBkb24ndCBuZWNlc3NhcmlseSBrbm93IHdoYXQga2luZCBvZiBvYnNlcnZhYmxlIHRvXG4gICAgICAgICAqIGNyZWF0ZS4gIFdlIGdvIHRocm91Z2ggYSBjb3VwbGUgc3RlcHMgdG8gdHJ5IHRvIGNvcGUgd2l0aCB0aGlzIChzZWUgaW5saW5lIGNvbW1lbnRzIGJlbG93KS5cbiAgICAgICAgICpcbiAgICAgICAgICogT25lIHBvdGVudGlhbCBmbGF3IGluIHRoaXMgcHJvY2VzcyBpcyB0aGF0IHRoaXMgYXNzdW1lcyBhIG1vZGVsIGF0dHJpYnV0ZSBjYW4gbm90IGNoYW5nZSB0eXBlIGR1cmluZyB0aGVcbiAgICAgICAgICogY291cnNlIG9mIHRoZSBtb2RlbCdzIGV4aXN0ZW5jZSAoYW5kIGV2ZW4gdGhlbiwgd2UgZG9uJ3QgY2FyZSBhYm91dCBjaGFuZ2VzIGZyb20sIHNheSwgc3RyaW5nIHRvIG51bGwuIEJ1dFxuICAgICAgICAgKiBqdXN0IGJldHdlZW4gb2JqZWN0cywgYXJyYXlzIGFuZCBzaW1wbGUgdHlwZXMpLiAgVGhlb3JldGljYWx5IHRoaXMgaXMgcG9zc2libGUsIGJ1dCBpbiBwcmFjdGljZSBpdCBkb2Vzbid0XG4gICAgICAgICAqIGhhcHBlbi4gIElmIHlvdSBhcmUgcmVhZGluZyB0aGlzIGNvbW1lbnQgYW5kIGN1cnNpbmcsIGl0IG1lYW5zIHRoYXQgYXNzdW1wdGlvbiBpcyBubyBsb25nZXIgdmFsaWQgYW5kIHlvdSdsbFxuICAgICAgICAgKiBuZWVkIHRvIGNyZWF0ZSBhbiBvYnNlcnZhYmxlIHdoaWNoIGNhbiAnbW9ycGgnLCB3aGljaCBpcyBkb2FibGUgYnV0IGp1c3QgbW9yZSB3b3JrLlxuICAgICAgICAgKlxuICAgICAgICAgKiBPbmUgYWN0dWFsIGZsYXcgaW4gdGhpcyBpcyB0aGF0IGlmIHlvdSB0cnkgdG8gY3JlYXRlIGEgY2xpZW50IG9iamVjdCB0aGF0IGlzIGFuIE9LUmVzdWx0IG9yIGFub3RoZXIgd2hpY2hcbiAgICAgICAgICogaGFzIGFuIGFycmF5IG9yIG9iamVjdCBhcyBvbmUgb2YgdGhlIHBvc3NpYmxlIHR5cGVzIGluIHRoYXQgYXJyYXkgb2YgdHlwZXMsIHRoaXMgd29uJ3QgZXZlciBjcmVhdGUgdGhlXG4gICAgICAgICAqIG9ic2VydmFibGUgZm9yIHRoYXQuXG4gICAgICAgICAqL1xuICAgICAgICB2YXIgdHlwZSA9IHByb3BEZWYudHlwZTtcbiAgICAgICAgaWYgKF8uaXNBcnJheShwcm9wRGVmLnR5cGUpKSB7XG4gICAgICAgICAgICB0eXBlID0gJ3NpbXBsZVZhbHVlJztcblxuICAgICAgICAgICAgLy8gQ2hlY2sgaWYgYSBub24tc2ltcGxlIHR5cGUgZXhpc3RzIGluIHRoZSBhcnJheSBvZiB0eXBlc1xuICAgICAgICAgICAgdmFyIGhhc05vblNpbXBsZVR5cGUgPSBfLmZpbmQocHJvcERlZi50eXBlLCBmdW5jdGlvbihhVHlwZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiAoYVR5cGUgPT09ICdhcnJheScgfHwgYVR5cGUgPT09ICdvYmplY3QnKTtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAvKlxuICAgICAgICAgICAgICogSXQgZG9lcy4gSWYgdGhlIG1vZGVsIGhhcyB1bmRlZmluZWQgZm9yIHRoaXMgcHJvcGVydHksIHRoZW4gd2UganVzdCBkb24ndCBjcmVhdGUgYW4gb2JzZXJ2YWJsZS5cbiAgICAgICAgICAgICAqIEV2ZW50dWFsbHkgdGhpcyB3aWxsIGJlIGNhbGxlZCB3aGVuIHRoZSBtb2RlbCBpcyByZWFkeSwgaW4gd2hpY2ggY2FzZSB3ZSdsbCBoYXZlIGFuIGFjdHVhbCB2YWx1ZS4gSW4gdGhhdFxuICAgICAgICAgICAgICogY2FzZSwgdXNlIHRoYXQgdHlwZSB0byBndWlkZSB0aGUgY29uc3RydWN0aW9uIG9mIHRoZSBvYnNlcnZhYmxlLCBiZWxvdy5cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgaWYgKGhhc05vblNpbXBsZVR5cGUpIHtcbiAgICAgICAgICAgICAgICB2YXIgdmFsdWUgPSBtb2RlbC5nZXQocHJvcE5hbWUpO1xuICAgICAgICAgICAgICAgIGlmIChfLmlzVW5kZWZpbmVkKHZhbHVlKSAmJiAhbW9kZWwuX2R4SXNSZWFkeSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChfLmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgICAgIHR5cGUgPSAnYXJyYXknO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoXy5pc09iamVjdCh2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgdHlwZSA9ICdvYmplY3QnO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgICAgICAgY2FzZSAnYXJyYXknOlxuICAgICAgICAgICAgICAgIG9zb1twcm9wTmFtZV0gPSBkeENvbXBsZXhPYnNlcnZhYmxlQXR0cnMubWFrZU9ic2VydmFibGVBcnJheUF0dHJpYnV0ZShtb2RlbCwgcHJvcE5hbWUsXG4gICAgICAgICAgICAgICAgICAgIG1ha2VPYmplY3RGcm9tTW9kZWwsIG9wdGlvbnMpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnb2JqZWN0JzpcbiAgICAgICAgICAgICAgICAvLyBEb24ndCB1c2UgbW9kZWwgZm9yIGNyZWF0aW5nIEpzb24gb2JqZWN0LCBiZWNhdXNlIHdlIGNvbnNpZGVyIGluc3RhbmNlcyBvZiB0aGlzIHR5cGUgYXMgYmxhY2sgYm94XG4gICAgICAgICAgICAgICAgaWYgKF8uaGFzKHByb3BEZWYsICckcmVmJykgJiYgcHJvcERlZi4kcmVmICE9PSAnSnNvbicpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gT25seSBwYXNzIG9uIGRpc3Bvc2FsQ29udGV4dCwgb3RoZXIgcGFyYW1zIGxpa2UgZGF0YU1hcHBpbmcgZG9uJ3QgYXBwbHkgdG8gY2hpbGRyZW5cbiAgICAgICAgICAgICAgICAgICAgdmFyIG5ld09wdGlvbnMgPSBfLnBpY2sob3B0aW9ucywgJ2Rpc3Bvc2FsQ29udGV4dCcpO1xuXG4gICAgICAgICAgICAgICAgICAgIG9zb1twcm9wTmFtZV0gPSBrby5vYnNlcnZhYmxlKG1ha2VPYmplY3RGcm9tTW9kZWwobW9kZWwuZ2V0KHByb3BOYW1lKSwgbmV3T3B0aW9ucykpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIG9zb1twcm9wTmFtZV0gPSBkeENvbXBsZXhPYnNlcnZhYmxlQXR0cnMubWFrZU9ic2VydmFibGVPYmplY3RBdHRyaWJ1dGUobW9kZWwsIHByb3BOYW1lLFxuICAgICAgICAgICAgICAgICAgICAgICAgbWFrZU9iamVjdEZyb21Nb2RlbCwgb3B0aW9ucyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICBvc29bcHJvcE5hbWVdID0gZHhPYnNlcnZhYmxlQXR0ci5tYWtlT2JzZXJ2YWJsZUF0dHJpYnV0ZShtb2RlbCwgcHJvcE5hbWUsIG9wdGlvbnMpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgfSk7XG5cbiAgICBpZiAoIV8uaGFzKG9wdGlvbnMsICdhZGRPYmplY3RPcEhhbmRsZXJzJykgfHwgb3B0aW9ucy5hZGRPYmplY3RPcEhhbmRsZXJzKSB7XG4gICAgICAgIGZvciAodmFyIHByb3BOYW1lIGluIG1vZGVsKSB7ICAgLy8gY2FuJ3QgdXNlIF8uZWFjaCgpIGFzIGl0IHdvbid0IGdldCB0aGUgdmFsdWVzIGZyb20gdGhlIHByb3RvdHlwZVxuICAgICAgICAgICAgaWYgKHByb3BOYW1lLmNoYXJBdCgwKSA9PT0gJyQnICYmXG4gICAgICAgICAgICAgICAgXy5pc0Z1bmN0aW9uKG1vZGVsW3Byb3BOYW1lXSkgJiZcbiAgICAgICAgICAgICAgICBfLmlzVW5kZWZpbmVkKG9zb1twcm9wTmFtZV0pKSB7XG4gICAgICAgICAgICAgICAgYWRkT3BlcmF0aW9uKG1vZGVsLCBwcm9wTmFtZSwgb3NvKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbn1cblxuZnVuY3Rpb24gc2V0RGVidWcodmFsdWUsIGlkZW50aWZpZXIpIHtcbiAgICB0aGlzLl9keERlYnVnID0gdmFsdWU7XG4gICAgdGhpcy5fZHhEZWJ1Z0lkZW50aWZpZXIgPSBpZGVudGlmaWVyO1xufVxuXG5mdW5jdGlvbiBpbnN0YW5jZU9mKHR5cGVOYW1lKSB7XG4gICAgcmV0dXJuIHRoaXMuX2R4TW9kZWwuaW5zdGFuY2VPZih0eXBlTmFtZSk7XG59XG5cbi8vIENsZWFuIHVwIHRoZSBvYmplY3QsIGJ5IGRpc2Nvbm5lY3RpbmcgYXMgbXVjaCBhcyBwb3NzaWJsZSBzbyBnYyBjYW4gaGFwcGVuIG1vcmUgZWFzaWx5LlxuZnVuY3Rpb24gZGlzcG9zZSgpIHtcbiAgICBpZiAodGhpcy5fZHhEZWJ1Zykge1xuICAgICAgICBkeFV0aWwuZGVidWcoJ0RJU1BPU0lORzogJyArIEpTT04uc3RyaW5naWZ5KHRoaXMuX2R4TW9kZWwgPyB0aGlzLl9keE1vZGVsLmF0dHJpYnV0ZXMgOiAnYWxyZWFkeSBkaXNwb3NlZCcpKTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5fZHhQcm94eSkge1xuICAgICAgICB0aGlzLl9keFByb3h5LnNldE1vZGVsKHVuZGVmaW5lZCk7XG4gICAgICAgIHRoaXMuX2R4UHJveHkub2ZmKHVuZGVmaW5lZCwgdW5kZWZpbmVkLCB0aGlzLl9keFNlbGZJZGVudGlmaWVyKTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5fZHhNb2RlbCkge1xuICAgICAgICB0aGlzLl9keE1vZGVsLm9mZih1bmRlZmluZWQsIHVuZGVmaW5lZCwgdGhpcy5fZHhTZWxmSWRlbnRpZmllcik7XG4gICAgfVxuXG4gICAgXy5lYWNoKHRoaXMsIGZ1bmN0aW9uKGl0ZW0pIHtcbiAgICAgICAgaWYgKGl0ZW0pIHtcbiAgICAgICAgICAgIGlmICghXy5pc1VuZGVmaW5lZChpdGVtLmRpc3Bvc2UpKSB7XG4gICAgICAgICAgICAgICAgaXRlbS5kaXNwb3NlKCk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGlzU2NoZW1hT2JqZWN0KGtvLnVud3JhcChpdGVtKSkpIHtcbiAgICAgICAgICAgICAgICBrby51bndyYXAoaXRlbSkuZHhEaXNwb3NlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9KTtcblxuICAgIHRoaXMuX2R4SXNEaXNwb3NlZCA9IHRydWU7XG59XG5cbmZ1bmN0aW9uIGlzRGlzcG9zZWQoKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIHJldHVybiAhIXNlbGYuX2R4SXNEaXNwb3NlZDtcbn1cblxuLypcbiAqIEdpdmVuIGEgbW9kZWwsIGNvbnN0cnVjdCBhbiBvYmplY3QgZnJvbSBpdC4gT3B0aW9ucyBhcmUgZG9jdW1lbnRlZCBhYm92ZS5cbiAqL1xuZnVuY3Rpb24gY3JlYXRlQ2xpZW50T3JTZXJ2ZXJPYmplY3QodGhlT2JqZWN0LCBiYWNrYm9uZU1vZGVsLCBvcHRpb25zKSB7XG4gICAgdmFyIGRlZmVycmVkID0gbmV3IGpRdWVyeS5EZWZlcnJlZCgpO1xuICAgIHRoZU9iamVjdC5fZHhTZWxmSWRlbnRpZmllciA9IHtcbiAgICAgICAgY2xpZW50U2VydmVyT2JqZWN0czogdHJ1ZSAgIC8vIGhlbHAgaWRlbnRpZnkgd2hhdCBraW5kIG9mIG9iamVjdCBoYXMgYSBob2xkIG9uIHRoZSBtb2RlbFxuICAgIH07XG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cbiAgICAvLyBjaGVjayBhcmdzXG4gICAgaWYgKCFfLmlzVW5kZWZpbmVkKG9wdGlvbnMpICYmICFfLmlzT2JqZWN0KG9wdGlvbnMpKSB7XG4gICAgICAgIGR4VXRpbC5mYWlsKCdPcHRpb25zLCBpZiBwcm92aWRlZCwgbXVzdCBiZSBhbiBvYmplY3QuJyk7XG4gICAgfVxuICAgIGlmICghXy5pc1VuZGVmaW5lZChvcHRpb25zLmRhdGFNYXBwaW5nKSAmJiAhXy5pc09iamVjdChvcHRpb25zLmRhdGFNYXBwaW5nKSkge1xuICAgICAgICBkeFV0aWwuZmFpbCgnRGF0YSBtYXBwaW5nIG11c3QgYmUgYW4gb2JqZWN0LicpO1xuICAgIH1cbiAgICBpZiAoIW9wdGlvbnMuZGF0YU1hcHBpbmcgJiYgb3B0aW9ucy5vbmx5VXNlTWFwcGluZykge1xuICAgICAgICBkeFV0aWwuZmFpbCgnTXVzdCBwcm92aWRlIGEgZGF0YU1hcHBpbmcgd2hlbiBvbmx5VXNlTWFwcGluZyBpcyBzcGVjaWZpZWQuJyk7XG4gICAgfVxuXG4gICAgdGhlT2JqZWN0LmR4RGF0YVJlYWR5ID0gZGVmZXJyZWQucHJvbWlzZSgpO1xuICAgIHRoZU9iamVjdC5keFJlYWR5U3RhdGUgPSBrby5vYnNlcnZhYmxlKCk7XG4gICAgdGhlT2JqZWN0Ll9keE1vZGVsID0gYmFja2JvbmVNb2RlbDtcbiAgICAvLyBidWlsZCB0aGUgcHJveHkgaWYgbmVlZGVkXG4gICAgaWYgKG9wdGlvbnMuZGF0YU1hcHBpbmcpIHtcbiAgICAgICAgdmFyIHByb3h5ID0gZHhQcm94eS5uZXdQcm94eShvcHRpb25zLmRhdGFNYXBwaW5nKTtcbiAgICAgICAgcHJveHkuc2V0TW9kZWwoYmFja2JvbmVNb2RlbCk7XG4gICAgICAgIGFkZFByb3h5QXR0cmlidXRlcyhwcm94eSwgb3B0aW9ucy5kYXRhTWFwcGluZywgdGhlT2JqZWN0LCBvcHRpb25zLmRpc3Bvc2FsQ29udGV4dCk7XG4gICAgICAgIHRoZU9iamVjdC5fZHhQcm94eSA9IHByb3h5O1xuICAgIH1cblxuICAgIC8vIEFkZCB0aGUgbW9kZWwncyBjdXJyZW50IHByb3BlcnRpZXNcbiAgICBhZGRTY2hlbWFQcm9wZXJ0aWVzKGJhY2tib25lTW9kZWwsIHRoZU9iamVjdCwgb3B0aW9ucyk7XG5cbiAgICAvLyByZXBvcnQgb25jZSB0aGUgbW9kZWwgaXMgcmVhZHkgdG8gZ28gKGFuZCB1cGRhdGUgcHJvcGVydGllcyBpbiBjYXNlIHRoZXJlIHdhcyBhIHR5cGUgdXBncmFkZSlcbiAgICBiYWNrYm9uZU1vZGVsLm9uY2UoJ3JlYWR5JywgZnVuY3Rpb24oKSB7XG4gICAgICAgIGFkZFNjaGVtYVByb3BlcnRpZXMoYmFja2JvbmVNb2RlbCwgdGhlT2JqZWN0LCBvcHRpb25zKTtcbiAgICAgICAgYmFja2JvbmVNb2RlbC5vZmYodW5kZWZpbmVkLCB1bmRlZmluZWQsIHRoZU9iamVjdC5fZHhTZWxmSWRlbnRpZmllcik7XG4gICAgICAgIGRlZmVycmVkLnJlc29sdmUodGhlT2JqZWN0KTtcbiAgICAgICAgdGhlT2JqZWN0LmR4UmVhZHlTdGF0ZSh0cnVlKTtcbiAgICB9LCB0aGVPYmplY3QuX2R4U2VsZklkZW50aWZpZXIpO1xuXG4gICAgYmFja2JvbmVNb2RlbC5vbmNlKCdlcnJvcicsIGZ1bmN0aW9uKG1vZGVsLCBlcnJvclJlc3VsdCkge1xuICAgICAgICBiYWNrYm9uZU1vZGVsLm9mZih1bmRlZmluZWQsIHVuZGVmaW5lZCwgdGhlT2JqZWN0Ll9keFNlbGZJZGVudGlmaWVyKTtcbiAgICAgICAgZGVmZXJyZWQucmVqZWN0KGR4T3BlcmF0aW9uLl9wcmVwUmVzdWx0KGVycm9yUmVzdWx0LCBtYWtlT2JqZWN0RnJvbU1vZGVsKSk7XG4gICAgICAgIHRoZU9iamVjdC5keFJlYWR5U3RhdGUoZmFsc2UpO1xuICAgIH0sIHRoZU9iamVjdC5fZHhTZWxmSWRlbnRpZmllcik7XG5cbiAgICBiYWNrYm9uZU1vZGVsLm9uY2UoJ2RlbGV0ZScsIGZ1bmN0aW9uKCkge1xuICAgICAgICB0aGVPYmplY3QuZHhEaXNwb3NlKCk7XG4gICAgfSwgdGhlT2JqZWN0Ll9keFNlbGZJZGVudGlmaWVyKTtcblxuICAgIC8vIERlZmluZSB0aGUgbmV3IHB1YmxpYyBhcGlcbiAgICBfLmV4dGVuZCh0aGVPYmplY3QsIHtcbiAgICAgICAgZHhEaXNwb3NlOiBkaXNwb3NlLFxuICAgICAgICBkeFNldERlYnVnOiBzZXREZWJ1ZyxcbiAgICAgICAgZHhJbnN0YW5jZU9mOiBpbnN0YW5jZU9mLFxuICAgICAgICBkeElzRGlzcG9zZWQ6IGlzRGlzcG9zZWRcbiAgICB9KTtcblxuICAgIGR4U3lzdGVtLmFkZFRvRGlzcG9zYWxDb250ZXh0KHRoZU9iamVjdCwgb3B0aW9ucy5kaXNwb3NhbENvbnRleHQpO1xuXG4gICAgcmV0dXJuIHRoZU9iamVjdDtcbn1cblxuLy8gZ2V0IGEgc2VydmVyIG1vZGVsLCBhbmQgcmV0dXJuIGEgc2VydmVyIG9iamVjdCBhcm91bmQgaXQuXG5mdW5jdGlvbiBTZXJ2ZXJPYmplY3QocmVmZXJlbmNlLCB0eXBlLCBvcHRpb25zKSB7XG4gICAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIFNlcnZlck9iamVjdCkpIHtcbiAgICAgICAgZHhVdGlsLmZhaWwoJ011c3QgY2FsbCB3aXRoIG5ldy4nKTtcbiAgICB9XG4gICAgdmFyIG1vZGVsID0gYXJndW1lbnRzWzNdOyAvLyBpZiB3ZSBwYXNzZWQgYSA0dGggYXJndW1lbnQsIHRoaXMgaXMgYW4gaW50ZXJuYWwgY2FsbCB3aGVyZSB3ZSBhbHJlYWR5IGhhdmUgdGhlIG1vZGVsXG4gICAgaWYgKF8uaXNVbmRlZmluZWQobW9kZWwpKSB7XG4gICAgICAgIHZhciBzdXBwcmVzc0Vycm9ySGFuZGxlciA9IG9wdGlvbnMgJiYgb3B0aW9ucy5zdXBwcmVzc0RlZmF1bHRFcnJvckhhbmRsZXI7XG4gICAgICAgIG1vZGVsID0gZHhEYXRhLmdldFNlcnZlck1vZGVsKHJlZmVyZW5jZSwgdHlwZSwgc3VwcHJlc3NFcnJvckhhbmRsZXIpO1xuICAgIH1cbiAgICByZXR1cm4gY3JlYXRlQ2xpZW50T3JTZXJ2ZXJPYmplY3QodGhpcywgbW9kZWwsIG9wdGlvbnMpO1xufVxuXG5mdW5jdGlvbiBTZXJ2ZXJTaW5nbGV0b25PYmplY3QodHlwZSwgb3B0aW9ucykge1xuICAgIGlmICghKHRoaXMgaW5zdGFuY2VvZiBTZXJ2ZXJTaW5nbGV0b25PYmplY3QpKSB7XG4gICAgICAgIGR4VXRpbC5mYWlsKCdNdXN0IGNhbGwgd2l0aCBuZXcuJyk7XG4gICAgfVxuICAgIHZhciBtb2RlbCA9IGFyZ3VtZW50c1syXTsgLy8gaWYgd2UgcGFzc2VkIGEgM3JkIGFyZ3VtZW50LCB0aGlzIGlzIGFuIGludGVybmFsIGNhbGwgd2hlcmUgd2UgYWxyZWFkeSBoYXZlIHRoZSBtb2RlbFxuICAgIGlmIChfLmlzVW5kZWZpbmVkKG1vZGVsKSkge1xuICAgICAgICB2YXIgc3VwcHJlc3NFcnJvckhhbmRsZXIgPSBvcHRpb25zICYmIG9wdGlvbnMuc3VwcHJlc3NEZWZhdWx0RXJyb3JIYW5kbGVyO1xuICAgICAgICBtb2RlbCA9IGR4RGF0YS5nZXRTZXJ2ZXJTaW5nbGV0b24odHlwZSwgeyBzdXBwcmVzc0RlZmF1bHRFcnJvckhhbmRsZXI6IHN1cHByZXNzRXJyb3JIYW5kbGVyIH0pO1xuICAgIH1cbiAgICByZXR1cm4gY3JlYXRlQ2xpZW50T3JTZXJ2ZXJPYmplY3QodGhpcywgbW9kZWwsIG9wdGlvbnMpO1xufVxuXG4vLyBjcmVhdGUgYSBjbGllbnQgbW9kZWwsIGFuZCByZXR1cm4gYSBjbGllbnQgb2JqZWN0IGFyb3VuZCBpdC5cbmZ1bmN0aW9uIENsaWVudE9iamVjdCh0eXBlLCBvcHRpb25zKSB7XG4gICAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIENsaWVudE9iamVjdCkpIHtcbiAgICAgICAgZHhVdGlsLmZhaWwoJ011c3QgY2FsbCB3aXRoIG5ldy4nKTtcbiAgICB9XG4gICAgdmFyIG1vZGVsID0gYXJndW1lbnRzWzJdOyAvLyBpZiB3ZSBwYXNzZWQgYSAzcmQgYXJndW1lbnQsIHRoaXMgaXMgYW4gaW50ZXJuYWwgY2FsbCB3aGVyZSB3ZSBhbHJlYWR5IGhhdmUgdGhlIG1vZGVsXG4gICAgaWYgKF8uaXNVbmRlZmluZWQobW9kZWwpKSB7XG4gICAgICAgIG1vZGVsID0gZHhEYXRhLm5ld0NsaWVudE1vZGVsKHR5cGUpO1xuICAgIH1cbiAgICByZXR1cm4gY3JlYXRlQ2xpZW50T3JTZXJ2ZXJPYmplY3QodGhpcywgbW9kZWwsIG9wdGlvbnMpO1xufVxuXG4vLyBnaXZlbiBhIG1vZGVsLCByZXR1cm4gdGhlIGFwcHJvcHJpYXRlIHNlcnZlciBvciBjbGllbnQgb2JqZWN0XG5mdW5jdGlvbiBtYWtlT2JqZWN0RnJvbU1vZGVsKG1vZGVsLCBvcHRpb25zKSB7XG4gICAgaWYgKF8uaXNVbmRlZmluZWQobW9kZWwpKSB7XG4gICAgICAgIGR4VXRpbC5mYWlsKCdNdXN0IHByb3ZpZGUgYSBtb2RlbC4nKTtcbiAgICB9XG5cbiAgICAvKlxuICAgICAqIENhbGwgdGhlIHB1YmxpYyBjb25zdHJ1Y3RvciBmdW5jdGlvbnMsIHNvIGZvbGtzIGNhbiBzdGlsbCBkbyBpbnN0YW5jZW9mLCBidXQgdGhlbiBwYXNzIHRoZSBtb2RlbCB3ZSBhbHJlYWR5XG4gICAgICogaGF2ZSBhcyBhIHNlY3JldCBwYXJhbWV0ZXIgdG8gdGhlIGNvbnN0cnVjdG9yIGZ1bmN0aW9ucyBzbyB0aGV5IHdvbid0IHRyeSB0byByZXRyaWV2ZSBhIG5ldyBvbmUuXG4gICAgICovXG4gICAgaWYgKG1vZGVsLmlzU2VydmVyTW9kZWwoKSkge1xuICAgICAgICBpZiAobW9kZWwuX2R4U2NoZW1hLnNpbmdsZXRvbikge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBTZXJ2ZXJTaW5nbGV0b25PYmplY3QodW5kZWZpbmVkLCBvcHRpb25zLCBtb2RlbCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFNlcnZlck9iamVjdCh1bmRlZmluZWQsIHVuZGVmaW5lZCwgb3B0aW9ucywgbW9kZWwpO1xuICAgICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIG5ldyBDbGllbnRPYmplY3QodW5kZWZpbmVkLCBvcHRpb25zLCBtb2RlbCk7XG4gICAgfVxufVxuXG4vKlxuICogSWRlbnRpZmllcyBpZiBhbiBvYmplY3QgaXMgYSBDbGllbnQgb3IgU2VydmVyIE9iamVjdFxuICpcbiAqIFBhcmFtZXRlcnM6XG4gKiAgIHZhbHVlOiBhbnl0aGluZy5cbiAqIFJldHVybjpcbiAqICAgdHJ1ZSBpZiB0aGUgb2JqZWN0IGlzIGFuIGluc3RhbmNlIG9mIFNlcnZlck9iamVjdCwgQ2xpZW50T2JqZWN0IG9yIFNlcnZlclNpbmdsZXRvbk9iamVjdC5cbiAqL1xuZnVuY3Rpb24gaXNTY2hlbWFPYmplY3QodmFsdWUpIHtcblxuICAgIHJldHVybiAodmFsdWUgaW5zdGFuY2VvZiBTZXJ2ZXJPYmplY3QgfHwgdmFsdWUgaW5zdGFuY2VvZiBDbGllbnRPYmplY3QgfHxcbiAgICAgICAgdmFsdWUgaW5zdGFuY2VvZiBTZXJ2ZXJTaW5nbGV0b25PYmplY3QpO1xufVxuXG4vKlxuICogTWFrZSBzdXJlIHRoYXQgdGhlIGhhbmRsZXIgaXMgY2FsbGVkIGF0IGV4YWN0bHkgb25lIHRpbWUgd2hlbiB0aGUgc3BlY2lmaWVkIHNlcnZlck9iamVjdCBpcyBcInJlYWR5XCIuXG4gKi9cbmZ1bmN0aW9uIGNoZWNrQW5kU3Vic2NyaWJlVG9TZXJ2ZXJPYmplY3Qoc2VydmVyT2JqZWN0LCBoYW5kbGVyLCBkaXNwb3NhbENvbnRleHQpIHtcbiAgICBpZiAoIWlzU2NoZW1hT2JqZWN0KHNlcnZlck9iamVjdCkpIHtcbiAgICAgICAgZHhVdGlsLmZhaWwoJ011c3QgY2FsbCBjaGVja0FuZFN1YnNjcmliZVRvU2VydmVyT2JqZWN0KCkgd2l0aCBhIHNjaGVtYSBvYmplY3QuJyk7XG4gICAgfVxuICAgIGlmICghaGFuZGxlcikge1xuICAgICAgICBkeFV0aWwuZmFpbCgnTXVzdCBjYWxsIGNoZWNrQW5kU3Vic2NyaWJlVG9TZXJ2ZXJPYmplY3QoKSB3aXRoIGEgaGFuZGxlci4nKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBwcm9jZXNzUmVzdWx0KCkge1xuICAgICAgICBoYW5kbGVyKHNlcnZlck9iamVjdC5keFJlYWR5U3RhdGUucGVlaygpLCBzZXJ2ZXJPYmplY3QpO1xuICAgIH1cblxuICAgIGlmICghXy5pc1VuZGVmaW5lZChzZXJ2ZXJPYmplY3QuZHhSZWFkeVN0YXRlLnBlZWsoKSkpIHtcbiAgICAgICAgcHJvY2Vzc1Jlc3VsdCgpO1xuICAgICAgICAvLyByZXR1cm4gYSBkdW1teSBzdWJzY3JpcHRpb24gc28gY2FsbGVyIGRvZXMgbm90IG5lZWQgdG8gcHJvdGVjdCBpdHNlbGYgYWdhaW5zdCB1bmRlZmluZWRcbiAgICAgICAgcmV0dXJuIGtvLm9ic2VydmFibGUoKS5zdWJzY3JpYmUoZnVuY3Rpb24gZHVtbXlGdW5jdGlvbigpIHt9KTtcbiAgICB9XG5cbiAgICByZXR1cm4gZHhTeXN0ZW0uc3Vic2NyaWJlT25jZShzZXJ2ZXJPYmplY3QuZHhSZWFkeVN0YXRlLCBwcm9jZXNzUmVzdWx0LCB1bmRlZmluZWQsIHVuZGVmaW5lZCxcbiAgICAgICAgZGlzcG9zYWxDb250ZXh0KTtcbn1cblxuLy8gRGVmaW5lIHRoZSBwdWJsaWMgYXBpXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgICBtYWtlT2JqZWN0RnJvbU1vZGVsOiBtYWtlT2JqZWN0RnJvbU1vZGVsLFxuICAgIFNlcnZlck9iamVjdDogU2VydmVyT2JqZWN0LFxuICAgIFNlcnZlclNpbmdsZXRvbk9iamVjdDogU2VydmVyU2luZ2xldG9uT2JqZWN0LFxuICAgIENsaWVudE9iamVjdDogQ2xpZW50T2JqZWN0LFxuICAgIGlzU2NoZW1hT2JqZWN0OiBpc1NjaGVtYU9iamVjdCxcbiAgICBjaGVja0FuZFN1YnNjcmliZVRvU2VydmVyT2JqZWN0OiBjaGVja0FuZFN1YnNjcmliZVRvU2VydmVyT2JqZWN0XG59O1xuIiwiLypcbiAqIENvcHlyaWdodCAoYykgMjAxNCwgMjAxNSBieSBEZWxwaGl4LiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICovXG5cbi8qIGdsb2JhbCBfLCBrbywgQmFja2JvbmUgKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCBkeFV0aWwgPSByZXF1aXJlKCdkeGNvcmUvanMvdXRpbC5qcycpLFxuICAgIGR4T2JzZXJ2YWJsZUF0dHIgPSByZXF1aXJlKCdkeGNvcmUva28vanMvT2JzZXJ2YWJsZUF0dHJpYnV0ZS5qcycpO1xuXG4vKlxuICogbWFrZU9ic2VydmFibGVBcnJheUF0dHJpYnV0ZVxuICogPT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogQW4gT2JzZXJ2YWJsZUFycmF5QXR0cmlidXRlIGlzIGEgc3BlY2lhbCBvYnNlcnZhYmxlQXJyYXkgdGhhdCB3cmFwcyB1cCBhY2Nlc3MgdG8gYW4gYXJyYXkgYXR0cmlidXRlIG9mIGEgQmFja2JvbmVcbiAqIE1vZGVsLiBEbyBub3QgY3JlYXRlIG9uZSBvZiB0aGVzZSB5b3Vyc2VsZiwgYnV0IGluc3RlYWQgdXNpbmcgaGlnaGVyLWxldmVsIHRoaW5ncyBsaWtlIE9ic2VydmFibGVTZXJ2ZXJPYmplY3RzLlxuICpcbiAqIENyZWF0ZSBhbiBvYnNlcnZhYmxlQXJyYXlBdHRyaWJ1dGUgbGlrZSB0aGlzOlxuICogICBtYWtlT2JzZXJ2YWJsZUFycmF5QXR0cmlidXRlKG15TW9kZWwsICduYW1lJywgbWFrZU9iamVjdEZyb21Nb2RlbClcbiAqIFRoaXMgcmV0dXJucyBhbiBvYnNlcnZhYmxlQXJyYXkgdGhhdCBjYW4gYmUgdXNlZCBlbnRpcmVseSBsaWtlIGFuIG9yZGluYXJ5IG9ic2VydmFibGVBcnJheVxuICogQW55IHRpbWUgdGhlIHVuZGVybHlpbmcgbW9kZWwgaXMgdXBkYXRlZCwgdGhlIG9ic2VydmFibGUgd2lsbCBub3RpY2UgYW5kIG5vdGlmeSBpdHMgc3Vic2NyaWJlcnMuXG4gKlxuICogT2JzZXJ2YWJsZUFycmF5QXR0cmlidXRlcyBoYXZlIHRoZSBzYW1lIHdyaXRpbmcgc2VtYW50aWNzIGFzIGFuIG9ic2VydmFibGVBdHRyaWJ1dGUuIFNlZSB0aGF0IGZvciBtb3JlIGRldGFpbHMuXG4gKiBUaGUgdGh1bWJuYWlsIHZlcnNpb24gaXM6XG4gKiAgLSBDbGllbnQgbW9kZWxzIGFyZSB1cGRhdGVkIGRpcmVjdGx5XG4gKiAgLSBTZXJ2ZXIgbW9kZWxzIHdoZW4gYSB3cml0ZXIgaXMgbm90IHByb3ZpZGVkLCAkJHVwZGF0ZSgpIGlzIGNhbGxlZCBvbiB0aGUgbW9kZWwgd2l0aCB0aGUgcHJvcG9zZWQgbmV3IHZhbHVlIGZvciB0aGVcbiAqICAgIGF0dHJpYnV0ZSAodGhlIGxvY2FsIGRhdGEgaXMgbm90IHVwZGF0ZWQgdW50aWwgdGhlIHNlcnZlciByZXNwb25kcykuXG4gKiAgLSBTZXJ2ZXIgbW9kZWxzLCB3aGVuIGEgd3JpdGVyIGlzIHByb3ZpZGVkLCBjYWxsIHRoZSB3cml0ZXIuICBJbiB0aGlzIGNhc2UsIHRoZSBhcnJheSBwYXNzZWQgdG8gdGhlIHdyaXRlciBtYXlcbiAqICAgIGNvbnRhaW4gb2JzZXJ2YWJsZU9iamVjdHMsIG5vdCB0aGUgYmFja2JvbmUgZXF1aXZhbGVudHMuIFRoZSB3cml0ZXIgY2FuIHJldHVybiBXUklURV9VTkhBTkRMRUQgaW4gb3JkZXIgdG8gZGVmZXJcbiAqICAgIHRvIHRoZSBzdGFuZGFyZCB1cGRhdGUgYmVoYXZpb3JcbiAqXG4gKiBJbiBhZGRpdGlvbiB0byBzdGFuZGFyZCBvYnNlcnZhYmxlIGZ1bmN0aW9ucywgT2JzZXJ2YWJsZUF0dHJpYnV0ZSBhbHNvIGhhcyB0aGVzZSBmdW5jdGlvbnM6XG4gKiAgICBkaXNwb3NlKCkgIDogZGlzcG9zZXMgdGhlIG9ic2VydmFibGUuIFRoaXMgaW5jbHVkZXMgcmVtb3ZpbmcgbGlzdGVuZXIocykgb24gdGhlIG1vZGVsLlxuICogICAgc2V0RGVidWcodmFsdWUsIGlkKSA6IElmIHRoZSB2YWx1ZSBpcyB0cnV0aHksIHRoaXMgd2lsbCBwcmludCBkZWJ1ZyBtZXNzYWdlcyBhdCBrZXkgcGxhY2VzLiAgSWYgYW4gaWQgaXNcbiAqICAgICAgICAgICAgICAgICBwcm92aWRlZCwgZGVidWcgbWVzc2FnZXMgZnJvbSB0aGlzIGluc3RhbmNlIHdpbGwgaW5jbHVkZSB0aGF0IGlkLlxuICpcbiAqIFRoZSBvcHRpb25zIG9iamVjdCBjYW4gYWNjZXB0IHRoZXNlIHZhbHVlczpcbiAqICAgIHdyaXRlciAgICAgOiBhIGZ1bmN0aW9uIHdpdGggdGhlIHNpZ25hdHVyZSB3cml0ZXIob2JzZXJ2YWJsZSwgcHJvcGVydHlOYW1lLCB2YWx1ZSkuIEl0IGlzIHVwIHRvIHRoZSB3cml0ZXIgdG9cbiAqICAgICAgICAgICAgICAgICBoYW5kbGUgYW4gdXBkYXRlIHRvIHRoZSBzcGVjaWZpZWQgcHJvcGVydHkuICBJZiBpdCBjaG9vc2VzIG5vdCB0bywgaXQgY2FuIHJldHVyblxuICogICAgICAgICAgICAgICAgIFdSSVRFX1VOSEFORExFRCwgaW4gd2hpY2ggY2FzZSB0aGUgc3RhbmRhcmQgd3JpdGUgYmVoYXZpb3Igd2lsbCBiZSBpbnZva2VkLlxuICpcbiAqIG1ha2VPYnNlcnZhYmxlT2JqZWN0QXR0cmlidXRlXG4gKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBBbiBPYnNlcnZhYmxlT2JqZWN0QXR0cmlidXRlIGlzIG11Y2ggbGlrZSBhbiBvYnNlcnZhYmxlQXJyYXlBdHRyaWJ1dGUsIGV4Y2VwdCB0aGF0IGl0IG1hbmFnZXMgYW4gb2JqZWN0IGF0dHJpYnV0ZSBvZlxuICogYSBCYWNrYm9uZSBtb2RlbC4gUmVhZGluZyBhbmQgd3JpdGluZyBiZWhhdmlvciwgYXMgd2VsbCBhcyBkaXNwb3NlKCkgYW5kIHNldERlYnVnKCkgYmVoYXZpb3IgaXMgdGhlIHNhbWUgYXMgdGhlXG4gKiBvYnNlcnZhYmxlQXJyYXlBdHRyaWJ1dGUuXG4gKi9cbi8qXG4gKiBDb252ZXJ0cyBhIHZhbHVlICh3aGljaCBtYXkgY29udGFpbiBiYWNrYm9uZSBtb2RlbHMgaW4gdGhlIGVsZW1lbnRzIG9mIGFuIGFycmF5IG9yIHZhbHVlcyBvZiBhbiBvYmplY3QncyBwcm9wZXJ0aWVzKVxuICogaW50byBmb3JtcyB1c2FibGUgYnkgdGhlc2Ugb2JzZXJ2YWJsZXMuIEluIHBhcnRpY3VsYXIsIGJhY2tib25lIG1vZGVscyBhcmUgY29udmVydGVkIGludG8gb2JzZXJ2YWJsZU9iamVjdHMuXG4gKi9cbmZ1bmN0aW9uIHByZXBhcmVWYWx1ZShzb3VyY2VWYWx1ZSwgYXNOb25PYnNlcnZhYmxlLCBkaXNwb3NhbENvbnRleHQsIG1ha2VPYmplY3RGcm9tTW9kZWwpIHtcbiAgICBpZiAoXy5pc0FycmF5KHNvdXJjZVZhbHVlKSkge1xuICAgICAgICB2YXIgbmV3QXJyYXkgPSBfLm1hcChzb3VyY2VWYWx1ZSwgZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgICAgIHJldHVybiBwcmVwYXJlVmFsdWUodmFsdWUsIGZhbHNlLCBkaXNwb3NhbENvbnRleHQsIG1ha2VPYmplY3RGcm9tTW9kZWwpO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuICghYXNOb25PYnNlcnZhYmxlKSA/IGtvLm9ic2VydmFibGVBcnJheShuZXdBcnJheSkgOiBuZXdBcnJheTtcbiAgICB9IGVsc2UgaWYgKF8uaXNPYmplY3Qoc291cmNlVmFsdWUpKSB7XG4gICAgICAgIHZhciByZXN1bHQ7XG4gICAgICAgIGlmIChzb3VyY2VWYWx1ZSBpbnN0YW5jZW9mIEJhY2tib25lLk1vZGVsKSB7XG4gICAgICAgICAgICByZXN1bHQgPSBtYWtlT2JqZWN0RnJvbU1vZGVsKHNvdXJjZVZhbHVlLCB7IGRpc3Bvc2FsQ29udGV4dDogZGlzcG9zYWxDb250ZXh0IH0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdmFyIG5ld09iamVjdCA9IHt9O1xuICAgICAgICAgICAgXy5lYWNoKHNvdXJjZVZhbHVlLCBmdW5jdGlvbih2YWx1ZSwga2V5KSB7XG4gICAgICAgICAgICAgICAgbmV3T2JqZWN0W2tleV0gPSBwcmVwYXJlVmFsdWUodmFsdWUsIGZhbHNlLCBkaXNwb3NhbENvbnRleHQsIG1ha2VPYmplY3RGcm9tTW9kZWwpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXN1bHQgPSBuZXdPYmplY3Q7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gKCFhc05vbk9ic2VydmFibGUpID8ga28ub2JzZXJ2YWJsZShyZXN1bHQpIDogcmVzdWx0O1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiAoIWFzTm9uT2JzZXJ2YWJsZSkgPyBrby5vYnNlcnZhYmxlKHNvdXJjZVZhbHVlKSA6IHNvdXJjZVZhbHVlO1xuICAgIH1cbn1cblxuLypcbiAqIGRpc3Bvc2UgYW55IG1lbWJlcnMgb2YgZWl0aGVyIGFycmF5IG9yIG9iamVjdCB2YWx1ZXMuXG4gKi9cbmZ1bmN0aW9uIGRpc3Bvc2VDdXJyZW50VmFsdWUob2JzZXJ2ZWRWYWx1ZSkge1xuICAgIGlmIChfLmlzT2JqZWN0KG9ic2VydmVkVmFsdWUpKSB7XG4gICAgICAgIF8uZWFjaChvYnNlcnZlZFZhbHVlLCBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICAgICAgdmFsdWUgPSBrby51bndyYXAodmFsdWUpO1xuICAgICAgICAgICAgaWYgKGR4VXRpbC5pc05vbmUodmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAodmFsdWUuZHhEaXNwb3NlKSB7XG4gICAgICAgICAgICAgICAgdmFsdWUuZHhEaXNwb3NlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodmFsdWUuZGlzcG9zZSkge1xuICAgICAgICAgICAgICAgIHZhbHVlLmRpc3Bvc2UoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxufVxuXG4vKlxuICogVGhlIG9iamVjdCBhdHRyaWJ1dGUgaW4gYSBiYWNrYm9uZSBtb2RlbCBoYXMgY2hhbmdlZC4gIFJlYnVpbGQgdGhlIG9iamVjdCB3ZSBhcmUgcHJlc2VudGluZyBhbmQgc2VuZCBub3RpZmljYXRpb25zLlxuICovXG5mdW5jdGlvbiBvYmplY3RBdHRyaWJ1dGVDaGFuZ2VkKCkge1xuICAgIHZhciBzZWxmID0gdGhpcztcblxuICAgIGlmIChzZWxmLl9keERlYnVnKSB7XG4gICAgICAgIHNob3dEZWJ1Z01lc3NhZ2Uoc2VsZiwgJ01vZGVsIGNoYW5nZWQnKTtcbiAgICB9XG4gICAgc2VsZi52YWx1ZVdpbGxNdXRhdGUoKTtcblxuICAgIHZhciBkaXNwb3NhbENvbnRleHQgPSBzZWxmLl9keE9wdGlvbnMgJiYgc2VsZi5fZHhPcHRpb25zLmRpc3Bvc2FsQ29udGV4dDtcblxuICAgIHZhciBiYk9iamVjdCA9IHNlbGYuX2R4TW9kZWwuZ2V0KHNlbGYuX2R4QXR0ck5hbWUpO1xuICAgIGRpc3Bvc2VDdXJyZW50VmFsdWUoc2VsZi5fZHhPYnNlcnZlZFZhbHVlKTtcblxuICAgIHNlbGYuX2R4T2JzZXJ2ZWRWYWx1ZSA9IF8uaXNVbmRlZmluZWQoYmJPYmplY3QpID8ge30gOiBwcmVwYXJlVmFsdWUoYmJPYmplY3QsIHRydWUsIGRpc3Bvc2FsQ29udGV4dCxcbiAgICAgICAgc2VsZi5fbWFrZU9iamVjdEZyb21Nb2RlbCk7XG5cbiAgICBzZWxmLnZhbHVlSGFzTXV0YXRlZCgpO1xufVxuXG4vKlxuICogVGhlIGF0dHJpYnV0ZSBvbiB0aGUgYmFja2JvbmUgbW9kZWwgY2hhbmdlZC4gIHJlc2V0IHRoZSBhcnJheSB0aGlzIG9ic2VydmFibGUgaXMgbWFuYWdpbmcsIGFuZCByZWJ1aWxkIGl0IGZyb20gdGhlXG4gKiBiYWNrYm9uZSBhcnJheVxuICovXG5mdW5jdGlvbiBhcnJheUF0dHJpYnV0ZUNoYW5nZWQoKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gICAgaWYgKHNlbGYuX2R4RGVidWcpIHtcbiAgICAgICAgc2hvd0RlYnVnTWVzc2FnZShzZWxmLCAnTW9kZWwgY2hhbmdlZCcpO1xuICAgIH1cbiAgICBzZWxmLnZhbHVlV2lsbE11dGF0ZSgpO1xuXG4gICAgdmFyIGRpc3Bvc2FsQ29udGV4dCA9IHNlbGYuX2R4T3B0aW9ucyAmJiBzZWxmLl9keE9wdGlvbnMuZGlzcG9zYWxDb250ZXh0O1xuXG4gICAgdmFyIGJiQXJyYXkgPSBzZWxmLl9keE1vZGVsLmdldChzZWxmLl9keEF0dHJOYW1lKTtcbiAgICBkaXNwb3NlQ3VycmVudFZhbHVlKHNlbGYuX2R4T2JzZXJ2ZWRWYWx1ZSk7XG4gICAgc2VsZi5fZHhPYnNlcnZlZFZhbHVlID0gXy5pc1VuZGVmaW5lZChiYkFycmF5KSA/IHVuZGVmaW5lZCA6IHByZXBhcmVWYWx1ZShiYkFycmF5LCB0cnVlLCBkaXNwb3NhbENvbnRleHQsXG4gICAgICAgIHNlbGYuX21ha2VPYmplY3RGcm9tTW9kZWwpO1xuXG4gICAgc2VsZi52YWx1ZUhhc011dGF0ZWQoKTtcbn1cblxuLy8gQ29udmVydCBhbiBhcnJheSwgd2hpY2ggbWF5IGNvbnRhaW4gb2JzZXJ2YWJsZSBvYmplY3RzLCBzbyB3ZSBuZWVkIHRvIGV4dHJhY3QgdGhlIGJhY2tib25lIHZlcnNpb25zIGFuZCBqc29uLWl6ZSB0aGVtXG5mdW5jdGlvbiBqc29uaWZ5KHNvdXJjZVZhbHVlKSB7XG4gICAgc291cmNlVmFsdWUgPSBrby51bndyYXAoc291cmNlVmFsdWUpO1xuICAgIHZhciByZXN1bHQgPSBzb3VyY2VWYWx1ZTtcblxuICAgIGlmIChfLmlzQXJyYXkoc291cmNlVmFsdWUpKSB7XG4gICAgICAgIHJlc3VsdCA9IF8ubWFwKHNvdXJjZVZhbHVlLCBmdW5jdGlvbihlbGVtZW50KSB7XG4gICAgICAgICAgICBlbGVtZW50ID0ga28udW53cmFwKGVsZW1lbnQpO1xuICAgICAgICAgICAgaWYgKGVsZW1lbnQuX2R4TW9kZWwpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZWxlbWVudC5fZHhNb2RlbC50b0pTT04oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBqc29uaWZ5KGVsZW1lbnQpO1xuICAgICAgICB9KTtcbiAgICB9IGVsc2UgaWYgKHNvdXJjZVZhbHVlICYmIF8uaXNPYmplY3Qoc291cmNlVmFsdWUpKSB7XG4gICAgICAgIHJlc3VsdCA9IHt9O1xuICAgICAgICBfLmVhY2goc291cmNlVmFsdWUsIGZ1bmN0aW9uKHZhbHVlLCBrZXkpIHtcbiAgICAgICAgICAgIHJlc3VsdFtrZXldID0gKHZhbHVlICYmIHZhbHVlLl9keE1vZGVsKSA/IHZhbHVlLl9keE1vZGVsLnRvSlNPTigpIDoganNvbmlmeSh2YWx1ZSk7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIHJldHVybiByZXN1bHQ7XG59XG5cbi8vIFdyaXRlIHRoZSBzcGVjaWZpZWQgYXJyYXkgdmFsdWUuXG5mdW5jdGlvbiB3cml0ZUFycmF5VmFsdWUob2JzZXJ2YWJsZSwgdmFsdWUsIG9wdGlvbnMpIHtcbiAgICBpZiAob2JzZXJ2YWJsZS5fZHhEaXNwb3NlZCkge1xuICAgICAgICBkeFV0aWwuZGVidWcob2JzZXJ2YWJsZSwgJ1dyaXRpbmcgdG8gYSBkaXNwb3NlZCBvYnNlcnZhYmxlJyk7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAoIV8uaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgZHhVdGlsLmZhaWwoJ011c3Qgd3JpdGUgYW4gYXJyYXkgdG8gYW4gb2JzZXJ2YWJsZSBhcnJheSBhdHRyaWJ1dGUuJyk7XG4gICAgfVxuXG4gICAgLy8gRG8gYSBzaW1wbGUgY2hlY2sgKGRvbid0IHdvcnJ5IGFib3V0IG5vbi1zaW1wbGUgdmFsdWVzKSB0byB0cnkgdG8gY2F0Y2ggY2FzZXMgd2hlcmUgdGhlIGFycmF5IGRvZXNuJ3QgY2hhbmdlLlxuICAgIGlmIChvYnNlcnZhYmxlLl9keE9ic2VydmVkVmFsdWUgJiYgb2JzZXJ2YWJsZS5fZHhPYnNlcnZlZFZhbHVlLmxlbmd0aCA9PT0gdmFsdWUubGVuZ3RoKSB7XG4gICAgICAgIHZhciBlcXVhbCA9IHRydWU7XG4gICAgICAgIGZvciAodmFyIGluZGV4ID0gMDsgaW5kZXggPCB2YWx1ZS5sZW5ndGg7IGluZGV4KyspIHtcbiAgICAgICAgICAgIGlmICghb2JzZXJ2YWJsZS5lcXVhbGl0eUNvbXBhcmVyKG9ic2VydmFibGUuX2R4T2JzZXJ2ZWRWYWx1ZVtpbmRleF0sIHZhbHVlW2luZGV4XSkpIHtcbiAgICAgICAgICAgICAgICBlcXVhbCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChlcXVhbCkge1xuICAgICAgICAgICAgcmV0dXJuIG9ic2VydmFibGU7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKlxuICAgICAqIGNvbnZlcnQgdGhlIGlucHV0IGFycmF5IGludG8gYSBqc29uIGZvcm0uICBUaGlzIGlzIG5lZWRlZCBzaW5jZSBpZiB0aGVyZSBhcmUgYmFja2JvbmUgbW9kZWxzIGluIHRoZXJlLCB3ZSBjYW4ndFxuICAgICAqIGRpcmVjdGx5IHNldCB0aGVtIG9uIHRoZSBtb2RlbFxuICAgICAqL1xuICAgIHZhciBqc29uQXJyYXkgPSBqc29uaWZ5KHZhbHVlKTtcblxuICAgIGlmIChfLmlzVW5kZWZpbmVkKG9ic2VydmFibGUuX2R4TW9kZWwuaXNTZXJ2ZXJNb2RlbCkgfHwgIW9ic2VydmFibGUuX2R4TW9kZWwuaXNTZXJ2ZXJNb2RlbCgpKSB7XG4gICAgICAgIHNob3dEZWJ1Z01lc3NhZ2Uob2JzZXJ2YWJsZSwgJ0Fib3V0IHRvIHdyaXRlIHRvIGNsaWVudCBtb2RlbCcpO1xuICAgICAgICBvYnNlcnZhYmxlLl9keE1vZGVsLnNldChvYnNlcnZhYmxlLl9keEF0dHJOYW1lLCBqc29uQXJyYXkpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChvcHRpb25zLndyaXRlcikge1xuICAgICAgICAgICAgc2hvd0RlYnVnTWVzc2FnZShvYnNlcnZhYmxlLCAnQWJvdXQgdG8gd3JpdGUgdG8gd3JpdGVyIGZvciBzZXJ2ZXIgbW9kZWwnKTtcbiAgICAgICAgICAgIHZhciB3cml0ZXJSZXN1bHQgPSBvcHRpb25zLndyaXRlcih2YWx1ZSwgb2JzZXJ2YWJsZS5fZHhBdHRyTmFtZSwgb2JzZXJ2YWJsZSk7XG5cbiAgICAgICAgICAgIGlmICh3cml0ZXJSZXN1bHQgIT09IGR4T2JzZXJ2YWJsZUF0dHIuV1JJVEVfVU5IQU5ETEVEKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG9ic2VydmFibGU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAob2JzZXJ2YWJsZS5fZHhNb2RlbC4kJHVwZGF0ZSkge1xuICAgICAgICAgICAgc2hvd0RlYnVnTWVzc2FnZShvYnNlcnZhYmxlLCAnQWJvdXQgdG8gc2VuZCAkJHVwZGF0ZSgpIGZvciBzZXJ2ZXIgbW9kZWwnKTtcbiAgICAgICAgICAgIHZhciBwYXlsb2FkID0ge307XG4gICAgICAgICAgICBwYXlsb2FkW29ic2VydmFibGUuX2R4QXR0ck5hbWVdID0ganNvbkFycmF5O1xuICAgICAgICAgICAgb2JzZXJ2YWJsZS5fZHhNb2RlbC4kJHVwZGF0ZShwYXlsb2FkKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGR4VXRpbC5mYWlsKCdUaGlzIGtpbmQgb2Ygc2VydmVyIG9iamVjdCBoYXMgbm8gdXBkYXRlIHN0YW5kYXJkIG9wZXJhdGlvbi4nKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBvYnNlcnZhYmxlO1xufVxuXG4vLyBXcml0ZSB0aGUgc3BlY2lmaWVkIG9iamVjdCB2YWx1ZS5cbmZ1bmN0aW9uIHdyaXRlT2JqZWN0VmFsdWUob2JzZXJ2YWJsZSwgdmFsdWUsIG9wdGlvbnMpIHtcbiAgICBpZiAob2JzZXJ2YWJsZS5fZHhEaXNwb3NlZCkge1xuICAgICAgICBkeFV0aWwuZGVidWcob2JzZXJ2YWJsZSwgJ1dyaXRpbmcgdG8gYSBkaXNwb3NlZCBvYnNlcnZhYmxlJyk7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKCFfLmlzT2JqZWN0KHZhbHVlKSAmJiAhZHhVdGlsLmlzTm9uZSh2YWx1ZSkpIHtcbiAgICAgICAgZHhVdGlsLmZhaWwoJ09ic2VydmFibGUgdmFsdWUgbXVzdCBiZSBhbiBvYmplY3QuJyk7XG4gICAgfVxuXG4gICAgdmFsdWUgPSBqc29uaWZ5KHZhbHVlKTtcblxuICAgIGlmIChfLmlzVW5kZWZpbmVkKG9ic2VydmFibGUuX2R4TW9kZWwuaXNTZXJ2ZXJNb2RlbCkgfHwgIW9ic2VydmFibGUuX2R4TW9kZWwuaXNTZXJ2ZXJNb2RlbCgpKSB7XG4gICAgICAgIHNob3dEZWJ1Z01lc3NhZ2Uob2JzZXJ2YWJsZSwgJ0Fib3V0IHRvIHdyaXRlIHRvIGNsaWVudCBtb2RlbCcpO1xuICAgICAgICBvYnNlcnZhYmxlLl9keE1vZGVsLnNldChvYnNlcnZhYmxlLl9keEF0dHJOYW1lLCB2YWx1ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKG9wdGlvbnMud3JpdGVyKSB7XG4gICAgICAgICAgICBzaG93RGVidWdNZXNzYWdlKG9ic2VydmFibGUsICdBYm91dCB0byB3cml0ZSB0byB3cml0ZSB0byB3cml0ZXIgZm9yIGEgc2VydmVyIG1vZGVsJyk7XG4gICAgICAgICAgICB2YXIgd3JpdGVyUmVzdWx0ID0gb3B0aW9ucy53cml0ZXIodmFsdWUsIG9ic2VydmFibGUuX2R4QXR0ck5hbWUsIG9ic2VydmFibGUpO1xuICAgICAgICAgICAgaWYgKHdyaXRlclJlc3VsdCAhPT0gZHhPYnNlcnZhYmxlQXR0ci5XUklURV9VTkhBTkRMRUQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gb2JzZXJ2YWJsZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChvYnNlcnZhYmxlLl9keE1vZGVsLiQkdXBkYXRlKSB7XG4gICAgICAgICAgICBzaG93RGVidWdNZXNzYWdlKG9ic2VydmFibGUsICdBYm91dCB0byBzZW5kICQkdXBkYXRlKCkgZm9yIHNlcnZlciBtb2RlbCcpO1xuICAgICAgICAgICAgdmFyIHBheWxvYWQgPSB7fTtcbiAgICAgICAgICAgIHBheWxvYWRbb2JzZXJ2YWJsZS5fZHhBdHRyTmFtZV0gPSB2YWx1ZTtcbiAgICAgICAgICAgIG9ic2VydmFibGUuX2R4TW9kZWwuJCR1cGRhdGUocGF5bG9hZCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBkeFV0aWwuZmFpbCgnVGhpcyBraW5kIG9mIHNlcnZlciBtb2RlbCBoYXMgbm8gdXBkYXRlIHN0YW5kYXJkIG9wZXJhdGlvbi4nKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBvYnNlcnZhYmxlO1xufVxuXG4vKlxuICogQ2FsbCBhbiBhcnJheS1tb2RpZmljYXRpb24gZnVuY3Rpb24gb24gdGhlIG9ic2VydmFibGUgYXJyYXkgYXR0cmlidXRlLiBJZiB0aGUgZnVuY3Rpb24gZXhpc3RzIG9uIEFycmF5LnByb3RvdHlwZSxcbiAqIHVzZSB0aGF0LiBGb3Iga25vY2tvdXQgc3BlY2lmaWMgZnVuY3Rpb25zIHN1Y2ggYXMgZGVzdHJveSgpLCB3ZSBtYWtlIGEgZHVtbXkgb2JzZXJ2YWJsZSB3aXRoIGEgY29weSBvZiB0aGUgY3VycmVudFxuICogYXJyYXkgYW5kIGNhbGwgdGhlIGZ1bmN0aW9uIG9uIHRoZSBkdW1teSBvYnNlcnZhYmxlLiBXZSB0aGVuIGdldCB0aGUgcmVzdWx0aW5nIHZhbHVlIGFuZCBzdGFydCBvdXIgb3duIHdyaXRlIHByb2Nlc3NcbiAqIHdpdGggaXQuXG4gKiBOb3RlIHRoYXQgd2hpbGUgY3JlYXRpbmcgYSBkdW1teSBvYnNlcnZhYmxlIGhhcyBvdmVyaGVhZCwgaXQgaXMgdGhlIHNpbXBsZXN0IHNvbHV0aW9uXG4gKiBmb3IgbWFraW5nIHN1cmUgdGhlcmUgYXJlIG5vIHNpZGUgYWZmZWN0cyBvZiB0aGUgb3BlcmF0aW9uIG9uIG91ciBvd24gb2JzZXJ2YWJsZS5cbiAqL1xuZnVuY3Rpb24gYXJyYXlGdW5jdGlvbigpIHtcbiAgICB2YXIga29PYUZ1bmNOYW1lID0gYXJndW1lbnRzWzBdO1xuICAgIHZhciBuZXdBcnJheTtcbiAgICB2YXIgc2hhbGxvd0NvcHkgPSB0aGlzLl9keE9ic2VydmVkVmFsdWUuc2xpY2UoMCk7XG5cbiAgICBpZiAoXy5pc0Z1bmN0aW9uKEFycmF5LnByb3RvdHlwZVtrb09hRnVuY05hbWVdKSkge1xuICAgICAgICBzaGFsbG93Q29weVtrb09hRnVuY05hbWVdLmFwcGx5KHNoYWxsb3dDb3B5LCBfLnJlc3QoYXJndW1lbnRzLCAxKSk7XG4gICAgICAgIG5ld0FycmF5ID0gc2hhbGxvd0NvcHk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIHRlbXBPYnNlcnZhYmxlID0ga28ub2JzZXJ2YWJsZUFycmF5KHNoYWxsb3dDb3B5KTtcbiAgICAgICAgdGVtcE9ic2VydmFibGVba29PYUZ1bmNOYW1lXS5hcHBseSh0ZW1wT2JzZXJ2YWJsZSwgXy5yZXN0KGFyZ3VtZW50cywgMSkpO1xuICAgICAgICBuZXdBcnJheSA9IHRlbXBPYnNlcnZhYmxlKCk7XG4gICAgfVxuXG4gICAgd3JpdGVBcnJheVZhbHVlKHRoaXMsIG5ld0FycmF5LCB0aGlzLl9keE9wdGlvbnMpO1xufVxuXG4vLyByZXR1cm4gdGhlIGN1cnJlbnQgdmFsdWUgb2YgdGhlIG9ic2VydmFibGUsIHdoaWxlIHNldHRpbmcgdXAga25vY2tvdXQgZGVwZW5kZW5jaWVzXG5mdW5jdGlvbiByZWFkVmFsdWUob2JzZXJ2YWJsZSwgZGVmYXVsdFZhbHVlKSB7XG4gICAga28uZGVwZW5kZW5jeURldGVjdGlvbi5yZWdpc3RlckRlcGVuZGVuY3kob2JzZXJ2YWJsZSk7XG5cbiAgICByZXR1cm4gb2JzZXJ2YWJsZS5fZHhPYnNlcnZlZFZhbHVlIHx8IGRlZmF1bHRWYWx1ZTtcbn1cblxuLy8gUmV0dXJuIHRoZSB2YWx1ZSBvZiB0aGUgdW5kZXJseWluZyBtb2RlbCdzIHByb3BlcnR5IHdpdGhvdXQgc2V0dGluZyB1cCBhbnkga25vY2tvdXQgZGVwZW5kZW5jaWVzLlxuZnVuY3Rpb24gcGVlaygpIHtcbiAgICByZXR1cm4gdGhpcy5fZHhPYnNlcnZlZFZhbHVlO1xufVxuXG4vLyBOb3RpZnkgc3Vic2NyaWJlcnMgdGhhdCB0aGUgb2JzZXJ2YWJsZSdzIHZhbHVlIGlzIGFib3V0IHRvIGNoYW5nZVxuZnVuY3Rpb24gdmFsdWVXaWxsTXV0YXRlKCkge1xuICAgIHRoaXMubm90aWZ5U3Vic2NyaWJlcnModGhpcy5fZHhPYnNlcnZlZFZhbHVlLCAnYmVmb3JlQ2hhbmdlJyk7XG59XG5cbi8vIE5vdGlmeSBzdWJzY3JpYmVycyB0aGF0IHRoZSBvYnNlcnZhYmxlJ3MgdmFsdWUgaGFzIGNoYW5nZWRcbmZ1bmN0aW9uIHZhbHVlSGFzTXV0YXRlZCgpIHtcbiAgICB0aGlzLm5vdGlmeVN1YnNjcmliZXJzKHRoaXMuX2R4T2JzZXJ2ZWRWYWx1ZSk7XG59XG5cbi8vIENsZWFuIHVwIHRoaXMgb2JzZXJ2YWJsZS4gUmVsZWFzZSBldmVyeXRoaW5nIHdlIGNhbi5cbmZ1bmN0aW9uIGRpc3Bvc2UoKSB7XG4gICAgdGhpcy5fZHhNb2RlbC5vZmYodW5kZWZpbmVkLCB1bmRlZmluZWQsIHRoaXMuX2R4U2VsZklkZW50aWZpZXIpO1xuICAgIGRpc3Bvc2VDdXJyZW50VmFsdWUodGhpcy5fZHhPYnNlcnZlZFZhbHVlKTtcbiAgICB0aGlzLl9keERpc3Bvc2VkID0gdHJ1ZTtcbn1cblxuZnVuY3Rpb24gc2hvd0RlYnVnTWVzc2FnZShvYnNlcnZhYmxlLCBtZXNzYWdlKSB7XG4gICAgdmFyIGF0dHJpYnV0ZSA9IG9ic2VydmFibGUuX2R4TW9kZWwuZ2V0KG9ic2VydmFibGUuX2R4QXR0ck5hbWUpO1xuICAgIHZhciBpZCA9IG9ic2VydmFibGUuX2R4RGVidWdJZCB8fCAnT2JzZXJ2YWJsZSc7XG4gICAgZHhVdGlsLmRlYnVnKGlkICsgJyB3aXRoIG1vZGVsICcgKyBvYnNlcnZhYmxlLl9keE1vZGVsLmlkICsgJzogJyArIG1lc3NhZ2UgKyAnOiAnICsgb2JzZXJ2YWJsZS5fZHhBdHRyTmFtZSArXG4gICAgICAgIChfLmlzQXJyYXkoYXR0cmlidXRlKSA/ICgnIHdpdGggJyArIChhdHRyaWJ1dGUgPyBhdHRyaWJ1dGUubGVuZ3RoIDogMCkgKyAnIGVsZW1lbnRzJykgOiAnJyksIGF0dHJpYnV0ZSk7XG59XG5cbmZ1bmN0aW9uIHNldERlYnVnKHZhbHVlLCBpZGVudGlmaWVyKSB7XG4gICAgdGhpcy5fZHhEZWJ1ZyA9IHZhbHVlO1xuICAgIHRoaXMuX2R4RGVidWdJZCA9IGlkZW50aWZpZXI7XG59XG5cbmZ1bmN0aW9uIGFzc2VydFBhcmFtc0dvb2QobW9kZWwsIGF0dHJOYW1lLCBtYWtlT2JqZWN0RnJvbU1vZGVsLCBvcHRpb25zKSB7XG4gICAgaWYgKCEobW9kZWwgaW5zdGFuY2VvZiBCYWNrYm9uZS5Nb2RlbCkpIHtcbiAgICAgICAgZHhVdGlsLmZhaWwoJ0EgYmFja2JvbmUgbW9kZWwgbXVzdCBiZSBwcm92aWRlZCBhcyB0aGUgZmlyc3QgYXJndW1lbnQuJyk7XG4gICAgfVxuXG4gICAgaWYgKCFfLmlzU3RyaW5nKGF0dHJOYW1lKSkge1xuICAgICAgICBkeFV0aWwuZmFpbCgnQSBwcm9wZXJ0eSBuYW1lIG11c3QgYmUgcHJvdmlkZWQgYXMgdGhlIHNlY29uZCBhcmd1bWVudC4nKTtcbiAgICB9XG5cbiAgICBpZiAoXy5pc1VuZGVmaW5lZChtYWtlT2JqZWN0RnJvbU1vZGVsKSB8fCAhXy5pc09iamVjdChtYWtlT2JqZWN0RnJvbU1vZGVsKSkge1xuICAgICAgICBkeFV0aWwuZmFpbCgnbWFrZU9iamVjdEZyb21Nb2RlbCBtdXN0IGJlIHByb3ZpZGVkIGFzIHRoZSB0aGlyZCBhcmd1bWVudC4nKTtcbiAgICB9XG5cbiAgICBpZiAoIV8uaXNVbmRlZmluZWQob3B0aW9ucykgJiYgIV8uaXNPYmplY3Qob3B0aW9ucykpIHtcbiAgICAgICAgZHhVdGlsLmZhaWwoJ09wdGlvbnMsIGlmIHByb3ZpZGVkLCBtdXN0IGJlIGFuIG9iamVjdC4nKTtcbiAgICB9XG59XG5cbi8qXG4gKiBBdHRhY2ggYSBidW5jaCBvZiBkYXRhIGFuZCBmdW5jdGlvbnMgdG8gdGhlIG9ic2VydmFibGUgZnVuY3Rpb24uICBOb3RlIHRoYXQgdGhlc2UgYXJlIGF0dGFjaGVkIHRvIHRoZSBmdW5jdGlvbixcbiAqIHJhdGhlciB0aGFuIGl0cyBwcm90b3R5cGUsIGJlY2F1c2Ugb25lIGNhbid0IGdpdmUgYSBmdW5jdGlvbiBhIHNwZWNpYWwgcHJvdG90eXBlLlxuICovXG5mdW5jdGlvbiBzZXRCYXNpY09ic2VydmFibGVQcm9wZXJ0aWVzKG9ic2VydmFibGUsIG1vZGVsLCBhdHRyTmFtZSwgbWFrZU9iamVjdEZyb21Nb2RlbCwgb3B0aW9ucykge1xuICAgIGtvLnN1YnNjcmliYWJsZS5jYWxsKG9ic2VydmFibGUpO1xuICAgIGtvLnV0aWxzLmV4dGVuZChvYnNlcnZhYmxlLCBrby5vYnNlcnZhYmxlLmZuKTtcbiAgICBfLmV4dGVuZChvYnNlcnZhYmxlLCB7XG4gICAgICAgIF9keE1vZGVsOiBtb2RlbCxcbiAgICAgICAgX2R4QXR0ck5hbWU6IGF0dHJOYW1lLFxuICAgICAgICBfbWFrZU9iamVjdEZyb21Nb2RlbDogbWFrZU9iamVjdEZyb21Nb2RlbCxcbiAgICAgICAgX2R4T3B0aW9uczogb3B0aW9ucyxcbiAgICAgICAgX2R4U2VsZklkZW50aWZpZXI6IHt9LCAvLyBhcmJpdHJheSBvYmplY3QgdXNlZCB0byB0cmFjayBvZiBvdXIgbGlzdGVuZXJzIG9uIHRoZSBtb2RlbFxuICAgICAgICB2YWx1ZUhhc011dGF0ZWQ6IHZhbHVlSGFzTXV0YXRlZCxcbiAgICAgICAgdmFsdWVXaWxsTXV0YXRlOiB2YWx1ZVdpbGxNdXRhdGUsXG4gICAgICAgIHBlZWs6IHBlZWssXG4gICAgICAgIHNldERlYnVnOiBzZXREZWJ1ZyxcbiAgICAgICAgZGlzcG9zZTogZGlzcG9zZVxuICAgIH0pO1xufVxuXG4vKlxuICogQ3JlYXRlIGFuIG9ic2VydmFibGUgYXJyYXkgYXR0cmlidXRlIGZyb20gdGhlIHNwZWNpZmllZCBtb2RlbFxuICovXG5mdW5jdGlvbiBtYWtlT2JzZXJ2YWJsZUFycmF5QXR0cmlidXRlKG1vZGVsLCBhdHRyTmFtZSwgbWFrZU9iamVjdEZyb21Nb2RlbCwgb3B0aW9ucykge1xuICAgIGZ1bmN0aW9uIG9ic2VydmFibGVBcnJheSgpIHtcbiAgICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICByZXR1cm4gd3JpdGVBcnJheVZhbHVlKG9ic2VydmFibGVBcnJheSwgYXJndW1lbnRzWzBdLCBvcHRpb25zIHx8IHt9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiByZWFkVmFsdWUob2JzZXJ2YWJsZUFycmF5LCBbXSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBhc3NlcnRQYXJhbXNHb29kKG1vZGVsLCBhdHRyTmFtZSwgbWFrZU9iamVjdEZyb21Nb2RlbCwgb3B0aW9ucyk7XG4gICAgc2V0QmFzaWNPYnNlcnZhYmxlUHJvcGVydGllcyhvYnNlcnZhYmxlQXJyYXksIG1vZGVsLCBhdHRyTmFtZSwgbWFrZU9iamVjdEZyb21Nb2RlbCwgb3B0aW9ucyk7XG5cbiAgICAvKlxuICAgICAqIEFkZCBhbGwgdGhlIHN0YW5kYXJkIG9ic2VydmFibGVBcnJheSBmdW5jdGlvbnMsIHNvIHRoaXMgbG9va3MgYW5kIGZlZWxzIGxpa2UgYW4gb2JzZXJ2YWJsZUFycmF5LlxuICAgICAqIE5vdGUgdGhhdCBiZWNhdXNlIGtvLm9ic2VydmFibGVBcnJheS5mbiBoYXMgdGhlIEZ1bmN0aW9uIHByb3RvdHlwZSBpbiBpdCdzIHByb3RvdHlwZSBjaGFpbiAoYXMgb2Yga25vY2tvdXRcbiAgICAgKiAzLjEuMCksIHdlIGNhbm5vdCB1c2UgXy5lYWNoIGRpcmVjdGx5IHRvIGdldCBpdCdzIHByb3BlcnRpZXMgKGJlY2F1c2UgZnVuY3Rpb25zIGhhdmUgYSBsZW5ndGggcHJvcGVydHkpLlxuICAgICAqL1xuICAgIF8uZWFjaChfLmtleXMoa28ub2JzZXJ2YWJsZUFycmF5LmZuKSwgZnVuY3Rpb24oa29PYUZ1bmNOYW1lKSB7XG4gICAgICAgIHZhciBrb09hRnVuYyA9IGtvLm9ic2VydmFibGVBcnJheS5mbltrb09hRnVuY05hbWVdO1xuXG4gICAgICAgIGlmIChfLmNvbnRhaW5zKFsnc2xpY2UnLCAncmV2ZXJzZScsICdzb3J0J10sIGtvT2FGdW5jTmFtZSkpIHtcbiAgICAgICAgICAgIG9ic2VydmFibGVBcnJheVtrb09hRnVuY05hbWVdID0ga29PYUZ1bmM7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgb2JzZXJ2YWJsZUFycmF5W2tvT2FGdW5jTmFtZV0gPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIEFycmF5LnByb3RvdHlwZS51bnNoaWZ0LmNhbGwoYXJndW1lbnRzLCBrb09hRnVuY05hbWUpO1xuICAgICAgICAgICAgYXJyYXlGdW5jdGlvbi5hcHBseShvYnNlcnZhYmxlQXJyYXksIGFyZ3VtZW50cyk7XG4gICAgICAgIH07XG4gICAgfSk7XG5cbiAgICBtb2RlbC5vbignY2hhbmdlOicgKyBhdHRyTmFtZSwgXy5iaW5kKGFycmF5QXR0cmlidXRlQ2hhbmdlZCwgb2JzZXJ2YWJsZUFycmF5KSwgb2JzZXJ2YWJsZUFycmF5Ll9keFNlbGZJZGVudGlmaWVyKTtcbiAgICBhcnJheUF0dHJpYnV0ZUNoYW5nZWQuY2FsbChvYnNlcnZhYmxlQXJyYXkpO1xuXG4gICAgcmV0dXJuIG9ic2VydmFibGVBcnJheS5leHRlbmQoe3RyYWNrQXJyYXlDaGFuZ2VzOiB0cnVlfSk7XG59XG5cbi8qXG4gKiBDcmVhdGUgYW4gb2JzZXJ2YWJsZSBvYmplY3QgYXR0cmlidXRlIGZyb20gdGhlIHNwZWNpZmllZCBtb2RlbFxuICovXG5mdW5jdGlvbiBtYWtlT2JzZXJ2YWJsZU9iamVjdEF0dHJpYnV0ZShtb2RlbCwgYXR0ck5hbWUsIG1ha2VPYmplY3RGcm9tTW9kZWwsIG9wdGlvbnMpIHtcbiAgICBmdW5jdGlvbiBvb0F0dHJpYnV0ZSgpIHtcbiAgICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICByZXR1cm4gd3JpdGVPYmplY3RWYWx1ZShvb0F0dHJpYnV0ZSwgYXJndW1lbnRzWzBdLCBvcHRpb25zIHx8IHt9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiByZWFkVmFsdWUob29BdHRyaWJ1dGUpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgYXNzZXJ0UGFyYW1zR29vZChtb2RlbCwgYXR0ck5hbWUsIG1ha2VPYmplY3RGcm9tTW9kZWwsIG9wdGlvbnMpO1xuICAgIHNldEJhc2ljT2JzZXJ2YWJsZVByb3BlcnRpZXMob29BdHRyaWJ1dGUsIG1vZGVsLCBhdHRyTmFtZSwgbWFrZU9iamVjdEZyb21Nb2RlbCwgb3B0aW9ucyk7XG5cbiAgICBtb2RlbC5vbignY2hhbmdlOicgKyBhdHRyTmFtZSwgXy5iaW5kKG9iamVjdEF0dHJpYnV0ZUNoYW5nZWQsIG9vQXR0cmlidXRlKSwgb29BdHRyaWJ1dGUuX2R4U2VsZklkZW50aWZpZXIpO1xuICAgIG9iamVjdEF0dHJpYnV0ZUNoYW5nZWQuY2FsbChvb0F0dHJpYnV0ZSk7XG5cbiAgICByZXR1cm4gb29BdHRyaWJ1dGU7XG59XG5cbi8qXG4gKiBBZGQgdGhlc2UgdGhpcyB0byB0aGUgcHVibGljIEFQSVxuICovXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgICBtYWtlT2JzZXJ2YWJsZUFycmF5QXR0cmlidXRlOiBtYWtlT2JzZXJ2YWJsZUFycmF5QXR0cmlidXRlLFxuICAgIG1ha2VPYnNlcnZhYmxlT2JqZWN0QXR0cmlidXRlOiBtYWtlT2JzZXJ2YWJsZU9iamVjdEF0dHJpYnV0ZVxufTtcbiIsIi8qXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTQsIDIwMTUgYnkgRGVscGhpeC4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqL1xuXG4vKiBnbG9iYWwgXywga28sIEJhY2tib25lICovXG5cbid1c2Ugc3RyaWN0JztcblxuY29uc3QgZHhVdGlsID0gcmVxdWlyZSgnZHhjb3JlL2pzL3V0aWwuanMnKTtcblxuLypcbiAqIEFuIG9ic2VydmFibGVBdHRyaWJ1dGUgaXMgYSBzcGVjaWFsIG9ic2VydmFibGUgdGhhdCAnd3JhcHMgdXAnIGFjY2VzcyB0byBhbiBhdHRyaWJ1dGUgb24gYSBCYWNrYm9uZSBtb2RlbCwgd2l0aFxuICogc3VwcG9ydCBmb3Igc29tZSBvZiB0aGUgc2VtYW50aWNzIG9mIG91ciBEZWxwaGl4IFNjaGVtYS1CYXNlZCBtb2RlbHMuICBZb3Ugc2hvdWxkIHJhcmVseSwgaWYgZXZlciwgYmUgY3JlYXRpbmcgb25lXG4gKiBvZiB0aGVzZSB5b3Vyc2VsZi4gIEluc3RlYWQgdGhleSBhcmUgY3JlYXRlZCBhbmQgbWFuYWdlZCBieSBoaWdoZXIgbGV2ZWwgdGhpbmdzLCBsaWtlIE9ic2VydmFibGVTZXJ2ZXJPYmplY3Qncy5cbiAqXG4gKiBDcmVhdGUgYW4gb2JzZXJ2YWJsZUF0dHJpYnV0ZSBsaWtlIHRoaXM6XG4gKiAgIG1ha2VPYnNlcnZhYmxlQXR0cmlidXRlKG15TW9kZWwsICduYW1lJylcbiAqIFRoaXMgcmV0dXJucyBhbiBvYnNlcnZhYmxlIHRoYXQgY2FuIGJlIHVzZWQgZW50aXJlbHkgbGlrZSBhbiBvcmRpbmFyeSBvYnNlcnZhYmxlLlxuICogQW55IHRpbWUgdGhlIHVuZGVybHlpbmcgbW9kZWwgaXMgdXBkYXRlZCwgdGhlIG9ic2VydmFibGUgd2lsbCBub3RpY2UgYW5kIG5vdGlmeSBpdHMgc3Vic2NyaWJlcnMuXG4gKlxuICogT2JzZXJ2YWJsZUF0dHJpYnV0ZXMgaGF2ZSBzZXZlcmFsIHNwZWNpYWwgYmVoYXZpb3JzIHdoZW4gaXQgY29tZXMgdG8gd3JpdGluZyB0byB0aGVtLlxuICpcbiAqIElmIHRoZSBtb2RlbCBpcyBhIGNsaWVudCBtb2RlbCAob3IgYW4gb3JkaW5hcnkgQmFja2JvbmUgbW9kZWwpIHVwZGF0aW5nIHRoZSBvYnNlcnZhYmxlIHdpbGwgdXBkYXRlIHRoZSBtb2RlbFxuICogZGlyZWN0bHkuXG4gKlxuICogSWYgdGhlIG1vZGVsIGlzIGEgc2VydmVyIG1vZGVsLCB0aGVuIG9uZSBvZiB0d28gdGhpbmdzIHdpbGwgaGFwcGVuLiBUaGUgZGVmYXVsdCBiZWhhdmlvciBpcyB0aGF0IHdoZW4gdGhlXG4gKiBvYnNlcnZhYmxlIGlzIHNldCAoZS5nLiBvYnNlcnZhYmxlKCduZXcgdmFsdWUnKSksIHRoZSBvYnNlcnZhYmxlIHdpbGwgc2VuZCBhbiB1cGRhdGUgc3RhbmRhcmQgb3BlcmF0aW9uIHRvIHRoZVxuICogc2VydmVyLiBPbmNlIHRoZSBzZXJ2ZXIgaGFzIHByb2Nlc3NlZCB0aGUgdXBkYXRlIGFuZCBkZWxpdmVyZWQgYSBub3RpZmljYXRpb24sIHRoZSB1bmRlcmx5aW5nIHNlcnZlciBtb2RlbCB3aWxsIGJlXG4gKiB1cGRhdGVkIGFuZCB0aGUgb2JzZXJ2YWJsZSB3aWxsIGJlIHVwZGF0ZWQuXG4gKlxuICogSW4gdGhlIGNhc2UgeW91IHdhbnQgYSBkaWZmZXJlbnQgYmVoYXZpb3IgZm9yIHdyaXRpbmcsIHlvdSBjYW4gcGFzcyBhICd3cml0ZXInIGluIGFuIG9wdGlvbnMgb2JqZWN0IHRvIHRoZSBjcmVhdGlvblxuICogcm91dGluZS4gIFRoaXMgd2lsbCB0aGVuIGJlIGludm9rZWQgd2hlbiB0aGVyZSBpcyBhIGNoYW5nZS4gWW91IGNhbiB0aGVuIGhhbmRsZSB0aGlzIGNoYW5nZSBpbiB5b3VyIHdyaXRlciByb3V0aW5lLFxuICogb3IgcmV0dXJuIFdSSVRFX1VOSEFORExFRCwgaW4gd2hpY2ggY2FzZSB0aGUgYWJvdmUgdXBkYXRlIGJlaGF2aW9yIHdpbGwgYmUgY2FycmllZCBvdXQuXG4gKlxuICogSW4gYWRkaXRpb24gdG8gc3RhbmRhcmQgb2JzZXJ2YWJsZSBmdW5jdGlvbnMsIE9ic2VydmFibGVBdHRyaWJ1dGUgYWxzbyBoYXMgdGhlc2UgZnVuY3Rpb25zOlxuICogICAgZGlzcG9zZSgpICA6IGRpc3Bvc2VzIHRoZSBvYnNlcnZhYmxlLiBUaGlzIGluY2x1ZGVzIHJlbW92aW5nIGxpc3RlbmVyKHMpIG9uIHRoZSBtb2RlbC5cbiAqICAgIHNldERlYnVnKHZhbHVlLCBpZCkgOiBJZiB0aGUgdmFsdWUgaXMgdHJ1dGh5LCB0aGlzIHdpbGwgcHJpbnQgZGVidWcgbWVzc2FnZXMgYXQga2V5IHBsYWNlcy4gIElmIGFuIGlkIGlzXG4gKiAgICAgICAgICAgICAgICAgcHJvdmlkZWQsIGRlYnVnIG1lc3NhZ2VzIGZyb20gdGhpcyBpbnN0YW5jZSB3aWxsIGluY2x1ZGUgdGhhdCBpZC5cbiAqXG4gKiBUaGUgb3B0aW9ucyBvYmplY3QgY2FuIGFjY2VwdCB0aGVzZSB2YWx1ZXM6XG4gKiAgICB3cml0ZXIgICAgIDogYSBmdW5jdGlvbiB3aXRoIHRoZSBzaWduYXR1cmUgd3JpdGVyKG9ic2VydmFibGUsIHByb3BlcnR5TmFtZSwgdmFsdWUpLiBJdCBpcyB1cCB0byB0aGUgd3JpdGVyIHRvXG4gKiAgICAgICAgICAgICAgICAgaGFuZGxlIGFuIHVwZGF0ZSB0byB0aGUgc3BlY2lmaWVkIHByb3BlcnR5LiAgSWYgaXQgY2hvb3NlcyBub3QgdG8sIGl0IGNhbiByZXR1cm5cbiAqICAgICAgICAgICAgICAgICBXUklURV9VTkhBTkRMRUQsIGluIHdoaWNoIGNhc2UgdGhlIHN0YW5kYXJkIHdyaXRlIGJlaGF2aW9yIHdpbGwgYmUgaW52b2tlZC5cbiAqL1xudmFyIFdSSVRFX1VOSEFORExFRCA9ICdXUklURSBVTkhBTkRMRUQnO1xuXG4vLyBSZXR1cm4gdGhlIHZhbHVlIG9mIHRoZSB1bmRlcmx5aW5nIG1vZGVsJ3MgcHJvcGVydHkgd2l0aG91dCBzZXR0aW5nIHVwIGFueSBrbm9ja291dCBkZXBlbmRlbmNpZXMuXG5mdW5jdGlvbiBwZWVrKCkge1xuICAgIHJldHVybiB0aGlzLl9keE1vZGVsLmdldCh0aGlzLl9keFByb3BOYW1lKTtcbn1cblxuLy8gQ2xlYW4gdXAgdGhpcyBvYnNlcnZhYmxlLiBSZWxlYXNlIGV2ZXJ5dGhpbmcgd2UgY2FuLlxuZnVuY3Rpb24gZGlzcG9zZSgpIHtcbiAgICB0aGlzLl9keE1vZGVsLm9mZih1bmRlZmluZWQsIHVuZGVmaW5lZCwgdGhpcy5fZHhTZWxmSWRlbnRpZmllcik7XG4gICAgdGhpcy5fZHhEaXNwb3NlZCA9IHRydWU7XG59XG5cbmZ1bmN0aW9uIHNob3dEZWJ1Z01lc3NhZ2Uob2JzZXJ2YWJsZSwgbWVzc2FnZSkge1xuICAgIGlmIChvYnNlcnZhYmxlLl9keERlYnVnKSB7XG4gICAgICAgIGR4VXRpbC5kZWJ1Zygob2JzZXJ2YWJsZS5fZHhEZWJ1Z0lkZW50aWZpZXIgfHwgJ09ic2VydmFibGUnKSArICcgd2l0aCBtb2RlbCAnICsgb2JzZXJ2YWJsZS5fZHhNb2RlbC5pZCArICc6ICcgK1xuICAgICAgICAgICAgbWVzc2FnZSArICc6ICcgKyBvYnNlcnZhYmxlLl9keFByb3BOYW1lICsgJz0nICsgb2JzZXJ2YWJsZS5fZHhNb2RlbC5nZXQob2JzZXJ2YWJsZS5fZHhQcm9wTmFtZSkpO1xuICAgIH1cbn1cblxuLypcbiAqIFJlc3BvbmQgdG8gYSBjaGFuZ2UgaW4gdGhlIG1vZGVsJ3MgcHJvcGVydHkuIE5vdGUgdGhhdCB0aGlzIGJyaWVmbHkgaW52b2tlcyAncHJldmlvdXMgbW9kZScgc2luY2Ugd2UgbmVlZCB0byBiZSBzdXJlXG4gKiB0byByZXR1cm4gdGhlICdwcmV2aW91cycgdmFsdWUgKGZyb20gQmFja2JvbmUncyBzdGFuZHBvaW50KSBkdXJpbmcgdGhlICdiZWZvcmVDaGFuZ2UnIG5vdGlmaWNhdGlvbi5cbiAqL1xuZnVuY3Rpb24gbW9kZWxDaGFuZ2VkKCkge1xuICAgIHNob3dEZWJ1Z01lc3NhZ2UodGhpcywgJ01vZGVsIGNoYW5nZWQnKTtcbiAgICB0aGlzLl9keEluUHJldmlvdXNNb2RlID0gdHJ1ZTtcbiAgICB0aGlzLnZhbHVlV2lsbE11dGF0ZSgpO1xuICAgIHRoaXMuX2R4SW5QcmV2aW91c01vZGUgPSBmYWxzZTtcbiAgICB0aGlzLnZhbHVlSGFzTXV0YXRlZCgpO1xufVxuXG4vLyBOb3RpZnkgc3Vic2NyaWJlcnMgdGhhdCB0aGUgb2JzZXJ2YWJsZSdzIHZhbHVlIGlzIGFib3V0IHRvIGNoYW5nZVxuZnVuY3Rpb24gdmFsdWVXaWxsTXV0YXRlKCkge1xuICAgIHRoaXMubm90aWZ5U3Vic2NyaWJlcnModGhpcy5fZHhNb2RlbC5wcmV2aW91cyh0aGlzLl9keFByb3BOYW1lKSwgJ2JlZm9yZUNoYW5nZScpO1xufVxuXG4vLyBOb3RpZnkgc3Vic2NyaWJlcnMgdGhhdCB0aGUgb2JzZXJ2YWJsZSdzIHZhbHVlIGhhcyBjaGFuZ2VkXG5mdW5jdGlvbiB2YWx1ZUhhc011dGF0ZWQoKSB7XG4gICAgdGhpcy5ub3RpZnlTdWJzY3JpYmVycyh0aGlzLl9keE1vZGVsLmdldCh0aGlzLl9keFByb3BOYW1lKSk7XG59XG5cbi8qXG4gKiBVcGRhdGUgdGhlIG9ic2VydmFibGUgb25seSBpZiB0aGUgdmFsdWUgaGFzIGNoYW5nZWQuICBJZiB0aGUgbW9kZWwgaXMgYSBjbGllbnQgbW9kZWwsIGp1c3QgdXBkYXRlIHRoZSBtb2RlbC5cbiAqIElmIGl0IGlzIGEgc2VydmVyIG1vZGVsLCB0aGVuIGlmIHdlJ3ZlIGJlZW4gZ2l2ZW4gYSB3cml0ZXIsIGdpdmUgdGhhdCBhIGNoYW5jZSB0byBoYW5kbGUgdGhlIHdyaXRlLiBJZiB0aGF0IGRvZXNuJ3RcbiAqIGV4aXN0IG9yIGRvZXNuJ3Qgd2FudCB0byBoYW5kbGUgdGhlIHdyaXRlLCBpc3N1ZSBhICQkdXBkYXRlKCkgc3RhbmRhcmQgb3BlcmF0aW9uIHRvIHRoZSBzZXJ2ZXIuXG4gKi9cbmZ1bmN0aW9uIHdyaXRlVmFsdWUob2JzZXJ2YWJsZSwgdmFsdWUsIG9wdGlvbnMpIHtcbiAgICBpZiAob2JzZXJ2YWJsZS5fZHhEaXNwb3NlZCkge1xuICAgICAgICBkeFV0aWwuZGVidWcob2JzZXJ2YWJsZSwgJ1dyaXRpbmcgdG8gYSBkaXNwb3NlZCBvYnNlcnZhYmxlJyk7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKG9ic2VydmFibGUuZXF1YWxpdHlDb21wYXJlciAmJlxuICAgICAgICBvYnNlcnZhYmxlLmVxdWFsaXR5Q29tcGFyZXIob2JzZXJ2YWJsZS5fZHhNb2RlbC5nZXQob2JzZXJ2YWJsZS5fZHhQcm9wTmFtZSksIHZhbHVlKSkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKF8uaXNVbmRlZmluZWQob2JzZXJ2YWJsZS5fZHhNb2RlbC5pc1NlcnZlck1vZGVsKSB8fCAhb2JzZXJ2YWJsZS5fZHhNb2RlbC5pc1NlcnZlck1vZGVsKCkpIHtcbiAgICAgICAgc2hvd0RlYnVnTWVzc2FnZShvYnNlcnZhYmxlLCAnQWJvdXQgdG8gd3JpdGUgdG8gY2xpZW50IG1vZGVsJyk7XG4gICAgICAgIG9ic2VydmFibGUuX2R4TW9kZWwuc2V0KG9ic2VydmFibGUuX2R4UHJvcE5hbWUsIHZhbHVlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBpZiAob3B0aW9ucy53cml0ZXIpIHtcbiAgICAgICAgICAgIHNob3dEZWJ1Z01lc3NhZ2Uob2JzZXJ2YWJsZSwgJ0Fib3V0IHRvIHdyaXRlIHRvIHdyaXRlciBmb3Igc2VydmVyIG1vZGVsJyk7XG4gICAgICAgICAgICB2YXIgd3JpdGVyUmVzdWx0ID0gb3B0aW9ucy53cml0ZXIodmFsdWUsIG9ic2VydmFibGUuX2R4UHJvcE5hbWUsIG9ic2VydmFibGUpO1xuICAgICAgICAgICAgaWYgKHdyaXRlclJlc3VsdCAhPT0gV1JJVEVfVU5IQU5ETEVEKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG9ic2VydmFibGUuX2R4TW9kZWwuJCR1cGRhdGUpIHtcbiAgICAgICAgICAgIHNob3dEZWJ1Z01lc3NhZ2Uob2JzZXJ2YWJsZSwgJ0Fib3V0IHRvIHNlbmQgJCR1cGRhdGUoKSBmb3Igc2VydmVyIG1vZGVsJyk7XG4gICAgICAgICAgICB2YXIgcGF5bG9hZCA9IHt9O1xuICAgICAgICAgICAgcGF5bG9hZFtvYnNlcnZhYmxlLl9keFByb3BOYW1lXSA9IHZhbHVlO1xuICAgICAgICAgICAgb2JzZXJ2YWJsZS5fZHhNb2RlbC4kJHVwZGF0ZShwYXlsb2FkKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGR4VXRpbC5mYWlsKCdUaGlzIGtpbmQgb2Ygc2VydmVyIG9iamVjdCBoYXMgbm8gdXBkYXRlIHN0YW5kYXJkIG9wZXJhdGlvbi4nKTtcbiAgICAgICAgfVxuICAgIH1cbn1cblxuLypcbiAqIFJldHVybiB0aGUgJ2N1cnJlbnQnIHZhbHVlIG9mIHRoZSBvYnNlcnZhYmxlLiAgaWYgd2UncmUgaW4gdGhlIG1pZGRsZSBvZiB1cGRhdGluZyB0aGUgb2JzZXJ2YWJsZSwgdGhlIGN1cnJlbnQgdmFsdWVcbiAqIGlzIHRoZSAncHJldmlvdXMnIGJhY2tib25lIHZhbHVlXG4gKi9cbmZ1bmN0aW9uIHJlYWRWYWx1ZShvYnNlcnZhYmxlKSB7XG4gICAga28uZGVwZW5kZW5jeURldGVjdGlvbi5yZWdpc3RlckRlcGVuZGVuY3kob2JzZXJ2YWJsZSk7XG5cbiAgICBpZiAob2JzZXJ2YWJsZS5fZHhJblByZXZpb3VzTW9kZSkge1xuICAgICAgICByZXR1cm4gb2JzZXJ2YWJsZS5fZHhNb2RlbC5wcmV2aW91cyhvYnNlcnZhYmxlLl9keFByb3BOYW1lKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gb2JzZXJ2YWJsZS5fZHhNb2RlbC5nZXQob2JzZXJ2YWJsZS5fZHhQcm9wTmFtZSk7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBzZXREZWJ1Zyh2YWx1ZSwgaWRlbnRpZmllcikge1xuICAgIHRoaXMuX2R4RGVidWcgPSB2YWx1ZTtcbiAgICB0aGlzLl9keERlYnVnSWRlbnRpZmllciA9IGlkZW50aWZpZXI7XG59XG5cbi8qXG4gKiBDb25zdHJ1Y3QgdGhlIG9ic2VydmFibGUgYXR0cmlidXRlLlxuICpcbiAqIE5vdGUgdGhhdCB0aGlzIG9ic2VydmFibGUgZnVuY3Rpb24gaGFzIGFzIGxpdHRsZSBjb2RlIGluIGl0IGFzIHBvc3NpYmxlIHNvIGFzIHRvIG1pbmltaXplIHRoZSBzaXplIG9mIHRoZSBvYmplY3RcbiAqIGluIG1lbW9yeS5cbiAqL1xuZnVuY3Rpb24gbWFrZU9ic2VydmFibGVBdHRyaWJ1dGUobW9kZWwsIHByb3BOYW1lLCBvcHRpb25zKSB7XG4gICAgZnVuY3Rpb24gb2JzZXJ2YWJsZUF0dHJpYnV0ZSgpIHtcbiAgICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICB3cml0ZVZhbHVlKG9ic2VydmFibGVBdHRyaWJ1dGUsIGFyZ3VtZW50c1swXSwgb3B0aW9ucyB8fCB7fSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gcmVhZFZhbHVlKG9ic2VydmFibGVBdHRyaWJ1dGUpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgaWYgKCEobW9kZWwgaW5zdGFuY2VvZiBCYWNrYm9uZS5Nb2RlbCkpIHtcbiAgICAgICAgZHhVdGlsLmZhaWwoJ0EgYmFja2JvbmUgbW9kZWwgbXVzdCBiZSBwcm92aWRlZCBhcyB0aGUgZmlyc3QgYXJndW1lbnQuJyk7XG4gICAgfVxuICAgIGlmICghXy5pc1N0cmluZyhwcm9wTmFtZSkpIHtcbiAgICAgICAgZHhVdGlsLmZhaWwoJ0EgcHJvcGVydHkgbmFtZSBtdXN0IGJlIHByb3ZpZGVkIGFzIHRoZSBzZWNvbmQgYXJndW1lbnQuJyk7XG4gICAgfVxuICAgIGlmICghXy5pc1VuZGVmaW5lZChvcHRpb25zKSAmJiAhXy5pc09iamVjdChvcHRpb25zKSkge1xuICAgICAgICBkeFV0aWwuZmFpbCgnT3B0aW9ucywgaWYgcHJvdmlkZWQsIG11c3QgYmUgYW4gb2JqZWN0LicpO1xuICAgIH1cblxuICAgIC8qXG4gICAgICogQmVjYXVzZSB0aGUgb2JzZXJ2YWJsZSBpcyBhIGZ1bmN0aW9uLCB3ZSBjYW4ndCBhY3R1YWxseSBwdXQgYWxsIHRoZXNlIGZ1bmN0aW9uIGluIGl0cyBwcm90b3R5cGUsIHNvIHdlIG11c3RcbiAgICAgKiBhZGQgdGhlbSB0byBlYWNoIG5ldyBpbnN0YW5jZS5cbiAgICAgKi9cbiAgICBrby5zdWJzY3JpYmFibGUuY2FsbChvYnNlcnZhYmxlQXR0cmlidXRlKTtcbiAgICBrby51dGlscy5leHRlbmQob2JzZXJ2YWJsZUF0dHJpYnV0ZSwga28ub2JzZXJ2YWJsZS5mbik7XG4gICAgXy5leHRlbmQob2JzZXJ2YWJsZUF0dHJpYnV0ZSwge1xuICAgICAgICBfZHhNb2RlbDogbW9kZWwsXG4gICAgICAgIF9keFByb3BOYW1lOiBwcm9wTmFtZSxcbiAgICAgICAgX2R4U2VsZklkZW50aWZpZXI6IHt9LCAvLyBhcmJpdHJheSBvYmplY3QgdXNlZCB0byBrZWVwIHRyYWNrIG9mIG91ciBsaXN0ZW5lcnMgb24gdGhlIG1vZGVsXG4gICAgICAgIF9keEluUHJldmlvdXNNb2RlOiBmYWxzZSxcbiAgICAgICAgcGVlazogcGVlayxcbiAgICAgICAgc2V0RGVidWc6IHNldERlYnVnLFxuICAgICAgICB2YWx1ZVdpbGxNdXRhdGU6IHZhbHVlV2lsbE11dGF0ZSxcbiAgICAgICAgdmFsdWVIYXNNdXRhdGVkOiB2YWx1ZUhhc011dGF0ZWQsXG4gICAgICAgIGRpc3Bvc2U6IGRpc3Bvc2VcbiAgICB9KTtcblxuICAgIG1vZGVsLm9uKCdjaGFuZ2U6JyArIHByb3BOYW1lLCBfLmJpbmQobW9kZWxDaGFuZ2VkLCBvYnNlcnZhYmxlQXR0cmlidXRlKSwgb2JzZXJ2YWJsZUF0dHJpYnV0ZS5fZHhTZWxmSWRlbnRpZmllcik7XG5cbiAgICByZXR1cm4gb2JzZXJ2YWJsZUF0dHJpYnV0ZTtcbn1cblxuLypcbiAqIEFkZCB0aGVzZSB0aGluZ3MgdG8gdGhlIHB1YmxpYyBBUElcbiAqL1xubW9kdWxlLmV4cG9ydHMgPSB7XG4gICAgV1JJVEVfVU5IQU5ETEVEOiBXUklURV9VTkhBTkRMRUQsXG4gICAgbWFrZU9ic2VydmFibGVBdHRyaWJ1dGU6IG1ha2VPYnNlcnZhYmxlQXR0cmlidXRlXG59O1xuIiwiLypcbiAqIENvcHlyaWdodCAoYykgMjAxNSBieSBEZWxwaGl4LiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICovXG5cbi8qIGdsb2JhbCBfLCBCYWNrYm9uZSwga28qL1xuXG4ndXNlIHN0cmljdCc7XG5cbmNvbnN0IGR4VXRpbCA9IHJlcXVpcmUoJ2R4Y29yZS9qcy91dGlsLmpzJyksXG4gICAgZHhEYXRhID0gcmVxdWlyZSgnZHhjb3JlL2RhdGEvanMvaW5kZXguanMnKTtcblxuLypcbiAqIFRoaXMgY29udGFpbnMgc29tZSBwcml2YXRlIHV0aWxpdHkgcm91dGluZXMgdXNlZCBieSB0aGUga28gc3lzdGVtLCBhcyB3ZWxsIGFzIGFuIGluaXRpYWxpemF0aW9uIHJvdXRpbmUuXG4gKiBUaGlzIHNob3VsZCBiZSBydW4gYWZ0ZXIgc2V0dGluZyB1cCB0aGUgZGF0YSBzeXN0ZW0uXG4gKi9cbi8qXG4gKiBDb252ZXJ0IHRoZSByZXN1bHQgb2YgYSBjYWxsIHRvIGFuIG9wZXJhdGlvbiBvbiB0aGUgYmFja2JvbmUgbW9kZWwgaW50byBhIGtvLWNvbXBhdGlibGUgQ2xpZW50IG9yIFNlcnZlciBvYmplY3QuXG4gKi9cbmZ1bmN0aW9uIHByZXBSZXN1bHQocmVzdWx0LCBtYWtlT2JqZWN0RnJvbU1vZGVsLCBkaXNwb3NhbENvbnRleHQpIHtcbiAgICByZXR1cm4gKHJlc3VsdCBpbnN0YW5jZW9mIEJhY2tib25lLk1vZGVsKSA/XG4gICAgICAgIG1ha2VPYmplY3RGcm9tTW9kZWwocmVzdWx0LCB7IGRpc3Bvc2FsQ29udGV4dDogZGlzcG9zYWxDb250ZXh0IH0pIDogcmVzdWx0O1xufVxuXG4vKlxuICogSWRlbnRpZnkgaWYgYW4gb2JqZWN0IGlzIGFuIG9wdGlvbnMgb2JqZWN0XG4gKiBQYXJhbWV0ZXI6XG4gKiAgIHZhbHVlOiB0aGUgdmFsdWUgdG8gdGVzdFxuICogUmV0dXJuOlxuICogICB0cnV0aHkgaWYgdGhlIHZhbHVlIGlzIGFuIG9iamVjdCwgaXQgaGFzIHN1Y2Nlc3MsIGVycm9yLCBhbmQvb3IgZGlzcG9zYWxDb250ZXh0IHByb3BlcnRpZXMgYW5kIG5vIG90aGVyXG4gKi9cbmZ1bmN0aW9uIGxvb2tzTGlrZU9wdGlvbnNPYmplY3QodmFsdWUpIHtcbiAgICB2YXIgdmFsaWRPcHRpb25zID0gWydzdWNjZXNzJywgJ2Vycm9yJywgJ2Rpc3Bvc2FsQ29udGV4dCddO1xuXG4gICAgcmV0dXJuIF8uaXNPYmplY3QodmFsdWUpICYmXG4gICAgICAgIF8uaXNFbXB0eShfLm9taXQodmFsdWUsIHZhbGlkT3B0aW9ucykpICYmXG4gICAgICAgICFfLmlzRW1wdHkoXy5waWNrKHZhbHVlLCB2YWxpZE9wdGlvbnMpKTtcbn1cblxuLypcbiAqIFBhcmFtZXRlcnM6XG4gKiAgIG90aGVyQXJnczogQW4gYXJyYXkgb2YgYXJndW1lbnRzIHRvIGEga28gcm9vdCwgc3RhbmRhcmQsIG9yIG9iamVjdCBvcGVyYXRpb25cbiAqIFJldHVybjpcbiAqICAgQW4gb2JqZWN0IGNvbnRhaW5pbmcgdGhlIHN1Y2Nlc3MgYW5kIGVycm9yIGNhbGxiYWNrcywgYXMgd2VsbCBhcyBvcHRpb25hbCBkaXNwb3NhbCBjb250ZXh0LCB0aGF0IG1heSBoYXZlIGJlZW5cbiAqICAgc3BlY2lmaWVkIGluIHRoZSBwYXJhbWV0ZXJzXG4gKi9cbmZ1bmN0aW9uIGV4dHJhY3RPcHRpb25zKGlzU2NoZW1hT2JqZWN0LCBvdGhlckFyZ3MpIHtcbiAgICB2YXIgb3B0aW9uc09iamVjdCA9IF8uZmluZChvdGhlckFyZ3MsIGZ1bmN0aW9uKGFyZykge1xuICAgICAgICAvKlxuICAgICAgICAgKiBSZXR1cm4gdHJ1dGh5IHdoZW4gd2UgZmluZCBhbiBhcmd1bWVudCB0aGF0IGlzIGFuIG9iamVjdCB0aGF0IGlzbid0IGEgY2xpZW50IG9yIHNlcnZlciBvYmplY3QsIGFuZCB0aGF0XG4gICAgICAgICAqIGhhcyBhIHN1Y2Nlc3MsIGVycm9yLCBhbmQvb3IgZGlzcG9zYWxDb250ZXh0IHByb3BlcnR5IGJ1dCBubyBvdGhlcnMuXG4gICAgICAgICAqL1xuICAgICAgICByZXR1cm4gbG9va3NMaWtlT3B0aW9uc09iamVjdChhcmcpICYmICFpc1NjaGVtYU9iamVjdChhcmcpO1xuICAgIH0pO1xuXG4gICAgcmV0dXJuIG9wdGlvbnNPYmplY3QgfHwge307XG59XG5cbi8qXG4gKiBQYXJhbWV0ZXJzOlxuICogICBvdGhlckFyZ3M6IEFuIGFycmF5LWxpa2Ugb2JqZWN0IG9mIGFyZ3VtZW50cyB0byBhIGtvIHJvb3QsIHN0YW5kYXJkLCBvciBvYmplY3Qgb3BlcmF0aW9uXG4gKiBSZXR1cm46XG4gKiAgIGEgbW9kaWZpZWQgdmVyc2lvbiBvZiB0aGVzZSBhcmd1bWVudHMgaW5jbHVkaW5nOlxuICogICAgIChhKSBhbnkga28gb2JqZWN0cyBjb252ZXJ0ZWQgdG8gdGhlaXIgZGF0YSBlcXVpdmFsZW50c1xuICogICAgIChiKSBzdWNjZXNzRXJyb3IgcmVwbGFjZWQgd2l0aCBhbiBlbXB0eSBvYmplY3QgKHdlIGhhbmRsZSB0aGUgY2FsbGJhY2tzIGluIHRoZSBwcm9taXNlKVxuICogICAgIChjKSB1bndyYXAgYW55IGtvLm9ic2VydmFibGVzIGluIG90aGVyIGFyZ3VtZW50c1xuICovXG5mdW5jdGlvbiBjb252ZXJ0VG9EeERhdGFBcmdzKG90aGVyQXJncykge1xuICAgIHZhciBuZXdBcmdzID0gW107XG4gICAgXy5lYWNoKG90aGVyQXJncywgZnVuY3Rpb24oYXJnKSB7XG4gICAgICAgIGlmICghXy5pc1VuZGVmaW5lZChhcmcuX2R4TW9kZWwpKSB7XG4gICAgICAgICAgICBuZXdBcmdzLnB1c2goYXJnLl9keE1vZGVsKTtcbiAgICAgICAgICAgIC8qXG4gICAgICAgICAgICAgKiBvbmx5IHByb2Nlc3MgdGhlIGVsZW1lbnQgaWYgaXQgb25seSBoYXMgc3VjY2VzcywgZXJyb3IsIGFuZC9vciBkaXNwb3NhbENvbnRleHQgcHJvcGVydGllcy4gV2UgaGF2ZSB0byBiZVxuICAgICAgICAgICAgICogY2FyZWZ1bCBoZXJlLiBJZiB0aGUgdW5kZXJseWluZyBvcGVyYXRpb24gaXMgb25lIHRoYXQgdGFrZXMgcGFyYW1ldGVycywgdGhlbiBpdCBjYW4gdGFrZSBiZXR3ZWUgMCBhbmQgMlxuICAgICAgICAgICAgICogYXJndW1lbnRzLCBhbnkgb2Ygd2hpY2ggYXJlIG9iamVjdHMuIFRvIGF2b2lkIG1vZGlmeWluZyB0aGUgcGFyYW1ldGVycyByYXRoZXIgdGhhbiB0aGUgb3B0aW9ucyBvYmplY3QsXG4gICAgICAgICAgICAgKiB3ZSBjb25zaWRlciB0aGUgb2JqZWN0IHRvIGJlIHRoZSBvcHRpb25zIG9ubHkgaWYgaXQgY29udGFpbnMgbm90aGluZyBvdGhlciB0aGFuIHN1Y2Nlc3MsIGVycm9yLCBvclxuICAgICAgICAgICAgICogZGlzcG9zYWxDb250ZXh0IHByb3BlcnRpZXMuXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgfSBlbHNlIGlmIChsb29rc0xpa2VPcHRpb25zT2JqZWN0KGFyZykpIHtcbiAgICAgICAgICAgIHZhciBwYXRjaGVkQ2FsbGJhY2tzID0ge307XG4gICAgICAgICAgICBuZXdBcmdzLnB1c2gocGF0Y2hlZENhbGxiYWNrcyk7XG4gICAgICAgICAgICBpZiAoYXJnLmVycm9yKSB7XG4gICAgICAgICAgICAgICAgcGF0Y2hlZENhbGxiYWNrcy5zdXBwcmVzc0RlZmF1bHRFcnJvckhhbmRsZXIgPSB0cnVlOyAvLyB3ZSBoYW5kbGUgdGhpcyBpbiB0aGUgY2FsbCdzIHByb21pc2VcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmIChfLmlzT2JqZWN0KGFyZykpIHtcbiAgICAgICAgICAgIHZhciB1bndyYXBwZWQgPSB7fTtcbiAgICAgICAgICAgIF8uZWFjaChhcmcsIGZ1bmN0aW9uKHZhbHVlLCBrZXkpIHtcbiAgICAgICAgICAgICAgICB1bndyYXBwZWRba2V5XSA9IGtvLnVud3JhcCh2YWx1ZSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIG5ld0FyZ3MucHVzaCh1bndyYXBwZWQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZHhVdGlsLmZhaWwoJ011c3QgcGFzcyBhIHBhcmFtZXRlcnMgb2JqZWN0LicpO1xuICAgICAgICB9XG4gICAgfSk7XG5cbiAgICByZXR1cm4gbmV3QXJncztcbn1cblxuLypcbiAqIENhbGwgYW4gb2JqZWN0IG9wZXJhdGlvbiwgY29udmVydGluZyBhcmd1bWVudHMgdG8gZGF0YSBmb3JtYXQsIGFuZCBjb252ZXJ0IHJldHVybiByZXN1bHRzIHRvIHRoZSBrbyBmb3JtLlxuICovXG5mdW5jdGlvbiBjYWxsS29PYmplY3RPcGVyYXRpb24oa29PYmplY3QsIGlzU2NoZW1hT2JqZWN0LCBtYWtlT2JqZWN0RnJvbU1vZGVsLCBmdW5jTmFtZSkge1xuICAgIGlmICghaXNTY2hlbWFPYmplY3Qoa29PYmplY3QpKSB7XG4gICAgICAgIGR4VXRpbC5mYWlsKCdrb09iamVjdCBtdXN0IGJlIGEgU2VydmVyIG9yIENsaWVudCBPYmplY3QuJyk7XG4gICAgfVxuICAgIHZhciBmdW5jQXJncyA9IF8ucmVzdChhcmd1bWVudHMsIDQpO1xuICAgIHJldHVybiBjYWxsT3BlcmF0aW9uKGtvT2JqZWN0Ll9keE1vZGVsLCBpc1NjaGVtYU9iamVjdCwgbWFrZU9iamVjdEZyb21Nb2RlbCwgJyQnICsgZnVuY05hbWUsIGZ1bmNBcmdzKTtcbn1cblxuZnVuY3Rpb24gY2FsbE9wZXJhdGlvbihkeENvcmVEYXRhT2JqZWN0LCBpc1NjaGVtYU9iamVjdCwgbWFrZU9iamVjdEZyb21Nb2RlbCwgZnVuY05hbWUsIGZ1bmNBcmdzKSB7XG4gICAgdmFyIG5ld0FyZ3MgPSBjb252ZXJ0VG9EeERhdGFBcmdzKGZ1bmNBcmdzKTtcbiAgICB2YXIgb3B0aW9ucyA9IGV4dHJhY3RPcHRpb25zKGlzU2NoZW1hT2JqZWN0LCBmdW5jQXJncyk7XG5cbiAgICByZXR1cm4gZHhDb3JlRGF0YU9iamVjdFtmdW5jTmFtZV0uYXBwbHkoZHhDb3JlRGF0YU9iamVjdCwgbmV3QXJncykudGhlbihmdW5jdGlvbihkb25lUmVzdWx0KSB7XG4gICAgICAgIHZhciByZXN1bHQgPSBwcmVwUmVzdWx0KGRvbmVSZXN1bHQsIG1ha2VPYmplY3RGcm9tTW9kZWwsIG9wdGlvbnMuZGlzcG9zYWxDb250ZXh0KTtcbiAgICAgICAgaWYgKG9wdGlvbnMuc3VjY2Vzcykge1xuICAgICAgICAgICAgb3B0aW9ucy5zdWNjZXNzKHJlc3VsdCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9LCBmdW5jdGlvbihmYWlsZWRSZXN1bHQpIHtcbiAgICAgICAgdmFyIHJlc3VsdCA9IHByZXBSZXN1bHQoZmFpbGVkUmVzdWx0LCBtYWtlT2JqZWN0RnJvbU1vZGVsLCBvcHRpb25zLmRpc3Bvc2FsQ29udGV4dCk7XG4gICAgICAgIGlmIChvcHRpb25zLmVycm9yKSB7XG4gICAgICAgICAgICBvcHRpb25zLmVycm9yKHJlc3VsdCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9KTtcbn1cblxuLypcbiAqIENhbGwgYSByb290IG9wZXJhdGlvbiwgY29udmVydGluZyBhcmd1bWVudHMgdG8gZGF0YSBmb3JtYXQsIGFuZCBjb252ZXJ0IHJldHVybiByZXN1bHRzIHRvIHRoZSBrbyBmb3JtLlxuICovXG5mdW5jdGlvbiBjYWxsUm9vdE9wZXJhdGlvbih0eXBlTmFtZSwgaXNTY2hlbWFPYmplY3QsIG1ha2VPYmplY3RGcm9tTW9kZWwsIG9wTmFtZSwgb3RoZXJBcmdzKSB7XG4gICAgdmFyIHR5cGVPYmplY3QgPSBkeERhdGEucm9vdE9wc1t0eXBlTmFtZV07XG4gICAgcmV0dXJuIGNhbGxPcGVyYXRpb24odHlwZU9iamVjdCwgaXNTY2hlbWFPYmplY3QsIG1ha2VPYmplY3RGcm9tTW9kZWwsIG9wTmFtZSwgb3RoZXJBcmdzKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gICAgX2NhbGxPcGVyYXRpb246IGNhbGxPcGVyYXRpb24sXG4gICAgY2FsbEtvT2JqZWN0T3BlcmF0aW9uOiBjYWxsS29PYmplY3RPcGVyYXRpb24sXG4gICAgY2FsbFJvb3RPcGVyYXRpb246IGNhbGxSb290T3BlcmF0aW9uLFxuICAgIF9wcmVwUmVzdWx0OiBwcmVwUmVzdWx0XG59O1xuIiwiLypcbiAqIENvcHlyaWdodCAoYykgMjAxNCwgMjAxNSBieSBEZWxwaGl4LiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICovXG5cbi8qIGdsb2JhbCBkeCwgXywga28gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCBkeFV0aWwgPSByZXF1aXJlKCdkeGNvcmUvanMvdXRpbC5qcycpLFxuICAgIGR4U2NyZWVuID0gcmVxdWlyZSgnZHhjb3JlL2pzL3NjcmVlbi5qcycpLFxuICAgIGR4RGF0YSA9IHJlcXVpcmUoJ2R4Y29yZS9kYXRhL2pzL2luZGV4LmpzJyk7XG5cbi8qXG4gKiBHaXZlbiBhbiBhcnJheSBvZiBvYmplY3RzLCBjYWxsIGRpc3Bvc2UoKSBvbiBhbnkgZWxlbWVudHMgd2l0aCBhIGRpc3Bvc2UoKSBmdW5jdGlvbiwgYW5kIGR4RGlzcG9zZSgpIG9uIGFueSBvYmplY3RzXG4gKiB3aXRoIGEgZHhEaXNwb3NlKCkgZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIGRpc3Bvc2VJdGVtcyhlbGVtZW50cykge1xuICAgIGlmICghXy5pc0FycmF5KGVsZW1lbnRzKSkge1xuICAgICAgICBkeFV0aWwuZmFpbCgnTXVzdCBwYXNzIGFuIGFycmF5IG9mIGVsZW1lbnRzIHRvIGJlIGRpc3Bvc2VkLicpO1xuICAgIH1cblxuICAgIHZhciBzZXJ2ZXJPYmplY3RzID0gW107XG4gICAgdmFyIG90aGVyRGlzcG9zZSA9IFtdO1xuXG4gICAgLy8gRmlyc3QgZGlzcG9zZSBhbGwgY29tcHV0ZWQncyBhbmQgc3Vic2NyaXB0aW9uc1xuICAgIF8uZWFjaChlbGVtZW50cywgZnVuY3Rpb24oZWxlbWVudCkge1xuICAgICAgICBpZiAoZWxlbWVudC5keERpc3Bvc2UpIHtcbiAgICAgICAgICAgIHNlcnZlck9iamVjdHMucHVzaChlbGVtZW50KTtcbiAgICAgICAgfSBlbHNlIGlmIChlbGVtZW50LnNldERlYnVnKSB7XG4gICAgICAgICAgICBvdGhlckRpc3Bvc2UucHVzaChlbGVtZW50KTtcbiAgICAgICAgfSBlbHNlIGlmIChlbGVtZW50LmRpc3Bvc2UpIHtcbiAgICAgICAgICAgIGVsZW1lbnQuZGlzcG9zZSgpO1xuICAgICAgICB9XG4gICAgfSk7XG5cbiAgICBfLmludm9rZShvdGhlckRpc3Bvc2UsICdkaXNwb3NlJyk7XG5cbiAgICAvLyBUaGVuIGRpc3Bvc2UgdGhlIHN0dWZmIHRoYXQgbWlnaHQgdHJpZ2dlciB0aG9zZSBjb21wdXRlZCdzIGFuZCBzdWJzY3JpcHRpb25zXG4gICAgXy5lYWNoKHNlcnZlck9iamVjdHMsIGZ1bmN0aW9uKGVsZW1lbnQpIHtcbiAgICAgICAgZWxlbWVudC5keERpc3Bvc2UoKTtcbiAgICB9KTtcbn1cblxuLypcbiAqIEluaXRpYWxpemUgdGhlIGtvIHN5c3RlbS4gQXQgdGhlIG1vbWVudCwgdGhpcyBqdXN0IGludm9sdmVzIHNldHRpbmcgdXAgdGhlIHJvb3Qgb3BlcmF0aW9ucy5cbiAqL1xuZnVuY3Rpb24gaW5pdGlhbGl6ZShjYWxsUm9vdE9wZXJhdGlvbiwgaXNTY2hlbWFPYmplY3QsIG1ha2VPYmplY3RGcm9tTW9kZWwpIHtcbiAgICBkeFNjcmVlbi5yZWdpc3RlckNsZWFudXBDYWxsYmFjayhjbGVhbnVwUGFnZUNvbnRleHQpO1xuXG4gICAgbW9kdWxlLmV4cG9ydHMucm9vdE9wcyA9IHt9O1xuICAgIG1vZHVsZS5leHBvcnRzLmVudW1zID0gZHhEYXRhLmVudW1zO1xuXG4gICAgXy5lYWNoKGR4RGF0YS5yb290T3BzLCBmdW5jdGlvbihvcHNPYmplY3QsIHR5cGVOYW1lKSB7XG4gICAgICAgIG1vZHVsZS5leHBvcnRzLnJvb3RPcHNbdHlwZU5hbWVdID0gbW9kdWxlLmV4cG9ydHMucm9vdE9wc1t0eXBlTmFtZV0gfHwge307XG4gICAgICAgIF8uZWFjaChvcHNPYmplY3QsIGZ1bmN0aW9uKG9wRnVuY3Rpb24sIG9wTmFtZSkge1xuICAgICAgICAgICAgaWYgKCFfLmlzRnVuY3Rpb24ob3BGdW5jdGlvbikgfHwgb3BOYW1lLmNoYXJBdCgwKSAhPT0gJyQnKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBtb2R1bGUuZXhwb3J0cy5yb290T3BzW3R5cGVOYW1lXVtvcE5hbWVdID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNhbGxSb290T3BlcmF0aW9uKHR5cGVOYW1lLCBpc1NjaGVtYU9iamVjdCwgbWFrZU9iamVjdEZyb21Nb2RlbCwgb3BOYW1lLCBhcmd1bWVudHMpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfSk7XG4gICAgfSk7XG59XG5cbi8qXG4gKiBUaGlzIGlzIGFuIG9iamVjdCB3aGljaCBjYW4gZ2F0aGVyIGtvIGFuZCBrbyBvYmplY3RzIGFuZCB0aGVuIGRpc3Bvc2UgdGhlbSBhdCBzb21lIGFwcHJvcHJpYXRlIHRpbWUuICBBdCB0aGUgdGltZSBvZlxuICogdGhpcyB3cml0aW5nLCB0aGVyZSBpcyBvbmUgZGlzcG9zYWwgY29udGV4dCwgd2hpY2ggaXMgdGhlIHBhZ2UgY29udGV4dCwgYnV0IHNob3VsZCBzb21lb25lIG5lZWQgYSBtb3JlIHNwZWNpZmljXG4gKiBjb250ZXh0IChlLmcuIHRoZXkgYXJlIGNyZWF0aW5nIG1hbnkgb2JqZWN0cyBpbiBhIHNob3J0IHRpbWUgYW5kIHdhbnQgdG8gZnJlZSB0aGVtIHVwIHNvb25lciB0aGFuIHBhZ2UgdHJhbnNpdGlvbilcbiAqIHRoaXMgY2FuIGJlIHVzZWQgZm9yIHRoYXQgcHVycG9zZS5cbiAqXG4gKiBBIGRpc3Bvc2FsIGNvbnRleHQgaXMgZ2l2ZW4gb25lIHB1YmxpYyBmdW5jdGlvbiB3aGljaCBpczpcbiAqICBkeEtvRGlzcG9zZSgpXG4gKiB3aGljaCB3aWxsIGRpc3Bvc2UgYWxsIHRoZSBvYmplY3RzIGluIHRoZSBjb250ZXh0LlxuICovXG5mdW5jdGlvbiBEaXNwb3NhbENvbnRleHQoKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIGlmICghKHNlbGYgaW5zdGFuY2VvZiBEaXNwb3NhbENvbnRleHQpKSB7XG4gICAgICAgIGR4VXRpbC5mYWlsKCdDYWxsIGNvbnN0cnVjdG9yIGZ1bmN0aW9uIERpc3Bvc2FsQ29udGV4dCB3aXRoIG5ldy4nKTtcbiAgICB9XG4gICAgc2VsZi5fZHhLb0Rpc3Bvc2FsTGlzdCA9IFtdO1xuICAgIHNlbGYuZHhLb0Rpc3Bvc2UgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgZGlzcG9zZUl0ZW1zKHNlbGYuX2R4S29EaXNwb3NhbExpc3QpO1xuICAgICAgICBzZWxmLl9keEtvRGlzcG9zYWxMaXN0Lmxlbmd0aCA9IDA7XG4gICAgfTtcbiAgICByZXR1cm4gc2VsZjtcbn1cblxuLypcbiAqIENyZWF0ZXMgYSBrby5jb21wdXRlZCwgYW5kIGFkZHMgaXQgdG8gYSBkaXNwb3NhbCBjb250ZXh0LlxuICpcbiAqIEJ5IGRlZmF1bHQsIHRoaXMgd2lsbCBiZSBwdXQgaW4gdGhlIHBhZ2UgZGlzcG9zYWwgY29udGV4dCwgaG93ZXZlciwgaWYgYSBkaWZmZXJlbnQgZGlzcG9zYWwgY29udGV4dCBpcyBhZGRlZCBpbiB0aGVcbiAqIG9wdGlvbnMsIGl0IHdpbGwgYmUgYWRkZWQgdG8gdGhhdCwgaW5zdGVhZC5cbiAqL1xuZnVuY3Rpb24gbWFrZUNvbXB1dGVkKGV2YWx1YXRvciwgdGFyZ2V0LCBvcHRpb25zKSB7XG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gICAgdmFyIGNvbXB1dGVkID0ga28uY29tcHV0ZWQoZXZhbHVhdG9yLCB0YXJnZXQsIG9wdGlvbnMpO1xuICAgIGFkZFRvRGlzcG9zYWxDb250ZXh0KGNvbXB1dGVkLCBvcHRpb25zLmRpc3Bvc2FsQ29udGV4dCk7XG4gICAgcmV0dXJuIGNvbXB1dGVkO1xufVxuXG4vKlxuICogQ3JlYXRlIGEga28gc3Vic2NyaXB0aW9uIG9uIHRoZSBzcGVjaWZpZWQgb2JzZXJ2YWJsZS4gIEFkZHMgdGhlIHN1YnNjcmlwdGlvbiB0byBhIGRpc3Bvc2FsIGNvbnRleHQgYW5kIHdpbGwgcmV0dXJuIGl0XG4gKiBQYXJhbWV0ZXJzXG4gKiAgICBvYnNlcnZhYmxlOiBUaGUgb2JzZXJ2YWJsZSB0byBzdWJzY3JpYmUgdG9cbiAqICAgIGhhbmRsZXI6IEFzIGRlZmluZWQgYnkga25vY2tvdXRcbiAqICAgIGhhbmRsZXJUYXJnZXQ6IGFzIGRlZmluZWQgYnkga25vY2tvdXRcbiAqICAgIGV2ZW50OiBhcyBkZWZpbmVkIGJ5IGtub2Nrb3V0XG4gKiAgICBkaXNwb3NhbENvbnRleHQ6IChvcHRpb25hbCkgdGhlIGNvbnRleHQgdG8gcHV0IHRoZSBzdWJzY3JpcHRpb24gaW4uIEJ5IGRlZmF1bHQgd2lsbCBnbyBpbnRvIHRoZSBwYWdlIGNvbnRleHQuXG4gKi9cbmZ1bmN0aW9uIHN1YnNjcmliZVRvT2JzZXJ2YWJsZShvYnNlcnZhYmxlLCBoYW5kbGVyLCBoYW5kbGVyVGFyZ2V0LCBldmVudCwgZGlzcG9zYWxDb250ZXh0KSB7XG4gICAgdmFyIHN1YnNjcmlwdGlvbiA9IG9ic2VydmFibGUuc3Vic2NyaWJlKGhhbmRsZXIsIGhhbmRsZXJUYXJnZXQsIGV2ZW50KTtcbiAgICBhZGRUb0Rpc3Bvc2FsQ29udGV4dChzdWJzY3JpcHRpb24sIGRpc3Bvc2FsQ29udGV4dCk7XG4gICAgcmV0dXJuIHN1YnNjcmlwdGlvbjtcbn1cblxuLypcbiAqIENyZWF0ZSBhIGtvIHN1YnNjcmlwdGlvbiBvbiB0aGUgc3BlY2lmaWVkIG9ic2VydmFibGUgdGhhdCB3aWxsIG9ubHkgcmVjZWl2ZSBhIHNpbmdsZSB1cGRhdGUsIGFuZCB0aGVuIGF1dG9tYXRpY2FsbHlcbiAqIGJlIGRpc3Bvc2VkLiAgQWRkcyB0aGUgc3Vic2NyaXB0aW9uIHRvIGEgZGlzcG9zYWwgY29udGV4dCBiZWZvcmUgcmV0dXJuaW5nIGl0LlxuICpcbiAqIFBhcmFtZXRlcnNcbiAqICAgIG9ic2VydmFibGU6IFRoZSBvYnNlcnZhYmxlIHRvIHN1YnNjcmliZSB0b1xuICogICAgaGFuZGxlcjogQXMgZGVmaW5lZCBieSBrbm9ja291dFxuICogICAgaGFuZGxlclRhcmdldDogYXMgZGVmaW5lZCBieSBrbm9ja291dFxuICogICAgZXZlbnQ6IGFzIGRlZmluZWQgYnkga25vY2tvdXRcbiAqICAgIGRpc3Bvc2FsQ29udGV4dDogKG9wdGlvbmFsKSB0aGUgY29udGV4dCB0byBwdXQgdGhlIHN1YnNjcmlwdGlvbiBpbi4gQnkgZGVmYXVsdCB3aWxsIGdvIGludG8gdGhlIHBhZ2UgY29udGV4dC5cbiAqL1xuZnVuY3Rpb24gc3Vic2NyaWJlVG9PYnNlcnZhYmxlRm9yT25lVXBkYXRlKG9ic2VydmFibGUsIGhhbmRsZXIsIGhhbmRsZXJUYXJnZXQsIGV2ZW50LCBkaXNwb3NhbENvbnRleHQpIHtcbiAgICB2YXIgc3Vic2NyaXB0aW9uID0gb2JzZXJ2YWJsZS5zdWJzY3JpYmUoZnVuY3Rpb24oKSB7XG4gICAgICAgIGhhbmRsZXIuYXBwbHkoaGFuZGxlclRhcmdldCwgYXJndW1lbnRzKTtcbiAgICAgICAgc3Vic2NyaXB0aW9uLmRpc3Bvc2UoKTtcbiAgICB9LCBoYW5kbGVyVGFyZ2V0LCBldmVudCk7XG4gICAgYWRkVG9EaXNwb3NhbENvbnRleHQoc3Vic2NyaXB0aW9uLCBkaXNwb3NhbENvbnRleHQpO1xuXG4gICAgcmV0dXJuIHN1YnNjcmlwdGlvbjtcblxufVxuXG52YXIgREVGQVVMVF9FVkVOVCA9ICdjaGFuZ2UnO1xuLypcbiAqIEdpdmVuIGFuIG9yZGluYXJ5IG9ic2VydmFibGUgYW5kIGEgaGFuZGxlciwgaWYgdGhlIHZhbHVlIGlzIG51bGwvdW5kZWZpbmVkIHN1YnNjcmliZSwgb3RoZXJ3aXNlIHRyaWdnZXIgaGFuZGxlclxuICogaW1tZWRpYXRlbHkgYW5kIHN1YnNjcmliZS5cbiAqL1xuZnVuY3Rpb24gY2hlY2tBbmRTdWJzY3JpYmUob2JzZXJ2YWJsZSwgaGFuZGxlciwgaGFuZGxlclRhcmdldCwgZXZlbnQsIGRpc3Bvc2FsQ29udGV4dCkge1xuICAgIGlmICgha28uaXNPYnNlcnZhYmxlKG9ic2VydmFibGUpKSB7XG4gICAgICAgIGR4VXRpbC5mYWlsKCdNdXN0IGNhbGwgY2hlY2tBbmRTdWJzY3JpYmUoKSB3aXRoIGFuIG9ic2VydmFibGUuJyk7XG4gICAgfVxuICAgIGlmICghaGFuZGxlcikge1xuICAgICAgICBkeFV0aWwuZmFpbCgnTXVzdCBjYWxsIGNoZWNrQW5kU3Vic2NyaWJlKCkgd2l0aCBhIGhhbmRsZXIuJyk7XG4gICAgfVxuXG4gICAgZXZlbnQgPSBldmVudCB8fCBERUZBVUxUX0VWRU5UO1xuICAgIGlmICghZHhVdGlsLmlzTm9uZShvYnNlcnZhYmxlKCkpICYmIGV2ZW50ID09PSBERUZBVUxUX0VWRU5UKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBrby5kZXBlbmRlbmN5RGV0ZWN0aW9uLmJlZ2luKCk7XG4gICAgICAgICAgICBoYW5kbGVyLmNhbGwoaGFuZGxlclRhcmdldCwgb2JzZXJ2YWJsZS5wZWVrKCksIERFRkFVTFRfRVZFTlQpO1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAga28uZGVwZW5kZW5jeURldGVjdGlvbi5lbmQoKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBzdWJzY3JpYmVUb09ic2VydmFibGUob2JzZXJ2YWJsZSwgaGFuZGxlciwgaGFuZGxlclRhcmdldCwgZXZlbnQsIGRpc3Bvc2FsQ29udGV4dCk7XG59XG5cbi8qXG4gKiBHaXZlbiBhIFN0YXRlZCBPYnNlcnZhYmxlIChzdWNoIGFzIHJldHVybmVkIGJ5IHByb21pc2VUb09ic2VydmFibGUoKSkgbWFrZSBzdXJlIHRoZSBoYW5kbGVyIGlzIGNhbGxlZCBvbmNlIHdoZW4gdGhlXG4gKiBzdGF0ZSB0cmFuc2l0aW9ucyB0byBub24tdW5kZWZpbmVkLCBvciBpcyBhbHJlYWR5IG5vbi11bmRlZmluZWQuIEFsd2F5cyByZXR1cm5zIGEgc3Vic2NyaXB0aW9uLCB0aG91Z2ggaXQgbWF5IGJlXG4gKiBhIGR1bW15IG9uZSBpZiB0aGUgaGFuZGxlciBoYXMgYWxyZWFkeSBiZWVuIGNhbGxlZFxuICpcbiAqIEEgc3RhdGVkIG9ic2VyYWJsZSBoYXMgdGhlc2UgY2hhcmFjdGVyaXN0aWNzOlxuICogLSBJdCBpcyBpdHNlbGYgYW4gb2JzZXJ2YWJsZVxuICogLSBJdCBoYXMgYSBwcm9wZXJ0eSwgd2hpY2ggaXMgYW4gb2JzZXJ2YWJsZSwgY2FsbGVkIHN0YXRlXG4gKiAtIFRoZSBtYWluIG9ic2VydmFibGUgaXMgaW5pdGlhbGx5IHVuZGVmaW5lZCB1bnRpbCBzb21lIGNyaXRlcmlhIGhhcyBiZWVuIG1ldCwgaW4gd2hpY2ggY2FzZSBpdCB3aWxsIGhhdmUgc29tZSB2YWx1ZVxuICogICAocG9zc2libHkgdW5kZWZpbmVkKSwgYW5kIHN0YXRlIHdpbGwgYmUgZWl0aGVyIHRydWUgb3IgZmFsc2UgYmFzZWQgb24gd2hldGhlciB0aGUgY3JpdGVyaWEgd2FzIHN1Y2Nlc3NmdWwgb3JcbiAqICAgYSBmYWlsdXJlLlxuICogLSBUaGUgc3RhdGVkIG9ic2VydmFibGUgYnJvYWRjYXN0cyB0d28gdmFsdWVzIHRvIHN1YnNjcmliZWQgZnVuY3Rpb25zOiBzdGF0ZSBhbmQgdmFsdWVcbiAqL1xuZnVuY3Rpb24gY2hlY2tBbmRTdWJzY3JpYmVUb1N0YXRlZE9ic2VydmFibGUob2JzZXJ2YWJsZSwgaGFuZGxlciwgaGFuZGxlclRhcmdldCwgZXZlbnQsIGRpc3Bvc2FsQ29udGV4dCkge1xuICAgIGlmICgha28uaXNPYnNlcnZhYmxlKG9ic2VydmFibGUpKSB7XG4gICAgICAgIGR4VXRpbC5mYWlsKCdNdXN0IGNhbGwgY2hlY2tBbmRTdWJzY3JpYmVUb1N0YXRlZE9ic2VydmFibGUoKSB3aXRoIGFuIG9ic2VydmFibGUuJyk7XG4gICAgfVxuICAgIGlmICghaGFuZGxlcikge1xuICAgICAgICBkeFV0aWwuZmFpbCgnTXVzdCBjYWxsIGNoZWNrQW5kU3Vic2NyaWJlVG9TdGF0ZWRPYnNlcnZhYmxlKCkgd2l0aCBhIGhhbmRsZXIuJyk7XG4gICAgfVxuICAgIGlmICghb2JzZXJ2YWJsZS5zdGF0ZSB8fCAha28uaXNPYnNlcnZhYmxlKG9ic2VydmFibGUuc3RhdGUpKSB7XG4gICAgICAgIGR4VXRpbC5mYWlsKCdNdXN0IHBhc3MgYSBzdGF0ZWQgb2JzZXJ2YWJsZSB0byBjaGVja0FuZFN1YnNjcmliZVRvU3RhdGVkT2JzZXJ2YWJsZSgpLicpO1xuICAgIH1cbiAgICBldmVudCA9IGV2ZW50IHx8IERFRkFVTFRfRVZFTlQ7XG5cbiAgICBmdW5jdGlvbiBoYW5kbGVTdGF0ZWRPYnNlcnZhYmxlQ2hhbmdlKCkge1xuICAgICAgICBoYW5kbGVyLmFwcGx5KGhhbmRsZXJUYXJnZXQsIFtvYnNlcnZhYmxlLnN0YXRlLnBlZWsoKSwgb2JzZXJ2YWJsZS5wZWVrKCldKTtcbiAgICB9XG5cbiAgICBpZiAoIV8uaXNVbmRlZmluZWQob2JzZXJ2YWJsZS5zdGF0ZS5wZWVrKCkpICYmIGV2ZW50ID09PSBERUZBVUxUX0VWRU5UKSB7XG4gICAgICAgIGhhbmRsZVN0YXRlZE9ic2VydmFibGVDaGFuZ2UoKTtcbiAgICAgICAgLy8gcmV0dXJuIGEgZHVtbXkgc3Vic2NyaXB0aW9uIHNvIGNhbGxlciBkb2VzIG5vdCBuZWVkIHRvIHByb3RlY3QgaXRzZWxmIGFnYWluc3QgdW5kZWZpbmVkXG4gICAgICAgIHJldHVybiBrby5vYnNlcnZhYmxlKCkuc3Vic2NyaWJlKGZ1bmN0aW9uIGR1bW15RnVuY3Rpb24oKSB7fSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHN1YnNjcmliZVRvT2JzZXJ2YWJsZUZvck9uZVVwZGF0ZShvYnNlcnZhYmxlLnN0YXRlLCBoYW5kbGVTdGF0ZWRPYnNlcnZhYmxlQ2hhbmdlLCB1bmRlZmluZWQsIGV2ZW50LFxuICAgICAgICBkaXNwb3NhbENvbnRleHQpO1xufVxuXG4vKlxuICogUmV0dXJucyBhIGNvbXB1dGVkIHJlcHJlc2VudGluZyB0aGUgY29tYmluZWQgc3RhdGUgb2YgdGhlIHBhc3NlZCBpbiBcInN0YXRlXCIgb2JzZXJ2YWJsZXMuXG4gKiBBY2NlcHRzIGFuIGFycmF5LlxuICogVGhlIHZhbHVlIG9mIHRoZSByZXR1cm5lZCBjb21wdXRlZCBpczpcbiAqICAtIHRydWUgaWYgYWxsIGlucHV0IG9ic2VydmFibGVzIGFyZSB0cnV0aHkgKGFsbCBoYXZlIHJlc29sdmVkKVxuICogIC0gZmFsc2UgaWYgYW55IGFyZSBmYWxzZSAoYXQgbGVhc3Qgb25lIGhhcyBmYWlsZWQpXG4gKiAgLSB1bmRlZmluZWQgb3RoZXJ3aXNlIChzb21lIGFyZSBwZW5kaW5nIGFuZCBub25lIGhhdmUgZmFpbGVkKVxuICovXG5mdW5jdGlvbiBtYWtlTWVyZ2VkU3RhdGVPYnNlcnZhYmxlKHN0YXRlT2JzZXJ2YWJsZXMsIG9wdGlvbnMgPSB7fSkge1xuXG4gICAgcmV0dXJuIG1vZHVsZS5leHBvcnRzLmNvbXB1dGVkKCgpID0+IHtcbiAgICAgICAgY29uc3Qgc3RhdGVWYWx1ZXMgPSBfLm1hcChzdGF0ZU9ic2VydmFibGVzLCAob2JzKSA9PiBvYnMoKSk7XG5cbiAgICAgICAgaWYgKF8uYWxsKHN0YXRlVmFsdWVzKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH0gZWxzZSBpZiAoXy5zb21lKHN0YXRlVmFsdWVzLCAodmFsKSA9PiB2YWwgPT09IGZhbHNlKSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfSwgeyBkaXNwb3NhbENvbnRleHQ6IG9wdGlvbnMuZGlzcG9zYWxDb250ZXh0IH0pO1xufVxuXG4vKlxuICogQWRkcyB0aGUgc3BlY2lmaWVkIG9iamVjdCB0byBhIGRpc3Bvc2FsIGNvbnRleHQuIElmIG5vbmUgaXMgc3BlY2lmaWVkLCB1c2UgdGhlIHBhZ2UgY29udGV4dC5cbiAqL1xuZnVuY3Rpb24gYWRkVG9EaXNwb3NhbENvbnRleHQoaXRlbSwgY29udGV4dCkge1xuICAgIGNvbnRleHQgPSBjb250ZXh0IHx8IG1vZHVsZS5leHBvcnRzLl9wYWdlQ29udGV4dDtcbiAgICBpZiAoIWNvbnRleHQuX2R4S29EaXNwb3NhbExpc3QpIHtcbiAgICAgICAgZHhVdGlsLmZhaWwoJ0ludmFsaWQgY29udGV4dCBvYmplY3QuJyk7XG4gICAgfVxuXG4gICAgY29udGV4dC5fZHhLb0Rpc3Bvc2FsTGlzdC5wdXNoKGl0ZW0pO1xufVxuXG4vKlxuICogRGlzcG9zZSBhbGwgb2JqZWN0cyBpbiBhbGwgY29udGV4dHMgbWFuYWdlZCBieSB0aGUga28gc3lzdGVtICh3aGljaCBpcyB0byBzYXksIHRoZSBwYWdlIGNvbnRleHQsICdldGVybmFsXG4gKiBjb250ZXh0JywgZXRjLiBidXQgbm90IGluZGl2aWR1YWwgb25lcyBtYW5hZ2VkIGJ5IGFwcCBkZXZlbG9wZXJzKS5cbiAqL1xuZnVuY3Rpb24gZGlzcG9zZUFsbCgpIHtcbiAgICBtb2R1bGUuZXhwb3J0cy5fcGFnZUNvbnRleHQuZHhLb0Rpc3Bvc2UoKTtcbiAgICBtb2R1bGUuZXhwb3J0cy5ldGVybmFsQ29udGV4dC5keEtvRGlzcG9zZSgpO1xuXG4gICAgaWYgKGR4LmNvcmUucGFnZUNvbnRleHQuX2FuZ3VsYXJQYWdlQ29udGV4dCkge1xuICAgICAgICBkeC5jb3JlLnBhZ2VDb250ZXh0Ll9hbmd1bGFyUGFnZUNvbnRleHQuZHhLb0Rpc3Bvc2UoKTtcbiAgICB9XG59XG5cbi8qXG4gKiBSb3V0aW5lIGNhbGxlZCBieSB0aGUgc2NyZWVuIHN5c3RlbSBvbiBwYWdlIHRyYW5zaXRpb24gdG8gY2xlYW4gdXAgdGhlIHBhZ2UgY29udGV4dCBvbiBwYWdlIHRyYW5zaXRpb24uXG4gKi9cbmZ1bmN0aW9uIGNsZWFudXBQYWdlQ29udGV4dCgpIHtcbiAgICBtb2R1bGUuZXhwb3J0cy5fcGFnZUNvbnRleHQuZHhLb0Rpc3Bvc2UoKTtcbiAgICBkeFNjcmVlbi5yZWdpc3RlckNsZWFudXBDYWxsYmFjayhjbGVhbnVwUGFnZUNvbnRleHQpO1xufVxuXG4vKlxuICogRnVuY3Rpb24gdG8gYmUgdXNlZCBmb3IgdGVzdGluZyB0byBtYWtlIHN1cmUgdGhlIHBhZ2UgY29udGV4dCBoYXMgbm90aGluZyBpbiBpdHMgZGlzcG9zYWwgbGlzdC5cbiAqL1xuZnVuY3Rpb24gYXNzZXJ0UGFnZUNvbnRleHRFbXB0eSgpIHtcbiAgICBpZiAobW9kdWxlLmV4cG9ydHMuX3BhZ2VDb250ZXh0Ll9keEtvRGlzcG9zYWxMaXN0Lmxlbmd0aCAhPT0gMCkge1xuICAgICAgICBkeFV0aWwuZmFpbCgnUGFnZSBjb250ZXh0IGlzIG5vdCBlbXB0eSEnKTtcbiAgICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICAgIHJvb3RPcHM6IHt9LFxuICAgIGluaXRpYWxpemU6IGluaXRpYWxpemUsXG4gICAgZGlzcG9zZUFsbEZvclRlc3Rpbmc6IGRpc3Bvc2VBbGwsXG4gICAgYXNzZXJ0UGFnZUNvbnRleHRFbXB0eTogYXNzZXJ0UGFnZUNvbnRleHRFbXB0eSxcbiAgICBEaXNwb3NhbENvbnRleHQ6IERpc3Bvc2FsQ29udGV4dCxcbiAgICBhZGRUb0Rpc3Bvc2FsQ29udGV4dDogYWRkVG9EaXNwb3NhbENvbnRleHQsXG4gICAgZGlzcG9zZUl0ZW1zOiBkaXNwb3NlSXRlbXMsXG4gICAgZXRlcm5hbENvbnRleHQ6IG5ldyBEaXNwb3NhbENvbnRleHQoKSxcbiAgICBfcGFnZUNvbnRleHQ6IG5ldyBEaXNwb3NhbENvbnRleHQoKSxcbiAgICBjb21wdXRlZDogbWFrZUNvbXB1dGVkLFxuICAgIHN1YnNjcmliZTogc3Vic2NyaWJlVG9PYnNlcnZhYmxlLFxuICAgIHN1YnNjcmliZU9uY2U6IHN1YnNjcmliZVRvT2JzZXJ2YWJsZUZvck9uZVVwZGF0ZSxcbiAgICBjaGVja0FuZFN1YnNjcmliZTogY2hlY2tBbmRTdWJzY3JpYmUsXG4gICAgY2hlY2tBbmRTdWJzY3JpYmVUb1N0YXRlZE9ic2VydmFibGU6IGNoZWNrQW5kU3Vic2NyaWJlVG9TdGF0ZWRPYnNlcnZhYmxlLFxuICAgIG1ha2VNZXJnZWRTdGF0ZU9ic2VydmFibGU6IG1ha2VNZXJnZWRTdGF0ZU9ic2VydmFibGVcbn07XG4iLCIvKlxuICogQ29weXJpZ2h0IChjKSAyMDE0LCAyMDE1IGJ5IERlbHBoaXguIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCBkeERhdGEgPSByZXF1aXJlKCdkeGNvcmUvZGF0YS9qcy9pbmRleC5qcycpLFxuICAgIGR4U3lzdGVtID0gcmVxdWlyZSgnZHhjb3JlL2tvL2pzL3N5c3RlbS5qcycpLFxuICAgIGR4T3BlcmF0aW9uID0gcmVxdWlyZSgnZHhjb3JlL2tvL2pzL29wZXJhdGlvbi5qcycpLFxuICAgIGR4Q1NPYmplY3RzID0gcmVxdWlyZSgnZHhjb3JlL2tvL2pzL0NsaWVudFNlcnZlck9iamVjdHMuanMnKTtcblxuLypcbiAqIEluaXRpYWxpemUvc3RhcnQgdXAgYW55IGR4Q29yZSBzeXN0ZW1zXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBpbml0aWFsaXplKCkge1xuICAgIGR4RGF0YS5pbml0aWFsaXplKCk7XG4gICAgZHhTeXN0ZW0uaW5pdGlhbGl6ZShkeE9wZXJhdGlvbi5jYWxsUm9vdE9wZXJhdGlvbiwgZHhDU09iamVjdHMuaXNTY2hlbWFPYmplY3QsIGR4Q1NPYmplY3RzLm1ha2VPYmplY3RGcm9tTW9kZWwpO1xufTtcbiIsIi8qXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTQsIDIwMTUgYnkgRGVscGhpeC4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqL1xuXG4vKiBnbG9iYWwgJCwgXywga28gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCBkeENTT2JqZWN0cyA9IHJlcXVpcmUoJ2R4Y29yZS9rby9qcy9DbGllbnRTZXJ2ZXJPYmplY3RzLmpzJyksXG4gICAgZHhMb2NhbGUgPSByZXF1aXJlKCdkeGNvcmUvanMvbG9jYWxlLmpzJyksXG4gICAgZHhVdGlsID0gcmVxdWlyZSgnZHhjb3JlL2pzL3V0aWwuanMnKSxcbiAgICBkeERhdGEgPSByZXF1aXJlKCdkeGNvcmUvZGF0YS9qcy9pbmRleC5qcycpLFxuICAgIGR4U2NyZWVuID0gcmVxdWlyZSgnZHhjb3JlL2pzL3NjcmVlbi5qcycpLFxuICAgIGR4VXNlclV0aWwgPSByZXF1aXJlKCdkeGNvcmUvanMvdXNlclV0aWwuanMnKSxcbiAgICBkeFN5c3RlbSA9IHJlcXVpcmUoJ2R4Y29yZS9rby9qcy9zeXN0ZW0uanMnKSxcbiAgICBkeFNlc3Npb24gPSByZXF1aXJlKCdkeGNvcmUvanMvc2Vzc2lvbi5qcycpLFxuICAgIGR4Q29uc3RhbnRzID0gcmVxdWlyZSgnZHhjb3JlL2pzL2NvbnN0YW50cy5qcycpO1xuXG4vKlxuICogVGhpcyBmaWxlIGNvbnRhaW5zIHRoZSBsb2dpYyB0byBpbml0aWF0ZSBzZXNzaW9uL2xvZ2luIGNhbGxzIHRvIHZlcmlmeSBjcmVkZW50aWFscyBvZiBhIHVzZXJcbiAqIGFuZCBsb2cgaGltIGludG8gdGhlIHN5c3RlbS5cbiAqXG4gKiBPbiBwYWdlIGxvYWQgd2UgY2hlY2sgZm9yIHByZXNlbmNlIG9mIGEgc2Vzc2lvbiBhbmQgaWYgYSB2YWxpZCBzZXNzaW9uIGlzIGZvdW5kLCB3ZSByZXRyaWV2ZSB0aGUgY3VycmVudCB1c2VyXG4gKiBhbmQgcmVkaXJlY3QgdG8gZWl0aGVyIHRoZSBtYWluIGFwcCBvciB0aGUgc3lzdGVtIGFwcC5cbiAqL1xubW9kdWxlLmV4cG9ydHMubG9naW5WaWV3TW9kZWwgPSBmdW5jdGlvbihicm93c2VyRGVwcmVjYXRlZCwgYnJvd3NlclVuc3VwcG9ydGVkKSB7XG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAvLyBwcml2YXRlIHByb3BlcnRpZXNgY29yZVxuXG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICB2YXIgc2VsZiA9IHRoaXMsXG4gICAgICAgIGN1cnJlbnRVc2VyO1xuXG4gICAgdmFyIGxvZ2luUmVxdWVzdE1vZGVsID0gbmV3IGR4Q1NPYmplY3RzLkNsaWVudE9iamVjdCgnTG9naW5SZXF1ZXN0JyksXG4gICAgICAgIC8vIGNvbnN0YW50c1xuICAgICAgICBET01BSU4gPSAnRE9NQUlOJyxcbiAgICAgICAgU1lTVEVNID0gJ1NZU1RFTScsXG4gICAgICAgIFNBUCA9ICdzYXAnO1xuXG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAvLyB2aWV3IG1vZGVsIHByb3BlcnRpZXNcbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgIHNlbGYudXNlcm5hbWUgPSBsb2dpblJlcXVlc3RNb2RlbC51c2VybmFtZTtcbiAgICBzZWxmLnBhc3N3b3JkID0gbG9naW5SZXF1ZXN0TW9kZWwucGFzc3dvcmQ7XG5cbiAgICAvLyBUaGUgYXBwIHRoZSB1c2VyIGlzIGF0dGVtcHRpbmcgdG8gbG9nIGludG9cbiAgICBzZWxmLnRhcmdldCA9IGxvZ2luUmVxdWVzdE1vZGVsLnRhcmdldDtcbiAgICBzZWxmLmlzRG9tYWluTG9naW4gPSBrby5jb21wdXRlZChmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHNlbGYudGFyZ2V0KCkgPT09IERPTUFJTjtcbiAgICB9KTtcbiAgICBzZWxmLmlzU3lzdGVtTG9naW4gPSBrby5jb21wdXRlZChmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHNlbGYudGFyZ2V0KCkgPT09IFNZU1RFTTtcbiAgICB9KTtcblxuICAgIHNlbGYuc2hvd0FkbWluTG9nbyA9IGtvLmNvbXB1dGVkKGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gc2VsZi5pc0RvbWFpbkxvZ2luKCkgJiYgIXNlbGYuZXhwcmVzc1Byb2R1Y3QoKTtcbiAgICB9KTtcblxuICAgIHNlbGYuc2hvd0ZyZWVBZG1pbkxvZ28gPSBrby5jb21wdXRlZChmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHNlbGYuaXNEb21haW5Mb2dpbigpICYmIHNlbGYuZXhwcmVzc1Byb2R1Y3QoKTtcbiAgICB9KTtcblxuICAgIHNlbGYuc2hvd1NldHVwTG9nbyA9IGtvLmNvbXB1dGVkKGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gc2VsZi5pc1N5c3RlbUxvZ2luKCkgJiYgIXNlbGYuZXhwcmVzc1Byb2R1Y3QoKTtcbiAgICB9KTtcblxuICAgIHNlbGYuc2hvd0ZyZWVTZXR1cExvZ28gPSBrby5jb21wdXRlZChmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHNlbGYuaXNTeXN0ZW1Mb2dpbigpICYmIHNlbGYuZXhwcmVzc1Byb2R1Y3QoKTtcbiAgICB9KTtcblxuICAgIHNlbGYuc3VibWl0SW5Qcm9ncmVzcyA9IGtvLm9ic2VydmFibGUoZmFsc2UpO1xuICAgIHNlbGYuY2FuY2VsSW5Qcm9ncmVzcyA9IGtvLm9ic2VydmFibGUoZmFsc2UpO1xuICAgIHNlbGYuZmF0YWxFcnJvck1lc3NhZ2UgPSBrby5vYnNlcnZhYmxlKHVuZGVmaW5lZCk7XG4gICAgc2VsZi5zdWdnZXN0ZWRBY3Rpb25NZXNzYWdlID0ga28ub2JzZXJ2YWJsZSh1bmRlZmluZWQpO1xuICAgIHNlbGYuYmFubmVyID0ga28ub2JzZXJ2YWJsZUFycmF5KCk7XG5cbiAgICBzZWxmLmhhc0ZhdGFsRXJyb3IgPSBrby5jb21wdXRlZChmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuICFfLmlzVW5kZWZpbmVkKHNlbGYuZmF0YWxFcnJvck1lc3NhZ2UoKSk7XG4gICAgfSk7XG5cbiAgICAvLyBIZWxwcyBzZXQgaW5wdXQgZm9jdXMgZm9yIGxvZ2luIGZvcm1cbiAgICBzZWxmLmF3YWl0aW5nTG9naW4gPSBrby5vYnNlcnZhYmxlKGZhbHNlKTtcbiAgICBzZWxmLmF3YWl0aW5nUGFzc3dvcmQgPSBrby5vYnNlcnZhYmxlKGZhbHNlKTtcblxuICAgIHNlbGYuaXNTQVBFZGl0aW9uID0ga28ub2JzZXJ2YWJsZShmYWxzZSk7XG4gICAgc2VsZi5leHByZXNzUHJvZHVjdCA9IGtvLm9ic2VydmFibGUoZmFsc2UpO1xuICAgIHNlbGYuYm9keUNzcyA9IGtvLm9ic2VydmFibGUoJ21haW4tYm9keSBkZWZhdWx0Jyk7XG5cbiAgICAvLyBGaXJzdCB0aW1lIGxvZ2luXG4gICAgc2VsZi5wYXNzd29yZFVwZGF0ZVJlcXVlc3RlZCA9IGtvLm9ic2VydmFibGUoZmFsc2UpO1xuICAgIHNlbGYuY29uZmlybVBhc3N3b3JkID0ga28ub2JzZXJ2YWJsZSgnJyk7XG4gICAgc2VsZi5uZXdQYXNzd29yZCA9IGtvLm9ic2VydmFibGUoJycpO1xuICAgIC8vIE9ubHkgYSBkZWxwaGl4IGFkbWluIG5lZWRzIHRvIGVudGVyIHRoZWlyIGVtYWlsIC0gYWxsIG90aGVyIHVzZXJzIHByb3ZpZGVkIGFuIGVtYWlsIGFkZHJlc3Mgd2hlbiBjcmVhdGVkXG4gICAgc2VsZi5pc0VtYWlsUmVxdWlyZWQgPSBrby5vYnNlcnZhYmxlKGZhbHNlKTtcbiAgICBzZWxmLmVtYWlsID0ga28ub2JzZXJ2YWJsZSgnJyk7XG4gICAgdmFyIHN5c3RlbUxvY2FsZSA9IGtvLm9ic2VydmFibGUoJycpO1xuXG4gICAgc2VsZi5tZXNzYWdlID0ga28ub2JzZXJ2YWJsZSgnJyk7XG4gICAgc2VsZi5pbnZhbGlkRW1haWxNZXNzYWdlID0ga28ub2JzZXJ2YWJsZSgnJyk7XG4gICAgc2VsZi5wYXNzd29yZENoYW5nZU1lc3NhZ2UgPSBrby5vYnNlcnZhYmxlKGR4TG9jYWxlLmdscygncGFzc3dvcmQuY2hhbmdlLm1lc3NhZ2UnKSk7XG5cbiAgICAvLyBJbml0aWFsaXplIHdpdGggZGVmYXVsdHNcbiAgICBzZWxmLnVzZXJuYW1lKCcnKTtcbiAgICBzZWxmLnBhc3N3b3JkKCcnKTtcbiAgICBzZWxmLnRhcmdldChET01BSU4pO1xuXG4gICAgLy8gVXNlIHBhcmFtZXRlcnMgdG8gc2V0IHVwIGEgd2FybmluZyB0byB0aGUgdXNlciBhYm91dCB0aGUgYnJvd3NlciB2ZXJzaW9uXG4gICAgc2VsZi5icm93c2VyTWVzc2FnZSA9IGtvLm9ic2VydmFibGUoJycpO1xuICAgIGlmIChicm93c2VyVW5zdXBwb3J0ZWQpIHtcbiAgICAgICAgc2VsZi5icm93c2VyTWVzc2FnZShkeExvY2FsZS5nbHMoJ2Jyb3dzZXIudW5zdXBwb3J0ZWQnKSk7XG4gICAgfSBlbHNlIGlmIChicm93c2VyRGVwcmVjYXRlZCkge1xuICAgICAgICBzZWxmLmJyb3dzZXJNZXNzYWdlKGR4TG9jYWxlLmdscygnYnJvd3Nlci5kZXByZWNhdGVkJykpO1xuICAgIH1cblxuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgLy8gdmlldyBtb2RlbCBmdW5jdGlvbnNcbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4gICAgLypcbiAgICAgKiBsb2dpbiBnZXRzIGludm9rZWQgd2hlbiB1c2VyIHN1Ym1pdHMgdGhlIGxvZ2luIGZvcm0uXG4gICAgICovXG4gICAgc2VsZi5sb2dpbiA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAvLyBJZiB1c2VyIGNsaWNrcyAnY29udGludWUnIHdoaWxlIGNhbmNlbCBpcyBpbiBwcm9ncmVzcywgZG9uJ3QgZG8gbG9naW5cbiAgICAgICAgaWYgKHNlbGYuY2FuY2VsSW5Qcm9ncmVzcygpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICAvKlxuICAgICAgICAgKiBUaGlzIGlzIGEgaGFjayB0byBhbGxvdyB1c2VybmFtZS9wYXNzd29yZCB2YWx1ZXMgdG8gYmUgcmVmbGVjdGVkIGluIG9ic2VydmFibGVzIGluIGNhc2UgdGhleSBoYXZlIGJlZW5cbiAgICAgICAgICogZmlsbGVkIGluIGF1dG9tYXRpY2FsbHkgYnkgYnJvd3NlcnMuXG4gICAgICAgICAqL1xuICAgICAgICAkKCcjdXNlcm5hbWUsI3Bhc3N3b3JkJykudHJpZ2dlcignY2hhbmdlJyk7XG5cbiAgICAgICAgc2VsZi5tZXNzYWdlKCcnKTtcbiAgICAgICAgc2VsZi5mYXRhbEVycm9yTWVzc2FnZSh1bmRlZmluZWQpO1xuICAgICAgICBzZWxmLnN1Z2dlc3RlZEFjdGlvbk1lc3NhZ2UodW5kZWZpbmVkKTtcbiAgICAgICAgaWYgKHNlbGYudXNlcm5hbWUoKSAhPT0gJycpIHtcbiAgICAgICAgICAgIHNlbGYuc3VibWl0SW5Qcm9ncmVzcyh0cnVlKTtcbiAgICAgICAgICAgIC8vIEl0J3MgcG9zc2libGUgd2UndmUgbG9zdCBvdXIgQVBJIHNlc3Npb24gc2luY2UgaW5pdGlhbGx5IG9idGFpbmluZyBpdFxuICAgICAgICAgICAgY3JlYXRlU2Vzc2lvbihwb3N0TG9naW4pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgc2VsZi5tZXNzYWdlKGR4TG9jYWxlLmdscygndXNlcm5hbWUucmVxdWlyZWQucHJvbXB0JykpO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIC8qXG4gICAgICogcG9zdExvZ2luIGluaXRpYXRlcyB0aGUgbG9naW4uIE9uIHN1Y2Nlc3MsIHRoZSBjdXJyZW50IHVzZXIgaW5mb3JtYXRpb24gaXMgZmV0Y2hlZC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBwb3N0TG9naW4oKSB7XG4gICAgICAgIGR4U3lzdGVtLnJvb3RPcHMuZGVscGhpeF9jb21tb24uJGxvZ2luKGxvZ2luUmVxdWVzdE1vZGVsLCB7XG4gICAgICAgICAgICBzdWNjZXNzOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICBnZXRDdXJyZW50VXNlcigpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGVycm9yOiBmdW5jdGlvbihlcnJvclJlc3VsdCkge1xuICAgICAgICAgICAgICAgIHNlbGYuc3VibWl0SW5Qcm9ncmVzcyhmYWxzZSk7XG4gICAgICAgICAgICAgICAgc2hvd0Vycm9yKGVycm9yUmVzdWx0Ll9keE1vZGVsKTsgLy8gc2hvd0Vycm9yIGV4cGVjdHMgYSBiYWNrYm9uZSBtb2RlbFxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICAvKlxuICAgICAqIHNob3dFcnJvciBhY2NlcHRzIGFuIGVycm9yUmVzdWx0IG9iamVjdCwgZmlzaGVzIG91dCBlcnJvciBtZXNzYWdlIGFuZCB1cGRhdGVzIHRoZSB2aWV3IG1vZGVsIG1lc3NhZ2UgYmluZGluZy5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBzaG93RXJyb3IoZXJyb3JSZXN1bHQpIHtcbiAgICAgICAgc2VsZi5tZXNzYWdlKGVycm9yUmVzdWx0LmdldCgnZXJyb3InKS5nZXQoJ2RldGFpbHMnKSk7XG4gICAgfVxuXG4gICAgLypcbiAgICAgKiBzaG93RXJyb3IgYWNjZXB0cyBhbiBlcnJvclJlc3VsdCBvYmplY3QsIGZpc2hlcyBvdXQgZXJyb3IgbWVzc2FnZSBhbmQgdXBkYXRlcyB0aGUgdmlldyBtb2RlbCBtZXNzYWdlIGJpbmRpbmcuXG4gICAgICovXG4gICAgc2VsZi5zaG93Q29ubmVjdGl2aXR5RXJyb3IgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgc2VsZi5tZXNzYWdlKGR4TG9jYWxlLmdscygnZ2VuZXJpYy5sb2dpbi5mYWlsdXJlJykpO1xuICAgIH07XG5cbiAgICAvKlxuICAgICAqIGdldEN1cnJlbnRVc2VyIGludm9rZXMgY3VycmVudCBvYmplY3Qgb3BlcmF0aW9uIG9uIHVzZXIgb2JqZWN0LlxuICAgICAqIE9uIHN1Y2Nlc3MsIGlmIHBhc3N3b3JkVXBkYXRlUmVxdWVzdGVkIGZsYWcgaXMgZm91bmQgdG8gYmUgZmFsc2UgdGhlbiB1c2VyIGlzIHJlZGlyZWN0ZWQgdG8gcmVxdWVzdGVkIGFwcCxcbiAgICAgKiBvdGhlcndpc2UgdGhlIHVzZXIgaXMgcmVxdWVzdGVkIGEgbmV3IHBhc3N3b3JkIChhY2hpZXZlZCBieSBwYXNzd29yZFVwZGF0ZVJlcXVlc3RlZCBWaWV3IEJpbmRpbmcpXG4gICAgICovXG4gICAgZnVuY3Rpb24gZ2V0Q3VycmVudFVzZXIoKSB7XG4gICAgICAgIGR4RGF0YS5yb290T3BzLlVzZXIuJGN1cnJlbnQoe1xuICAgICAgICAgICAgc3VjY2VzczogZnVuY3Rpb24ob2tSZXN1bHQpIHtcbiAgICAgICAgICAgICAgICAvKlxuICAgICAgICAgICAgICAgICAqIE5vdGU6IGN1cnJlbnRVc2VyIGNhbiBiZSB1bmRlZmluZWQgaWYgdGhlIERlbHBoaXggRW5naW5lIGlzbid0IHNldCB1cC4gSG93ZXZlciwgdG8gZ2V0IHRoaXMgcG9pbnRcbiAgICAgICAgICAgICAgICAgKiBpbiB0aGUgcHJvY2VzcywgaXQgaGFzIHRvIGhhdmUgYmVlbiBzZXQgdXAuXG4gICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgY3VycmVudFVzZXIgPSBva1Jlc3VsdC5nZXQoJ3Jlc3VsdCcpO1xuICAgICAgICAgICAgICAgIGlmIChjdXJyZW50VXNlci5nZXQoJ3Bhc3N3b3JkVXBkYXRlUmVxdWVzdGVkJykgPT09IHRydWUpIHtcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5zdWJtaXRJblByb2dyZXNzKGZhbHNlKTtcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5wYXNzd29yZFVwZGF0ZVJlcXVlc3RlZCh0cnVlKTtcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5hd2FpdGluZ1Bhc3N3b3JkKHRydWUpO1xuICAgICAgICAgICAgICAgICAgICBzZWxmLnVzZXJuYW1lKGN1cnJlbnRVc2VyLmdldCgnbmFtZScpKTtcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5lbWFpbChjdXJyZW50VXNlci5nZXQoJ2VtYWlsQWRkcmVzcycpKTtcblxuICAgICAgICAgICAgICAgICAgICBpZiAoc2VsZi51c2VybmFtZSgpID09PSAnZGVscGhpeF9hZG1pbicgJiYgXy5pc0VtcHR5KHNlbGYuZW1haWwoKSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYuaXNFbWFpbFJlcXVpcmVkKHRydWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5wYXNzd29yZENoYW5nZU1lc3NhZ2UoZHhMb2NhbGUuZ2xzKCdwYXNzd29yZC5hbmQuZW1haWwuY2hhbmdlLm1lc3NhZ2UnKSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB2YXIgbG9jYWxlID0gY3VycmVudFVzZXIuZ2V0KCdsb2NhbGUnKTtcblxuICAgICAgICAgICAgICAgICAgICBpZiAoXy5pc1N0cmluZyhsb2NhbGUpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobG9jYWxlID09PSAnZGVmYXVsdCcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsb2NhbGUgPSBzeXN0ZW1Mb2NhbGUoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgLypcbiAgICAgICAgICAgICAgICAgICAgICAgICAqIFRoZSBmcm9udGVuZCBsb2NhbGUgaGFuZGxlcnMgdXNlZCBieSBib3RoIGZsZXggYW5kIHRoZSBKUyBHVUkgZG9uJ3QgbGlrZSBvdXJcbiAgICAgICAgICAgICAgICAgICAgICAgICAqIDItZGFzaGVkIGxvY2FsZS4gR2l2ZW4gb3VyIHBzZXVkb2xvY2FsaXphdGlvbiBsb2NhbGUsIG1vZGlmeSBpdCBmb3IgdGhlIGZyb250XG4gICAgICAgICAgICAgICAgICAgICAgICAgKiBlbmQgdG8gdGhpcyBub24tZXhpc3RpbmcgbG9jYWxlIGNvZGUuXG4gICAgICAgICAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChsb2NhbGUgPT09ICdlbi1VUy1wc2FjY2VudCcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsb2NhbGUgPSAnZW4tUFMnO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICBkeFV0aWwuc2V0Q29va2llKCdsb2NhbGUnLCBsb2NhbGUsIDMwKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIHJlZGlyZWN0VXNlcigpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBlcnJvcjogZnVuY3Rpb24oZXJyb3JSZXN1bHQpIHtcbiAgICAgICAgICAgICAgICBzZWxmLnN1Ym1pdEluUHJvZ3Jlc3MoZmFsc2UpO1xuICAgICAgICAgICAgICAgIHNob3dFcnJvcihlcnJvclJlc3VsdCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIC8qXG4gICAgICogQ2FuIGJlIHRyaWdnZXJlZCBieSB0aGUgdXNlciBjbGlja2luZyAnY2FuY2VsJyBpbiB0aGUgdXBkYXRlIHVzZXIgZm9ybVxuICAgICAqL1xuICAgIHNlbGYuY2FuY2VsTG9naW4gPSBmdW5jdGlvbigpIHtcbiAgICAgICAgLypcbiAgICAgICAgICogQWZ0ZXIgc3VibWl0dGluZyB1cGRhdGVkIHBhc3N3b3JkLCB0aGUgY2FuY2VsIGJ1dHRvbiBpcyBzdGlsbCBlbmFibGVkLlxuICAgICAgICAgKiBNYWtlIHN1cmUgdGhlIHVzZXIgZG9lc24ndCBjbGljayBjYW5jZWwgd2hpbGUgc3VibWl0IGlzIGluIHByb2dyZXNzLlxuICAgICAgICAgKi9cbiAgICAgICAgaWYgKHNlbGYuc3VibWl0SW5Qcm9ncmVzcygpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBzZWxmLmNhbmNlbEluUHJvZ3Jlc3ModHJ1ZSk7XG4gICAgICAgIGR4U2Vzc2lvbi5lbmRTZXNzaW9uKCk7XG4gICAgfTtcblxuICAgIC8qXG4gICAgICogdXBkYXRlVXNlciBjaGVja3MgZm9yIHZhbGlkIHBhc3N3b3JkIGFuZCB0aGVuIHRoZW4gdHJpZ2dlcnMgdXBkYXRlIHBhc3N3b3JkIG1ldGhvZC5cbiAgICAgKiBUcmlnZ2VyZWQgZnJvbSBjbGlja2luZyAnY29udGludWUnIGluIHRoZSB1cGRhdGUgdXNlciBmb3JtXG4gICAgICovXG4gICAgc2VsZi51cGRhdGVVc2VyID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHNlbGYuaW52YWxpZEVtYWlsTWVzc2FnZSgnJyk7XG4gICAgICAgIHNlbGYubWVzc2FnZSgnJyk7XG5cbiAgICAgICAgaWYgKHNlbGYuaXNFbWFpbFJlcXVpcmVkKCkpIHtcbiAgICAgICAgICAgIGlmIChzZWxmLmVtYWlsKCkgPT09ICcnKSB7XG4gICAgICAgICAgICAgICAgc2VsZi5pbnZhbGlkRW1haWxNZXNzYWdlKGR4TG9jYWxlLmdscygnZW1haWwucmVxdWlyZWQucHJvbXB0JykpO1xuICAgICAgICAgICAgfSBlbHNlIGlmICghZHhVdGlsLmlzVmFsaWRFbWFpbChzZWxmLmVtYWlsKCkpKSB7XG4gICAgICAgICAgICAgICAgc2VsZi5pbnZhbGlkRW1haWxNZXNzYWdlKGR4TG9jYWxlLmdscygnaW52YWxpZC5lbWFpbC5wcm9tcHQnKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoc2VsZi5uZXdQYXNzd29yZCgpID09PSAnJykge1xuICAgICAgICAgICAgc2VsZi5tZXNzYWdlKGR4TG9jYWxlLmdscygncGFzc3dvcmQucmVxdWlyZWQucHJvbXB0JykpO1xuICAgICAgICB9IGVsc2UgaWYgKHNlbGYubmV3UGFzc3dvcmQoKSAhPT0gc2VsZi5jb25maXJtUGFzc3dvcmQoKSkge1xuICAgICAgICAgICAgc2VsZi5tZXNzYWdlKGR4TG9jYWxlLmdscygncGFzc3dvcmRzLm5vdC5tYXRjaGluZy5wcm9tcHQnKSk7XG4gICAgICAgIH0gZWxzZSBpZiAoc2VsZi5pc0VtYWlsUmVxdWlyZWQoKSkge1xuICAgICAgICAgICAgaWYgKHNlbGYuaW52YWxpZEVtYWlsTWVzc2FnZSgpID09PSAnJykge1xuICAgICAgICAgICAgICAgIGN1cnJlbnRVc2VyLiQkdXBkYXRlKHtcbiAgICAgICAgICAgICAgICAgICAgZW1haWxBZGRyZXNzOiBzZWxmLmVtYWlsKClcbiAgICAgICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgICAgICAgIHN1Y2Nlc3M6IHVwZGF0ZVBhc3N3b3JkLFxuICAgICAgICAgICAgICAgICAgICBlcnJvcjogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZWxmLm1lc3NhZ2UoZHhMb2NhbGUuZ2xzKCdnZW5lcmljLmxvZ2luLmZhaWx1cmUnKSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHVwZGF0ZVBhc3N3b3JkKCk7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgLypcbiAgICAgKiB1cGRhdGVQYXNzd29yZCBmaXJlcyB1cGRhdGVDcmVkZW50aWFsIG9wZXJhdGlvbiBvbiB1c2VyIG9iamVjdCB0byB1cGRhdGUgdXNlciBwYXNzd29yZC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiB1cGRhdGVQYXNzd29yZCgpIHtcbiAgICAgICAgdmFyIHVwZGF0ZVBhcmFtZXRlcnMgPSBkeERhdGEubmV3Q2xpZW50TW9kZWwoJ0NyZWRlbnRpYWxVcGRhdGVQYXJhbWV0ZXJzJyk7XG4gICAgICAgIHVwZGF0ZVBhcmFtZXRlcnMuZ2V0KCdvbGRDcmVkZW50aWFsJykuc2V0KCdwYXNzd29yZCcsIHNlbGYucGFzc3dvcmQoKSk7XG4gICAgICAgIHVwZGF0ZVBhcmFtZXRlcnMuZ2V0KCduZXdDcmVkZW50aWFsJykuc2V0KCdwYXNzd29yZCcsIHNlbGYuY29uZmlybVBhc3N3b3JkKCkpO1xuXG4gICAgICAgIHNlbGYuc3VibWl0SW5Qcm9ncmVzcyh0cnVlKTtcbiAgICAgICAgY3VycmVudFVzZXIuJHVwZGF0ZUNyZWRlbnRpYWwodXBkYXRlUGFyYW1ldGVycywge1xuICAgICAgICAgICAgc3VjY2VzczogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgc2VsZi5wYXNzd29yZChzZWxmLmNvbmZpcm1QYXNzd29yZCgpKTtcbiAgICAgICAgICAgICAgICBzZWxmLmxvZ2luKCk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZXJyb3I6IGZ1bmN0aW9uKGVycm9yUmVzdWx0KSB7XG4gICAgICAgICAgICAgICAgc2VsZi5zdWJtaXRJblByb2dyZXNzKGZhbHNlKTtcbiAgICAgICAgICAgICAgICBzaG93RXJyb3IoZXJyb3JSZXN1bHQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICAvKlxuICAgICAqIFRoaXMgZnVuY3Rpb24gcmVkaXJlY3RzIHRoZSB1c2VyIHRvIGFuIGFwcHJvcHJpYXRlIGFwcCBhZnRlciBhIHN1Y2Nlc3NmdWwgbG9naW4uXG4gICAgICovXG4gICAgZnVuY3Rpb24gcmVkaXJlY3RVc2VyKCkge1xuICAgICAgICB2YXIgdXNlclR5cGUgPSBjdXJyZW50VXNlci5nZXQoJ3VzZXJUeXBlJykudG9VcHBlckNhc2UoKSxcbiAgICAgICAgICAgIHVzZXJSZWYgPSBjdXJyZW50VXNlci5nZXQoJ3JlZmVyZW5jZScpO1xuXG4gICAgICAgIGlmICh1c2VyVHlwZSA9PT0gRE9NQUlOICYmIHNlbGYudGFyZ2V0KCkgPT09IERPTUFJTikge1xuICAgICAgICAgICAgdmFyIHJvbGVzUHJvbWlzZSA9IGR4VXNlclV0aWwuZ2V0RGVmYXVsdFJvbGVzKCksXG4gICAgICAgICAgICAgICAgYXV0aG9yaXphdGlvbnNQcm9taXNlID0gZHhEYXRhLmdldFNlcnZlckNvbGxlY3Rpb24oJ0F1dGhvcml6YXRpb24nKVxuICAgICAgICAgICAgICAgIC4kJGxpc3Qoe1xuICAgICAgICAgICAgICAgICAgICB1c2VyOiB1c2VyUmVmXG4gICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIC8vIFdhaXQgdW50aWwgd2UndmUgZ290dGVuIGFsbCByZWxldmFudCB1c2VyIGluZm8gdG8gaGFuZGxlIHBlcm1pc3Npb24gYW5kIHJlZGlyZWN0IGxvZ2ljXG4gICAgICAgICAgICAkLndoZW4oYXV0aG9yaXphdGlvbnNQcm9taXNlLCByb2xlc1Byb21pc2UpXG4gICAgICAgICAgICAgICAgLnRoZW4oZnVuY3Rpb24oYXV0aG9yaXphdGlvbnMsIGRlZmF1bHRSb2xlcykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgaXNKZXRTdHJlYW1Vc2VyID0gZHhVc2VyVXRpbC5pc0pldFN0cmVhbVVzZXIodXNlclJlZiwgYXV0aG9yaXphdGlvbnMsIGRlZmF1bHRSb2xlcyksXG4gICAgICAgICAgICAgICAgICAgICAgICBpc0FkbWluID0gZHhVc2VyVXRpbC5pc0RlbHBoaXhBZG1pbih1c2VyUmVmLCBhdXRob3JpemF0aW9ucywgZGVmYXVsdFJvbGVzKTtcblxuICAgICAgICAgICAgICAgICAgICBpZiAoaXNKZXRTdHJlYW1Vc2VyICYmICFpc0FkbWluKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkeFNjcmVlbi5uYXZpZ2F0ZUV4dGVybmFsKCcvamV0c3RyZWFtLyNkYXRhLW1nbXQnKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGR4U2NyZWVuLm5hdmlnYXRlRXh0ZXJuYWwoJy9TZXJ2ZXIuaHRtbCcpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSkuZmFpbChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5tZXNzYWdlKGR4TG9jYWxlLmdscygnZ2VuZXJpYy5sb2dpbi5mYWlsdXJlJykpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2UgaWYgKHVzZXJUeXBlID09PSBTWVNURU0gJiYgc2VsZi50YXJnZXQoKSA9PT0gU1lTVEVNKSB7XG4gICAgICAgICAgICBkeFNjcmVlbi5uYXZpZ2F0ZUV4dGVybmFsKCcvU2VydmVyU2V0dXAuaHRtbCcpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgc2VsZi5zdWJtaXRJblByb2dyZXNzKGZhbHNlKTtcbiAgICAgICAgICAgIHNlbGYubWVzc2FnZShkeExvY2FsZS5nbHMoJ2ludmFsaWQuY3JlZGVudGlhbHMucHJvbXB0JykpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLypcbiAgICAgKiBnZXRQdWJsaWNTeXN0ZW1JbmZvIG1ldGhvZCBmZXRjaGVzIHRoZSBQdWJsaWNTeXN0ZW1JbmZvIHNpbmdsZXRvbiBvYmplY3QgdG8gdmVyaWZ5IGlmIHRoZSBzZXJ2ZXJcbiAgICAgKiBoYXMgYmVlbiBjb25maWd1cmVkIG9yIG5vdC4gSWYgaXQgaGFzIGJlZW4gY29uZmlndXJlZCwgaXQgZmlyZXMgdGhlIGdldEN1cnJlbnRVc2VyIG1ldGhvZCBvdGhlcndpc2VcbiAgICAgKiByZWRpcmVjdHMgdGhlIHVzZXIgdG8gc2V0dXAgYXBwLlxuICAgICAqIE9uIGVycm9yLCBpdCBpcyBhc3N1bWVkIHRoYXQgc2VydmVyIGlzIHVucmVhY2hhYmxlIGFuZCBhIHJldHJ5IGlzIGlzc3VlZCBldmVyeSAxMDBtcy5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBnZXRQdWJsaWNTeXN0ZW1JbmZvKCkge1xuICAgICAgICB2YXIgcHVibGljU3lzdGVtSW5mbyA9IGR4RGF0YS5nZXRTZXJ2ZXJTaW5nbGV0b24oJ1B1YmxpY1N5c3RlbUluZm8nKTtcbiAgICAgICAgZnVuY3Rpb24gc3VjY2Vzc0hhbmRsZXIoKSB7XG4gICAgICAgICAgICAvLyBDbGVhciBlcnJvciBtZXNzYWdlIGluIGNhc2UgdGhpcyBjYWxsIGhhZCBwcmV2aW91c2x5IGZhaWxlZFxuICAgICAgICAgICAgc2VsZi5tZXNzYWdlKCcnKTtcblxuICAgICAgICAgICAgaWYgKCFwdWJsaWNTeXN0ZW1JbmZvLmdldCgnY29uZmlndXJlZCcpKSB7XG4gICAgICAgICAgICAgICAgZHhTY3JlZW4ubmF2aWdhdGVFeHRlcm5hbCgnL1NldHVwLmh0bWwnKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgc2VsZi5pc1NBUEVkaXRpb24ocHVibGljU3lzdGVtSW5mby5nZXQoJ3Byb2R1Y3RUeXBlJykgPT09IFNBUCk7XG5cbiAgICAgICAgICAgIGlmIChwdWJsaWNTeXN0ZW1JbmZvLmdldCgnYmFubmVyJykpIHtcbiAgICAgICAgICAgICAgICAvLyBSZXByZXNlbnQgYXMgYW4gYXJyYXkgb2YgbGluZXMgdG8gbWFrZSBtdWx0aWxpbmUgYmFubmVycyB3aXRoIDxicj4gZWFzaWVyXG4gICAgICAgICAgICAgICAgc2VsZi5iYW5uZXIocHVibGljU3lzdGVtSW5mby5nZXQoJ2Jhbm5lcicpLnNwbGl0KCdcXG4nKSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChwdWJsaWNTeXN0ZW1JbmZvLmdldCgnY3VycmVudExvY2FsZScpKSB7XG4gICAgICAgICAgICAgICAgc3lzdGVtTG9jYWxlKHB1YmxpY1N5c3RlbUluZm8uZ2V0KCdjdXJyZW50TG9jYWxlJykpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBTZXQgd2hldGhlciBvciBub3QgdGhpcyBpcyB0aGUgZXhwcmVzcyBlZGl0aW9uIHByb2R1Y3RcbiAgICAgICAgICAgIGNvbnN0IHByb2R1Y3RUeXBlID0gcHVibGljU3lzdGVtSW5mby5nZXQoJ3Byb2R1Y3RUeXBlJyk7XG4gICAgICAgICAgICBzZWxmLmV4cHJlc3NQcm9kdWN0KHByb2R1Y3RUeXBlID09PSAnZXhwcmVzcycpO1xuICAgICAgICB9XG4gICAgICAgIHB1YmxpY1N5c3RlbUluZm8ub25jZSgncmVhZHknLCBzdWNjZXNzSGFuZGxlcik7XG4gICAgICAgIHB1YmxpY1N5c3RlbUluZm8ub25jZSgnZXJyb3InLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHNlbGYubWVzc2FnZShkeExvY2FsZS5nbHMoJ2dlbmVyaWMubG9naW4uZmFpbHVyZScpKTtcbiAgICAgICAgICAgIHNldFRpbWVvdXQoZ2V0UHVibGljU3lzdGVtSW5mbywgMTAwKTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY3JlYXRlU2Vzc2lvbihjb250aW51YXRpb24pIHtcbiAgICAgICAgdmFyIHNlc3Npb25QYXlsb2FkID0gZHhEYXRhLm5ld0NsaWVudE1vZGVsKCdBUElTZXNzaW9uJyk7XG5cbiAgICAgICAgc2Vzc2lvblBheWxvYWQuc2V0KHtcbiAgICAgICAgICAgIHZlcnNpb246IHtcbiAgICAgICAgICAgICAgICBtYWpvcjogZHhDb25zdGFudHMuVkVSU0lPTl9NQUpPUixcbiAgICAgICAgICAgICAgICBtaW5vcjogZHhDb25zdGFudHMuVkVSU0lPTl9NSU5PUixcbiAgICAgICAgICAgICAgICBtaWNybzogZHhDb25zdGFudHMuVkVSU0lPTl9NSUNST1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICBkeERhdGEucm9vdE9wcy5BUElTZXNzaW9uLiQkY3JlYXRlKHNlc3Npb25QYXlsb2FkLCB7XG4gICAgICAgICAgICBzdWNjZXNzOiBjb250aW51YXRpb24sXG4gICAgICAgICAgICBlcnJvcjogZnVuY3Rpb24oZXJyb3IpIHtcbiAgICAgICAgICAgICAgICBzZWxmLmZhdGFsRXJyb3JNZXNzYWdlKGVycm9yLmdldCgnZXJyb3InKS5nZXQoJ2RldGFpbHMnKSk7XG4gICAgICAgICAgICAgICAgc2VsZi5zdWdnZXN0ZWRBY3Rpb25NZXNzYWdlKGVycm9yLmdldCgnZXJyb3InKS5nZXQoJ2FjdGlvbicpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAvLyBmZXRjaCBtb2RlbHMvY29sbGVjdGlvbnMgZnJvbSBzZXJ2ZXJcbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4gICAgLypcbiAgICAgKiBTZXNzaW9uIGlzIHdoZXJlIGl0IGFsbCBiZWdpbnMuXG4gICAgICogV2UgZmlyc3QgY2hlY2sgZXhpc3RlbmNlIG9mIGEgdmFsaWQgc2Vzc2lvbiwgaWYgbm90IGZvdW5kIGEgc2Vzc2lvbiBpcyBjcmVhdGVkIGFuZCB0aGVuIGdldFB1YmxpY1N5c3RlbUluZm9cbiAgICAgKiBpcyB0cmlnZ2VyZWQuXG4gICAgICovXG4gICAgZHhEYXRhLmdldFNlcnZlclNpbmdsZXRvbignQVBJU2Vzc2lvbicsIHtcbiAgICAgICAgc3VjY2VzczogZ2V0UHVibGljU3lzdGVtSW5mbyxcbiAgICAgICAgZXJyb3I6IGZ1bmN0aW9uKCkgeyBjcmVhdGVTZXNzaW9uKGdldFB1YmxpY1N5c3RlbUluZm8pOyB9XG4gICAgfSk7XG59O1xuIiwiLypcbiAqIENvcHlyaWdodCAoYykgMjAxMywgMjAxNSBieSBEZWxwaGl4LiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICovXG5cbi8qIGdsb2JhbCAkLCBrbywgbG9naW5WTSAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbmNvbnN0IGR4TG9jYWxlID0gcmVxdWlyZSgnZHhjb3JlL2pzL2xvY2FsZS5qcycpLFxuICAgIGR4VXRpbCA9IHJlcXVpcmUoJ2R4Y29yZS9qcy91dGlsLmpzJyk7XG5cbi8qXG4gKiBUaGlzIGZpbGUgY29udGFpbnMgY29uZmlndXJhdGlvbiBmb3Iga25vY2tvdXQgYmluZGluZyBoYW5kbGVycywgZGVscGhpeCBhamF4IGNhbGxzLCBsb2NhbGUgc2V0dGluZ3MgYW5kXG4gKiBzb21lIG1pc2NlbGxhbmVvdXMgdmlldyBjb25maWd1cmF0aW9uLlxuICovXG5mdW5jdGlvbiBsb2dpbkFqYXhFcnJvckhhbmRsZXIoZXZlbnQsIGpxeGhyKSB7XG4gICAgaWYgKGpxeGhyLnN0YXR1cyA9PT0gMCkge1xuICAgICAgICBsb2dpblZNLnNob3dDb25uZWN0aXZpdHlFcnJvcigpO1xuICAgIH1cbiAgICAvLyBmaWx0ZXJpbmcgb3V0IEhUTUwgdGFnc1xuICAgIGR4VXRpbC5kZWJ1ZygkLnRyaW0oZHhVdGlsLmlzTm9uZShqcXhoci5yZXNwb25zZVRleHQpID8gJycgOiBqcXhoci5yZXNwb25zZVRleHQucmVwbGFjZSgvKDwoW14+XSspPikvaWcsICcgJykpKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBzZXR1cENvbmZpZygpIHtcbiAgICAvKlxuICAgICAqIGZhZGVWaXNpYmxlIGlzIGEgY3VzdG9tIGhhbmRsZXIgZm9yIGtub2Nrb3V0IHRoYXQgdXNlcyBqUXVlcnkncyBmYWRlIG1ldGhvZHMgdG8gaGlkZS9zaG93IGVsZW1lbnRzLlxuICAgICAqL1xuICAgIGtvLmJpbmRpbmdIYW5kbGVycy5mYWRlVmlzaWJsZSA9IHtcbiAgICAgICAgdXBkYXRlOiBmdW5jdGlvbihlbGVtZW50LCB2YWx1ZUFjY2Vzc29yKSB7XG4gICAgICAgICAgICB2YXIgc2hvdWxkRGlzcGxheSA9IHZhbHVlQWNjZXNzb3IoKTtcbiAgICAgICAgICAgIGlmIChzaG91bGREaXNwbGF5KSB7XG4gICAgICAgICAgICAgICAgJChlbGVtZW50KS5mYWRlSW4oJ3Nsb3cnKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgJChlbGVtZW50KS5mYWRlT3V0KCdmYXN0Jyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgLypcbiAgICAgKiBMb2NhbGUgY29uZmlndXJhdGlvbi5cbiAgICAgKi9cbiAgICBkeExvY2FsZS5zZXR1cExvY2FsZShbIHtcbiAgICAgICAgbmFtZTogJ21lc3NhZ2VzJyxcbiAgICAgICAgcGF0aDogJy4uL2R4Y29yZS9sb2NhbGUvJyxcbiAgICAgICAgbGFuZ3VhZ2U6ICdlbl9VUydcbiAgICB9LCB7XG4gICAgICAgIG5hbWU6ICdtZXNzYWdlcycsXG4gICAgICAgIHBhdGg6ICdsb2NhbGUvJyxcbiAgICAgICAgbGFuZ3VhZ2U6ICdlbl9VUydcbiAgICB9XSk7XG5cbiAgICAkKGRvY3VtZW50KS5hamF4RXJyb3IobG9naW5BamF4RXJyb3JIYW5kbGVyKTtcbn07XG4iLCIvKlxuICogQ29weXJpZ2h0IChjKSAyMDEzLCAyMDE1IGJ5IERlbHBoaXguIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKi9cblxuLyogZ2xvYmFsIEJhY2tib25lICovXG5cbid1c2Ugc3RyaWN0JztcblxuLypcbiAqIFRoaXMgZmlsZSBjb250YWlucyByb3V0ZXIgY29uZmlndXJhdGlvbiBmb3IgbG9naW4gYXBwbGljYXRpb24gd29ya2Zsb3cuXG4gKi9cbmZ1bmN0aW9uIHNldHVwUm91dGVyKGxvZ2luVmlld01vZGVsKSB7XG4gICAgLypcbiAgICAgKiBCYWNrYm9uZSByb3V0ZXIgdG8gaGFuZGxlIFVSTCByb3V0ZSByZXF1ZXN0cy5cbiAgICAgKi9cbiAgICB2YXIgQXBwUm91dGVyID0gQmFja2JvbmUuUm91dGVyLmV4dGVuZCh7XG4gICAgICAgIHJvdXRlczoge1xuICAgICAgICAgICAgc2VydmVyU2V0dXA6ICdyb3V0ZVRvU2VydmVyU2V0dXAnLFxuICAgICAgICAgICAgJyphY3Rpb25zJzogJ2RlZmF1bHRSb3V0ZSdcbiAgICAgICAgfVxuICAgIH0pO1xuXG4gICAgdmFyIGFwcF9yb3V0ZXIgPSBuZXcgQXBwUm91dGVyKCk7XG4gICAgYXBwX3JvdXRlci5vbigncm91dGU6cm91dGVUb1NlcnZlclNldHVwJywgZnVuY3Rpb24oKSB7XG4gICAgICAgIHRvZ2dsZUxvZ2luU2NyZWVuKCdTWVNURU0nKTtcbiAgICB9KTtcblxuICAgIGFwcF9yb3V0ZXIub24oJ3JvdXRlOmRlZmF1bHRSb3V0ZScsIGZ1bmN0aW9uKCkge1xuICAgICAgICB0b2dnbGVMb2dpblNjcmVlbignRE9NQUlOJyk7XG4gICAgfSk7XG5cbiAgICAvKlxuICAgICAqIFRvZ2dsZXMgdGhlIERlbHBoaXggRW5naW5lL1NldHVwIGxvZ28gYW5kIGxpbmtzLlxuICAgICAqICAgICBzY3JlZW4gLSBET01BSU4gb3IgU1lTVEVNIHNjcmVlbi5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiB0b2dnbGVMb2dpblNjcmVlbihzY3JlZW4pIHtcbiAgICAgICAgbG9naW5WaWV3TW9kZWwudGFyZ2V0KHNjcmVlbik7XG4gICAgICAgIGxvZ2luVmlld01vZGVsLm1lc3NhZ2UoJycpO1xuICAgICAgICBsb2dpblZpZXdNb2RlbC5hd2FpdGluZ0xvZ2luKHRydWUpO1xuICAgIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBzdGFydChsb2dpblZpZXdNb2RlbCkge1xuICAgIHNldHVwUm91dGVyKGxvZ2luVmlld01vZGVsKTtcbiAgICBCYWNrYm9uZS5oaXN0b3J5LnN0YXJ0KCk7XG59O1xuIiwiLypcbiAqIENvcHlyaWdodCAoYykgMjAxMiwgMjAxNSBieSBEZWxwaGl4LiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICovXG5cbi8qIGdsb2JhbCAkLCBkeCwga28gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG4vLyBFeHBvc2UgbmFtZXNwYWNlIHRvIGJlIGNhbGxlZCBmcm9tIGh0bWxcbnJlcXVpcmUoJ2R4Y29yZS9qcy9kZWxwaGl4LmpzJykubmFtZXNwYWNlKCdkeC5sb2dpbicpO1xuXG5jb25zdCBkeFRlbXBsYXRlID0gcmVxdWlyZSgnZHhjb3JlL2pzL3RlbXBsYXRlLmpzJyksXG4gICAgZHhJbml0aWFsaXplID0gcmVxdWlyZSgnZHhjb3JlL21haW4vanMvc3RhcnREeENvcmUuanMnKSxcbiAgICBkeFNldHVwQ29uZmlnID0gcmVxdWlyZSgnbG9naW4vanMvbG9naW4tY29uZmlnLmpzJyksXG4gICAgZHhQYXNzd29yZFN0cmVuZ3RoTWV0ZXIgPSByZXF1aXJlKCdsb2dpbi9qcy9wYXNzd29yZC1zdHJlbmd0aC1tZXRlci5qcycpLFxuICAgIGR4U3RhcnRSb3V0ZXIgPSByZXF1aXJlKCdsb2dpbi9qcy9sb2dpbi1yb3V0ZXIuanMnKSxcbiAgICBkeExvZ2luVk0gPSByZXF1aXJlKCdsb2dpbi9qcy9Mb2dpblZpZXdNb2RlbC5qcycpO1xuXG4vKlxuICogRW50cnlwb2ludCBmb3IgdGhlIGxvZ2luIGFwcFxuICovXG5cbmZ1bmN0aW9uIGFwcGVuZChlbGVtLCB2bSkge1xuICAgIGlmICghdm0pXG4gICAgICAgIHZtID0gbmV3IGR4TG9naW5WTS5sb2dpblZpZXdNb2RlbCgpO1xuICAgIHZhciBsb2dpblRlbXBsYXRlID0gZHhUZW1wbGF0ZS50ZW1wbGF0ZSgnbG9naW4vdGVtcGxhdGUvbG9naW4nKTtcbiAgICBpZiAoZWxlbSlcbiAgICAgICAgZWxlbS5hcHBlbmQobG9naW5UZW1wbGF0ZSk7XG4gICAga28uYXBwbHlCaW5kaW5ncyh2bSwgbG9naW5UZW1wbGF0ZS5nZXQoMCkpO1xuICAgIHJldHVybiBsb2dpblRlbXBsYXRlO1xufVxuXG4vKlxuICogQmVnaW5zIHRoZSBsb2dpbiBwcm9jZXNzLlxuICogUGFyYW1ldGVyczpcbiAqIGJyb3N3ZXJEZXByZWNhdGVkOiB0cnVlL2ZhbHNlIGluZGljYXRpbmcgdGhhdCBhIG1lc3NhZ2Ugc2hvdWxkIGJlIGRpc3BsYXllZFxuICogICAgdG8gdGhlIGVmZmVjdCB0aGF0IHN1cHBvcnQgZm9yIHRoZSB1c2VyJ3MgYnJvd3NlciB3aWxsIGJlIHJlbW92ZWQgaW4gYVxuICogICAgc3Vic2VxdWVudCByZWxlYXNlLlxuICogYnJvd3NlclVuc3VwcG9ydGVkOiB0cnVlL2ZhbHNlIGluZGljYXRpbmcgdGhhdCBhIG1lc3NhZ2Ugc2hvdWxkIGJlIGRpc3BsYXllZFxuICogICAgdG8gdGhlIGVmZmVjdCB0aGF0IHRoZSB1c2VyJ3MgYnJvc3dlciBpcyBub3Qgc3VwcG9ydGVkIGFuZCB0aGF0IGJlaGF2aW9yXG4gKiAgICBvZiB0aGUgYXBwIGNhbm5vdCBiZSBwcmVkaWN0ZWQuIFRha2VzIHByZWNlZGVuY2Ugb3ZlciBkZXByZWNhdGVkLlxuICovXG5mdW5jdGlvbiBzdGFydExvZ2luKGJyb3dzZXJEZXByZWNhdGVkLCBicm9zd2VyVW5zdXBwb3J0ZWQpIHtcbiAgICBkeEluaXRpYWxpemUoKTtcbiAgICBkeFNldHVwQ29uZmlnKCk7XG4gICAgdmFyIHZtID0gbmV3IGR4TG9naW5WTS5sb2dpblZpZXdNb2RlbChicm93c2VyRGVwcmVjYXRlZCwgYnJvc3dlclVuc3VwcG9ydGVkKTtcbiAgICBhcHBlbmQoJCgnYm9keScpLCB2bSk7XG4gICAgZHhQYXNzd29yZFN0cmVuZ3RoTWV0ZXIuc2V0dXBQYXNzd29yZFN0cmVuZ3RoTWV0ZXIoKTtcbiAgICBkeFN0YXJ0Um91dGVyKHZtKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gICAgLy8gRXhwb3NlZCBmb3IgdGVzdGluZ1xuICAgIF9hcHBlbmQ6IGFwcGVuZFxufTtcblxuZHgubG9naW4uc3RhcnRMb2dpbiA9IHN0YXJ0TG9naW47XG4iLCIvKlxuICogQ29weXJpZ2h0IChjKSAyMDEzLCAyMDE1IGJ5IERlbHBoaXguIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKi9cblxuLyogZ2xvYmFsICQgKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCBkeExvY2FsZSA9IHJlcXVpcmUoJ2R4Y29yZS9qcy9sb2NhbGUuanMnKTtcblxuLypcbiAqIFRoaXMgZmlsZSBjb250YWlucyBjb25maWd1cmF0aW9uIHBhc3N3b3JkIHN0cmVuZ3RoIG1ldGVyIHVzZWQgb24gdGhlIGxvZ2luIHBhZ2Ugd2hpbGUgaW5pdGlhbGl6aW5nIGEgdXNlci5cbiAqL1xuZnVuY3Rpb24gc2V0dXBQYXNzd29yZFN0cmVuZ3RoTWV0ZXIoKSB7XG4gICAgLypcbiAgICAgKiBCaW5kaW5ncyBmb3IgdGhlIHBhc3N3b3JkIHN0cmVuZ3RoIG1vbml0b3IuXG4gICAgICovXG4gICAgJCgnI25ld1Bhc3N3b3JkJykua2V5dXAoZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciB2ZXJkaWN0ID0gcGFzc3dvcmRTdHJlbmd0aE1vbml0b3IoJCh0aGlzKS52YWwoKSk7XG4gICAgICAgIHVwZGF0ZVBhc3N3b3JkU3RyZW5ndGhNZXRlcih2ZXJkaWN0KTtcbiAgICB9KTtcblxuICAgIC8qXG4gICAgICogVGhpcyBmdW5jdGlvbiB1cGRhdGVzIHRoZSBwYXNzd29yZCBzdHJlbmd0aCBtZXRlciBiYXNlZCBvbiB0aGUgbmV3IHBhc3N3b3JkIGVudGVyZWQgYnkgdGhlIHVzZXIuXG4gICAgICovXG4gICAgZnVuY3Rpb24gdXBkYXRlUGFzc3dvcmRTdHJlbmd0aE1ldGVyKHN0cmVuZ3RoKSB7XG4gICAgICAgIHZhciBzdHJlbmd0aExhYmVsID0gJCgnI3N0cmVuZ3RoTGFiZWwnKTtcblxuICAgICAgICBpZiAoc3RyZW5ndGggIT09IHN0cmVuZ3RoTGFiZWwuaHRtbCgpKSB7XG4gICAgICAgICAgICAkKCdkaXZbaWQqPXN0cmVuZ3RoTWV0ZXJdJykuZWFjaChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAkKHRoaXMpLmFkZENsYXNzKCdiYXItbmV1dHJhbCcpXG4gICAgICAgICAgICAgICAgICAgIC5yZW1vdmVDbGFzcygncHJvZ3Jlc3MtYmFyLXN1Y2Nlc3MgcHJvZ3Jlc3MtYmFyLXdhcm5pbmcgcHJvZ3Jlc3MtYmFyLWVycm9yJyk7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgaWYgKHN0cmVuZ3RoID09PSBkeExvY2FsZS5nbHMoJ3Bhc3N3b3JkLnN0cmVuZ3RoLnZlcnl3ZWFrJykpIHtcbiAgICAgICAgICAgICAgICAkKCcjc3RyZW5ndGhNZXRlcjEnKS5yZW1vdmVDbGFzcygnYmFyLW5ldXRyYWwnKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoc3RyZW5ndGggPT09IGR4TG9jYWxlLmdscygncGFzc3dvcmQuc3RyZW5ndGgud2VhaycpKSB7XG4gICAgICAgICAgICAgICAgJCgnZGl2W2lkKj1zdHJlbmd0aE1ldGVyXTpsdCgyKScpLmVhY2goZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICQodGhpcykucmVtb3ZlQ2xhc3MoJ2Jhci1uZXV0cmFsJyk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHN0cmVuZ3RoID09PSBkeExvY2FsZS5nbHMoJ3Bhc3N3b3JkLnN0cmVuZ3RoLnN0cm9uZycpKSB7XG4gICAgICAgICAgICAgICAgJCgnZGl2W2lkKj1zdHJlbmd0aE1ldGVyXTpsdCgzKScpLmVhY2goZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICQodGhpcykucmVtb3ZlQ2xhc3MoJ2Jhci1uZXV0cmFsJykuYWRkQ2xhc3MoJ3Byb2dyZXNzLWJhci13YXJuaW5nJyk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHN0cmVuZ3RoID09PSBkeExvY2FsZS5nbHMoJ3Bhc3N3b3JkLnN0cmVuZ3RoLnZlcnlzdHJvbmcnKSkge1xuICAgICAgICAgICAgICAgICQoJ2RpdltpZCo9c3RyZW5ndGhNZXRlcl0nKS5lYWNoKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAkKHRoaXMpLnJlbW92ZUNsYXNzKCdiYXItbmV1dHJhbCcpLmFkZENsYXNzKCdwcm9ncmVzcy1iYXItc3VjY2VzcycpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBzdHJlbmd0aExhYmVsLmh0bWwoc3RyZW5ndGgpO1xuICAgICAgICB9XG4gICAgfVxufVxuXG4vKlxuICogUGFzc3dvcmQgc3RyZW5ndGggbW9uaXRvciBmdW5jdGlvbiByaXBwZWQgb2ZmIGZyb20gZmxleCBjb2RlLlxuICogQHBhcmFtIHtPYmplY3R9IHBhc3N3ZFxuICovXG5mdW5jdGlvbiBwYXNzd29yZFN0cmVuZ3RoTW9uaXRvcihwYXNzd2QpIHtcbiAgICB2YXIgc2NvcmUgPSAwO1xuICAgIHZhciB2ZXJkaWN0ID0gZHhMb2NhbGUuZ2xzKCdwYXNzd29yZC5zdHJlbmd0aC52ZXJ5d2VhaycpO1xuXG4gICAgLy8gUEFTU1dPUkQgTEVOR1RIXG4gICAgaWYgKHBhc3N3ZC5sZW5ndGggPCA4KSB7XG4gICAgICAgIHNjb3JlIC09IDM7XG4gICAgfSBlbHNlIGlmIChwYXNzd2QubGVuZ3RoID4gNyAmJiBwYXNzd2QubGVuZ3RoIDwgMTUpIHtcbiAgICAgICAgLy8gbGVuZ3RoIGJldHdlZW4gNyBhbmQgMTRcbiAgICAgICAgc2NvcmUgKz0gMTI7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgLy8gbGVuZ3RoIDE1IG9yIG1vcmVcbiAgICAgICAgc2NvcmUgKz0gMTg7XG4gICAgfVxuXG4gICAgLy8gTEVUVEVSU1xuICAgIGlmIChwYXNzd2QubWF0Y2goL1thLXpdLykpIHtcbiAgICAgICAgLy8gW3ZlcmlmaWVkXSBhdCBsZWFzdCBvbmUgbG93ZXIgY2FzZSBsZXR0ZXJcbiAgICAgICAgc2NvcmUgKz0gMTtcbiAgICB9XG4gICAgaWYgKHBhc3N3ZC5tYXRjaCgvW0EtWl0vKSkge1xuICAgICAgICAvLyBbdmVyaWZpZWRdIGF0IGxlYXN0IG9uZSB1cHBlciBjYXNlIGxldHRlclxuICAgICAgICBzY29yZSArPSA1O1xuICAgIH1cblxuICAgIC8vIE5VTUJFUlNcbiAgICBpZiAocGFzc3dkLm1hdGNoKC9cXGQrLykpIHtcbiAgICAgICAgLy8gW3ZlcmlmaWVkXSBhdCBsZWFzdCBvbmUgbnVtYmVyXG4gICAgICAgIHNjb3JlICs9IDY7XG4gICAgfVxuXG4gICAgaWYgKHBhc3N3ZC5tYXRjaCgvKFxcZC4qXFxkLipcXGQpLykpIHtcbiAgICAgICAgLy8gW3ZlcmlmaWVkXSBhdCBsZWFzdCB0aHJlZSBudW1iZXJzXG4gICAgICAgIHNjb3JlICs9IDc7XG4gICAgfVxuXG4gICAgLy8gU1BFQ0lBTCBDSEFSQUNURVJTXG4gICAgaWYgKHBhc3N3ZC5tYXRjaCgvWyEsQCMkJVxcXiYqP19+XS8pKSB7XG4gICAgICAgIC8vIFt2ZXJpZmllZF0gYXQgbGVhc3Qgb25lIHNwZWNpYWwgY2hhcmFjdGVyXG4gICAgICAgIHNjb3JlICs9IDY7XG4gICAgfVxuXG4gICAgaWYgKHBhc3N3ZC5tYXRjaCgvKFshLEAjJCVcXF4mKj9ffl0uKlshLEAjJCVcXF4mKj9ffl0pLykpIHtcbiAgICAgICAgLy8gW3ZlcmlmaWVkXSBhdCBsZWFzdCB0d28gc3BlY2lhbCBjaGFyYWN0ZXJzXG4gICAgICAgIHNjb3JlICs9IDc7XG4gICAgfVxuXG4gICAgLy8gQ09NQklOQVRJT05TXG4gICAgaWYgKHBhc3N3ZC5tYXRjaCgvW2Etel0vKSAmJiBwYXNzd2QubWF0Y2goL1tBLVpdLykpIHtcbiAgICAgICAgLy8gW3ZlcmlmaWVkXSBib3RoIHVwcGVyIGFuZCBsb3dlciBjYXNlXG4gICAgICAgIHNjb3JlICs9IDM7XG4gICAgfVxuXG4gICAgaWYgKHBhc3N3ZC5tYXRjaCgvXFxkLykgJiYgcGFzc3dkLm1hdGNoKC9cXEQvKSkge1xuICAgICAgICAvLyBbdmVyaWZpZWRdIGJvdGggbGV0dGVycyBhbmQgbnVtYmVyc1xuICAgICAgICBzY29yZSArPSA0O1xuICAgIH1cblxuICAgIC8vIFtWZXJpZmllZF0gVXBwZXIgTGV0dGVycywgTG93ZXIgTGV0dGVycywgbnVtYmVycyBhbmQgc3BlY2lhbCBjaGFyYWN0ZXJzXG4gICAgaWYgKHBhc3N3ZC5tYXRjaCgvW2Etel0vKSAmJiBwYXNzd2QubWF0Y2goL1tBLVpdLykgJiYgcGFzc3dkLm1hdGNoKC9cXGQvKSAmJiBwYXNzd2QubWF0Y2goL1shLEAjJCVcXF4mKj9ffl0vKSkge1xuICAgICAgICBzY29yZSArPSA0O1xuICAgIH1cblxuICAgIC8vIHRoZSBzdHJpbmcgJ2RlbHBoaXgnIG1ha2VzIHBhc3N3b3JkIGVhc2llciB0byBndWVzcy4gaGVuY2UgbmVnYXRpdmUgbWFya3NcbiAgICBpZiAocGFzc3dkLnRvTG93ZXJDYXNlKCkuaW5kZXhPZignZGVscGhpeCcpICE9PSAtMSkge1xuICAgICAgICBzY29yZSAtPSAxMDtcbiAgICB9XG5cbiAgICAvLyBjb21wdXRlIGZpbmFsIHZlcmRpY3QuXG4gICAgaWYgKHNjb3JlIDwgMTYpIHtcbiAgICAgICAgdmVyZGljdCA9IGR4TG9jYWxlLmdscygncGFzc3dvcmQuc3RyZW5ndGgudmVyeXdlYWsnKTtcbiAgICB9IGVsc2UgaWYgKHNjb3JlID4gMTUgJiYgc2NvcmUgPCAzNSkge1xuICAgICAgICB2ZXJkaWN0ID0gZHhMb2NhbGUuZ2xzKCdwYXNzd29yZC5zdHJlbmd0aC53ZWFrJyk7XG4gICAgfSBlbHNlIGlmIChzY29yZSA+IDM0ICYmIHNjb3JlIDwgNDUpIHtcbiAgICAgICAgdmVyZGljdCA9IGR4TG9jYWxlLmdscygncGFzc3dvcmQuc3RyZW5ndGguc3Ryb25nJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgdmVyZGljdCA9IGR4TG9jYWxlLmdscygncGFzc3dvcmQuc3RyZW5ndGgudmVyeXN0cm9uZycpO1xuICAgIH1cblxuICAgIGlmIChwYXNzd2QubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHZlcmRpY3QgPSAnJztcbiAgICAgICAgc2NvcmUgPSAwO1xuICAgIH1cblxuICAgIHJldHVybiB2ZXJkaWN0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgICBzZXR1cFBhc3N3b3JkU3RyZW5ndGhNZXRlcjogc2V0dXBQYXNzd29yZFN0cmVuZ3RoTWV0ZXIsXG4gICAgcGFzc3dvcmRTdHJlbmd0aE1vbml0b3I6IHBhc3N3b3JkU3RyZW5ndGhNb25pdG9yXG59O1xuIl19
